Require Import Stdlib.Reals.Reals mathcomp.boot.ssrnat mathcomp.boot.div mathcomp.boot.seq mathcomp.algebra.ssralg mathcomp.algebra.ssrint mathcomp.algebra.intdiv mathcomp.classical.classical_sets mathcomp.classical.cardinality mathcomp.analysis_stdlib.Rstruct_topology HOLLight.Multivariate.mappings.
Definition _FALSITY_ : Prop := False.
Lemma _FALSITY__def : _FALSITY_ = False.
Proof. exact (REFL _FALSITY_). Qed.
Definition o {A B C : Type'} : (B -> C) -> (A -> B) -> A -> C := fun f : B -> C => fun g : A -> B => fun x : A => f (g x).
Lemma o_def {A B C : Type'} : (@o A B C) = (fun f : B -> C => fun g : A -> B => fun x : A => f (g x)).
Proof. exact (REFL (@o A B C)). Qed.
Definition I {A : Type'} : A -> A := fun x : A => x.
Lemma I_def {A : Type'} : (@I A) = (fun x : A => x).
Proof. exact (REFL (@I A)). Qed.
Definition hashek : Prop := True.
Lemma hashek_def : hashek = True.
Proof. exact (REFL hashek). Qed.
Definition LET {A B : Type'} : (A -> B) -> A -> B := fun f : A -> B => fun x : A => f x.
Lemma LET_def {A B : Type'} : (@LET A B) = (fun f : A -> B => fun x : A => f x).
Proof. exact (REFL (@LET A B)). Qed.
Definition LET_END {A : Type'} : A -> A := fun t : A => t.
Lemma LET_END_def {A : Type'} : (@LET_END A) = (fun t : A => t).
Proof. exact (REFL (@LET_END A)). Qed.
Definition GABS {A : Type'} : (A -> Prop) -> A := fun P : A -> Prop => @ε A P.
Lemma GABS_def {A : Type'} : (@GABS A) = (fun P : A -> Prop => @ε A P).
Proof. exact (REFL (@GABS A)). Qed.
Definition _SEQPATTERN {A B : Type'} : (A -> B -> Prop) -> (A -> B -> Prop) -> A -> B -> Prop := fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x).
Lemma _SEQPATTERN_def {A B : Type'} : (@_SEQPATTERN A B) = (fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x)).
Proof. exact (REFL (@_SEQPATTERN A B)). Qed.
Definition _UNGUARDED_PATTERN : Prop -> Prop -> Prop := fun p : Prop => fun r : Prop => p /\ r.
Lemma _UNGUARDED_PATTERN_def : _UNGUARDED_PATTERN = (fun p : Prop => fun r : Prop => p /\ r).
Proof. exact (REFL _UNGUARDED_PATTERN). Qed.
Definition _GUARDED_PATTERN : Prop -> Prop -> Prop -> Prop := fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r).
Lemma _GUARDED_PATTERN_def : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Proof. exact (REFL _GUARDED_PATTERN). Qed.
Definition _MATCH {A B : Type'} : A -> (A -> B -> Prop) -> B := fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False)).
Lemma _MATCH_def {A B : Type'} : (@_MATCH A B) = (fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False))).
Proof. exact (REFL (@_MATCH A B)). Qed.
Definition _FUNCTION {A B : Type'} : (A -> B -> Prop) -> A -> B := fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False)).
Lemma _FUNCTION_def {A B : Type'} : (@_FUNCTION A B) = (fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False))).
Proof. exact (REFL (@_FUNCTION A B)). Qed.
Definition CURRY {A B C : Type'} : ((prod A B) -> C) -> A -> B -> C := fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285).
Lemma CURRY_def {A B C : Type'} : (@CURRY A B C) = (fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285)).
Proof. exact (REFL (@CURRY A B C)). Qed.
Definition UNCURRY {A B C : Type'} : (A -> B -> C) -> (prod A B) -> C := fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305).
Lemma UNCURRY_def {A B C : Type'} : (@UNCURRY A B C) = (fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305)).
Proof. exact (REFL (@UNCURRY A B C)). Qed.
Definition PASSOC {A B C D : Type'} : ((prod (prod A B) C) -> D) -> (prod A (prod B C)) -> D := fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322))).
Lemma PASSOC_def {A B C D : Type'} : (@PASSOC A B C D) = (fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322)))).
Proof. exact (REFL (@PASSOC A B C D)). Qed.
Definition minimal : (nat -> Prop) -> nat := fun _6536 : nat -> Prop => @ε nat (fun n : nat => (_6536 n) /\ (forall m : nat, (ltn m n) -> ~ (_6536 m))).
Lemma minimal_def : minimal = (fun _6536 : nat -> Prop => @ε nat (fun n : nat => (_6536 n) /\ (forall m : nat, (ltn m n) -> ~ (_6536 m)))).
Proof. exact (REFL minimal). Qed.
Definition MEASURE {A : Type'} : (A -> nat) -> A -> A -> Prop := fun _8094 : A -> nat => fun x : A => fun y : A => ltn (_8094 x) (_8094 y).
Lemma MEASURE_def {A : Type'} : (@MEASURE A) = (fun _8094 : A -> nat => fun x : A => fun y : A => ltn (_8094 x) (_8094 y)).
Proof. exact (REFL (@MEASURE A)). Qed.
Definition NUMPAIR : nat -> nat -> nat := fun _17487 : nat => fun _17488 : nat => muln (expn (NUMERAL (BIT0 (BIT1 O))) _17487) (addn (muln (NUMERAL (BIT0 (BIT1 O))) _17488) (NUMERAL (BIT1 O))).
Lemma NUMPAIR_def : NUMPAIR = (fun _17487 : nat => fun _17488 : nat => muln (expn (NUMERAL (BIT0 (BIT1 O))) _17487) (addn (muln (NUMERAL (BIT0 (BIT1 O))) _17488) (NUMERAL (BIT1 O)))).
Proof. exact (REFL NUMPAIR). Qed.
Definition NUMFST : nat -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun X : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17503 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), exists Y : nat -> nat, forall x : nat, forall y : nat, ((X _17503 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O))))))))))))).
Lemma NUMFST_def : NUMFST = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun X : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17503 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), exists Y : nat -> nat, forall x : nat, forall y : nat, ((X _17503 (NUMPAIR x y)) = x) /\ ((Y (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))))))))).
Proof. exact (REFL NUMFST). Qed.
Definition NUMSND : nat -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun Y : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17504 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), forall x : nat, forall y : nat, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17504 (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))))).
Lemma NUMSND_def : NUMSND = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat) (fun Y : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> nat => forall _17504 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), forall x : nat, forall y : nat, ((NUMFST (NUMPAIR x y)) = x) /\ ((Y _17504 (NUMPAIR x y)) = y)) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))))))).
Proof. exact (REFL NUMSND). Qed.
Definition NUMSUM : Prop -> nat -> nat := fun _17505 : Prop => fun _17506 : nat => @COND nat _17505 (S (muln (NUMERAL (BIT0 (BIT1 O))) _17506)) (muln (NUMERAL (BIT0 (BIT1 O))) _17506).
Lemma NUMSUM_def : NUMSUM = (fun _17505 : Prop => fun _17506 : nat => @COND nat _17505 (S (muln (NUMERAL (BIT0 (BIT1 O))) _17506)) (muln (NUMERAL (BIT0 (BIT1 O))) _17506)).
Proof. exact (REFL NUMSUM). Qed.
Definition INJN {A : Type'} : nat -> nat -> A -> Prop := fun _17537 : nat => fun n : nat => fun a : A => n = _17537.
Lemma INJN_def {A : Type'} : (@INJN A) = (fun _17537 : nat => fun n : nat => fun a : A => n = _17537).
Proof. exact (REFL (@INJN A)). Qed.
Definition INJA {A : Type'} : A -> nat -> A -> Prop := fun _17542 : A => fun n : nat => fun b : A => b = _17542.
Lemma INJA_def {A : Type'} : (@INJA A) = (fun _17542 : A => fun n : nat => fun b : A => b = _17542).
Proof. exact (REFL (@INJA A)). Qed.
Definition INJF {A : Type'} : (nat -> nat -> A -> Prop) -> nat -> A -> Prop := fun _17549 : nat -> nat -> A -> Prop => fun n : nat => _17549 (NUMFST n) (NUMSND n).
Lemma INJF_def {A : Type'} : (@INJF A) = (fun _17549 : nat -> nat -> A -> Prop => fun n : nat => _17549 (NUMFST n) (NUMSND n)).
Proof. exact (REFL (@INJF A)). Qed.
Definition INJP {A : Type'} : (nat -> A -> Prop) -> (nat -> A -> Prop) -> nat -> A -> Prop := fun _17554 : nat -> A -> Prop => fun _17555 : nat -> A -> Prop => fun n : nat => fun a : A => @COND Prop (NUMLEFT n) (_17554 (NUMRIGHT n) a) (_17555 (NUMRIGHT n) a).
Lemma INJP_def {A : Type'} : (@INJP A) = (fun _17554 : nat -> A -> Prop => fun _17555 : nat -> A -> Prop => fun n : nat => fun a : A => @COND Prop (NUMLEFT n) (_17554 (NUMRIGHT n) a) (_17555 (NUMRIGHT n) a)).
Proof. exact (REFL (@INJP A)). Qed.
Definition ZCONSTR {A : Type'} : nat -> A -> (nat -> nat -> A -> Prop) -> nat -> A -> Prop := fun _17566 : nat => fun _17567 : A => fun _17568 : nat -> nat -> A -> Prop => @INJP A (@INJN A (S _17566)) (@INJP A (@INJA A _17567) (@INJF A _17568)).
Lemma ZCONSTR_def {A : Type'} : (@ZCONSTR A) = (fun _17566 : nat => fun _17567 : A => fun _17568 : nat -> nat -> A -> Prop => @INJP A (@INJN A (S _17566)) (@INJP A (@INJA A _17567) (@INJF A _17568))).
Proof. exact (REFL (@ZCONSTR A)). Qed.
Definition ZBOT {A : Type'} : nat -> A -> Prop := @INJP A (@INJN A (NUMERAL O)) (@ε (nat -> A -> Prop) (fun z : nat -> A -> Prop => True)).
Lemma ZBOT_def {A : Type'} : (@ZBOT A) = (@INJP A (@INJN A (NUMERAL O)) (@ε (nat -> A -> Prop) (fun z : nat -> A -> Prop => True))).
Proof. exact (REFL (@ZBOT A)). Qed.
Definition FNIL {A : Type'} : nat -> A := fun _17624 : nat => @ε A (fun x : A => True).
Lemma FNIL_def {A : Type'} : (@FNIL A) = (fun _17624 : nat => @ε A (fun x : A => True)).
Proof. exact (REFL (@FNIL A)). Qed.
Definition OUTL {A B : Type'} : (Datatypes.sum A B) -> A := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17649 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O))))))))))).
Lemma OUTL_def {A B : Type'} : (@OUTL A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17649 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))))))).
Proof. exact (REFL (@OUTL A B)). Qed.
Definition OUTR {A B : Type'} : (Datatypes.sum A B) -> B := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17651 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O))))))))))).
Lemma OUTR_def {A B : Type'} : (@OUTR A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17651 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))))))).
Proof. exact (REFL (@OUTR A B)). Qed.
Definition _22943 : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL O) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7).
Lemma _22943_def : _22943 = (fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL O) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7)).
Proof. exact (REFL _22943). Qed.
Definition ASCII : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := _22943.
Lemma ASCII_def : ASCII = _22943.
Proof. exact (REFL ASCII). Qed.
Definition DECIMAL : nat -> nat -> R := fun _27914 : nat => fun _27915 : nat => divr (R_of_nat _27914) (R_of_nat _27915).
Lemma DECIMAL_def : DECIMAL = (fun _27914 : nat => fun _27915 : nat => divr (R_of_nat _27914) (R_of_nat _27915)).
Proof. exact (REFL DECIMAL). Qed.
Definition eq2 {A : Type'} : A -> A -> (A -> A -> Prop) -> Prop := fun _29688 : A => fun _29689 : A => fun _29690 : A -> A -> Prop => _29690 _29688 _29689.
Lemma eq2_def {A : Type'} : (@eq2 A) = (fun _29688 : A => fun _29689 : A => fun _29690 : A -> A -> Prop => _29690 _29688 _29689).
Proof. exact (REFL (@eq2 A)). Qed.
Definition int_mod : int -> int -> int -> Prop := fun _29750 : int => fun _29751 : int => fun _29752 : int => dividez _29750 (subz _29751 _29752).
Lemma int_mod_def : int_mod = (fun _29750 : int => fun _29751 : int => fun _29752 : int => dividez _29750 (subz _29751 _29752)).
Proof. exact (REFL int_mod). Qed.
Definition num_of_int : int -> nat := fun _31320 : int => @ε nat (fun n : nat => (int_of_nat n) = _31320).
Lemma num_of_int_def : num_of_int = (fun _31320 : int => @ε nat (fun n : nat => (int_of_nat n) = _31320)).
Proof. exact (REFL num_of_int). Qed.
Definition num_divides : nat -> nat -> Prop := fun _31352 : nat => fun _31353 : nat => dividez (int_of_nat _31352) (int_of_nat _31353).
Lemma num_divides_def : num_divides = (fun _31352 : nat => fun _31353 : nat => dividez (int_of_nat _31352) (int_of_nat _31353)).
Proof. exact (REFL num_divides). Qed.
Definition num_mod : nat -> nat -> nat -> Prop := fun _31364 : nat => fun _31365 : nat => fun _31366 : nat => int_mod (int_of_nat _31364) (int_of_nat _31365) (int_of_nat _31366).
Lemma num_mod_def : num_mod = (fun _31364 : nat => fun _31365 : nat => fun _31366 : nat => int_mod (int_of_nat _31364) (int_of_nat _31365) (int_of_nat _31366)).
Proof. exact (REFL num_mod). Qed.
Definition num_coprime : (prod nat nat) -> Prop := fun _31385 : prod nat nat => pair_coprimez (@pair int int (int_of_nat (@fst nat nat _31385)) (int_of_nat (@snd nat nat _31385))).
Lemma num_coprime_def : num_coprime = (fun _31385 : prod nat nat => pair_coprimez (@pair int int (int_of_nat (@fst nat nat _31385)) (int_of_nat (@snd nat nat _31385)))).
Proof. exact (REFL num_coprime). Qed.
Definition num_gcd : (prod nat nat) -> nat := fun _31394 : prod nat nat => num_of_int (pair_gcdz (@pair int int (int_of_nat (@fst nat nat _31394)) (int_of_nat (@snd nat nat _31394)))).
Lemma num_gcd_def : num_gcd = (fun _31394 : prod nat nat => num_of_int (pair_gcdz (@pair int int (int_of_nat (@fst nat nat _31394)) (int_of_nat (@snd nat nat _31394))))).
Proof. exact (REFL num_gcd). Qed.
Definition num_lcm : (prod nat nat) -> nat := fun _31403 : prod nat nat => num_of_int (pair_lcmz (@pair int int (int_of_nat (@fst nat nat _31403)) (int_of_nat (@snd nat nat _31403)))).
Lemma num_lcm_def : num_lcm = (fun _31403 : prod nat nat => num_of_int (pair_lcmz (@pair int int (int_of_nat (@fst nat nat _31403)) (int_of_nat (@snd nat nat _31403))))).
Proof. exact (REFL num_lcm). Qed.
Definition prime : nat -> Prop := fun _32188 : nat => (~ (_32188 = (NUMERAL (BIT1 O)))) /\ (forall x : nat, (num_divides x _32188) -> (x = (NUMERAL (BIT1 O))) \/ (x = _32188)).
Lemma prime_def : prime = (fun _32188 : nat => (~ (_32188 = (NUMERAL (BIT1 O)))) /\ (forall x : nat, (num_divides x _32188) -> (x = (NUMERAL (BIT1 O))) \/ (x = _32188))).
Proof. exact (REFL prime). Qed.
Definition real_zpow : R -> int -> R := fun _32346 : R => fun _32347 : int => @COND R (lez (int_of_nat (NUMERAL O)) _32347) (expr _32346 (num_of_int _32347)) (invr (expr _32346 (num_of_int (oppz _32347)))).
Lemma real_zpow_def : real_zpow = (fun _32346 : R => fun _32347 : int => @COND R (lez (int_of_nat (NUMERAL O)) _32347) (expr _32346 (num_of_int _32347)) (invr (expr _32346 (num_of_int (oppz _32347))))).
Proof. exact (REFL real_zpow). Qed.
Definition INFINITE {A : Type'} : (A -> Prop) -> Prop := fun _32574 : A -> Prop => ~ (@finite_set A _32574).
Lemma INFINITE_def {A : Type'} : (@INFINITE A) = (fun _32574 : A -> Prop => ~ (@finite_set A _32574)).
Proof. exact (REFL (@INFINITE A)). Qed.
Definition INJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32591 : A -> B => fun _32592 : A -> Prop => fun _32593 : B -> Prop => (forall x : A, (@IN A x _32592) -> @IN B (_32591 x) _32593) /\ (forall x : A, forall y : A, ((@IN A x _32592) /\ ((@IN A y _32592) /\ ((_32591 x) = (_32591 y)))) -> x = y).
Lemma INJ_def {A B : Type'} : (@INJ A B) = (fun _32591 : A -> B => fun _32592 : A -> Prop => fun _32593 : B -> Prop => (forall x : A, (@IN A x _32592) -> @IN B (_32591 x) _32593) /\ (forall x : A, forall y : A, ((@IN A x _32592) /\ ((@IN A y _32592) /\ ((_32591 x) = (_32591 y)))) -> x = y)).
Proof. exact (REFL (@INJ A B)). Qed.
Definition SURJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32612 : A -> B => fun _32613 : A -> Prop => fun _32614 : B -> Prop => (forall x : A, (@IN A x _32613) -> @IN B (_32612 x) _32614) /\ (forall x : B, (@IN B x _32614) -> exists y : A, (@IN A y _32613) /\ ((_32612 y) = x)).
Lemma SURJ_def {A B : Type'} : (@SURJ A B) = (fun _32612 : A -> B => fun _32613 : A -> Prop => fun _32614 : B -> Prop => (forall x : A, (@IN A x _32613) -> @IN B (_32612 x) _32614) /\ (forall x : B, (@IN B x _32614) -> exists y : A, (@IN A y _32613) /\ ((_32612 y) = x))).
Proof. exact (REFL (@SURJ A B)). Qed.
Definition BIJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32633 : A -> B => fun _32634 : A -> Prop => fun _32635 : B -> Prop => (@INJ A B _32633 _32634 _32635) /\ (@SURJ A B _32633 _32634 _32635).
Lemma BIJ_def {A B : Type'} : (@BIJ A B) = (fun _32633 : A -> B => fun _32634 : A -> Prop => fun _32635 : B -> Prop => (@INJ A B _32633 _32634 _32635) /\ (@SURJ A B _32633 _32634 _32635)).
Proof. exact (REFL (@BIJ A B)). Qed.
Definition CHOICE {A : Type'} : (A -> Prop) -> A := fun _32654 : A -> Prop => @ε A (fun x : A => @IN A x _32654).
Lemma CHOICE_def {A : Type'} : (@CHOICE A) = (fun _32654 : A -> Prop => @ε A (fun x : A => @IN A x _32654)).
Proof. exact (REFL (@CHOICE A)). Qed.
Definition REST {A : Type'} : (A -> Prop) -> A -> Prop := fun _32659 : A -> Prop => @DELETE A _32659 (@CHOICE A _32659).
Lemma REST_def {A : Type'} : (@REST A) = (fun _32659 : A -> Prop => @DELETE A _32659 (@CHOICE A _32659)).
Proof. exact (REFL (@REST A)). Qed.
Definition FINREC {A B : Type'} : (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _42261 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42261 f b s a (NUMERAL O)) = ((s = (@set0 A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _42261 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42261 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))))).
Lemma FINREC_def {A B : Type'} : (@FINREC A B) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _42261 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42261 f b s a (NUMERAL O)) = ((s = (@set0 A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _42261 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42261 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))))))).
Proof. exact (REFL (@FINREC A B)). Qed.
Definition HAS_SIZE {A : Type'} : (A -> Prop) -> nat -> Prop := fun _43489 : A -> Prop => fun _43490 : nat => (@finite_set A _43489) /\ ((@CARD A _43489) = _43490).
Lemma HAS_SIZE_def {A : Type'} : (@HAS_SIZE A) = (fun _43489 : A -> Prop => fun _43490 : nat => (@finite_set A _43489) /\ ((@CARD A _43489) = _43490)).
Proof. exact (REFL (@HAS_SIZE A)). Qed.
Definition CROSS {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (prod A B) -> Prop := fun _47408 : A -> Prop => fun _47409 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47408) /\ (@IN B y _47409)) (@pair A B x y)).
Lemma CROSS_def {A B : Type'} : (@CROSS A B) = (fun _47408 : A -> Prop => fun _47409 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47408) /\ (@IN B y _47409)) (@pair A B x y))).
Proof. exact (REFL (@CROSS A B)). Qed.
Definition ARB {A : Type'} : A := @ε A (fun x : A => False).
Lemma ARB_def {A : Type'} : (@ARB A) = (@ε A (fun x : A => False)).
Proof. exact (REFL (@ARB A)). Qed.
Definition EXTENSIONAL {A B : Type'} : (A -> Prop) -> (A -> B) -> Prop := fun _48182 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48182)) -> (f x) = (@ARB B)) f).
Lemma EXTENSIONAL_def {A B : Type'} : (@EXTENSIONAL A B) = (fun _48182 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48182)) -> (f x) = (@ARB B)) f)).
Proof. exact (REFL (@EXTENSIONAL A B)). Qed.
Definition RESTRICTION {A B : Type'} : (A -> Prop) -> (A -> B) -> A -> B := fun _48234 : A -> Prop => fun _48235 : A -> B => fun _48236 : A => @COND B (@IN A _48236 _48234) (_48235 _48236) (@ARB B).
Lemma RESTRICTION_def {A B : Type'} : (@RESTRICTION A B) = (fun _48234 : A -> Prop => fun _48235 : A -> B => fun _48236 : A => @COND B (@IN A _48236 _48234) (_48235 _48236) (@ARB B)).
Proof. exact (REFL (@RESTRICTION A B)). Qed.
Definition cartesian_product {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (K -> A) -> Prop := fun _48429 : K -> Prop => fun _48430 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48429 f) /\ (forall i : K, (@IN K i _48429) -> @IN A (f i) (_48430 i))) f).
Lemma cartesian_product_def {A K : Type'} : (@cartesian_product A K) = (fun _48429 : K -> Prop => fun _48430 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48429 f) /\ (forall i : K, (@IN K i _48429) -> @IN A (f i) (_48430 i))) f)).
Proof. exact (REFL (@cartesian_product A K)). Qed.
Definition product_map {A B K : Type'} : (K -> Prop) -> (K -> A -> B) -> (K -> A) -> K -> B := fun _49478 : K -> Prop => fun _49479 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49478 (fun i : K => _49479 i (x i)).
Lemma product_map_def {A B K : Type'} : (@product_map A B K) = (fun _49478 : K -> Prop => fun _49479 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49478 (fun i : K => _49479 i (x i))).
Proof. exact (REFL (@product_map A B K)). Qed.
Definition disjoint_union {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (prod K A) -> Prop := fun _49614 : K -> Prop => fun _49615 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49614) /\ (@IN A x (_49615 i))) (@pair K A i x)).
Lemma disjoint_union_def {A K : Type'} : (@disjoint_union A K) = (fun _49614 : K -> Prop => fun _49615 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49614) /\ (@IN A x (_49615 i))) (@pair K A i x))).
Proof. exact (REFL (@disjoint_union A K)). Qed.
Definition pairwise {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _56702 : A -> A -> Prop => fun _56703 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56703) /\ ((@IN A y _56703) /\ (~ (x = y)))) -> _56702 x y.
Lemma pairwise_def {A : Type'} : (@pairwise A) = (fun _56702 : A -> A -> Prop => fun _56703 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56703) /\ ((@IN A y _56703) /\ (~ (x = y)))) -> _56702 x y).
Proof. exact (REFL (@pairwise A)). Qed.
Definition UNION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57415 : ((A -> Prop) -> Prop) -> Prop => fun _57416 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57415 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57416 c) /\ ((@UNIONS A u) = s)).
Lemma UNION_OF_def {A : Type'} : (@UNION_OF A) = (fun _57415 : ((A -> Prop) -> Prop) -> Prop => fun _57416 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57415 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57416 c) /\ ((@UNIONS A u) = s))).
Proof. exact (REFL (@UNION_OF A)). Qed.
Definition INTERSECTION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57427 : ((A -> Prop) -> Prop) -> Prop => fun _57428 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57427 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57428 c) /\ ((@INTERS A u) = s)).
Lemma INTERSECTION_OF_def {A : Type'} : (@INTERSECTION_OF A) = (fun _57427 : ((A -> Prop) -> Prop) -> Prop => fun _57428 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57427 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57428 c) /\ ((@INTERS A u) = s))).
Proof. exact (REFL (@INTERSECTION_OF A)). Qed.
Definition ARBITRARY {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _57563 : (A -> Prop) -> Prop => True.
Lemma ARBITRARY_def {A : Type'} : (@ARBITRARY A) = (fun _57563 : (A -> Prop) -> Prop => True).
Proof. exact (REFL (@ARBITRARY A)). Qed.
Definition le_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64157 : A -> Prop => fun _64158 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64157) -> @IN B (f x) _64158) /\ (forall x : A, forall y : A, ((@IN A x _64157) /\ ((@IN A y _64157) /\ ((f x) = (f y)))) -> x = y).
Lemma le_c_def {A B : Type'} : (@le_c A B) = (fun _64157 : A -> Prop => fun _64158 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64157) -> @IN B (f x) _64158) /\ (forall x : A, forall y : A, ((@IN A x _64157) /\ ((@IN A y _64157) /\ ((f x) = (f y)))) -> x = y)).
Proof. exact (REFL (@le_c A B)). Qed.
Definition lt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64169 : A -> Prop => fun _64170 : B -> Prop => (@le_c A B _64169 _64170) /\ (~ (@le_c B A _64170 _64169)).
Lemma lt_c_def {A B : Type'} : (@lt_c A B) = (fun _64169 : A -> Prop => fun _64170 : B -> Prop => (@le_c A B _64169 _64170) /\ (~ (@le_c B A _64170 _64169))).
Proof. exact (REFL (@lt_c A B)). Qed.
Definition eq_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64181 : A -> Prop => fun _64182 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64181) -> @IN B (f x) _64182) /\ (forall y : B, (@IN B y _64182) -> @ex1 A (fun x : A => (@IN A x _64181) /\ ((f x) = y))).
Lemma eq_c_def {A B : Type'} : (@eq_c A B) = (fun _64181 : A -> Prop => fun _64182 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64181) -> @IN B (f x) _64182) /\ (forall y : B, (@IN B y _64182) -> @ex1 A (fun x : A => (@IN A x _64181) /\ ((f x) = y)))).
Proof. exact (REFL (@eq_c A B)). Qed.
Definition ge_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64193 : A -> Prop => fun _64194 : B -> Prop => @le_c B A _64194 _64193.
Lemma ge_c_def {A B : Type'} : (@ge_c A B) = (fun _64193 : A -> Prop => fun _64194 : B -> Prop => @le_c B A _64194 _64193).
Proof. exact (REFL (@ge_c A B)). Qed.
Definition gt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64205 : A -> Prop => fun _64206 : B -> Prop => @lt_c B A _64206 _64205.
Lemma gt_c_def {A B : Type'} : (@gt_c A B) = (fun _64205 : A -> Prop => fun _64206 : B -> Prop => @lt_c B A _64206 _64205).
Proof. exact (REFL (@gt_c A B)). Qed.
Definition COUNTABLE {A : Type'} : (A -> Prop) -> Prop := fun _64356 : A -> Prop => @ge_c nat A (@setT nat) _64356.
Lemma COUNTABLE_def {A : Type'} : (@COUNTABLE A) = (fun _64356 : A -> Prop => @ge_c nat A (@setT nat) _64356).
Proof. exact (REFL (@COUNTABLE A)). Qed.
Definition sup : (R -> Prop) -> R := fun _64361 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64361) -> ler x a) /\ (forall b : R, (forall x : R, (@IN R x _64361) -> ler x b) -> ler a b)).
Lemma sup_def : sup = (fun _64361 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64361) -> ler x a) /\ (forall b : R, (forall x : R, (@IN R x _64361) -> ler x b) -> ler a b))).
Proof. exact (REFL sup). Qed.
Definition inf : (R -> Prop) -> R := fun _65220 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65220) -> ler a x) /\ (forall b : R, (forall x : R, (@IN R x _65220) -> ler b x) -> ler b a)).
Lemma inf_def : inf = (fun _65220 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65220) -> ler a x) /\ (forall b : R, (forall x : R, (@IN R x _65220) -> ler b x) -> ler b a))).
Proof. exact (REFL inf). Qed.
Definition has_inf : (R -> Prop) -> R -> Prop := fun _66570 : R -> Prop => fun _66571 : R => forall c : R, (forall x : R, (@IN R x _66570) -> ler c x) = (ler c _66571).
Lemma has_inf_def : has_inf = (fun _66570 : R -> Prop => fun _66571 : R => forall c : R, (forall x : R, (@IN R x _66570) -> ler c x) = (ler c _66571)).
Proof. exact (REFL has_inf). Qed.
Definition has_sup : (R -> Prop) -> R -> Prop := fun _66582 : R -> Prop => fun _66583 : R => forall c : R, (forall x : R, (@IN R x _66582) -> ler x c) = (ler _66583 c).
Lemma has_sup_def : has_sup = (fun _66582 : R -> Prop => fun _66583 : R => forall c : R, (forall x : R, (@IN R x _66582) -> ler x c) = (ler _66583 c)).
Proof. exact (REFL has_sup). Qed.
Definition monoidal {A : Type'} : (A -> A -> A) -> Prop := fun _68925 : A -> A -> A => (forall x : A, forall y : A, (_68925 x y) = (_68925 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68925 x (_68925 y z)) = (_68925 (_68925 x y) z)) /\ (forall x : A, (_68925 (@neutral A _68925) x) = x)).
Lemma monoidal_def {A : Type'} : (@monoidal A) = (fun _68925 : A -> A -> A => (forall x : A, forall y : A, (_68925 x y) = (_68925 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68925 x (_68925 y z)) = (_68925 (_68925 x y) z)) /\ (forall x : A, (_68925 (@neutral A _68925) x) = x))).
Proof. exact (REFL (@monoidal A)). Qed.
Definition iterato {A K : Type'} : (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76787 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76787 dom neut op ltle k f) = (@COND A ((@finite_set K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) = (@set0 K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76787 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))).
Lemma iterato_def {A K : Type'} : (@iterato A K) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76787 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76787 dom neut op ltle k f) = (@COND A ((@finite_set K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) = (@set0 K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76787 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))).
Proof. exact (REFL (@iterato A K)). Qed.
Definition nproduct {A : Type'} : (A -> Prop) -> (A -> nat) -> nat := @iterate A nat muln.
Lemma nproduct_def {A : Type'} : (@nproduct A) = (@iterate A nat muln).
Proof. exact (REFL (@nproduct A)). Qed.
Definition iproduct {A : Type'} : (A -> Prop) -> (A -> int) -> int := @iterate A int mulz.
Lemma iproduct_def {A : Type'} : (@iproduct A) = (@iterate A int mulz).
Proof. exact (REFL (@iproduct A)). Qed.
Definition product {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R mulr.
Lemma product_def {A : Type'} : (@product A) = (@iterate A R mulr).
Proof. exact (REFL (@product A)). Qed.
Definition isum {A : Type'} : (A -> Prop) -> (A -> int) -> int := @iterate A int addz.
Lemma isum_def {A : Type'} : (@isum A) = (@iterate A int addz).
Proof. exact (REFL (@isum A)). Qed.
Definition nsum {A : Type'} : (A -> Prop) -> (A -> nat) -> nat := @iterate A nat addn.
Lemma nsum_def {A : Type'} : (@nsum A) = (@iterate A nat addn).
Proof. exact (REFL (@nsum A)). Qed.
Definition polynomial_function : (R -> R) -> Prop := fun _94200 : R -> R => exists m : nat, exists c : nat -> R, forall x : R, (_94200 x) = (@sum nat (dotdot (NUMERAL O) m) (fun i : nat => mulr (c i) (expr x i))).
Lemma polynomial_function_def : polynomial_function = (fun _94200 : R -> R => exists m : nat, exists c : nat -> R, forall x : R, (_94200 x) = (@sum nat (dotdot (NUMERAL O) m) (fun i : nat => mulr (c i) (expr x i)))).
Proof. exact (REFL polynomial_function). Qed.
Definition pastecart {A M N' : Type'} : (cart A M) -> (cart A N') -> cart A (finite_sum M N') := fun _94979 : cart A M => fun _94980 : cart A N' => @lambda A (finite_sum M N') (fun i : nat => @COND A (leqn i (@dimindex M (@setT M))) (@dollar A M _94979 i) (@dollar A N' _94980 (subn i (@dimindex M (@setT M))))).
Lemma pastecart_def {A M N' : Type'} : (@pastecart A M N') = (fun _94979 : cart A M => fun _94980 : cart A N' => @lambda A (finite_sum M N') (fun i : nat => @COND A (leqn i (@dimindex M (@setT M))) (@dollar A M _94979 i) (@dollar A N' _94980 (subn i (@dimindex M (@setT M)))))).
Proof. exact (REFL (@pastecart A M N')). Qed.
Definition fstcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A M := fun _94991 : cart A (finite_sum M N') => @lambda A M (fun i : nat => @dollar A (finite_sum M N') _94991 i).
Lemma fstcart_def {A M N' : Type'} : (@fstcart A M N') = (fun _94991 : cart A (finite_sum M N') => @lambda A M (fun i : nat => @dollar A (finite_sum M N') _94991 i)).
Proof. exact (REFL (@fstcart A M N')). Qed.
Definition sndcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A N' := fun _94996 : cart A (finite_sum M N') => @lambda A N' (fun i : nat => @dollar A (finite_sum M N') _94996 (addn i (@dimindex M (@setT M)))).
Lemma sndcart_def {A M N' : Type'} : (@sndcart A M N') = (fun _94996 : cart A (finite_sum M N') => @lambda A N' (fun i : nat => @dollar A (finite_sum M N') _94996 (addn i (@dimindex M (@setT M))))).
Proof. exact (REFL (@sndcart A M N')). Qed.
Definition _100406 {A : Type'} : (finite_sum A A) -> tybit0 A := fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum A A))) a).
Lemma _100406_def {A : Type'} : (@_100406 A) = (fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum A A))) a)).
Proof. exact (REFL (@_100406 A)). Qed.
Definition mktybit0 {A : Type'} : (finite_sum A A) -> tybit0 A := @_100406 A.
Lemma mktybit0_def {A : Type'} : (@mktybit0 A) = (@_100406 A).
Proof. exact (REFL (@mktybit0 A)). Qed.
Definition _100425 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a).
Lemma _100425_def {A : Type'} : (@_100425 A) = (fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a)).
Proof. exact (REFL (@_100425 A)). Qed.
Definition mktybit1 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := @_100425 A.
Lemma mktybit1_def {A : Type'} : (@mktybit1 A) = (@_100425 A).
Proof. exact (REFL (@mktybit1 A)). Qed.
Definition vector {A N' : Type'} : (seq A) -> cart A N' := fun _102119 : seq A => @lambda A N' (fun i : nat => @EL A (subn i (NUMERAL (BIT1 O))) _102119).
Lemma vector_def {A N' : Type'} : (@vector A N') = (fun _102119 : seq A => @lambda A N' (fun i : nat => @EL A (subn i (NUMERAL (BIT1 O))) _102119)).
Proof. exact (REFL (@vector A N')). Qed.
Definition PCROSS {A M N' : Type'} : ((cart A M) -> Prop) -> ((cart A N') -> Prop) -> (cart A (finite_sum M N')) -> Prop := fun _102146 : (cart A M) -> Prop => fun _102147 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102146) /\ (@IN (cart A N') y _102147)) (@pastecart A M N' x y)).
Lemma PCROSS_def {A M N' : Type'} : (@PCROSS A M N') = (fun _102146 : (cart A M) -> Prop => fun _102147 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102146) /\ (@IN (cart A N') y _102147)) (@pastecart A M N' x y))).
Proof. exact (REFL (@PCROSS A M N')). Qed.
Definition CASEWISE {_138002 _138038 _138042 _138043 : Type'} : (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 => forall _102751 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@nil (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) f x) = (@ε _138002 (fun y : _138002 => True))) /\ (forall h : prod (_138038 -> _138042) (_138043 -> _138038 -> _138002), forall t : seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)), forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@cons (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) h t) f x) = (@COND _138002 (exists y : _138038, (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x) (@snd (_138038 -> _138042) (_138043 -> _138038 -> _138002) h f (@ε _138038 (fun y : _138038 => (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x))) (CASEWISE' _102751 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))))))).
Lemma CASEWISE_def {_138002 _138038 _138042 _138043 : Type'} : (@CASEWISE _138002 _138038 _138042 _138043) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 => forall _102751 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@nil (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) f x) = (@ε _138002 (fun y : _138002 => True))) /\ (forall h : prod (_138038 -> _138042) (_138043 -> _138038 -> _138002), forall t : seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)), forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@cons (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) h t) f x) = (@COND _138002 (exists y : _138038, (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x) (@snd (_138038 -> _138042) (_138043 -> _138038 -> _138002) h f (@ε _138038 (fun y : _138038 => (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x))) (CASEWISE' _102751 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))))))))).
Proof. exact (REFL (@CASEWISE _138002 _138038 _138042 _138043)). Qed.
Definition admissible {_138333 _138336 _138340 _138341 _138346 : Type'} : (_138340 -> _138333 -> Prop) -> ((_138340 -> _138336) -> _138346 -> Prop) -> (_138346 -> _138333) -> ((_138340 -> _138336) -> _138346 -> _138341) -> Prop := fun _103818 : _138340 -> _138333 -> Prop => fun _103819 : (_138340 -> _138336) -> _138346 -> Prop => fun _103820 : _138346 -> _138333 => fun _103821 : (_138340 -> _138336) -> _138346 -> _138341 => forall f : _138340 -> _138336, forall g : _138340 -> _138336, forall a : _138346, ((_103819 f a) /\ ((_103819 g a) /\ (forall z : _138340, (_103818 z (_103820 a)) -> (f z) = (g z)))) -> (_103821 f a) = (_103821 g a).
Lemma admissible_def {_138333 _138336 _138340 _138341 _138346 : Type'} : (@admissible _138333 _138336 _138340 _138341 _138346) = (fun _103818 : _138340 -> _138333 -> Prop => fun _103819 : (_138340 -> _138336) -> _138346 -> Prop => fun _103820 : _138346 -> _138333 => fun _103821 : (_138340 -> _138336) -> _138346 -> _138341 => forall f : _138340 -> _138336, forall g : _138340 -> _138336, forall a : _138346, ((_103819 f a) /\ ((_103819 g a) /\ (forall z : _138340, (_103818 z (_103820 a)) -> (f z) = (g z)))) -> (_103821 f a) = (_103821 g a)).
Proof. exact (REFL (@admissible _138333 _138336 _138340 _138341 _138346)). Qed.
Definition tailadmissible {A B P : Type'} : (A -> A -> Prop) -> ((A -> B) -> P -> Prop) -> (P -> A) -> ((A -> B) -> P -> B) -> Prop := fun _103850 : A -> A -> Prop => fun _103851 : (A -> B) -> P -> Prop => fun _103852 : P -> A => fun _103853 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103850 y (G f a))) -> _103850 y (_103852 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103850 z (_103852 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103851 f a) -> (_103853 f a) = (@COND B (P' f a) (f (G f a)) (H f a)))).
Lemma tailadmissible_def {A B P : Type'} : (@tailadmissible A B P) = (fun _103850 : A -> A -> Prop => fun _103851 : (A -> B) -> P -> Prop => fun _103852 : P -> A => fun _103853 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103850 y (G f a))) -> _103850 y (_103852 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103850 z (_103852 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103851 f a) -> (_103853 f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Proof. exact (REFL (@tailadmissible A B P)). Qed.
Definition superadmissible {_138490 _138492 _138498 : Type'} : (_138490 -> _138490 -> Prop) -> ((_138490 -> _138492) -> _138498 -> Prop) -> (_138498 -> _138490) -> ((_138490 -> _138492) -> _138498 -> _138492) -> Prop := fun _103882 : _138490 -> _138490 -> Prop => fun _103883 : (_138490 -> _138492) -> _138498 -> Prop => fun _103884 : _138498 -> _138490 => fun _103885 : (_138490 -> _138492) -> _138498 -> _138492 => (@admissible _138490 _138492 _138490 Prop _138498 _103882 (fun f : _138490 -> _138492 => fun a : _138498 => True) _103884 _103883) -> @tailadmissible _138490 _138492 _138498 _103882 _103883 _103884 _103885.
Lemma superadmissible_def {_138490 _138492 _138498 : Type'} : (@superadmissible _138490 _138492 _138498) = (fun _103882 : _138490 -> _138490 -> Prop => fun _103883 : (_138490 -> _138492) -> _138498 -> Prop => fun _103884 : _138498 -> _138490 => fun _103885 : (_138490 -> _138492) -> _138498 -> _138492 => (@admissible _138490 _138492 _138490 Prop _138498 _103882 (fun f : _138490 -> _138492 => fun a : _138498 => True) _103884 _103883) -> @tailadmissible _138490 _138492 _138498 _103882 _103883 _103884 _103885).
Proof. exact (REFL (@superadmissible _138490 _138492 _138498)). Qed.
Definition fld {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _113806 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_372 : A => exists x : A, @SETSPEC A GEN_PVAR_372 (exists y : A, (_113806 x y) \/ (_113806 y x)) x).
Lemma fld_def {A : Type'} : (@fld A) = (fun _113806 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_372 : A => exists x : A, @SETSPEC A GEN_PVAR_372 (exists y : A, (_113806 x y) \/ (_113806 y x)) x)).
Proof. exact (REFL (@fld A)). Qed.
Definition qoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113861 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113861)) -> _113861 x x) /\ (forall x : A, forall y : A, forall z : A, ((_113861 x y) /\ (_113861 y z)) -> _113861 x z).
Lemma qoset_def {A : Type'} : (@qoset A) = (fun _113861 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113861)) -> _113861 x x) /\ (forall x : A, forall y : A, forall z : A, ((_113861 x y) /\ (_113861 y z)) -> _113861 x z)).
Proof. exact (REFL (@qoset A)). Qed.
Definition poset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113866 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113866)) -> _113866 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113866 x y) /\ (_113866 y z)) -> _113866 x z) /\ (forall x : A, forall y : A, ((_113866 x y) /\ (_113866 y x)) -> x = y)).
Lemma poset_def {A : Type'} : (@poset A) = (fun _113866 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113866)) -> _113866 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113866 x y) /\ (_113866 y z)) -> _113866 x z) /\ (forall x : A, forall y : A, ((_113866 x y) /\ (_113866 y x)) -> x = y))).
Proof. exact (REFL (@poset A)). Qed.
Definition toset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113871 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113871)) -> _113871 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113871 x y) /\ (_113871 y z)) -> _113871 x z) /\ ((forall x : A, forall y : A, ((_113871 x y) /\ (_113871 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _113871)) /\ (@IN A y (@fld A _113871))) -> (_113871 x y) \/ (_113871 y x)))).
Lemma toset_def {A : Type'} : (@toset A) = (fun _113871 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113871)) -> _113871 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113871 x y) /\ (_113871 y z)) -> _113871 x z) /\ ((forall x : A, forall y : A, ((_113871 x y) /\ (_113871 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _113871)) /\ (@IN A y (@fld A _113871))) -> (_113871 x y) \/ (_113871 y x))))).
Proof. exact (REFL (@toset A)). Qed.
Definition woset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113876 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113876)) -> _113876 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113876 x y) /\ (_113876 y z)) -> _113876 x z) /\ ((forall x : A, forall y : A, ((_113876 x y) /\ (_113876 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _113876)) /\ (@IN A y (@fld A _113876))) -> (_113876 x y) \/ (_113876 y x)) /\ (forall s : A -> Prop, ((@subset A s (@fld A _113876)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _113876 x y))))).
Lemma woset_def {A : Type'} : (@woset A) = (fun _113876 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113876)) -> _113876 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113876 x y) /\ (_113876 y z)) -> _113876 x z) /\ ((forall x : A, forall y : A, ((_113876 x y) /\ (_113876 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _113876)) /\ (@IN A y (@fld A _113876))) -> (_113876 x y) \/ (_113876 y x)) /\ (forall s : A -> Prop, ((@subset A s (@fld A _113876)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _113876 x y)))))).
Proof. exact (REFL (@woset A)). Qed.
Definition wqoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _113881 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113881)) -> _113881 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113881 x y) /\ (_113881 y z)) -> _113881 x z) /\ (forall s : A -> Prop, (@subset A s (@fld A _113881)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_113881 x y))))).
Lemma wqoset_def {A : Type'} : (@wqoset A) = (fun _113881 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _113881)) -> _113881 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_113881 x y) /\ (_113881 y z)) -> _113881 x z) /\ (forall s : A -> Prop, (@subset A s (@fld A _113881)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_113881 x y)))))).
Proof. exact (REFL (@wqoset A)). Qed.
Definition chain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _113886 : A -> A -> Prop => fun _113887 : A -> Prop => forall x : A, forall y : A, ((@IN A x _113887) /\ (@IN A y _113887)) -> (_113886 x y) \/ (_113886 y x).
Lemma chain_def {A : Type'} : (@chain A) = (fun _113886 : A -> A -> Prop => fun _113887 : A -> Prop => forall x : A, forall y : A, ((@IN A x _113887) /\ (@IN A y _113887)) -> (_113886 x y) \/ (_113886 y x)).
Proof. exact (REFL (@chain A)). Qed.
Definition antichain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _113898 : A -> A -> Prop => fun _113899 : A -> Prop => (@subset A _113899 (@fld A _113898)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_113898 x y)) _113899).
Lemma antichain_def {A : Type'} : (@antichain A) = (fun _113898 : A -> A -> Prop => fun _113899 : A -> Prop => (@subset A _113899 (@fld A _113898)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_113898 x y)) _113899)).
Proof. exact (REFL (@antichain A)). Qed.
Definition strictly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _114551 : A -> A -> Prop => fun x : A => fun y : A => (_114551 x y) /\ (~ (_114551 y x)).
Lemma strictly_def {A : Type'} : (@strictly A) = (fun _114551 : A -> A -> Prop => fun x : A => fun y : A => (_114551 x y) /\ (~ (_114551 y x))).
Proof. exact (REFL (@strictly A)). Qed.
Definition properly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _114556 : A -> A -> Prop => fun x : A => fun y : A => (_114556 x y) /\ (~ (x = y)).
Lemma properly_def {A : Type'} : (@properly A) = (fun _114556 : A -> A -> Prop => fun x : A => fun y : A => (_114556 x y) /\ (~ (x = y))).
Proof. exact (REFL (@properly A)). Qed.
Definition inseg {A : Type'} : (A -> A -> Prop) -> (A -> A -> Prop) -> Prop := fun _118817 : A -> A -> Prop => fun _118818 : A -> A -> Prop => forall x : A, forall y : A, (_118817 x y) = ((_118818 x y) /\ (@fld A _118817 y)).
Lemma inseg_def {A : Type'} : (@inseg A) = (fun _118817 : A -> A -> Prop => fun _118818 : A -> A -> Prop => forall x : A, forall y : A, (_118817 x y) = ((_118818 x y) /\ (@fld A _118817 y))).
Proof. exact (REFL (@inseg A)). Qed.
Definition linseg {A : Type'} : (A -> A -> Prop) -> A -> A -> A -> Prop := fun _118889 : A -> A -> Prop => fun _118890 : A => fun x : A => fun y : A => (_118889 x y) /\ (@properly A _118889 y _118890).
Lemma linseg_def {A : Type'} : (@linseg A) = (fun _118889 : A -> A -> Prop => fun _118890 : A => fun x : A => fun y : A => (_118889 x y) /\ (@properly A _118889 y _118890)).
Proof. exact (REFL (@linseg A)). Qed.
Definition ordinal {A : Type'} : (A -> A -> Prop) -> Prop := fun _118901 : A -> A -> Prop => (@woset A _118901) /\ (forall x : A, (@fld A _118901 x) -> x = (@ε A (fun y : A => ~ (@properly A _118901 y x)))).
Lemma ordinal_def {A : Type'} : (@ordinal A) = (fun _118901 : A -> A -> Prop => (@woset A _118901) /\ (forall x : A, (@fld A _118901 x) -> x = (@ε A (fun y : A => ~ (@properly A _118901 y x))))).
Proof. exact (REFL (@ordinal A)). Qed.
Definition add_c {_155246 _155247 : Type'} : (_155247 -> Prop) -> (_155246 -> Prop) -> (Datatypes.sum _155247 _155246) -> Prop := fun _201370 : _155247 -> Prop => fun _201371 : _155246 -> Prop => @setU (Datatypes.sum _155247 _155246) (@GSPEC (Datatypes.sum _155247 _155246) (fun GEN_PVAR_406 : Datatypes.sum _155247 _155246 => exists x : _155247, @SETSPEC (Datatypes.sum _155247 _155246) GEN_PVAR_406 (@IN _155247 x _201370) (@inl _155247 _155246 x))) (@GSPEC (Datatypes.sum _155247 _155246) (fun GEN_PVAR_407 : Datatypes.sum _155247 _155246 => exists y : _155246, @SETSPEC (Datatypes.sum _155247 _155246) GEN_PVAR_407 (@IN _155246 y _201371) (@inr _155247 _155246 y))).
Lemma add_c_def {_155246 _155247 : Type'} : (@add_c _155246 _155247) = (fun _201370 : _155247 -> Prop => fun _201371 : _155246 -> Prop => @setU (Datatypes.sum _155247 _155246) (@GSPEC (Datatypes.sum _155247 _155246) (fun GEN_PVAR_406 : Datatypes.sum _155247 _155246 => exists x : _155247, @SETSPEC (Datatypes.sum _155247 _155246) GEN_PVAR_406 (@IN _155247 x _201370) (@inl _155247 _155246 x))) (@GSPEC (Datatypes.sum _155247 _155246) (fun GEN_PVAR_407 : Datatypes.sum _155247 _155246 => exists y : _155246, @SETSPEC (Datatypes.sum _155247 _155246) GEN_PVAR_407 (@IN _155246 y _201371) (@inr _155247 _155246 y)))).
Proof. exact (REFL (@add_c _155246 _155247)). Qed.
Definition mul_c {_155279 _155280 : Type'} : (_155280 -> Prop) -> (_155279 -> Prop) -> (prod _155280 _155279) -> Prop := fun _201382 : _155280 -> Prop => fun _201383 : _155279 -> Prop => @GSPEC (prod _155280 _155279) (fun GEN_PVAR_408 : prod _155280 _155279 => exists x : _155280, exists y : _155279, @SETSPEC (prod _155280 _155279) GEN_PVAR_408 ((@IN _155280 x _201382) /\ (@IN _155279 y _201383)) (@pair _155280 _155279 x y)).
Lemma mul_c_def {_155279 _155280 : Type'} : (@mul_c _155279 _155280) = (fun _201382 : _155280 -> Prop => fun _201383 : _155279 -> Prop => @GSPEC (prod _155280 _155279) (fun GEN_PVAR_408 : prod _155280 _155279 => exists x : _155280, exists y : _155279, @SETSPEC (prod _155280 _155279) GEN_PVAR_408 ((@IN _155280 x _201382) /\ (@IN _155279 y _201383)) (@pair _155280 _155279 x y))).
Proof. exact (REFL (@mul_c _155279 _155280)). Qed.
Definition pow_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (B -> A) -> Prop := fun _237663 : A -> Prop => fun _237664 : B -> Prop => @GSPEC (B -> A) (fun GEN_PVAR_450 : B -> A => exists f : B -> A, @SETSPEC (B -> A) GEN_PVAR_450 ((forall x : B, (@IN B x _237664) -> @IN A (f x) _237663) /\ (forall x : B, (~ (@IN B x _237664)) -> (f x) = (@ε A (fun y : A => False)))) f).
Lemma pow_c_def {A B : Type'} : (@pow_c A B) = (fun _237663 : A -> Prop => fun _237664 : B -> Prop => @GSPEC (B -> A) (fun GEN_PVAR_450 : B -> A => exists f : B -> A, @SETSPEC (B -> A) GEN_PVAR_450 ((forall x : B, (@IN B x _237664) -> @IN A (f x) _237663) /\ (forall x : B, (~ (@IN B x _237664)) -> (f x) = (@ε A (fun y : A => False)))) f)).
Proof. exact (REFL (@pow_c A B)). Qed.
Definition permutes {_173218 : Type'} : (_173218 -> _173218) -> (_173218 -> Prop) -> Prop := fun _245262 : _173218 -> _173218 => fun _245263 : _173218 -> Prop => (forall x : _173218, (~ (@IN _173218 x _245263)) -> (_245262 x) = x) /\ (forall y : _173218, @ex1 _173218 (fun x : _173218 => (_245262 x) = y)).
Lemma permutes_def {_173218 : Type'} : (@permutes _173218) = (fun _245262 : _173218 -> _173218 => fun _245263 : _173218 -> Prop => (forall x : _173218, (~ (@IN _173218 x _245263)) -> (_245262 x) = x) /\ (forall y : _173218, @ex1 _173218 (fun x : _173218 => (_245262 x) = y))).
Proof. exact (REFL (@permutes _173218)). Qed.
Definition inverse {_173233 _173236 : Type'} : (_173236 -> _173233) -> _173233 -> _173236 := fun _245274 : _173236 -> _173233 => fun y : _173233 => @ε _173236 (fun x : _173236 => (_245274 x) = y).
Lemma inverse_def {_173233 _173236 : Type'} : (@inverse _173233 _173236) = (fun _245274 : _173236 -> _173233 => fun y : _173233 => @ε _173236 (fun x : _173236 => (_245274 x) = y)).
Proof. exact (REFL (@inverse _173233 _173236)). Qed.
Definition swap {_173440 : Type'} : (prod _173440 _173440) -> _173440 -> _173440 := fun _245688 : prod _173440 _173440 => fun _245689 : _173440 => @COND _173440 (_245689 = (@fst _173440 _173440 _245688)) (@snd _173440 _173440 _245688) (@COND _173440 (_245689 = (@snd _173440 _173440 _245688)) (@fst _173440 _173440 _245688) _245689).
Lemma swap_def {_173440 : Type'} : (@swap _173440) = (fun _245688 : prod _173440 _173440 => fun _245689 : _173440 => @COND _173440 (_245689 = (@fst _173440 _173440 _245688)) (@snd _173440 _173440 _245688) (@COND _173440 (_245689 = (@snd _173440 _173440 _245688)) (@fst _173440 _173440 _245688) _245689)).
Proof. exact (REFL (@swap _173440)). Qed.
Definition swapseq {_196662 : Type'} : nat -> (_196662 -> _196662) -> Prop := fun a0 : nat => fun a1 : _196662 -> _196662 => forall swapseq' : nat -> (_196662 -> _196662) -> Prop, (forall a0' : nat, forall a1' : _196662 -> _196662, (((a0' = (NUMERAL O)) /\ (a1' = (@I _196662))) \/ (exists a : _196662, exists b : _196662, exists p : _196662 -> _196662, exists n : nat, (a0' = (S n)) /\ ((a1' = (@o _196662 _196662 _196662 (@swap _196662 (@pair _196662 _196662 a b)) p)) /\ ((swapseq' n p) /\ (~ (a = b)))))) -> swapseq' a0' a1') -> swapseq' a0 a1.
Lemma swapseq_def {_196662 : Type'} : (@swapseq _196662) = (fun a0 : nat => fun a1 : _196662 -> _196662 => forall swapseq' : nat -> (_196662 -> _196662) -> Prop, (forall a0' : nat, forall a1' : _196662 -> _196662, (((a0' = (NUMERAL O)) /\ (a1' = (@I _196662))) \/ (exists a : _196662, exists b : _196662, exists p : _196662 -> _196662, exists n : nat, (a0' = (S n)) /\ ((a1' = (@o _196662 _196662 _196662 (@swap _196662 (@pair _196662 _196662 a b)) p)) /\ ((swapseq' n p) /\ (~ (a = b)))))) -> swapseq' a0' a1') -> swapseq' a0 a1).
Proof. exact (REFL (@swapseq _196662)). Qed.
Definition permutation {_196676 : Type'} : (_196676 -> _196676) -> Prop := fun _253332 : _196676 -> _196676 => exists n : nat, @swapseq _196676 n _253332.
Lemma permutation_def {_196676 : Type'} : (@permutation _196676) = (fun _253332 : _196676 -> _196676 => exists n : nat, @swapseq _196676 n _253332).
Proof. exact (REFL (@permutation _196676)). Qed.
Definition evenperm {_197379 : Type'} : (_197379 -> _197379) -> Prop := fun _256269 : _197379 -> _197379 => even (@ε nat (fun n : nat => @swapseq _197379 n _256269)).
Lemma evenperm_def {_197379 : Type'} : (@evenperm _197379) = (fun _256269 : _197379 -> _197379 => even (@ε nat (fun n : nat => @swapseq _197379 n _256269))).
Proof. exact (REFL (@evenperm _197379)). Qed.
Definition sign {_198303 : Type'} : (_198303 -> _198303) -> R := fun _258511 : _198303 -> _198303 => @COND R (@evenperm _198303 _258511) (R_of_nat (NUMERAL (BIT1 O))) (oppr (R_of_nat (NUMERAL (BIT1 O)))).
Lemma sign_def {_198303 : Type'} : (@sign _198303) = (fun _258511 : _198303 -> _198303 => @COND R (@evenperm _198303 _258511) (R_of_nat (NUMERAL (BIT1 O))) (oppr (R_of_nat (NUMERAL (BIT1 O))))).
Proof. exact (REFL (@sign _198303)). Qed.
Definition rational : R -> Prop := fun _268987 : R => exists m : R, exists n : R, (Rint m) /\ ((Rint n) /\ ((~ (n = (R_of_nat (NUMERAL O)))) /\ (_268987 = (divr m n)))).
Lemma rational_def : rational = (fun _268987 : R => exists m : R, exists n : R, (Rint m) /\ ((Rint n) /\ ((~ (n = (R_of_nat (NUMERAL O)))) /\ (_268987 = (divr m n))))).
Proof. exact (REFL rational). Qed.
Definition floor : R -> R := @ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> R -> R) (fun n : (prod nat (prod nat (prod nat (prod nat nat)))) -> R -> R => forall _269369 : prod nat (prod nat (prod nat (prod nat nat))), exists r : R -> R, forall x : R, (Rint (n _269369 x)) /\ ((ler (R_of_nat (NUMERAL O)) (r x)) /\ ((ltr (r x) (R_of_nat (NUMERAL (BIT1 O)))) /\ (x = (addr (n _269369 x) (r x)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))).
Lemma floor_def : floor = (@ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> R -> R) (fun n : (prod nat (prod nat (prod nat (prod nat nat)))) -> R -> R => forall _269369 : prod nat (prod nat (prod nat (prod nat nat))), exists r : R -> R, forall x : R, (Rint (n _269369 x)) /\ ((ler (R_of_nat (NUMERAL O)) (r x)) /\ ((ltr (r x) (R_of_nat (NUMERAL (BIT1 O)))) /\ (x = (addr (n _269369 x) (r x)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))).
Proof. exact (REFL floor). Qed.
Definition frac : R -> R := @ε ((prod nat (prod nat (prod nat nat))) -> R -> R) (fun r : (prod nat (prod nat (prod nat nat))) -> R -> R => forall _269370 : prod nat (prod nat (prod nat nat)), forall x : R, (Rint (floor x)) /\ ((ler (R_of_nat (NUMERAL O)) (r _269370 x)) /\ ((ltr (r _269370 x) (R_of_nat (NUMERAL (BIT1 O)))) /\ (x = (addr (floor x) (r _269370 x)))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))).
Lemma frac_def : frac = (@ε ((prod nat (prod nat (prod nat nat))) -> R -> R) (fun r : (prod nat (prod nat (prod nat nat))) -> R -> R => forall _269370 : prod nat (prod nat (prod nat nat)), forall x : R, (Rint (floor x)) /\ ((ler (R_of_nat (NUMERAL O)) (r _269370 x)) /\ ((ltr (r _269370 x) (R_of_nat (NUMERAL (BIT1 O)))) /\ (x = (addr (floor x) (r _269370 x)))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))).
Proof. exact (REFL frac). Qed.
Definition is_realinterval : (R -> Prop) -> Prop := fun _271108 : R -> Prop => forall a : R, forall b : R, forall c : R, ((@IN R a _271108) /\ ((@IN R b _271108) /\ ((ler a c) /\ (ler c b)))) -> @IN R c _271108.
Lemma is_realinterval_def : is_realinterval = (fun _271108 : R -> Prop => forall a : R, forall b : R, forall c : R, ((@IN R a _271108) /\ ((@IN R b _271108) /\ ((ler a c) /\ (ler c b)))) -> @IN R c _271108).
Proof. exact (REFL is_realinterval). Qed.
Definition open_real_interval : (prod R R) -> R -> Prop := fun _271169 : prod R R => @GSPEC R (fun GEN_PVAR_630 : R => exists x : R, @SETSPEC R GEN_PVAR_630 ((ltr (@fst R R _271169) x) /\ (ltr x (@snd R R _271169))) x).
Lemma open_real_interval_def : open_real_interval = (fun _271169 : prod R R => @GSPEC R (fun GEN_PVAR_630 : R => exists x : R, @SETSPEC R GEN_PVAR_630 ((ltr (@fst R R _271169) x) /\ (ltr x (@snd R R _271169))) x)).
Proof. exact (REFL open_real_interval). Qed.
Definition closed_real_interval : (seq (prod R R)) -> R -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) -> (seq (prod R R)) -> R -> Prop) (fun closed_real_interval' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) -> (seq (prod R R)) -> R -> Prop => forall _271288 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))), forall a : R, forall b : R, (closed_real_interval' _271288 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_631 : R => exists x : R, @SETSPEC R GEN_PVAR_631 ((ler a x) /\ (ler x b)) x))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))))).
Lemma closed_real_interval_def : closed_real_interval = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) -> (seq (prod R R)) -> R -> Prop) (fun closed_real_interval' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) -> (seq (prod R R)) -> R -> Prop => forall _271288 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))), forall a : R, forall b : R, (closed_real_interval' _271288 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_631 : R => exists x : R, @SETSPEC R GEN_PVAR_631 ((ler a x) /\ (ler x b)) x))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))))).
Proof. exact (REFL closed_real_interval). Qed.
Definition vectorize {A M N' : Type'} : (cart (cart A N') M) -> cart A (finite_prod M N') := fun x : cart (cart A N') M => @lambda A (finite_prod M N') (fun i : nat => @dollar A N' (@dollar (cart A N') M x (addn (NUMERAL (BIT1 O)) (divn (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N'))))) (addn (NUMERAL (BIT1 O)) (modn (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N'))))).
Lemma vectorize_def {A M N' : Type'} : (@vectorize A M N') = (fun x : cart (cart A N') M => @lambda A (finite_prod M N') (fun i : nat => @dollar A N' (@dollar (cart A N') M x (addn (NUMERAL (BIT1 O)) (divn (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N'))))) (addn (NUMERAL (BIT1 O)) (modn (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N')))))).
Proof. exact (REFL (@vectorize A M N')). Qed.
Definition matrify {A M N' : Type'} : (cart A (finite_prod M N')) -> cart (cart A N') M := fun x : cart A (finite_prod M N') => @lambda (cart A N') M (fun i : nat => @lambda A N' (fun j : nat => @dollar A (finite_prod M N') x (addn (muln (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N'))) j))).
Lemma matrify_def {A M N' : Type'} : (@matrify A M N') = (fun x : cart A (finite_prod M N') => @lambda (cart A N') M (fun i : nat => @lambda A N' (fun j : nat => @dollar A (finite_prod M N') x (addn (muln (subn i (NUMERAL (BIT1 O))) (@dimindex N' (@setT N'))) j)))).
Proof. exact (REFL (@matrify A M N')). Qed.
Definition hull {_219543 : Type'} : ((_219543 -> Prop) -> Prop) -> (_219543 -> Prop) -> _219543 -> Prop := fun _272467 : (_219543 -> Prop) -> Prop => fun _272468 : _219543 -> Prop => @INTERS _219543 (@GSPEC (_219543 -> Prop) (fun GEN_PVAR_636 : _219543 -> Prop => exists t : _219543 -> Prop, @SETSPEC (_219543 -> Prop) GEN_PVAR_636 ((_272467 t) /\ (@subset _219543 _272468 t)) t)).
Lemma hull_def {_219543 : Type'} : (@hull _219543) = (fun _272467 : (_219543 -> Prop) -> Prop => fun _272468 : _219543 -> Prop => @INTERS _219543 (@GSPEC (_219543 -> Prop) (fun GEN_PVAR_636 : _219543 -> Prop => exists t : _219543 -> Prop, @SETSPEC (_219543 -> Prop) GEN_PVAR_636 ((_272467 t) /\ (@subset _219543 _272468 t)) t))).
Proof. exact (REFL (@hull _219543)). Qed.
Definition relative_to {_231582 : Type'} : ((_231582 -> Prop) -> Prop) -> (_231582 -> Prop) -> (_231582 -> Prop) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> ((_231582 -> Prop) -> Prop) -> (_231582 -> Prop) -> (_231582 -> Prop) -> Prop) (fun relative_to' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> ((_231582 -> Prop) -> Prop) -> (_231582 -> Prop) -> (_231582 -> Prop) -> Prop => forall _277011 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), forall P : (_231582 -> Prop) -> Prop, forall s : _231582 -> Prop, forall t : _231582 -> Prop, (relative_to' _277011 P s t) = (exists u : _231582 -> Prop, (P u) /\ ((@setI _231582 s u) = t))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Lemma relative_to_def {_231582 : Type'} : (@relative_to _231582) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> ((_231582 -> Prop) -> Prop) -> (_231582 -> Prop) -> (_231582 -> Prop) -> Prop) (fun relative_to' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> ((_231582 -> Prop) -> Prop) -> (_231582 -> Prop) -> (_231582 -> Prop) -> Prop => forall _277011 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), forall P : (_231582 -> Prop) -> Prop, forall s : _231582 -> Prop, forall t : _231582 -> Prop, (relative_to' _277011 P s t) = (exists u : _231582 -> Prop, (P u) /\ ((@setI _231582 s u) = t))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))).
Proof. exact (REFL (@relative_to _231582)). Qed.
Definition suslin_operation {A : Type'} : ((seq nat) -> A -> Prop) -> A -> Prop := fun _305502 : (seq nat) -> A -> Prop => @UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_682 : A -> Prop => exists s : nat -> nat, @SETSPEC (A -> Prop) GEN_PVAR_682 (@IN (nat -> nat) s (@setT (nat -> nat))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_681 : A -> Prop => exists n : nat, @SETSPEC (A -> Prop) GEN_PVAR_681 (leqn (NUMERAL (BIT1 O)) n) (_305502 (@mkseq nat s n))))))).
Lemma suslin_operation_def {A : Type'} : (@suslin_operation A) = (fun _305502 : (seq nat) -> A -> Prop => @UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_682 : A -> Prop => exists s : nat -> nat, @SETSPEC (A -> Prop) GEN_PVAR_682 (@IN (nat -> nat) s (@setT (nat -> nat))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_681 : A -> Prop => exists n : nat, @SETSPEC (A -> Prop) GEN_PVAR_681 (leqn (NUMERAL (BIT1 O)) n) (_305502 (@mkseq nat s n)))))))).
Proof. exact (REFL (@suslin_operation A)). Qed.
Definition suslin {_235924 : Type'} : ((_235924 -> Prop) -> Prop) -> (_235924 -> Prop) -> Prop := fun _305507 : (_235924 -> Prop) -> Prop => @GSPEC (_235924 -> Prop) (fun GEN_PVAR_683 : _235924 -> Prop => exists f : (seq nat) -> _235924 -> Prop, @SETSPEC (_235924 -> Prop) GEN_PVAR_683 (forall l : seq nat, (~ (l = (@nil nat))) -> @IN (_235924 -> Prop) (f l) _305507) (@suslin_operation _235924 f)).
Lemma suslin_def {_235924 : Type'} : (@suslin _235924) = (fun _305507 : (_235924 -> Prop) -> Prop => @GSPEC (_235924 -> Prop) (fun GEN_PVAR_683 : _235924 -> Prop => exists f : (seq nat) -> _235924 -> Prop, @SETSPEC (_235924 -> Prop) GEN_PVAR_683 (forall l : seq nat, (~ (l = (@nil nat))) -> @IN (_235924 -> Prop) (f l) _305507) (@suslin_operation _235924 f))).
Proof. exact (REFL (@suslin _235924)). Qed.
Definition ITER {_238145 : Type'} : nat -> (_238145 -> _238145) -> _238145 -> _238145 := @ε ((prod nat (prod nat (prod nat nat))) -> nat -> (_238145 -> _238145) -> _238145 -> _238145) (fun ITER' : (prod nat (prod nat (prod nat nat))) -> nat -> (_238145 -> _238145) -> _238145 -> _238145 => forall _337704 : prod nat (prod nat (prod nat nat)), (forall x : _238145, forall f : _238145 -> _238145, (ITER' _337704 (NUMERAL O) f x) = x) /\ (forall x : _238145, forall f : _238145 -> _238145, forall n : nat, (ITER' _337704 (S n) f x) = (f (ITER' _337704 n f x)))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O))))))))))).
Lemma ITER_def {_238145 : Type'} : (@ITER _238145) = (@ε ((prod nat (prod nat (prod nat nat))) -> nat -> (_238145 -> _238145) -> _238145 -> _238145) (fun ITER' : (prod nat (prod nat (prod nat nat))) -> nat -> (_238145 -> _238145) -> _238145 -> _238145 => forall _337704 : prod nat (prod nat (prod nat nat)), (forall x : _238145, forall f : _238145 -> _238145, (ITER' _337704 (NUMERAL O) f x) = x) /\ (forall x : _238145, forall f : _238145 -> _238145, forall n : nat, (ITER' _337704 (S n) f x) = (f (ITER' _337704 n f x)))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))))))).
Proof. exact (REFL (@ITER _238145)). Qed.
Definition frag_support {A : Type'} : (frag A) -> A -> Prop := fun _338887 : frag A => @GSPEC A (fun GEN_PVAR_710 : A => exists a : A, @SETSPEC A GEN_PVAR_710 (~ ((@dest_frag A _338887 a) = (int_of_nat (NUMERAL O)))) a).
Lemma frag_support_def {A : Type'} : (@frag_support A) = (fun _338887 : frag A => @GSPEC A (fun GEN_PVAR_710 : A => exists a : A, @SETSPEC A GEN_PVAR_710 (~ ((@dest_frag A _338887 a) = (int_of_nat (NUMERAL O)))) a)).
Proof. exact (REFL (@frag_support A)). Qed.
Definition frag_0 {A : Type'} : frag A := @mk_frag A (fun x : A => int_of_nat (NUMERAL O)).
Lemma frag_0_def {A : Type'} : (@frag_0 A) = (@mk_frag A (fun x : A => int_of_nat (NUMERAL O))).
Proof. exact (REFL (@frag_0 A)). Qed.
Definition frag_of {A : Type'} : A -> frag A := fun _338892 : A => @mk_frag A (fun a : A => @COND int (a = _338892) (int_of_nat (NUMERAL (BIT1 O))) (int_of_nat (NUMERAL O))).
Lemma frag_of_def {A : Type'} : (@frag_of A) = (fun _338892 : A => @mk_frag A (fun a : A => @COND int (a = _338892) (int_of_nat (NUMERAL (BIT1 O))) (int_of_nat (NUMERAL O)))).
Proof. exact (REFL (@frag_of A)). Qed.
Definition frag_neg {A : Type'} : (frag A) -> frag A := fun _338897 : frag A => @mk_frag A (fun a : A => oppz (@dest_frag A _338897 a)).
Lemma frag_neg_def {A : Type'} : (@frag_neg A) = (fun _338897 : frag A => @mk_frag A (fun a : A => oppz (@dest_frag A _338897 a))).
Proof. exact (REFL (@frag_neg A)). Qed.
Definition frag_cmul {A : Type'} : int -> (frag A) -> frag A := fun _338902 : int => fun _338903 : frag A => @mk_frag A (fun a : A => mulz _338902 (@dest_frag A _338903 a)).
Lemma frag_cmul_def {A : Type'} : (@frag_cmul A) = (fun _338902 : int => fun _338903 : frag A => @mk_frag A (fun a : A => mulz _338902 (@dest_frag A _338903 a))).
Proof. exact (REFL (@frag_cmul A)). Qed.
Definition frag_add {A : Type'} : (frag A) -> (frag A) -> frag A := fun _338914 : frag A => fun _338915 : frag A => @mk_frag A (fun a : A => addz (@dest_frag A _338914 a) (@dest_frag A _338915 a)).
Lemma frag_add_def {A : Type'} : (@frag_add A) = (fun _338914 : frag A => fun _338915 : frag A => @mk_frag A (fun a : A => addz (@dest_frag A _338914 a) (@dest_frag A _338915 a))).
Proof. exact (REFL (@frag_add A)). Qed.
Definition frag_sub {A : Type'} : (frag A) -> (frag A) -> frag A := fun _338926 : frag A => fun _338927 : frag A => @mk_frag A (fun a : A => subz (@dest_frag A _338926 a) (@dest_frag A _338927 a)).
Lemma frag_sub_def {A : Type'} : (@frag_sub A) = (fun _338926 : frag A => fun _338927 : frag A => @mk_frag A (fun a : A => subz (@dest_frag A _338926 a) (@dest_frag A _338927 a))).
Proof. exact (REFL (@frag_sub A)). Qed.
Definition frag_extend {A B : Type'} : (A -> frag B) -> (frag A) -> frag B := fun _339532 : A -> frag B => fun _339533 : frag A => @iterate A (frag B) (@frag_add B) (@frag_support A _339533) (fun a : A => @frag_cmul B (@dest_frag A _339533 a) (_339532 a)).
Lemma frag_extend_def {A B : Type'} : (@frag_extend A B) = (fun _339532 : A -> frag B => fun _339533 : frag A => @iterate A (frag B) (@frag_add B) (@frag_support A _339533) (fun a : A => @frag_cmul B (@dest_frag A _339533 a) (_339532 a))).
Proof. exact (REFL (@frag_extend A B)). Qed.
Definition index : nat -> nat -> nat := fun _346720 : nat => fun _346721 : nat => @COND nat ((leqn _346720 (NUMERAL (BIT1 O))) \/ (_346721 = (NUMERAL O))) (NUMERAL O) (@CARD nat (@GSPEC nat (fun GEN_PVAR_729 : nat => exists j : nat, @SETSPEC nat GEN_PVAR_729 ((leqn (NUMERAL (BIT1 O)) j) /\ (num_divides (expn _346720 j) _346721)) j))).
Lemma index_def : index = (fun _346720 : nat => fun _346721 : nat => @COND nat ((leqn _346720 (NUMERAL (BIT1 O))) \/ (_346721 = (NUMERAL O))) (NUMERAL O) (@CARD nat (@GSPEC nat (fun GEN_PVAR_729 : nat => exists j : nat, @SETSPEC nat GEN_PVAR_729 ((leqn (NUMERAL (BIT1 O)) j) /\ (num_divides (expn _346720 j) _346721)) j)))).
Proof. exact (REFL index). Qed.
Definition singleton_group {A : Type'} : A -> hol_Group A := fun _354299 : A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INSERT A _354299 (@set0 A)) (@pair A (prod (A -> A) (A -> A -> A)) _354299 (@pair (A -> A) (A -> A -> A) (fun x : A => _354299) (fun x : A => fun y : A => _354299)))).
Lemma singleton_group_def {A : Type'} : (@singleton_group A) = (fun _354299 : A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INSERT A _354299 (@set0 A)) (@pair A (prod (A -> A) (A -> A -> A)) _354299 (@pair (A -> A) (A -> A -> A) (fun x : A => _354299) (fun x : A => fun y : A => _354299))))).
Proof. exact (REFL (@singleton_group A)). Qed.
Definition trivial_group {_255762 : Type'} : (hol_Group _255762) -> Prop := fun _354304 : hol_Group _255762 => (@gcar _255762 _354304) = (@INSERT _255762 (@g0 _255762 _354304) (@set0 _255762)).
Lemma trivial_group_def {_255762 : Type'} : (@trivial_group _255762) = (fun _354304 : hol_Group _255762 => (@gcar _255762 _354304) = (@INSERT _255762 (@g0 _255762 _354304) (@set0 _255762))).
Proof. exact (REFL (@trivial_group _255762)). Qed.
Definition opposite_group {A : Type'} : (hol_Group A) -> hol_Group A := fun _354370 : hol_Group A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@gcar A _354370) (@pair A (prod (A -> A) (A -> A -> A)) (@g0 A _354370) (@pair (A -> A) (A -> A -> A) (@ginv A _354370) (fun x : A => fun y : A => @gop A _354370 y x)))).
Lemma opposite_group_def {A : Type'} : (@opposite_group A) = (fun _354370 : hol_Group A => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@gcar A _354370) (@pair A (prod (A -> A) (A -> A -> A)) (@g0 A _354370) (@pair (A -> A) (A -> A -> A) (@ginv A _354370) (fun x : A => fun y : A => @gop A _354370 y x))))).
Proof. exact (REFL (@opposite_group A)). Qed.
Definition group_div {_256135 : Type'} : (hol_Group _256135) -> _256135 -> _256135 -> _256135 := fun _354375 : hol_Group _256135 => fun _354376 : _256135 => fun _354377 : _256135 => @gop _256135 _354375 _354376 (@ginv _256135 _354375 _354377).
Lemma group_div_def {_256135 : Type'} : (@group_div _256135) = (fun _354375 : hol_Group _256135 => fun _354376 : _256135 => fun _354377 : _256135 => @gop _256135 _354375 _354376 (@ginv _256135 _354375 _354377)).
Proof. exact (REFL (@group_div _256135)). Qed.
Definition group_pow {_257327 : Type'} : (hol_Group _257327) -> _257327 -> nat -> _257327 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (hol_Group _257327) -> _257327 -> nat -> _257327) (fun group_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (hol_Group _257327) -> _257327 -> nat -> _257327 => forall _355010 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), (forall x : _257327, forall G : hol_Group _257327, (group_pow' _355010 G x (NUMERAL O)) = (@g0 _257327 G)) /\ (forall G : hol_Group _257327, forall x : _257327, forall n : nat, (group_pow' _355010 G x (S n)) = (@gop _257327 G x (group_pow' _355010 G x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))))))).
Lemma group_pow_def {_257327 : Type'} : (@group_pow _257327) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (hol_Group _257327) -> _257327 -> nat -> _257327) (fun group_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (hol_Group _257327) -> _257327 -> nat -> _257327 => forall _355010 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), (forall x : _257327, forall G : hol_Group _257327, (group_pow' _355010 G x (NUMERAL O)) = (@g0 _257327 G)) /\ (forall G : hol_Group _257327, forall x : _257327, forall n : nat, (group_pow' _355010 G x (S n)) = (@gop _257327 G x (group_pow' _355010 G x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))))))).
Proof. exact (REFL (@group_pow _257327)). Qed.
Definition group_zpow {A : Type'} : (hol_Group A) -> A -> int -> A := fun _355070 : hol_Group A => fun _355071 : A => fun _355072 : int => @COND A (lez (int_of_nat (NUMERAL O)) _355072) (@group_pow A _355070 _355071 (num_of_int _355072)) (@ginv A _355070 (@group_pow A _355070 _355071 (num_of_int (oppz _355072)))).
Lemma group_zpow_def {A : Type'} : (@group_zpow A) = (fun _355070 : hol_Group A => fun _355071 : A => fun _355072 : int => @COND A (lez (int_of_nat (NUMERAL O)) _355072) (@group_pow A _355070 _355071 (num_of_int _355072)) (@ginv A _355070 (@group_pow A _355070 _355071 (num_of_int (oppz _355072))))).
Proof. exact (REFL (@group_zpow A)). Qed.
Definition abelian_group {A : Type'} : (hol_Group A) -> Prop := fun _355258 : hol_Group A => forall x : A, forall y : A, ((@IN A x (@gcar A _355258)) /\ (@IN A y (@gcar A _355258))) -> (@gop A _355258 x y) = (@gop A _355258 y x).
Lemma abelian_group_def {A : Type'} : (@abelian_group A) = (fun _355258 : hol_Group A => forall x : A, forall y : A, ((@IN A x (@gcar A _355258)) /\ (@IN A y (@gcar A _355258))) -> (@gop A _355258 x y) = (@gop A _355258 y x)).
Proof. exact (REFL (@abelian_group A)). Qed.
Definition group_neg {_259163 : Type'} : (hol_Group _259163) -> _259163 -> _259163 := fun _355475 : hol_Group _259163 => fun _355476 : _259163 => @COND _259163 (@IN _259163 _355476 (@gcar _259163 _355475)) (@ginv _259163 _355475 _355476) _355476.
Lemma group_neg_def {_259163 : Type'} : (@group_neg _259163) = (fun _355475 : hol_Group _259163 => fun _355476 : _259163 => @COND _259163 (@IN _259163 _355476 (@gcar _259163 _355475)) (@ginv _259163 _355475 _355476) _355476).
Proof. exact (REFL (@group_neg _259163)). Qed.
Definition group_add {A : Type'} : (hol_Group A) -> A -> A -> A := fun _355487 : hol_Group A => fun _355488 : A => fun _355489 : A => @COND A ((@IN A _355488 (@gcar A _355487)) /\ (@IN A _355489 (@gcar A _355487))) (@gop A _355487 _355488 _355489) (@COND A (@IN A _355488 (@gcar A _355487)) _355489 (@COND A (@IN A _355489 (@gcar A _355487)) _355488 (@ε A (fun w : A => ~ (@IN A w (@gcar A _355487)))))).
Lemma group_add_def {A : Type'} : (@group_add A) = (fun _355487 : hol_Group A => fun _355488 : A => fun _355489 : A => @COND A ((@IN A _355488 (@gcar A _355487)) /\ (@IN A _355489 (@gcar A _355487))) (@gop A _355487 _355488 _355489) (@COND A (@IN A _355488 (@gcar A _355487)) _355489 (@COND A (@IN A _355489 (@gcar A _355487)) _355488 (@ε A (fun w : A => ~ (@IN A w (@gcar A _355487))))))).
Proof. exact (REFL (@group_add A)). Qed.
Definition group_nmul {_259244 : Type'} : (hol_Group _259244) -> nat -> _259244 -> _259244 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (hol_Group _259244) -> nat -> _259244 -> _259244) (fun group_nmul' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (hol_Group _259244) -> nat -> _259244 -> _259244 => forall _355515 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), (forall x : _259244, forall G : hol_Group _259244, (group_nmul' _355515 G (NUMERAL O) x) = (@g0 _259244 G)) /\ (forall G : hol_Group _259244, forall n : nat, forall x : _259244, (group_nmul' _355515 G (S n) x) = (@group_add _259244 G x (group_nmul' _355515 G n x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))).
Lemma group_nmul_def {_259244 : Type'} : (@group_nmul _259244) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (hol_Group _259244) -> nat -> _259244 -> _259244) (fun group_nmul' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (hol_Group _259244) -> nat -> _259244 -> _259244 => forall _355515 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), (forall x : _259244, forall G : hol_Group _259244, (group_nmul' _355515 G (NUMERAL O) x) = (@g0 _259244 G)) /\ (forall G : hol_Group _259244, forall n : nat, forall x : _259244, (group_nmul' _355515 G (S n) x) = (@group_add _259244 G x (group_nmul' _355515 G n x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Proof. exact (REFL (@group_nmul _259244)). Qed.
Definition group_product {_260356 A : Type'} : (hol_Group A) -> (_260356 -> _260356 -> Prop) -> (_260356 -> Prop) -> (_260356 -> A) -> A := fun _355877 : hol_Group A => @iterato A _260356 (@gcar A _355877) (@g0 A _355877) (@gop A _355877).
Lemma group_product_def {_260356 A : Type'} : (@group_product _260356 A) = (fun _355877 : hol_Group A => @iterato A _260356 (@gcar A _355877) (@g0 A _355877) (@gop A _355877)).
Proof. exact (REFL (@group_product _260356 A)). Qed.
Definition group_sum {A K : Type'} : (hol_Group A) -> (K -> Prop) -> (K -> A) -> A := fun _355882 : hol_Group A => @group_product K A _355882 (@ε (K -> K -> Prop) (fun l : K -> K -> Prop => (@woset K l) /\ ((@fld K l) = (@setT K)))).
Lemma group_sum_def {A K : Type'} : (@group_sum A K) = (fun _355882 : hol_Group A => @group_product K A _355882 (@ε (K -> K -> Prop) (fun l : K -> K -> Prop => (@woset K l) /\ ((@fld K l) = (@setT K))))).
Proof. exact (REFL (@group_sum A K)). Qed.
Definition group_conjugation {_265792 : Type'} : (hol_Group _265792) -> _265792 -> _265792 -> _265792 := fun _371120 : hol_Group _265792 => fun _371121 : _265792 => fun _371122 : _265792 => @gop _265792 _371120 _371121 (@gop _265792 _371120 _371122 (@ginv _265792 _371120 _371121)).
Lemma group_conjugation_def {_265792 : Type'} : (@group_conjugation _265792) = (fun _371120 : hol_Group _265792 => fun _371121 : _265792 => fun _371122 : _265792 => @gop _265792 _371120 _371121 (@gop _265792 _371120 _371122 (@ginv _265792 _371120 _371121))).
Proof. exact (REFL (@group_conjugation _265792)). Qed.
Definition subgroup_of {A : Type'} : (A -> Prop) -> (hol_Group A) -> Prop := fun _371828 : A -> Prop => fun _371829 : hol_Group A => (@subset A _371828 (@gcar A _371829)) /\ ((@IN A (@g0 A _371829) _371828) /\ ((forall x : A, (@IN A x _371828) -> @IN A (@ginv A _371829 x) _371828) /\ (forall x : A, forall y : A, ((@IN A x _371828) /\ (@IN A y _371828)) -> @IN A (@gop A _371829 x y) _371828))).
Lemma subgroup_of_def {A : Type'} : (@subgroup_of A) = (fun _371828 : A -> Prop => fun _371829 : hol_Group A => (@subset A _371828 (@gcar A _371829)) /\ ((@IN A (@g0 A _371829) _371828) /\ ((forall x : A, (@IN A x _371828) -> @IN A (@ginv A _371829 x) _371828) /\ (forall x : A, forall y : A, ((@IN A x _371828) /\ (@IN A y _371828)) -> @IN A (@gop A _371829 x y) _371828)))).
Proof. exact (REFL (@subgroup_of A)). Qed.
Definition subgroup_generated {A : Type'} : (hol_Group A) -> (A -> Prop) -> hol_Group A := fun _372670 : hol_Group A => fun _372671 : A -> Prop => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_810 : A -> Prop => exists h : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_810 ((@subgroup_of A h _372670) /\ (@subset A (@setI A (@gcar A _372670) _372671) h)) h))) (@pair A (prod (A -> A) (A -> A -> A)) (@g0 A _372670) (@pair (A -> A) (A -> A -> A) (@ginv A _372670) (@gop A _372670)))).
Lemma subgroup_generated_def {A : Type'} : (@subgroup_generated A) = (fun _372670 : hol_Group A => fun _372671 : A -> Prop => @group A (@pair (A -> Prop) (prod A (prod (A -> A) (A -> A -> A))) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_810 : A -> Prop => exists h : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_810 ((@subgroup_of A h _372670) /\ (@subset A (@setI A (@gcar A _372670) _372671) h)) h))) (@pair A (prod (A -> A) (A -> A -> A)) (@g0 A _372670) (@pair (A -> A) (A -> A -> A) (@ginv A _372670) (@gop A _372670))))).
Proof. exact (REFL (@subgroup_generated A)). Qed.
Definition prod_group {A B : Type'} : (hol_Group A) -> (hol_Group B) -> hol_Group (prod A B) := fun _374630 : hol_Group A => fun _374631 : hol_Group B => @group (prod A B) (@pair ((prod A B) -> Prop) (prod (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B))) (@CROSS A B (@gcar A _374630) (@gcar B _374631)) (@pair (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B)) (@pair A B (@g0 A _374630) (@g0 B _374631)) (@pair ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B) (@GABS ((prod A B) -> prod A B) (fun f : (prod A B) -> prod A B => forall x : A, forall x' : B, @eq (prod A B) (f (@pair A B x x')) (@pair A B (@ginv A _374630 x) (@ginv B _374631 x')))) (@GABS ((prod A B) -> (prod A B) -> prod A B) (fun f : (prod A B) -> (prod A B) -> prod A B => forall x : A, forall x' : B, @eq ((prod A B) -> prod A B) (f (@pair A B x x')) (@GABS ((prod A B) -> prod A B) (fun f' : (prod A B) -> prod A B => forall y : A, forall y' : B, @eq (prod A B) (f' (@pair A B y y')) (@pair A B (@gop A _374630 x y) (@gop B _374631 x' y'))))))))).
Lemma prod_group_def {A B : Type'} : (@prod_group A B) = (fun _374630 : hol_Group A => fun _374631 : hol_Group B => @group (prod A B) (@pair ((prod A B) -> Prop) (prod (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B))) (@CROSS A B (@gcar A _374630) (@gcar B _374631)) (@pair (prod A B) (prod ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B)) (@pair A B (@g0 A _374630) (@g0 B _374631)) (@pair ((prod A B) -> prod A B) ((prod A B) -> (prod A B) -> prod A B) (@GABS ((prod A B) -> prod A B) (fun f : (prod A B) -> prod A B => forall x : A, forall x' : B, @eq (prod A B) (f (@pair A B x x')) (@pair A B (@ginv A _374630 x) (@ginv B _374631 x')))) (@GABS ((prod A B) -> (prod A B) -> prod A B) (fun f : (prod A B) -> (prod A B) -> prod A B => forall x : A, forall x' : B, @eq ((prod A B) -> prod A B) (f (@pair A B x x')) (@GABS ((prod A B) -> prod A B) (fun f' : (prod A B) -> prod A B => forall y : A, forall y' : B, @eq (prod A B) (f' (@pair A B y y')) (@pair A B (@gop A _374630 x y) (@gop B _374631 x' y')))))))))).
Proof. exact (REFL (@prod_group A B)). Qed.
Definition product_group {A K : Type'} : (K -> Prop) -> (K -> hol_Group A) -> hol_Group (K -> A) := fun _375392 : K -> Prop => fun _375393 : K -> hol_Group A => @group (K -> A) (@pair ((K -> A) -> Prop) (prod (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A))) (@cartesian_product A K _375392 (fun i : K => @gcar A (_375393 i))) (@pair (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A)) (@RESTRICTION K A _375392 (fun i : K => @g0 A (_375393 i))) (@pair ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A) (fun x : K -> A => @RESTRICTION K A _375392 (fun i : K => @ginv A (_375393 i) (x i))) (fun x : K -> A => fun y : K -> A => @RESTRICTION K A _375392 (fun i : K => @gop A (_375393 i) (x i) (y i)))))).
Lemma product_group_def {A K : Type'} : (@product_group A K) = (fun _375392 : K -> Prop => fun _375393 : K -> hol_Group A => @group (K -> A) (@pair ((K -> A) -> Prop) (prod (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A))) (@cartesian_product A K _375392 (fun i : K => @gcar A (_375393 i))) (@pair (K -> A) (prod ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A)) (@RESTRICTION K A _375392 (fun i : K => @g0 A (_375393 i))) (@pair ((K -> A) -> K -> A) ((K -> A) -> (K -> A) -> K -> A) (fun x : K -> A => @RESTRICTION K A _375392 (fun i : K => @ginv A (_375393 i) (x i))) (fun x : K -> A => fun y : K -> A => @RESTRICTION K A _375392 (fun i : K => @gop A (_375393 i) (x i) (y i))))))).
Proof. exact (REFL (@product_group A K)). Qed.
Definition sum_group {A K : Type'} : (K -> Prop) -> (K -> hol_Group A) -> hol_Group (K -> A) := fun _375734 : K -> Prop => fun _375735 : K -> hol_Group A => @subgroup_generated (K -> A) (@product_group A K _375734 _375735) (@GSPEC (K -> A) (fun GEN_PVAR_820 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_820 ((@IN (K -> A) x (@cartesian_product A K _375734 (fun i : K => @gcar A (_375735 i)))) /\ (@finite_set K (@GSPEC K (fun GEN_PVAR_819 : K => exists i : K, @SETSPEC K GEN_PVAR_819 ((@IN K i _375734) /\ (~ ((x i) = (@g0 A (_375735 i))))) i)))) x)).
Lemma sum_group_def {A K : Type'} : (@sum_group A K) = (fun _375734 : K -> Prop => fun _375735 : K -> hol_Group A => @subgroup_generated (K -> A) (@product_group A K _375734 _375735) (@GSPEC (K -> A) (fun GEN_PVAR_820 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_820 ((@IN (K -> A) x (@cartesian_product A K _375734 (fun i : K => @gcar A (_375735 i)))) /\ (@finite_set K (@GSPEC K (fun GEN_PVAR_819 : K => exists i : K, @SETSPEC K GEN_PVAR_819 ((@IN K i _375734) /\ (~ ((x i) = (@g0 A (_375735 i))))) i)))) x))).
Proof. exact (REFL (@sum_group A K)). Qed.
Definition group_homomorphism {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> Prop := fun _376261 : prod (hol_Group A) (hol_Group B) => fun _376262 : A -> B => (@subset B (@IMAGE A B _376262 (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) (@gcar B (@snd (hol_Group A) (hol_Group B) _376261))) /\ (((_376262 (@g0 A (@fst (hol_Group A) (hol_Group B) _376261))) = (@g0 B (@snd (hol_Group A) (hol_Group B) _376261))) /\ ((forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) -> (_376262 (@ginv A (@fst (hol_Group A) (hol_Group B) _376261) x)) = (@ginv B (@snd (hol_Group A) (hol_Group B) _376261) (_376262 x))) /\ (forall x : A, forall y : A, ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) /\ (@IN A y (@gcar A (@fst (hol_Group A) (hol_Group B) _376261)))) -> (_376262 (@gop A (@fst (hol_Group A) (hol_Group B) _376261) x y)) = (@gop B (@snd (hol_Group A) (hol_Group B) _376261) (_376262 x) (_376262 y))))).
Lemma group_homomorphism_def {A B : Type'} : (@group_homomorphism A B) = (fun _376261 : prod (hol_Group A) (hol_Group B) => fun _376262 : A -> B => (@subset B (@IMAGE A B _376262 (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) (@gcar B (@snd (hol_Group A) (hol_Group B) _376261))) /\ (((_376262 (@g0 A (@fst (hol_Group A) (hol_Group B) _376261))) = (@g0 B (@snd (hol_Group A) (hol_Group B) _376261))) /\ ((forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) -> (_376262 (@ginv A (@fst (hol_Group A) (hol_Group B) _376261) x)) = (@ginv B (@snd (hol_Group A) (hol_Group B) _376261) (_376262 x))) /\ (forall x : A, forall y : A, ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376261))) /\ (@IN A y (@gcar A (@fst (hol_Group A) (hol_Group B) _376261)))) -> (_376262 (@gop A (@fst (hol_Group A) (hol_Group B) _376261) x y)) = (@gop B (@snd (hol_Group A) (hol_Group B) _376261) (_376262 x) (_376262 y)))))).
Proof. exact (REFL (@group_homomorphism A B)). Qed.
Definition group_monomorphism {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> Prop := fun _376278 : prod (hol_Group A) (hol_Group B) => fun _376279 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376278) (@snd (hol_Group A) (hol_Group B) _376278)) _376279) /\ (forall x : A, forall y : A, ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376278))) /\ ((@IN A y (@gcar A (@fst (hol_Group A) (hol_Group B) _376278))) /\ ((_376279 x) = (_376279 y)))) -> x = y).
Lemma group_monomorphism_def {A B : Type'} : (@group_monomorphism A B) = (fun _376278 : prod (hol_Group A) (hol_Group B) => fun _376279 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376278) (@snd (hol_Group A) (hol_Group B) _376278)) _376279) /\ (forall x : A, forall y : A, ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376278))) /\ ((@IN A y (@gcar A (@fst (hol_Group A) (hol_Group B) _376278))) /\ ((_376279 x) = (_376279 y)))) -> x = y)).
Proof. exact (REFL (@group_monomorphism A B)). Qed.
Definition group_epimorphism {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> Prop := fun _376295 : prod (hol_Group A) (hol_Group B) => fun _376296 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376295) (@snd (hol_Group A) (hol_Group B) _376295)) _376296) /\ ((@IMAGE A B _376296 (@gcar A (@fst (hol_Group A) (hol_Group B) _376295))) = (@gcar B (@snd (hol_Group A) (hol_Group B) _376295))).
Lemma group_epimorphism_def {A B : Type'} : (@group_epimorphism A B) = (fun _376295 : prod (hol_Group A) (hol_Group B) => fun _376296 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376295) (@snd (hol_Group A) (hol_Group B) _376295)) _376296) /\ ((@IMAGE A B _376296 (@gcar A (@fst (hol_Group A) (hol_Group B) _376295))) = (@gcar B (@snd (hol_Group A) (hol_Group B) _376295)))).
Proof. exact (REFL (@group_epimorphism A B)). Qed.
Definition group_endomorphism {A : Type'} : (hol_Group A) -> (A -> A) -> Prop := fun _376312 : hol_Group A => fun _376313 : A -> A => @group_homomorphism A A (@pair (hol_Group A) (hol_Group A) _376312 _376312) _376313.
Lemma group_endomorphism_def {A : Type'} : (@group_endomorphism A) = (fun _376312 : hol_Group A => fun _376313 : A -> A => @group_homomorphism A A (@pair (hol_Group A) (hol_Group A) _376312 _376312) _376313).
Proof. exact (REFL (@group_endomorphism A)). Qed.
Definition group_isomorphisms {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _376324 : prod (hol_Group A) (hol_Group B) => fun _376325 : prod (A -> B) (B -> A) => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376324) (@snd (hol_Group A) (hol_Group B) _376324)) (@fst (A -> B) (B -> A) _376325)) /\ ((@group_homomorphism B A (@pair (hol_Group B) (hol_Group A) (@snd (hol_Group A) (hol_Group B) _376324) (@fst (hol_Group A) (hol_Group B) _376324)) (@snd (A -> B) (B -> A) _376325)) /\ ((forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376324))) -> (@snd (A -> B) (B -> A) _376325 (@fst (A -> B) (B -> A) _376325 x)) = x) /\ (forall y : B, (@IN B y (@gcar B (@snd (hol_Group A) (hol_Group B) _376324))) -> (@fst (A -> B) (B -> A) _376325 (@snd (A -> B) (B -> A) _376325 y)) = y))).
Lemma group_isomorphisms_def {A B : Type'} : (@group_isomorphisms A B) = (fun _376324 : prod (hol_Group A) (hol_Group B) => fun _376325 : prod (A -> B) (B -> A) => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376324) (@snd (hol_Group A) (hol_Group B) _376324)) (@fst (A -> B) (B -> A) _376325)) /\ ((@group_homomorphism B A (@pair (hol_Group B) (hol_Group A) (@snd (hol_Group A) (hol_Group B) _376324) (@fst (hol_Group A) (hol_Group B) _376324)) (@snd (A -> B) (B -> A) _376325)) /\ ((forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _376324))) -> (@snd (A -> B) (B -> A) _376325 (@fst (A -> B) (B -> A) _376325 x)) = x) /\ (forall y : B, (@IN B y (@gcar B (@snd (hol_Group A) (hol_Group B) _376324))) -> (@fst (A -> B) (B -> A) _376325 (@snd (A -> B) (B -> A) _376325 y)) = y)))).
Proof. exact (REFL (@group_isomorphisms A B)). Qed.
Definition group_isomorphism {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> Prop := fun _376346 : prod (hol_Group A) (hol_Group B) => fun _376347 : A -> B => exists g : B -> A, @group_isomorphisms A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376346) (@snd (hol_Group A) (hol_Group B) _376346)) (@pair (A -> B) (B -> A) _376347 g).
Lemma group_isomorphism_def {A B : Type'} : (@group_isomorphism A B) = (fun _376346 : prod (hol_Group A) (hol_Group B) => fun _376347 : A -> B => exists g : B -> A, @group_isomorphisms A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _376346) (@snd (hol_Group A) (hol_Group B) _376346)) (@pair (A -> B) (B -> A) _376347 g)).
Proof. exact (REFL (@group_isomorphism A B)). Qed.
Definition group_automorphism {A : Type'} : (hol_Group A) -> (A -> A) -> Prop := fun _376363 : hol_Group A => fun _376364 : A -> A => @group_isomorphism A A (@pair (hol_Group A) (hol_Group A) _376363 _376363) _376364.
Lemma group_automorphism_def {A : Type'} : (@group_automorphism A) = (fun _376363 : hol_Group A => fun _376364 : A -> A => @group_isomorphism A A (@pair (hol_Group A) (hol_Group A) _376363 _376363) _376364).
Proof. exact (REFL (@group_automorphism A)). Qed.
Definition isomorphic_group {A B : Type'} : (hol_Group A) -> (hol_Group B) -> Prop := fun _399186 : hol_Group A => fun _399187 : hol_Group B => exists f : A -> B, @group_isomorphism A B (@pair (hol_Group A) (hol_Group B) _399186 _399187) f.
Lemma isomorphic_group_def {A B : Type'} : (@isomorphic_group A B) = (fun _399186 : hol_Group A => fun _399187 : hol_Group B => exists f : A -> B, @group_isomorphism A B (@pair (hol_Group A) (hol_Group B) _399186 _399187) f).
Proof. exact (REFL (@isomorphic_group A B)). Qed.
Definition group_setinv {_281415 : Type'} : (hol_Group _281415) -> (_281415 -> Prop) -> _281415 -> Prop := fun _403259 : hol_Group _281415 => fun _403260 : _281415 -> Prop => @GSPEC _281415 (fun GEN_PVAR_842 : _281415 => exists x : _281415, @SETSPEC _281415 GEN_PVAR_842 (@IN _281415 x _403260) (@ginv _281415 _403259 x)).
Lemma group_setinv_def {_281415 : Type'} : (@group_setinv _281415) = (fun _403259 : hol_Group _281415 => fun _403260 : _281415 -> Prop => @GSPEC _281415 (fun GEN_PVAR_842 : _281415 => exists x : _281415, @SETSPEC _281415 GEN_PVAR_842 (@IN _281415 x _403260) (@ginv _281415 _403259 x))).
Proof. exact (REFL (@group_setinv _281415)). Qed.
Definition group_setmul {_281444 : Type'} : (hol_Group _281444) -> (_281444 -> Prop) -> (_281444 -> Prop) -> _281444 -> Prop := fun _403271 : hol_Group _281444 => fun _403272 : _281444 -> Prop => fun _403273 : _281444 -> Prop => @GSPEC _281444 (fun GEN_PVAR_843 : _281444 => exists x : _281444, exists y : _281444, @SETSPEC _281444 GEN_PVAR_843 ((@IN _281444 x _403272) /\ (@IN _281444 y _403273)) (@gop _281444 _403271 x y)).
Lemma group_setmul_def {_281444 : Type'} : (@group_setmul _281444) = (fun _403271 : hol_Group _281444 => fun _403272 : _281444 -> Prop => fun _403273 : _281444 -> Prop => @GSPEC _281444 (fun GEN_PVAR_843 : _281444 => exists x : _281444, exists y : _281444, @SETSPEC _281444 GEN_PVAR_843 ((@IN _281444 x _403272) /\ (@IN _281444 y _403273)) (@gop _281444 _403271 x y))).
Proof. exact (REFL (@group_setmul _281444)). Qed.
Definition group_action {A X : Type'} : (hol_Group A) -> (X -> Prop) -> (A -> X -> X) -> Prop := fun _405489 : hol_Group A => fun _405490 : X -> Prop => fun _405491 : A -> X -> X => (forall g : A, forall x : X, ((@IN A g (@gcar A _405489)) /\ (@IN X x _405490)) -> @IN X (_405491 g x) _405490) /\ ((forall x : X, (@IN X x _405490) -> (_405491 (@g0 A _405489) x) = x) /\ (forall g : A, forall h : A, forall x : X, ((@IN A g (@gcar A _405489)) /\ ((@IN A h (@gcar A _405489)) /\ (@IN X x _405490))) -> (_405491 (@gop A _405489 g h) x) = (_405491 g (_405491 h x)))).
Lemma group_action_def {A X : Type'} : (@group_action A X) = (fun _405489 : hol_Group A => fun _405490 : X -> Prop => fun _405491 : A -> X -> X => (forall g : A, forall x : X, ((@IN A g (@gcar A _405489)) /\ (@IN X x _405490)) -> @IN X (_405491 g x) _405490) /\ ((forall x : X, (@IN X x _405490) -> (_405491 (@g0 A _405489) x) = x) /\ (forall g : A, forall h : A, forall x : X, ((@IN A g (@gcar A _405489)) /\ ((@IN A h (@gcar A _405489)) /\ (@IN X x _405490))) -> (_405491 (@gop A _405489 g h) x) = (_405491 g (_405491 h x))))).
Proof. exact (REFL (@group_action A X)). Qed.
Definition group_stabilizer {A X : Type'} : (hol_Group A) -> (A -> X -> X) -> X -> A -> Prop := fun _408422 : hol_Group A => fun _408423 : A -> X -> X => fun _408424 : X => @GSPEC A (fun GEN_PVAR_855 : A => exists g : A, @SETSPEC A GEN_PVAR_855 ((@IN A g (@gcar A _408422)) /\ ((_408423 g _408424) = _408424)) g).
Lemma group_stabilizer_def {A X : Type'} : (@group_stabilizer A X) = (fun _408422 : hol_Group A => fun _408423 : A -> X -> X => fun _408424 : X => @GSPEC A (fun GEN_PVAR_855 : A => exists g : A, @SETSPEC A GEN_PVAR_855 ((@IN A g (@gcar A _408422)) /\ ((_408423 g _408424) = _408424)) g)).
Proof. exact (REFL (@group_stabilizer A X)). Qed.
Definition group_orbit {A X : Type'} : (hol_Group A) -> (X -> Prop) -> (A -> X -> X) -> X -> X -> Prop := fun _409090 : hol_Group A => fun _409091 : X -> Prop => fun _409092 : A -> X -> X => fun _409093 : X => fun _409094 : X => (@IN X _409093 _409091) /\ ((@IN X _409094 _409091) /\ (exists g : A, (@IN A g (@gcar A _409090)) /\ ((_409092 g _409093) = _409094))).
Lemma group_orbit_def {A X : Type'} : (@group_orbit A X) = (fun _409090 : hol_Group A => fun _409091 : X -> Prop => fun _409092 : A -> X -> X => fun _409093 : X => fun _409094 : X => (@IN X _409093 _409091) /\ ((@IN X _409094 _409091) /\ (exists g : A, (@IN A g (@gcar A _409090)) /\ ((_409092 g _409093) = _409094)))).
Proof. exact (REFL (@group_orbit A X)). Qed.
Definition right_coset {_288210 : Type'} : (hol_Group _288210) -> (_288210 -> Prop) -> _288210 -> _288210 -> Prop := fun _414594 : hol_Group _288210 => fun _414595 : _288210 -> Prop => fun _414596 : _288210 => @group_setmul _288210 _414594 _414595 (@INSERT _288210 _414596 (@set0 _288210)).
Lemma right_coset_def {_288210 : Type'} : (@right_coset _288210) = (fun _414594 : hol_Group _288210 => fun _414595 : _288210 -> Prop => fun _414596 : _288210 => @group_setmul _288210 _414594 _414595 (@INSERT _288210 _414596 (@set0 _288210))).
Proof. exact (REFL (@right_coset _288210)). Qed.
Definition left_coset {_288225 : Type'} : (hol_Group _288225) -> _288225 -> (_288225 -> Prop) -> _288225 -> Prop := fun _414615 : hol_Group _288225 => fun _414616 : _288225 => fun _414617 : _288225 -> Prop => @group_setmul _288225 _414615 (@INSERT _288225 _414616 (@set0 _288225)) _414617.
Lemma left_coset_def {_288225 : Type'} : (@left_coset _288225) = (fun _414615 : hol_Group _288225 => fun _414616 : _288225 => fun _414617 : _288225 -> Prop => @group_setmul _288225 _414615 (@INSERT _288225 _414616 (@set0 _288225)) _414617).
Proof. exact (REFL (@left_coset _288225)). Qed.
Definition normal_subgroup_of {A : Type'} : (A -> Prop) -> (hol_Group A) -> Prop := fun _420277 : A -> Prop => fun _420278 : hol_Group A => (@subgroup_of A _420277 _420278) /\ (forall x : A, (@IN A x (@gcar A _420278)) -> (@left_coset A _420278 x _420277) = (@right_coset A _420278 _420277 x)).
Lemma normal_subgroup_of_def {A : Type'} : (@normal_subgroup_of A) = (fun _420277 : A -> Prop => fun _420278 : hol_Group A => (@subgroup_of A _420277 _420278) /\ (forall x : A, (@IN A x (@gcar A _420278)) -> (@left_coset A _420278 x _420277) = (@right_coset A _420278 _420277 x))).
Proof. exact (REFL (@normal_subgroup_of A)). Qed.
Definition group_conjugate {A : Type'} : (hol_Group A) -> (A -> Prop) -> (A -> Prop) -> Prop := fun _422749 : hol_Group A => fun _422750 : A -> Prop => fun _422751 : A -> Prop => (@subset A _422750 (@gcar A _422749)) /\ ((@subset A _422751 (@gcar A _422749)) /\ (exists a : A, (@IN A a (@gcar A _422749)) /\ ((@IMAGE A A (@group_conjugation A _422749 a) _422750) = _422751))).
Lemma group_conjugate_def {A : Type'} : (@group_conjugate A) = (fun _422749 : hol_Group A => fun _422750 : A -> Prop => fun _422751 : A -> Prop => (@subset A _422750 (@gcar A _422749)) /\ ((@subset A _422751 (@gcar A _422749)) /\ (exists a : A, (@IN A a (@gcar A _422749)) /\ ((@IMAGE A A (@group_conjugation A _422749 a) _422750) = _422751)))).
Proof. exact (REFL (@group_conjugate A)). Qed.
Definition group_centralizer {A : Type'} : (hol_Group A) -> (A -> Prop) -> A -> Prop := fun _423522 : hol_Group A => fun _423523 : A -> Prop => @GSPEC A (fun GEN_PVAR_944 : A => exists x : A, @SETSPEC A GEN_PVAR_944 ((@IN A x (@gcar A _423522)) /\ (forall y : A, ((@IN A y (@gcar A _423522)) /\ (@IN A y _423523)) -> (@gop A _423522 x y) = (@gop A _423522 y x))) x).
Lemma group_centralizer_def {A : Type'} : (@group_centralizer A) = (fun _423522 : hol_Group A => fun _423523 : A -> Prop => @GSPEC A (fun GEN_PVAR_944 : A => exists x : A, @SETSPEC A GEN_PVAR_944 ((@IN A x (@gcar A _423522)) /\ (forall y : A, ((@IN A y (@gcar A _423522)) /\ (@IN A y _423523)) -> (@gop A _423522 x y) = (@gop A _423522 y x))) x)).
Proof. exact (REFL (@group_centralizer A)). Qed.
Definition group_normalizer {A : Type'} : (hol_Group A) -> (A -> Prop) -> A -> Prop := fun _423534 : hol_Group A => fun _423535 : A -> Prop => @GSPEC A (fun GEN_PVAR_945 : A => exists x : A, @SETSPEC A GEN_PVAR_945 ((@IN A x (@gcar A _423534)) /\ ((@group_setmul A _423534 (@INSERT A x (@set0 A)) (@setI A (@gcar A _423534) _423535)) = (@group_setmul A _423534 (@setI A (@gcar A _423534) _423535) (@INSERT A x (@set0 A))))) x).
Lemma group_normalizer_def {A : Type'} : (@group_normalizer A) = (fun _423534 : hol_Group A => fun _423535 : A -> Prop => @GSPEC A (fun GEN_PVAR_945 : A => exists x : A, @SETSPEC A GEN_PVAR_945 ((@IN A x (@gcar A _423534)) /\ ((@group_setmul A _423534 (@INSERT A x (@set0 A)) (@setI A (@gcar A _423534) _423535)) = (@group_setmul A _423534 (@setI A (@gcar A _423534) _423535) (@INSERT A x (@set0 A))))) x)).
Proof. exact (REFL (@group_normalizer A)). Qed.
Definition quotient_group {A : Type'} : (hol_Group A) -> (A -> Prop) -> hol_Group (A -> Prop) := fun _425605 : hol_Group A => fun _425606 : A -> Prop => @group (A -> Prop) (@pair ((A -> Prop) -> Prop) (prod (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop))) (@GSPEC (A -> Prop) (fun GEN_PVAR_963 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_963 (@IN A x (@gcar A _425605)) (@right_coset A _425605 _425606 x))) (@pair (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop)) _425606 (@pair ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop) (@group_setinv A _425605) (@group_setmul A _425605)))).
Lemma quotient_group_def {A : Type'} : (@quotient_group A) = (fun _425605 : hol_Group A => fun _425606 : A -> Prop => @group (A -> Prop) (@pair ((A -> Prop) -> Prop) (prod (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop))) (@GSPEC (A -> Prop) (fun GEN_PVAR_963 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_963 (@IN A x (@gcar A _425605)) (@right_coset A _425605 _425606 x))) (@pair (A -> Prop) (prod ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop)) _425606 (@pair ((A -> Prop) -> A -> Prop) ((A -> Prop) -> (A -> Prop) -> A -> Prop) (@group_setinv A _425605) (@group_setmul A _425605))))).
Proof. exact (REFL (@quotient_group A)). Qed.
Definition group_kernel {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> A -> Prop := fun _428080 : prod (hol_Group A) (hol_Group B) => fun _428081 : A -> B => @GSPEC A (fun GEN_PVAR_971 : A => exists x : A, @SETSPEC A GEN_PVAR_971 ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _428080))) /\ ((_428081 x) = (@g0 B (@snd (hol_Group A) (hol_Group B) _428080)))) x).
Lemma group_kernel_def {A B : Type'} : (@group_kernel A B) = (fun _428080 : prod (hol_Group A) (hol_Group B) => fun _428081 : A -> B => @GSPEC A (fun GEN_PVAR_971 : A => exists x : A, @SETSPEC A GEN_PVAR_971 ((@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _428080))) /\ ((_428081 x) = (@g0 B (@snd (hol_Group A) (hol_Group B) _428080)))) x)).
Proof. exact (REFL (@group_kernel A B)). Qed.
Definition group_image {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> B -> Prop := fun _428097 : prod (hol_Group A) (hol_Group B) => fun _428098 : A -> B => @IMAGE A B _428098 (@gcar A (@fst (hol_Group A) (hol_Group B) _428097)).
Lemma group_image_def {A B : Type'} : (@group_image A B) = (fun _428097 : prod (hol_Group A) (hol_Group B) => fun _428098 : A -> B => @IMAGE A B _428098 (@gcar A (@fst (hol_Group A) (hol_Group B) _428097))).
Proof. exact (REFL (@group_image A B)). Qed.
Definition trivial_homomorphism {A B : Type'} : (prod (hol_Group A) (hol_Group B)) -> (A -> B) -> Prop := fun _458400 : prod (hol_Group A) (hol_Group B) => fun _458401 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _458400) (@snd (hol_Group A) (hol_Group B) _458400)) _458401) /\ (forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _458400))) -> (_458401 x) = (@g0 B (@snd (hol_Group A) (hol_Group B) _458400))).
Lemma trivial_homomorphism_def {A B : Type'} : (@trivial_homomorphism A B) = (fun _458400 : prod (hol_Group A) (hol_Group B) => fun _458401 : A -> B => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (hol_Group B) _458400) (@snd (hol_Group A) (hol_Group B) _458400)) _458401) /\ (forall x : A, (@IN A x (@gcar A (@fst (hol_Group A) (hol_Group B) _458400))) -> (_458401 x) = (@g0 B (@snd (hol_Group A) (hol_Group B) _458400)))).
Proof. exact (REFL (@trivial_homomorphism A B)). Qed.
Definition group_element_order {A : Type'} : (hol_Group A) -> A -> nat := fun _459891 : hol_Group A => fun _459892 : A => @ε nat (fun d : nat => forall n : nat, ((@group_pow A _459891 _459892 n) = (@g0 A _459891)) = (num_divides d n)).
Lemma group_element_order_def {A : Type'} : (@group_element_order A) = (fun _459891 : hol_Group A => fun _459892 : A => @ε nat (fun d : nat => forall n : nat, ((@group_pow A _459891 _459892 n) = (@g0 A _459891)) = (num_divides d n))).
Proof. exact (REFL (@group_element_order A)). Qed.
Definition cyclic_group {_310304 : Type'} : (hol_Group _310304) -> Prop := fun _464718 : hol_Group _310304 => exists x : _310304, (@IN _310304 x (@gcar _310304 _464718)) /\ ((@subgroup_generated _310304 _464718 (@INSERT _310304 x (@set0 _310304))) = _464718).
Lemma cyclic_group_def {_310304 : Type'} : (@cyclic_group _310304) = (fun _464718 : hol_Group _310304 => exists x : _310304, (@IN _310304 x (@gcar _310304 _464718)) /\ ((@subgroup_generated _310304 _464718 (@INSERT _310304 x (@set0 _310304))) = _464718)).
Proof. exact (REFL (@cyclic_group _310304)). Qed.
Definition finitely_generated_group {A : Type'} : (hol_Group A) -> Prop := fun _467767 : hol_Group A => exists s : A -> Prop, (@finite_set A s) /\ ((@subgroup_generated A _467767 s) = _467767).
Lemma finitely_generated_group_def {A : Type'} : (@finitely_generated_group A) = (fun _467767 : hol_Group A => exists s : A -> Prop, (@finite_set A s) /\ ((@subgroup_generated A _467767 s) = _467767)).
Proof. exact (REFL (@finitely_generated_group A)). Qed.
Definition integer_group : hol_Group int := @group int (@pair (int -> Prop) (prod int (prod (int -> int) (int -> int -> int))) (@setT int) (@pair int (prod (int -> int) (int -> int -> int)) (int_of_nat (NUMERAL O)) (@pair (int -> int) (int -> int -> int) oppz addz))).
Lemma integer_group_def : integer_group = (@group int (@pair (int -> Prop) (prod int (prod (int -> int) (int -> int -> int))) (@setT int) (@pair int (prod (int -> int) (int -> int -> int)) (int_of_nat (NUMERAL O)) (@pair (int -> int) (int -> int -> int) oppz addz)))).
Proof. exact (REFL integer_group). Qed.
Definition integer_mod_group : nat -> hol_Group int := fun _494002 : nat => @COND (hol_Group int) (_494002 = (NUMERAL O)) integer_group (@group int (@pair (int -> Prop) (prod int (prod (int -> int) (int -> int -> int))) (@GSPEC int (fun GEN_PVAR_1055 : int => exists m : int, @SETSPEC int GEN_PVAR_1055 ((lez (int_of_nat (NUMERAL O)) m) /\ (ltz m (int_of_nat _494002))) m)) (@pair int (prod (int -> int) (int -> int -> int)) (int_of_nat (NUMERAL O)) (@pair (int -> int) (int -> int -> int) (fun a : int => modz (oppz a) (int_of_nat _494002)) (fun a : int => fun b : int => modz (addz a b) (int_of_nat _494002)))))).
Lemma integer_mod_group_def : integer_mod_group = (fun _494002 : nat => @COND (hol_Group int) (_494002 = (NUMERAL O)) integer_group (@group int (@pair (int -> Prop) (prod int (prod (int -> int) (int -> int -> int))) (@GSPEC int (fun GEN_PVAR_1055 : int => exists m : int, @SETSPEC int GEN_PVAR_1055 ((lez (int_of_nat (NUMERAL O)) m) /\ (ltz m (int_of_nat _494002))) m)) (@pair int (prod (int -> int) (int -> int -> int)) (int_of_nat (NUMERAL O)) (@pair (int -> int) (int -> int -> int) (fun a : int => modz (oppz a) (int_of_nat _494002)) (fun a : int => fun b : int => modz (addz a b) (int_of_nat _494002))))))).
Proof. exact (REFL integer_mod_group). Qed.
Definition pgroup {A : Type'} : (nat -> Prop) -> (hol_Group A) -> Prop := fun _496845 : nat -> Prop => fun _496846 : hol_Group A => forall p : nat, forall x : A, ((prime p) /\ ((@IN A x (@gcar A _496846)) /\ (num_divides p (@group_element_order A _496846 x)))) -> @IN nat p _496845.
Lemma pgroup_def {A : Type'} : (@pgroup A) = (fun _496845 : nat -> Prop => fun _496846 : hol_Group A => forall p : nat, forall x : A, ((prime p) /\ ((@IN A x (@gcar A _496846)) /\ (num_divides p (@group_element_order A _496846 x)))) -> @IN nat p _496845).
Proof. exact (REFL (@pgroup A)). Qed.
Definition free_abelian_group {A : Type'} : (A -> Prop) -> hol_Group (frag A) := fun _567242 : A -> Prop => @group (frag A) (@pair ((frag A) -> Prop) (prod (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A))) (@GSPEC (frag A) (fun GEN_PVAR_1210 : frag A => exists c : frag A, @SETSPEC (frag A) GEN_PVAR_1210 (@subset A (@frag_support A c) _567242) c)) (@pair (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A)) (@frag_0 A) (@pair ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A) (@frag_neg A) (@frag_add A)))).
Lemma free_abelian_group_def {A : Type'} : (@free_abelian_group A) = (fun _567242 : A -> Prop => @group (frag A) (@pair ((frag A) -> Prop) (prod (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A))) (@GSPEC (frag A) (fun GEN_PVAR_1210 : frag A => exists c : frag A, @SETSPEC (frag A) GEN_PVAR_1210 (@subset A (@frag_support A c) _567242) c)) (@pair (frag A) (prod ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A)) (@frag_0 A) (@pair ((frag A) -> frag A) ((frag A) -> (frag A) -> frag A) (@frag_neg A) (@frag_add A))))).
Proof. exact (REFL (@free_abelian_group A)). Qed.
Definition group_exactness {A B C : Type'} : (prod (hol_Group A) (prod (hol_Group B) (hol_Group C))) -> (prod (A -> B) (B -> C)) -> Prop := fun _569070 : prod (hol_Group A) (prod (hol_Group B) (hol_Group C)) => fun _569071 : prod (A -> B) (B -> C) => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@fst (A -> B) (B -> C) _569071)) /\ ((@group_homomorphism B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@snd (A -> B) (B -> C) _569071)) /\ ((@group_image A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@fst (A -> B) (B -> C) _569071)) = (@group_kernel B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@snd (A -> B) (B -> C) _569071)))).
Lemma group_exactness_def {A B C : Type'} : (@group_exactness A B C) = (fun _569070 : prod (hol_Group A) (prod (hol_Group B) (hol_Group C)) => fun _569071 : prod (A -> B) (B -> C) => (@group_homomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@fst (A -> B) (B -> C) _569071)) /\ ((@group_homomorphism B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@snd (A -> B) (B -> C) _569071)) /\ ((@group_image A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@fst (A -> B) (B -> C) _569071)) = (@group_kernel B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569070))) (@snd (A -> B) (B -> C) _569071))))).
Proof. exact (REFL (@group_exactness A B C)). Qed.
Definition short_exact_sequence {A B C : Type'} : (prod (hol_Group A) (prod (hol_Group B) (hol_Group C))) -> (prod (A -> B) (B -> C)) -> Prop := fun _569097 : prod (hol_Group A) (prod (hol_Group B) (hol_Group C)) => fun _569098 : prod (A -> B) (B -> C) => (@group_monomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097))) (@fst (A -> B) (B -> C) _569098)) /\ ((@group_exactness A B C (@pair (hol_Group A) (prod (hol_Group B) (hol_Group C)) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097) (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)))) (@pair (A -> B) (B -> C) (@fst (A -> B) (B -> C) _569098) (@snd (A -> B) (B -> C) _569098))) /\ (@group_epimorphism B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097))) (@snd (A -> B) (B -> C) _569098))).
Lemma short_exact_sequence_def {A B C : Type'} : (@short_exact_sequence A B C) = (fun _569097 : prod (hol_Group A) (prod (hol_Group B) (hol_Group C)) => fun _569098 : prod (A -> B) (B -> C) => (@group_monomorphism A B (@pair (hol_Group A) (hol_Group B) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097))) (@fst (A -> B) (B -> C) _569098)) /\ ((@group_exactness A B C (@pair (hol_Group A) (prod (hol_Group B) (hol_Group C)) (@fst (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097) (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)))) (@pair (A -> B) (B -> C) (@fst (A -> B) (B -> C) _569098) (@snd (A -> B) (B -> C) _569098))) /\ (@group_epimorphism B C (@pair (hol_Group B) (hol_Group C) (@fst (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097)) (@snd (hol_Group B) (hol_Group C) (@snd (hol_Group A) (prod (hol_Group B) (hol_Group C)) _569097))) (@snd (A -> B) (B -> C) _569098)))).
Proof. exact (REFL (@short_exact_sequence A B C)). Qed.
Definition matroid_spanning {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600863 : Matroid A => fun _600864 : A -> Prop => (@subset A _600864 (@mat_set A _600863)) /\ ((@mat_span A _600863 _600864) = (@mat_set A _600863)).
Lemma matroid_spanning_def {A : Type'} : (@matroid_spanning A) = (fun _600863 : Matroid A => fun _600864 : A -> Prop => (@subset A _600864 (@mat_set A _600863)) /\ ((@mat_span A _600863 _600864) = (@mat_set A _600863))).
Proof. exact (REFL (@matroid_spanning A)). Qed.
Definition matroid_independent {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600875 : Matroid A => fun _600876 : A -> Prop => (@subset A _600876 (@mat_set A _600875)) /\ (forall x : A, (@IN A x _600876) -> ~ (@IN A x (@mat_span A _600875 (@DELETE A _600876 x)))).
Lemma matroid_independent_def {A : Type'} : (@matroid_independent A) = (fun _600875 : Matroid A => fun _600876 : A -> Prop => (@subset A _600876 (@mat_set A _600875)) /\ (forall x : A, (@IN A x _600876) -> ~ (@IN A x (@mat_span A _600875 (@DELETE A _600876 x))))).
Proof. exact (REFL (@matroid_independent A)). Qed.
Definition matroid_basis {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _600887 : Matroid A => fun _600888 : A -> Prop => (@matroid_spanning A _600887 _600888) /\ (@matroid_independent A _600887 _600888).
Lemma matroid_basis_def {A : Type'} : (@matroid_basis A) = (fun _600887 : Matroid A => fun _600888 : A -> Prop => (@matroid_spanning A _600887 _600888) /\ (@matroid_independent A _600887 _600888)).
Proof. exact (REFL (@matroid_basis A)). Qed.
Definition matroid_dependent {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_dependent' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _601012 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dependent' _601012 m s) = ((@subset A s (@mat_set A m)) /\ (~ (@matroid_independent A m s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))))))))))))))).
Lemma matroid_dependent_def {A : Type'} : (@matroid_dependent A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_dependent' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _601012 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dependent' _601012 m s) = ((@subset A s (@mat_set A m)) /\ (~ (@matroid_independent A m s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))))))))))))))).
Proof. exact (REFL (@matroid_dependent A)). Qed.
Definition matroid_subspace {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := fun _608336 : Matroid A => fun _608337 : A -> Prop => (@subset A _608337 (@mat_set A _608336)) /\ ((@mat_span A _608336 _608337) = _608337).
Lemma matroid_subspace_def {A : Type'} : (@matroid_subspace A) = (fun _608336 : Matroid A => fun _608337 : A -> Prop => (@subset A _608337 (@mat_set A _608336)) /\ ((@mat_span A _608336 _608337) = _608337)).
Proof. exact (REFL (@matroid_subspace A)). Qed.
Definition submatroid {A : Type'} : (Matroid A) -> (A -> Prop) -> Matroid A := fun _608483 : Matroid A => fun _608484 : A -> Prop => @matroid A (@pair (A -> Prop) ((A -> Prop) -> A -> Prop) (@mat_span A _608483 (@setI A (@mat_set A _608483) _608484)) (@mat_span A _608483)).
Lemma submatroid_def {A : Type'} : (@submatroid A) = (fun _608483 : Matroid A => fun _608484 : A -> Prop => @matroid A (@pair (A -> Prop) ((A -> Prop) -> A -> Prop) (@mat_span A _608483 (@setI A (@mat_set A _608483) _608484)) (@mat_span A _608483))).
Proof. exact (REFL (@submatroid A)). Qed.
Definition matroid_finite_dimensional {A : Type'} : (Matroid A) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))))) -> (Matroid A) -> Prop) (fun matroid_finite_dimensional' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))))) -> (Matroid A) -> Prop => forall _608917 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))), forall m : Matroid A, (matroid_finite_dimensional' _608917 m) = (exists b : A -> Prop, (@finite_set A b) /\ (@matroid_spanning A m b))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))))))))))).
Lemma matroid_finite_dimensional_def {A : Type'} : (@matroid_finite_dimensional A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))))) -> (Matroid A) -> Prop) (fun matroid_finite_dimensional' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))))) -> (Matroid A) -> Prop => forall _608917 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))), forall m : Matroid A, (matroid_finite_dimensional' _608917 m) = (exists b : A -> Prop, (@finite_set A b) /\ (@matroid_spanning A m b))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))))))))))).
Proof. exact (REFL (@matroid_finite_dimensional A)). Qed.
Definition matroid_dimension {A : Type'} : (Matroid A) -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> nat) (fun matroid_dimension' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> nat => forall _608942 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall m : Matroid A, (matroid_dimension' _608942 m) = (@ε nat (fun n : nat => forall b : A -> Prop, (@matroid_basis A m b) -> @HAS_SIZE A b n))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))).
Lemma matroid_dimension_def {A : Type'} : (@matroid_dimension A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> nat) (fun matroid_dimension' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> (Matroid A) -> nat => forall _608942 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall m : Matroid A, (matroid_dimension' _608942 m) = (@ε nat (fun n : nat => forall b : A -> Prop, (@matroid_basis A m b) -> @HAS_SIZE A b n))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))).
Proof. exact (REFL (@matroid_dimension A)). Qed.
Definition matroid_finite_dim {A : Type'} : (Matroid A) -> (A -> Prop) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_finite_dim' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _609056 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_finite_dim' _609056 m s) = ((@subset A s (@mat_set A m)) /\ (@matroid_finite_dimensional A (@submatroid A m s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))).
Lemma matroid_finite_dim_def {A : Type'} : (@matroid_finite_dim A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop) (fun matroid_finite_dim' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) -> (Matroid A) -> (A -> Prop) -> Prop => forall _609056 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_finite_dim' _609056 m s) = ((@subset A s (@mat_set A m)) /\ (@matroid_finite_dimensional A (@submatroid A m s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))).
Proof. exact (REFL (@matroid_finite_dim A)). Qed.
Definition matroid_dim {A : Type'} : (Matroid A) -> (A -> Prop) -> nat := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (Matroid A) -> (A -> Prop) -> nat) (fun matroid_dim' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (Matroid A) -> (A -> Prop) -> nat => forall _609170 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dim' _609170 m s) = (@matroid_dimension A (@submatroid A m s))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Lemma matroid_dim_def {A : Type'} : (@matroid_dim A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (Matroid A) -> (A -> Prop) -> nat) (fun matroid_dim' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (Matroid A) -> (A -> Prop) -> nat => forall _609170 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), forall m : Matroid A, forall s : A -> Prop, (matroid_dim' _609170 m s) = (@matroid_dimension A (@submatroid A m s))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))).
Proof. exact (REFL (@matroid_dim A)). Qed.
Definition binom : (prod nat nat) -> nat := @ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> (prod nat nat) -> nat) (fun binom' : (prod nat (prod nat (prod nat (prod nat nat)))) -> (prod nat nat) -> nat => forall _613308 : prod nat (prod nat (prod nat (prod nat nat))), (forall n : nat, (binom' _613308 (@pair nat nat n (NUMERAL O))) = (NUMERAL (BIT1 O))) /\ ((forall k : nat, (binom' _613308 (@pair nat nat (NUMERAL O) (S k))) = (NUMERAL O)) /\ (forall n : nat, forall k : nat, (binom' _613308 (@pair nat nat (S n) (S k))) = (addn (binom' _613308 (@pair nat nat n (S k))) (binom' _613308 (@pair nat nat n k)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))).
Lemma binom_def : binom = (@ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> (prod nat nat) -> nat) (fun binom' : (prod nat (prod nat (prod nat (prod nat nat)))) -> (prod nat nat) -> nat => forall _613308 : prod nat (prod nat (prod nat (prod nat nat))), (forall n : nat, (binom' _613308 (@pair nat nat n (NUMERAL O))) = (NUMERAL (BIT1 O))) /\ ((forall k : nat, (binom' _613308 (@pair nat nat (NUMERAL O) (S k))) = (NUMERAL O)) /\ (forall n : nat, forall k : nat, (binom' _613308 (@pair nat nat (S n) (S k))) = (addn (binom' _613308 (@pair nat nat n (S k))) (binom' _613308 (@pair nat nat n k)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))).
Proof. exact (REFL binom). Qed.
Definition istopology {_352037 : Type'} : ((_352037 -> Prop) -> Prop) -> Prop := fun _614427 : (_352037 -> Prop) -> Prop => (@IN (_352037 -> Prop) (@set0 _352037) _614427) /\ ((forall s : _352037 -> Prop, forall t : _352037 -> Prop, ((@IN (_352037 -> Prop) s _614427) /\ (@IN (_352037 -> Prop) t _614427)) -> @IN (_352037 -> Prop) (@setI _352037 s t) _614427) /\ (forall k : (_352037 -> Prop) -> Prop, (@subset (_352037 -> Prop) k _614427) -> @IN (_352037 -> Prop) (@UNIONS _352037 k) _614427)).
Lemma istopology_def {_352037 : Type'} : (@istopology _352037) = (fun _614427 : (_352037 -> Prop) -> Prop => (@IN (_352037 -> Prop) (@set0 _352037) _614427) /\ ((forall s : _352037 -> Prop, forall t : _352037 -> Prop, ((@IN (_352037 -> Prop) s _614427) /\ (@IN (_352037 -> Prop) t _614427)) -> @IN (_352037 -> Prop) (@setI _352037 s t) _614427) /\ (forall k : (_352037 -> Prop) -> Prop, (@subset (_352037 -> Prop) k _614427) -> @IN (_352037 -> Prop) (@UNIONS _352037 k) _614427))).
Proof. exact (REFL (@istopology _352037)). Qed.
Definition topspace {_352099 : Type'} : (Topology _352099) -> _352099 -> Prop := fun _614469 : Topology _352099 => @UNIONS _352099 (@GSPEC (_352099 -> Prop) (fun GEN_PVAR_1231 : _352099 -> Prop => exists s : _352099 -> Prop, @SETSPEC (_352099 -> Prop) GEN_PVAR_1231 (@open_in _352099 _614469 s) s)).
Lemma topspace_def {_352099 : Type'} : (@topspace _352099) = (fun _614469 : Topology _352099 => @UNIONS _352099 (@GSPEC (_352099 -> Prop) (fun GEN_PVAR_1231 : _352099 -> Prop => exists s : _352099 -> Prop, @SETSPEC (_352099 -> Prop) GEN_PVAR_1231 (@open_in _352099 _614469 s) s))).
Proof. exact (REFL (@topspace _352099)). Qed.
Definition closed_in {_352402 : Type'} : (Topology _352402) -> (_352402 -> Prop) -> Prop := fun _614504 : Topology _352402 => fun _614505 : _352402 -> Prop => (@subset _352402 _614505 (@topspace _352402 _614504)) /\ (@open_in _352402 _614504 (@setD _352402 (@topspace _352402 _614504) _614505)).
Lemma closed_in_def {_352402 : Type'} : (@closed_in _352402) = (fun _614504 : Topology _352402 => fun _614505 : _352402 -> Prop => (@subset _352402 _614505 (@topspace _352402 _614504)) /\ (@open_in _352402 _614504 (@setD _352402 (@topspace _352402 _614504) _614505))).
Proof. exact (REFL (@closed_in _352402)). Qed.
Definition discrete_topology {A : Type'} : (A -> Prop) -> Topology A := fun _615083 : A -> Prop => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1235 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1235 (@subset A s _615083) s)).
Lemma discrete_topology_def {A : Type'} : (@discrete_topology A) = (fun _615083 : A -> Prop => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1235 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1235 (@subset A s _615083) s))).
Proof. exact (REFL (@discrete_topology A)). Qed.
Definition discrete_space {A : Type'} : (Topology A) -> Prop := fun _615088 : Topology A => (@discrete_topology A (@topspace A _615088)) = _615088.
Lemma discrete_space_def {A : Type'} : (@discrete_space A) = (fun _615088 : Topology A => (@discrete_topology A (@topspace A _615088)) = _615088).
Proof. exact (REFL (@discrete_space A)). Qed.
Definition subtopology {_353738 : Type'} : (Topology _353738) -> (_353738 -> Prop) -> Topology _353738 := fun _615434 : Topology _353738 => fun _615435 : _353738 -> Prop => @topology _353738 (@GSPEC (_353738 -> Prop) (fun GEN_PVAR_1237 : _353738 -> Prop => exists s : _353738 -> Prop, @SETSPEC (_353738 -> Prop) GEN_PVAR_1237 (@open_in _353738 _615434 s) (@setI _353738 s _615435))).
Lemma subtopology_def {_353738 : Type'} : (@subtopology _353738) = (fun _615434 : Topology _353738 => fun _615435 : _353738 -> Prop => @topology _353738 (@GSPEC (_353738 -> Prop) (fun GEN_PVAR_1237 : _353738 -> Prop => exists s : _353738 -> Prop, @SETSPEC (_353738 -> Prop) GEN_PVAR_1237 (@open_in _353738 _615434 s) (@setI _353738 s _615435)))).
Proof. exact (REFL (@subtopology _353738)). Qed.
Definition hereditarily {A : Type'} : ((Topology A) -> Prop) -> (Topology A) -> Prop := fun _616434 : (Topology A) -> Prop => fun _616435 : Topology A => forall s : A -> Prop, (@subset A s (@topspace A _616435)) -> _616434 (@subtopology A _616435 s).
Lemma hereditarily_def {A : Type'} : (@hereditarily A) = (fun _616434 : (Topology A) -> Prop => fun _616435 : Topology A => forall s : A -> Prop, (@subset A s (@topspace A _616435)) -> _616434 (@subtopology A _616435 s)).
Proof. exact (REFL (@hereditarily A)). Qed.
Definition derived_set_of {A : Type'} : (Topology A) -> (A -> Prop) -> A -> Prop := fun _616456 : Topology A => fun _616457 : A -> Prop => @GSPEC A (fun GEN_PVAR_1246 : A => exists x : A, @SETSPEC A GEN_PVAR_1246 ((@IN A x (@topspace A _616456)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _616456 t)) -> exists y : A, (~ (y = x)) /\ ((@IN A y _616457) /\ (@IN A y t)))) x).
Lemma derived_set_of_def {A : Type'} : (@derived_set_of A) = (fun _616456 : Topology A => fun _616457 : A -> Prop => @GSPEC A (fun GEN_PVAR_1246 : A => exists x : A, @SETSPEC A GEN_PVAR_1246 ((@IN A x (@topspace A _616456)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _616456 t)) -> exists y : A, (~ (y = x)) /\ ((@IN A y _616457) /\ (@IN A y t)))) x)).
Proof. exact (REFL (@derived_set_of A)). Qed.
Definition closure_of {A : Type'} : (Topology A) -> (A -> Prop) -> A -> Prop := fun _616895 : Topology A => fun _616896 : A -> Prop => @GSPEC A (fun GEN_PVAR_1249 : A => exists x : A, @SETSPEC A GEN_PVAR_1249 ((@IN A x (@topspace A _616895)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _616895 t)) -> exists y : A, (@IN A y _616896) /\ (@IN A y t))) x).
Lemma closure_of_def {A : Type'} : (@closure_of A) = (fun _616895 : Topology A => fun _616896 : A -> Prop => @GSPEC A (fun GEN_PVAR_1249 : A => exists x : A, @SETSPEC A GEN_PVAR_1249 ((@IN A x (@topspace A _616895)) /\ (forall t : A -> Prop, ((@IN A x t) /\ (@open_in A _616895 t)) -> exists y : A, (@IN A y _616896) /\ (@IN A y t))) x)).
Proof. exact (REFL (@closure_of A)). Qed.
Definition interior_of {_358624 : Type'} : (Topology _358624) -> (_358624 -> Prop) -> _358624 -> Prop := fun _617435 : Topology _358624 => fun _617436 : _358624 -> Prop => @GSPEC _358624 (fun GEN_PVAR_1259 : _358624 => exists x : _358624, @SETSPEC _358624 GEN_PVAR_1259 (exists t : _358624 -> Prop, (@open_in _358624 _617435 t) /\ ((@IN _358624 x t) /\ (@subset _358624 t _617436))) x).
Lemma interior_of_def {_358624 : Type'} : (@interior_of _358624) = (fun _617435 : Topology _358624 => fun _617436 : _358624 -> Prop => @GSPEC _358624 (fun GEN_PVAR_1259 : _358624 => exists x : _358624, @SETSPEC _358624 GEN_PVAR_1259 (exists t : _358624 -> Prop, (@open_in _358624 _617435 t) /\ ((@IN _358624 x t) /\ (@subset _358624 t _617436))) x)).
Proof. exact (REFL (@interior_of _358624)). Qed.
Definition frontier_of {_359960 : Type'} : (Topology _359960) -> (_359960 -> Prop) -> _359960 -> Prop := fun _617796 : Topology _359960 => fun _617797 : _359960 -> Prop => @setD _359960 (@closure_of _359960 _617796 _617797) (@interior_of _359960 _617796 _617797).
Lemma frontier_of_def {_359960 : Type'} : (@frontier_of _359960) = (fun _617796 : Topology _359960 => fun _617797 : _359960 -> Prop => @setD _359960 (@closure_of _359960 _617796 _617797) (@interior_of _359960 _617796 _617797)).
Proof. exact (REFL (@frontier_of _359960)). Qed.
Definition locally_finite_in {_361688 : Type'} : (Topology _361688) -> ((_361688 -> Prop) -> Prop) -> Prop := fun _618199 : Topology _361688 => fun _618200 : (_361688 -> Prop) -> Prop => (forall u : _361688 -> Prop, (@IN (_361688 -> Prop) u _618200) -> @subset _361688 u (@topspace _361688 _618199)) /\ (forall x : _361688, (@IN _361688 x (@topspace _361688 _618199)) -> exists v : _361688 -> Prop, (@open_in _361688 _618199 v) /\ ((@IN _361688 x v) /\ (@finite_set (_361688 -> Prop) (@GSPEC (_361688 -> Prop) (fun GEN_PVAR_1263 : _361688 -> Prop => exists u : _361688 -> Prop, @SETSPEC (_361688 -> Prop) GEN_PVAR_1263 ((@IN (_361688 -> Prop) u _618200) /\ (~ ((@setI _361688 u v) = (@set0 _361688)))) u))))).
Lemma locally_finite_in_def {_361688 : Type'} : (@locally_finite_in _361688) = (fun _618199 : Topology _361688 => fun _618200 : (_361688 -> Prop) -> Prop => (forall u : _361688 -> Prop, (@IN (_361688 -> Prop) u _618200) -> @subset _361688 u (@topspace _361688 _618199)) /\ (forall x : _361688, (@IN _361688 x (@topspace _361688 _618199)) -> exists v : _361688 -> Prop, (@open_in _361688 _618199 v) /\ ((@IN _361688 x v) /\ (@finite_set (_361688 -> Prop) (@GSPEC (_361688 -> Prop) (fun GEN_PVAR_1263 : _361688 -> Prop => exists u : _361688 -> Prop, @SETSPEC (_361688 -> Prop) GEN_PVAR_1263 ((@IN (_361688 -> Prop) u _618200) /\ (~ ((@setI _361688 u v) = (@set0 _361688)))) u)))))).
Proof. exact (REFL (@locally_finite_in _361688)). Qed.
Definition continuous_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _618425 : prod (Topology A) (Topology B) => fun _618426 : A -> B => (forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _618425))) -> @IN B (_618426 x) (@topspace B (@snd (Topology A) (Topology B) _618425))) /\ (forall u : B -> Prop, (@open_in B (@snd (Topology A) (Topology B) _618425) u) -> @open_in A (@fst (Topology A) (Topology B) _618425) (@GSPEC A (fun GEN_PVAR_1276 : A => exists x : A, @SETSPEC A GEN_PVAR_1276 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _618425))) /\ (@IN B (_618426 x) u)) x))).
Lemma continuous_map_def {A B : Type'} : (@continuous_map A B) = (fun _618425 : prod (Topology A) (Topology B) => fun _618426 : A -> B => (forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _618425))) -> @IN B (_618426 x) (@topspace B (@snd (Topology A) (Topology B) _618425))) /\ (forall u : B -> Prop, (@open_in B (@snd (Topology A) (Topology B) _618425) u) -> @open_in A (@fst (Topology A) (Topology B) _618425) (@GSPEC A (fun GEN_PVAR_1276 : A => exists x : A, @SETSPEC A GEN_PVAR_1276 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _618425))) /\ (@IN B (_618426 x) u)) x)))).
Proof. exact (REFL (@continuous_map A B)). Qed.
Definition open_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _626467 : prod (Topology A) (Topology B) => fun _626468 : A -> B => forall u : A -> Prop, (@open_in A (@fst (Topology A) (Topology B) _626467) u) -> @open_in B (@snd (Topology A) (Topology B) _626467) (@IMAGE A B _626468 u).
Lemma open_map_def {A B : Type'} : (@open_map A B) = (fun _626467 : prod (Topology A) (Topology B) => fun _626468 : A -> B => forall u : A -> Prop, (@open_in A (@fst (Topology A) (Topology B) _626467) u) -> @open_in B (@snd (Topology A) (Topology B) _626467) (@IMAGE A B _626468 u)).
Proof. exact (REFL (@open_map A B)). Qed.
Definition closed_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _626484 : prod (Topology A) (Topology B) => fun _626485 : A -> B => forall u : A -> Prop, (@closed_in A (@fst (Topology A) (Topology B) _626484) u) -> @closed_in B (@snd (Topology A) (Topology B) _626484) (@IMAGE A B _626485 u).
Lemma closed_map_def {A B : Type'} : (@closed_map A B) = (fun _626484 : prod (Topology A) (Topology B) => fun _626485 : A -> B => forall u : A -> Prop, (@closed_in A (@fst (Topology A) (Topology B) _626484) u) -> @closed_in B (@snd (Topology A) (Topology B) _626484) (@IMAGE A B _626485 u)).
Proof. exact (REFL (@closed_map A B)). Qed.
Definition quotient_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _630315 : prod (Topology A) (Topology B) => fun _630316 : A -> B => ((@IMAGE A B _630316 (@topspace A (@fst (Topology A) (Topology B) _630315))) = (@topspace B (@snd (Topology A) (Topology B) _630315))) /\ (forall u : B -> Prop, (@subset B u (@topspace B (@snd (Topology A) (Topology B) _630315))) -> (@open_in A (@fst (Topology A) (Topology B) _630315) (@GSPEC A (fun GEN_PVAR_1371 : A => exists x : A, @SETSPEC A GEN_PVAR_1371 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _630315))) /\ (@IN B (_630316 x) u)) x))) = (@open_in B (@snd (Topology A) (Topology B) _630315) u)).
Lemma quotient_map_def {A B : Type'} : (@quotient_map A B) = (fun _630315 : prod (Topology A) (Topology B) => fun _630316 : A -> B => ((@IMAGE A B _630316 (@topspace A (@fst (Topology A) (Topology B) _630315))) = (@topspace B (@snd (Topology A) (Topology B) _630315))) /\ (forall u : B -> Prop, (@subset B u (@topspace B (@snd (Topology A) (Topology B) _630315))) -> (@open_in A (@fst (Topology A) (Topology B) _630315) (@GSPEC A (fun GEN_PVAR_1371 : A => exists x : A, @SETSPEC A GEN_PVAR_1371 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _630315))) /\ (@IN B (_630316 x) u)) x))) = (@open_in B (@snd (Topology A) (Topology B) _630315) u))).
Proof. exact (REFL (@quotient_map A B)). Qed.
Definition prod_topology {A B : Type'} : (Topology A) -> (Topology B) -> Topology (prod A B) := fun _639550 : Topology A => fun _639551 : Topology B => @topology (prod A B) (@UNION_OF (prod A B) (@ARBITRARY (prod A B)) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_1385 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_1385 ((@open_in A _639550 s) /\ (@open_in B _639551 t)) (@CROSS A B s t)))).
Lemma prod_topology_def {A B : Type'} : (@prod_topology A B) = (fun _639550 : Topology A => fun _639551 : Topology B => @topology (prod A B) (@UNION_OF (prod A B) (@ARBITRARY (prod A B)) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_1385 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_1385 ((@open_in A _639550 s) /\ (@open_in B _639551 t)) (@CROSS A B s t))))).
Proof. exact (REFL (@prod_topology A B)). Qed.
Definition product_topology {A K : Type'} : (K -> Prop) -> (K -> Topology A) -> Topology (K -> A) := fun _643435 : K -> Prop => fun _643436 : K -> Topology A => @topology (K -> A) (@UNION_OF (K -> A) (@ARBITRARY (K -> A)) (@relative_to (K -> A) (@INTERSECTION_OF (K -> A) (@finite_set ((K -> A) -> Prop)) (@GSPEC ((K -> A) -> Prop) (fun GEN_PVAR_1390 : (K -> A) -> Prop => exists k : K, exists u : A -> Prop, @SETSPEC ((K -> A) -> Prop) GEN_PVAR_1390 ((@IN K k _643435) /\ (@open_in A (_643436 k) u)) (@GSPEC (K -> A) (fun GEN_PVAR_1389 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1389 (@IN A (x k) u) x))))) (@GSPEC (K -> A) (fun GEN_PVAR_1391 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1391 ((@EXTENSIONAL K A _643435 x) /\ (forall k : K, (@IN K k _643435) -> @IN A (x k) (@topspace A (_643436 k)))) x)))).
Lemma product_topology_def {A K : Type'} : (@product_topology A K) = (fun _643435 : K -> Prop => fun _643436 : K -> Topology A => @topology (K -> A) (@UNION_OF (K -> A) (@ARBITRARY (K -> A)) (@relative_to (K -> A) (@INTERSECTION_OF (K -> A) (@finite_set ((K -> A) -> Prop)) (@GSPEC ((K -> A) -> Prop) (fun GEN_PVAR_1390 : (K -> A) -> Prop => exists k : K, exists u : A -> Prop, @SETSPEC ((K -> A) -> Prop) GEN_PVAR_1390 ((@IN K k _643435) /\ (@open_in A (_643436 k) u)) (@GSPEC (K -> A) (fun GEN_PVAR_1389 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1389 (@IN A (x k) u) x))))) (@GSPEC (K -> A) (fun GEN_PVAR_1391 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_1391 ((@EXTENSIONAL K A _643435 x) /\ (forall k : K, (@IN K k _643435) -> @IN A (x k) (@topspace A (_643436 k)))) x))))).
Proof. exact (REFL (@product_topology A K)). Qed.
Definition sum_topology {A K : Type'} : (K -> Prop) -> (K -> Topology A) -> Topology (prod K A) := fun _650526 : K -> Prop => fun _650527 : K -> Topology A => @topology (prod K A) (@GSPEC ((prod K A) -> Prop) (fun GEN_PVAR_1454 : (prod K A) -> Prop => exists u : (prod K A) -> Prop, @SETSPEC ((prod K A) -> Prop) GEN_PVAR_1454 ((@subset (prod K A) u (@disjoint_union A K _650526 (@o K (Topology A) (A -> Prop) (@topspace A) _650527))) /\ (forall i : K, (@IN K i _650526) -> @open_in A (_650527 i) (@GSPEC A (fun GEN_PVAR_1453 : A => exists x : A, @SETSPEC A GEN_PVAR_1453 (@IN (prod K A) (@pair K A i x) u) x)))) u)).
Lemma sum_topology_def {A K : Type'} : (@sum_topology A K) = (fun _650526 : K -> Prop => fun _650527 : K -> Topology A => @topology (prod K A) (@GSPEC ((prod K A) -> Prop) (fun GEN_PVAR_1454 : (prod K A) -> Prop => exists u : (prod K A) -> Prop, @SETSPEC ((prod K A) -> Prop) GEN_PVAR_1454 ((@subset (prod K A) u (@disjoint_union A K _650526 (@o K (Topology A) (A -> Prop) (@topspace A) _650527))) /\ (forall i : K, (@IN K i _650526) -> @open_in A (_650527 i) (@GSPEC A (fun GEN_PVAR_1453 : A => exists x : A, @SETSPEC A GEN_PVAR_1453 (@IN (prod K A) (@pair K A i x) u) x)))) u))).
Proof. exact (REFL (@sum_topology A K)). Qed.
Definition homeomorphic_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _651053 : prod (Topology A) (Topology B) => fun _651054 : A -> B => (@quotient_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _651053) (@snd (Topology A) (Topology B) _651053)) _651054) /\ (forall x : A, forall y : A, ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _651053))) /\ (@IN A y (@topspace A (@fst (Topology A) (Topology B) _651053)))) -> ((_651054 x) = (_651054 y)) = (x = y)).
Lemma homeomorphic_map_def {A B : Type'} : (@homeomorphic_map A B) = (fun _651053 : prod (Topology A) (Topology B) => fun _651054 : A -> B => (@quotient_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _651053) (@snd (Topology A) (Topology B) _651053)) _651054) /\ (forall x : A, forall y : A, ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _651053))) /\ (@IN A y (@topspace A (@fst (Topology A) (Topology B) _651053)))) -> ((_651054 x) = (_651054 y)) = (x = y))).
Proof. exact (REFL (@homeomorphic_map A B)). Qed.
Definition homeomorphic_maps {A B : Type'} : (prod (Topology A) (Topology B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _651070 : prod (Topology A) (Topology B) => fun _651071 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _651070) (@snd (Topology A) (Topology B) _651070)) (@fst (A -> B) (B -> A) _651071)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _651070) (@fst (Topology A) (Topology B) _651070)) (@snd (A -> B) (B -> A) _651071)) /\ ((forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _651070))) -> (@snd (A -> B) (B -> A) _651071 (@fst (A -> B) (B -> A) _651071 x)) = x) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _651070))) -> (@fst (A -> B) (B -> A) _651071 (@snd (A -> B) (B -> A) _651071 y)) = y))).
Lemma homeomorphic_maps_def {A B : Type'} : (@homeomorphic_maps A B) = (fun _651070 : prod (Topology A) (Topology B) => fun _651071 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _651070) (@snd (Topology A) (Topology B) _651070)) (@fst (A -> B) (B -> A) _651071)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _651070) (@fst (Topology A) (Topology B) _651070)) (@snd (A -> B) (B -> A) _651071)) /\ ((forall x : A, (@IN A x (@topspace A (@fst (Topology A) (Topology B) _651070))) -> (@snd (A -> B) (B -> A) _651071 (@fst (A -> B) (B -> A) _651071 x)) = x) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _651070))) -> (@fst (A -> B) (B -> A) _651071 (@snd (A -> B) (B -> A) _651071 y)) = y)))).
Proof. exact (REFL (@homeomorphic_maps A B)). Qed.
Definition homeomorphic_space {A B : Type'} : (Topology A) -> (Topology B) -> Prop := fun _704472 : Topology A => fun _704473 : Topology B => exists f : A -> B, exists g : B -> A, @homeomorphic_maps A B (@pair (Topology A) (Topology B) _704472 _704473) (@pair (A -> B) (B -> A) f g).
Lemma homeomorphic_space_def {A B : Type'} : (@homeomorphic_space A B) = (fun _704472 : Topology A => fun _704473 : Topology B => exists f : A -> B, exists g : B -> A, @homeomorphic_maps A B (@pair (Topology A) (Topology B) _704472 _704473) (@pair (A -> B) (B -> A) f g)).
Proof. exact (REFL (@homeomorphic_space A B)). Qed.
Definition embedding_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _705806 : prod (Topology A) (Topology B) => fun _705807 : A -> B => @homeomorphic_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _705806) (@subtopology B (@snd (Topology A) (Topology B) _705806) (@IMAGE A B _705807 (@topspace A (@fst (Topology A) (Topology B) _705806))))) _705807.
Lemma embedding_map_def {A B : Type'} : (@embedding_map A B) = (fun _705806 : prod (Topology A) (Topology B) => fun _705807 : A -> B => @homeomorphic_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _705806) (@subtopology B (@snd (Topology A) (Topology B) _705806) (@IMAGE A B _705807 (@topspace A (@fst (Topology A) (Topology B) _705806))))) _705807).
Proof. exact (REFL (@embedding_map A B)). Qed.
Definition retraction_maps {A B : Type'} : (prod (Topology A) (Topology B)) -> (prod (A -> B) (B -> A)) -> Prop := fun _708937 : prod (Topology A) (Topology B) => fun _708938 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _708937) (@snd (Topology A) (Topology B) _708937)) (@fst (A -> B) (B -> A) _708938)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _708937) (@fst (Topology A) (Topology B) _708937)) (@snd (A -> B) (B -> A) _708938)) /\ (forall x : B, (@IN B x (@topspace B (@snd (Topology A) (Topology B) _708937))) -> (@fst (A -> B) (B -> A) _708938 (@snd (A -> B) (B -> A) _708938 x)) = x)).
Lemma retraction_maps_def {A B : Type'} : (@retraction_maps A B) = (fun _708937 : prod (Topology A) (Topology B) => fun _708938 : prod (A -> B) (B -> A) => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _708937) (@snd (Topology A) (Topology B) _708937)) (@fst (A -> B) (B -> A) _708938)) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _708937) (@fst (Topology A) (Topology B) _708937)) (@snd (A -> B) (B -> A) _708938)) /\ (forall x : B, (@IN B x (@topspace B (@snd (Topology A) (Topology B) _708937))) -> (@fst (A -> B) (B -> A) _708938 (@snd (A -> B) (B -> A) _708938 x)) = x))).
Proof. exact (REFL (@retraction_maps A B)). Qed.
Definition section_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _708959 : prod (Topology A) (Topology B) => fun _708960 : A -> B => exists g : B -> A, @retraction_maps B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _708959) (@fst (Topology A) (Topology B) _708959)) (@pair (B -> A) (A -> B) g _708960).
Lemma section_map_def {A B : Type'} : (@section_map A B) = (fun _708959 : prod (Topology A) (Topology B) => fun _708960 : A -> B => exists g : B -> A, @retraction_maps B A (@pair (Topology B) (Topology A) (@snd (Topology A) (Topology B) _708959) (@fst (Topology A) (Topology B) _708959)) (@pair (B -> A) (A -> B) g _708960)).
Proof. exact (REFL (@section_map A B)). Qed.
Definition retraction_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _708976 : prod (Topology A) (Topology B) => fun _708977 : A -> B => exists g : B -> A, @retraction_maps A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _708976) (@snd (Topology A) (Topology B) _708976)) (@pair (A -> B) (B -> A) _708977 g).
Lemma retraction_map_def {A B : Type'} : (@retraction_map A B) = (fun _708976 : prod (Topology A) (Topology B) => fun _708977 : A -> B => exists g : B -> A, @retraction_maps A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _708976) (@snd (Topology A) (Topology B) _708976)) (@pair (A -> B) (B -> A) _708977 g)).
Proof. exact (REFL (@retraction_map A B)). Qed.
Definition retract_of_space {A : Type'} : (A -> Prop) -> (Topology A) -> Prop := fun _714529 : A -> Prop => fun _714530 : Topology A => (@subset A _714529 (@topspace A _714530)) /\ (exists r : A -> A, (@continuous_map A A (@pair (Topology A) (Topology A) _714530 (@subtopology A _714530 _714529)) r) /\ (forall x : A, (@IN A x _714529) -> (r x) = x)).
Lemma retract_of_space_def {A : Type'} : (@retract_of_space A) = (fun _714529 : A -> Prop => fun _714530 : Topology A => (@subset A _714529 (@topspace A _714530)) /\ (exists r : A -> A, (@continuous_map A A (@pair (Topology A) (Topology A) _714530 (@subtopology A _714530 _714529)) r) /\ (forall x : A, (@IN A x _714529) -> (r x) = x))).
Proof. exact (REFL (@retract_of_space A)). Qed.
Definition compact_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _715308 : Topology A => fun _715309 : A -> Prop => (@subset A _715309 (@topspace A _715308)) /\ (forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _715308 u) /\ (@subset A _715309 (@UNIONS A U))) -> exists V : (A -> Prop) -> Prop, (@finite_set (A -> Prop) V) /\ ((@subset (A -> Prop) V U) /\ (@subset A _715309 (@UNIONS A V)))).
Lemma compact_in_def {A : Type'} : (@compact_in A) = (fun _715308 : Topology A => fun _715309 : A -> Prop => (@subset A _715309 (@topspace A _715308)) /\ (forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _715308 u) /\ (@subset A _715309 (@UNIONS A U))) -> exists V : (A -> Prop) -> Prop, (@finite_set (A -> Prop) V) /\ ((@subset (A -> Prop) V U) /\ (@subset A _715309 (@UNIONS A V))))).
Proof. exact (REFL (@compact_in A)). Qed.
Definition compact_space {A : Type'} : (Topology A) -> Prop := fun _715320 : Topology A => @compact_in A _715320 (@topspace A _715320).
Lemma compact_space_def {A : Type'} : (@compact_space A) = (fun _715320 : Topology A => @compact_in A _715320 (@topspace A _715320)).
Proof. exact (REFL (@compact_space A)). Qed.
Definition separated_in {_390453 : Type'} : (Topology _390453) -> (_390453 -> Prop) -> (_390453 -> Prop) -> Prop := fun _728429 : Topology _390453 => fun _728430 : _390453 -> Prop => fun _728431 : _390453 -> Prop => (@subset _390453 _728430 (@topspace _390453 _728429)) /\ ((@subset _390453 _728431 (@topspace _390453 _728429)) /\ (((@setI _390453 _728430 (@closure_of _390453 _728429 _728431)) = (@set0 _390453)) /\ ((@setI _390453 _728431 (@closure_of _390453 _728429 _728430)) = (@set0 _390453)))).
Lemma separated_in_def {_390453 : Type'} : (@separated_in _390453) = (fun _728429 : Topology _390453 => fun _728430 : _390453 -> Prop => fun _728431 : _390453 -> Prop => (@subset _390453 _728430 (@topspace _390453 _728429)) /\ ((@subset _390453 _728431 (@topspace _390453 _728429)) /\ (((@setI _390453 _728430 (@closure_of _390453 _728429 _728431)) = (@set0 _390453)) /\ ((@setI _390453 _728431 (@closure_of _390453 _728429 _728430)) = (@set0 _390453))))).
Proof. exact (REFL (@separated_in _390453)). Qed.
Definition t1_space {_391634 : Type'} : (Topology _391634) -> Prop := fun _730573 : Topology _391634 => forall x : _391634, forall y : _391634, ((@IN _391634 x (@topspace _391634 _730573)) /\ ((@IN _391634 y (@topspace _391634 _730573)) /\ (~ (x = y)))) -> exists u : _391634 -> Prop, (@open_in _391634 _730573 u) /\ ((@IN _391634 x u) /\ (~ (@IN _391634 y u))).
Lemma t1_space_def {_391634 : Type'} : (@t1_space _391634) = (fun _730573 : Topology _391634 => forall x : _391634, forall y : _391634, ((@IN _391634 x (@topspace _391634 _730573)) /\ ((@IN _391634 y (@topspace _391634 _730573)) /\ (~ (x = y)))) -> exists u : _391634 -> Prop, (@open_in _391634 _730573 u) /\ ((@IN _391634 x u) /\ (~ (@IN _391634 y u)))).
Proof. exact (REFL (@t1_space _391634)). Qed.
Definition hausdorff_space {A : Type'} : (Topology A) -> Prop := fun _731756 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _731756)) /\ ((@IN A y (@topspace A _731756)) /\ (~ (x = y)))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _731756 u) /\ ((@open_in A _731756 v) /\ ((@IN A x u) /\ ((@IN A y v) /\ (@DISJOINT A u v)))).
Lemma hausdorff_space_def {A : Type'} : (@hausdorff_space A) = (fun _731756 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _731756)) /\ ((@IN A y (@topspace A _731756)) /\ (~ (x = y)))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _731756 u) /\ ((@open_in A _731756 v) /\ ((@IN A x u) /\ ((@IN A y v) /\ (@DISJOINT A u v))))).
Proof. exact (REFL (@hausdorff_space A)). Qed.
Definition kc_space {A : Type'} : (Topology A) -> Prop := fun _738313 : Topology A => forall s : A -> Prop, (@compact_in A _738313 s) -> @closed_in A _738313 s.
Lemma kc_space_def {A : Type'} : (@kc_space A) = (fun _738313 : Topology A => forall s : A -> Prop, (@compact_in A _738313 s) -> @closed_in A _738313 s).
Proof. exact (REFL (@kc_space A)). Qed.
Definition proper_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _739805 : prod (Topology A) (Topology B) => fun _739806 : A -> B => (@closed_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _739805) (@snd (Topology A) (Topology B) _739805)) _739806) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _739805))) -> @compact_in A (@fst (Topology A) (Topology B) _739805) (@GSPEC A (fun GEN_PVAR_1536 : A => exists x : A, @SETSPEC A GEN_PVAR_1536 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _739805))) /\ ((_739806 x) = y)) x))).
Lemma proper_map_def {A B : Type'} : (@proper_map A B) = (fun _739805 : prod (Topology A) (Topology B) => fun _739806 : A -> B => (@closed_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _739805) (@snd (Topology A) (Topology B) _739805)) _739806) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _739805))) -> @compact_in A (@fst (Topology A) (Topology B) _739805) (@GSPEC A (fun GEN_PVAR_1536 : A => exists x : A, @SETSPEC A GEN_PVAR_1536 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _739805))) /\ ((_739806 x) = y)) x)))).
Proof. exact (REFL (@proper_map A B)). Qed.
Definition perfect_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _748570 : prod (Topology A) (Topology B) => fun _748571 : A -> B => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _748570) (@snd (Topology A) (Topology B) _748570)) _748571) /\ ((@proper_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _748570) (@snd (Topology A) (Topology B) _748570)) _748571) /\ ((@IMAGE A B _748571 (@topspace A (@fst (Topology A) (Topology B) _748570))) = (@topspace B (@snd (Topology A) (Topology B) _748570)))).
Lemma perfect_map_def {A B : Type'} : (@perfect_map A B) = (fun _748570 : prod (Topology A) (Topology B) => fun _748571 : A -> B => (@continuous_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _748570) (@snd (Topology A) (Topology B) _748570)) _748571) /\ ((@proper_map A B (@pair (Topology A) (Topology B) (@fst (Topology A) (Topology B) _748570) (@snd (Topology A) (Topology B) _748570)) _748571) /\ ((@IMAGE A B _748571 (@topspace A (@fst (Topology A) (Topology B) _748570))) = (@topspace B (@snd (Topology A) (Topology B) _748570))))).
Proof. exact (REFL (@perfect_map A B)). Qed.
Definition lindelof_space {A : Type'} : (Topology A) -> Prop := fun _753375 : Topology A => forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _753375 u) /\ ((@UNIONS A U) = (@topspace A _753375))) -> exists V : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) V) /\ ((@subset (A -> Prop) V U) /\ ((@UNIONS A V) = (@topspace A _753375))).
Lemma lindelof_space_def {A : Type'} : (@lindelof_space A) = (fun _753375 : Topology A => forall U : (A -> Prop) -> Prop, ((forall u : A -> Prop, (@IN (A -> Prop) u U) -> @open_in A _753375 u) /\ ((@UNIONS A U) = (@topspace A _753375))) -> exists V : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) V) /\ ((@subset (A -> Prop) V U) /\ ((@UNIONS A V) = (@topspace A _753375)))).
Proof. exact (REFL (@lindelof_space A)). Qed.
Definition second_countable {A : Type'} : (Topology A) -> Prop := fun _755790 : Topology A => exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _755790 v) /\ (forall u : A -> Prop, forall x : A, ((@open_in A _755790 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@subset A v u)))).
Lemma second_countable_def {A : Type'} : (@second_countable A) = (fun _755790 : Topology A => exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _755790 v) /\ (forall u : A -> Prop, forall x : A, ((@open_in A _755790 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@subset A v u))))).
Proof. exact (REFL (@second_countable A)). Qed.
Definition first_countable {A : Type'} : (Topology A) -> Prop := fun _755795 : Topology A => forall x : A, (@IN A x (@topspace A _755795)) -> exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _755795 v) /\ (forall u : A -> Prop, ((@open_in A _755795 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@subset A v u)))).
Lemma first_countable_def {A : Type'} : (@first_countable A) = (fun _755795 : Topology A => forall x : A, (@IN A x (@topspace A _755795)) -> exists b : (A -> Prop) -> Prop, (@COUNTABLE (A -> Prop) b) /\ ((forall v : A -> Prop, (@IN (A -> Prop) v b) -> @open_in A _755795 v) /\ (forall u : A -> Prop, ((@open_in A _755795 u) /\ (@IN A x u)) -> exists v : A -> Prop, (@IN (A -> Prop) v b) /\ ((@IN A x v) /\ (@subset A v u))))).
Proof. exact (REFL (@first_countable A)). Qed.
Definition separable_space {A : Type'} : (Topology A) -> Prop := fun _755800 : Topology A => exists c : A -> Prop, (@COUNTABLE A c) /\ ((@subset A c (@topspace A _755800)) /\ ((@closure_of A _755800 c) = (@topspace A _755800))).
Lemma separable_space_def {A : Type'} : (@separable_space A) = (fun _755800 : Topology A => exists c : A -> Prop, (@COUNTABLE A c) /\ ((@subset A c (@topspace A _755800)) /\ ((@closure_of A _755800 c) = (@topspace A _755800)))).
Proof. exact (REFL (@separable_space A)). Qed.
Definition netlimit {A : Type'} : (net A) -> A := fun _757803 : net A => @ε A (fun x : A => @IN A x (@net_limits A _757803)).
Lemma netlimit_def {A : Type'} : (@netlimit A) = (fun _757803 : net A => @ε A (fun x : A => @IN A x (@net_limits A _757803))).
Proof. exact (REFL (@netlimit A)). Qed.
Definition within {_408036 : Type'} : (net _408036) -> (_408036 -> Prop) -> net _408036 := fun _757831 : net _408036 => fun _757832 : _408036 -> Prop => @mk_net _408036 (@pair ((_408036 -> Prop) -> Prop) (_408036 -> Prop) (@relative_to _408036 (@net_filter _408036 _757831) _757832) (@net_limits _408036 _757831)).
Lemma within_def {_408036 : Type'} : (@within _408036) = (fun _757831 : net _408036 => fun _757832 : _408036 -> Prop => @mk_net _408036 (@pair ((_408036 -> Prop) -> Prop) (_408036 -> Prop) (@relative_to _408036 (@net_filter _408036 _757831) _757832) (@net_limits _408036 _757831))).
Proof. exact (REFL (@within _408036)). Qed.
Definition trivial_limit {_408209 : Type'} : (net _408209) -> Prop := fun _757923 : net _408209 => @eventually _408209 (fun x : _408209 => False) _757923.
Lemma trivial_limit_def {_408209 : Type'} : (@trivial_limit _408209) = (fun _757923 : net _408209 => @eventually _408209 (fun x : _408209 => False) _757923).
Proof. exact (REFL (@trivial_limit _408209)). Qed.
Definition fsigma_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _758433 : Topology A => @UNION_OF A (@COUNTABLE (A -> Prop)) (@closed_in A _758433).
Lemma fsigma_in_def {A : Type'} : (@fsigma_in A) = (fun _758433 : Topology A => @UNION_OF A (@COUNTABLE (A -> Prop)) (@closed_in A _758433)).
Proof. exact (REFL (@fsigma_in A)). Qed.
Definition gdelta_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _758438 : Topology A => @relative_to A (@INTERSECTION_OF A (@COUNTABLE (A -> Prop)) (@open_in A _758438)) (@topspace A _758438).
Lemma gdelta_in_def {A : Type'} : (@gdelta_in A) = (fun _758438 : Topology A => @relative_to A (@INTERSECTION_OF A (@COUNTABLE (A -> Prop)) (@open_in A _758438)) (@topspace A _758438)).
Proof. exact (REFL (@gdelta_in A)). Qed.
Definition is_metric_space {A : Type'} : (prod (A -> Prop) ((prod A A) -> R)) -> Prop := fun _759684 : prod (A -> Prop) ((prod A A) -> R) => (forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> ler (R_of_nat (NUMERAL O)) (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y))) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> ((@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) = (R_of_nat (NUMERAL O))) = (x = y)) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) = (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A y x))) /\ (forall x : A, forall y : A, forall z : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ ((@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A z (@fst (A -> Prop) ((prod A A) -> R) _759684)))) -> ler (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x z)) (addr (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A y z)))))).
Lemma is_metric_space_def {A : Type'} : (@is_metric_space A) = (fun _759684 : prod (A -> Prop) ((prod A A) -> R) => (forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> ler (R_of_nat (NUMERAL O)) (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y))) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> ((@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) = (R_of_nat (NUMERAL O))) = (x = y)) /\ ((forall x : A, forall y : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684))) -> (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) = (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A y x))) /\ (forall x : A, forall y : A, forall z : A, ((@IN A x (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ ((@IN A y (@fst (A -> Prop) ((prod A A) -> R) _759684)) /\ (@IN A z (@fst (A -> Prop) ((prod A A) -> R) _759684)))) -> ler (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x z)) (addr (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A x y)) (@snd (A -> Prop) ((prod A A) -> R) _759684 (@pair A A y z))))))).
Proof. exact (REFL (@is_metric_space A)). Qed.
Definition mspace {A : Type'} : (Metric A) -> A -> Prop := fun _759924 : Metric A => @fst (A -> Prop) ((prod A A) -> R) (@dest_metric A _759924).
Lemma mspace_def {A : Type'} : (@mspace A) = (fun _759924 : Metric A => @fst (A -> Prop) ((prod A A) -> R) (@dest_metric A _759924)).
Proof. exact (REFL (@mspace A)). Qed.
Definition mdist {A : Type'} : (Metric A) -> (prod A A) -> R := fun _759929 : Metric A => @snd (A -> Prop) ((prod A A) -> R) (@dest_metric A _759929).
Lemma mdist_def {A : Type'} : (@mdist A) = (fun _759929 : Metric A => @snd (A -> Prop) ((prod A A) -> R) (@dest_metric A _759929)).
Proof. exact (REFL (@mdist A)). Qed.
Definition mball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _760443 : Metric A => fun _760444 : prod A R => @GSPEC A (fun GEN_PVAR_1613 : A => exists y : A, @SETSPEC A GEN_PVAR_1613 ((@IN A (@fst A R _760444) (@mspace A _760443)) /\ ((@IN A y (@mspace A _760443)) /\ (ltr (@mdist A _760443 (@pair A A (@fst A R _760444) y)) (@snd A R _760444)))) y).
Lemma mball_def {A : Type'} : (@mball A) = (fun _760443 : Metric A => fun _760444 : prod A R => @GSPEC A (fun GEN_PVAR_1613 : A => exists y : A, @SETSPEC A GEN_PVAR_1613 ((@IN A (@fst A R _760444) (@mspace A _760443)) /\ ((@IN A y (@mspace A _760443)) /\ (ltr (@mdist A _760443 (@pair A A (@fst A R _760444) y)) (@snd A R _760444)))) y)).
Proof. exact (REFL (@mball A)). Qed.
Definition submetric {A : Type'} : (Metric A) -> (A -> Prop) -> Metric A := fun _760513 : Metric A => fun _760514 : A -> Prop => @metric A (@pair (A -> Prop) ((prod A A) -> R) (@setI A _760514 (@mspace A _760513)) (@mdist A _760513)).
Lemma submetric_def {A : Type'} : (@submetric A) = (fun _760513 : Metric A => fun _760514 : A -> Prop => @metric A (@pair (A -> Prop) ((prod A A) -> R) (@setI A _760514 (@mspace A _760513)) (@mdist A _760513))).
Proof. exact (REFL (@submetric A)). Qed.
Definition mtopology {A : Type'} : (Metric A) -> Topology A := fun _760531 : Metric A => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1614 : A -> Prop => exists u : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1614 ((@subset A u (@mspace A _760531)) /\ (forall x : A, (@IN A x u) -> exists r : R, (ltr (R_of_nat (NUMERAL O)) r) /\ (@subset A (@mball A _760531 (@pair A R x r)) u))) u)).
Lemma mtopology_def {A : Type'} : (@mtopology A) = (fun _760531 : Metric A => @topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_1614 : A -> Prop => exists u : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_1614 ((@subset A u (@mspace A _760531)) /\ (forall x : A, (@IN A x u) -> exists r : R, (ltr (R_of_nat (NUMERAL O)) r) /\ (@subset A (@mball A _760531 (@pair A R x r)) u))) u))).
Proof. exact (REFL (@mtopology A)). Qed.
Definition mcball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _760810 : Metric A => fun _760811 : prod A R => @GSPEC A (fun GEN_PVAR_1620 : A => exists y : A, @SETSPEC A GEN_PVAR_1620 ((@IN A (@fst A R _760811) (@mspace A _760810)) /\ ((@IN A y (@mspace A _760810)) /\ (ler (@mdist A _760810 (@pair A A (@fst A R _760811) y)) (@snd A R _760811)))) y).
Lemma mcball_def {A : Type'} : (@mcball A) = (fun _760810 : Metric A => fun _760811 : prod A R => @GSPEC A (fun GEN_PVAR_1620 : A => exists y : A, @SETSPEC A GEN_PVAR_1620 ((@IN A (@fst A R _760811) (@mspace A _760810)) /\ ((@IN A y (@mspace A _760810)) /\ (ler (@mdist A _760810 (@pair A A (@fst A R _760811) y)) (@snd A R _760811)))) y)).
Proof. exact (REFL (@mcball A)). Qed.
Definition msphere {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _761023 : Metric A => fun _761024 : prod A R => @GSPEC A (fun GEN_PVAR_1621 : A => exists y : A, @SETSPEC A GEN_PVAR_1621 ((@mdist A _761023 (@pair A A (@fst A R _761024) y)) = (@snd A R _761024)) y).
Lemma msphere_def {A : Type'} : (@msphere A) = (fun _761023 : Metric A => fun _761024 : prod A R => @GSPEC A (fun GEN_PVAR_1621 : A => exists y : A, @SETSPEC A GEN_PVAR_1621 ((@mdist A _761023 (@pair A A (@fst A R _761024) y)) = (@snd A R _761024)) y)).
Proof. exact (REFL (@msphere A)). Qed.
Definition mbounded {A : Type'} : (Metric A) -> (A -> Prop) -> Prop := fun _761088 : Metric A => fun _761089 : A -> Prop => exists c : A, exists b : R, @subset A _761089 (@mcball A _761088 (@pair A R c b)).
Lemma mbounded_def {A : Type'} : (@mbounded A) = (fun _761088 : Metric A => fun _761089 : A -> Prop => exists c : A, exists b : R, @subset A _761089 (@mcball A _761088 (@pair A R c b))).
Proof. exact (REFL (@mbounded A)). Qed.
Definition discrete_metric {_416212 : Type'} : (_416212 -> Prop) -> Metric _416212 := fun _761613 : _416212 -> Prop => @metric _416212 (@pair (_416212 -> Prop) ((prod _416212 _416212) -> R) _761613 (@GABS ((prod _416212 _416212) -> R) (fun f : (prod _416212 _416212) -> R => forall x : _416212, forall y : _416212, @eq R (f (@pair _416212 _416212 x y)) (@COND R (x = y) (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O))))))).
Lemma discrete_metric_def {_416212 : Type'} : (@discrete_metric _416212) = (fun _761613 : _416212 -> Prop => @metric _416212 (@pair (_416212 -> Prop) ((prod _416212 _416212) -> R) _761613 (@GABS ((prod _416212 _416212) -> R) (fun f : (prod _416212 _416212) -> R => forall x : _416212, forall y : _416212, @eq R (f (@pair _416212 _416212 x y)) (@COND R (x = y) (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))))))).
Proof. exact (REFL (@discrete_metric _416212)). Qed.
Definition metrizable_space {_416390 : Type'} : (Topology _416390) -> Prop := fun _761840 : Topology _416390 => exists m : Metric _416390, _761840 = (@mtopology _416390 m).
Lemma metrizable_space_def {_416390 : Type'} : (@metrizable_space _416390) = (fun _761840 : Topology _416390 => exists m : Metric _416390, _761840 = (@mtopology _416390 m)).
Proof. exact (REFL (@metrizable_space _416390)). Qed.
Definition connected_space {A : Type'} : (Topology A) -> Prop := fun _764801 : Topology A => ~ (exists e1 : A -> Prop, exists e2 : A -> Prop, (@open_in A _764801 e1) /\ ((@open_in A _764801 e2) /\ ((@subset A (@topspace A _764801) (@setU A e1 e2)) /\ (((@setI A e1 e2) = (@set0 A)) /\ ((~ (e1 = (@set0 A))) /\ (~ (e2 = (@set0 A)))))))).
Lemma connected_space_def {A : Type'} : (@connected_space A) = (fun _764801 : Topology A => ~ (exists e1 : A -> Prop, exists e2 : A -> Prop, (@open_in A _764801 e1) /\ ((@open_in A _764801 e2) /\ ((@subset A (@topspace A _764801) (@setU A e1 e2)) /\ (((@setI A e1 e2) = (@set0 A)) /\ ((~ (e1 = (@set0 A))) /\ (~ (e2 = (@set0 A))))))))).
Proof. exact (REFL (@connected_space A)). Qed.
Definition connected_in {_417083 : Type'} : (Topology _417083) -> (_417083 -> Prop) -> Prop := fun _764806 : Topology _417083 => fun _764807 : _417083 -> Prop => (@subset _417083 _764807 (@topspace _417083 _764806)) /\ (@connected_space _417083 (@subtopology _417083 _764806 _764807)).
Lemma connected_in_def {_417083 : Type'} : (@connected_in _417083) = (fun _764806 : Topology _417083 => fun _764807 : _417083 -> Prop => (@subset _417083 _764807 (@topspace _417083 _764806)) /\ (@connected_space _417083 (@subtopology _417083 _764806 _764807))).
Proof. exact (REFL (@connected_in _417083)). Qed.
Definition separated_between {A : Type'} : (Topology A) -> (A -> Prop) -> (A -> Prop) -> Prop := fun _777481 : Topology A => fun _777482 : A -> Prop => fun _777483 : A -> Prop => exists u : A -> Prop, exists v : A -> Prop, (@open_in A _777481 u) /\ ((@open_in A _777481 v) /\ (((@setU A u v) = (@topspace A _777481)) /\ ((@DISJOINT A u v) /\ ((@subset A _777482 u) /\ (@subset A _777483 v))))).
Lemma separated_between_def {A : Type'} : (@separated_between A) = (fun _777481 : Topology A => fun _777482 : A -> Prop => fun _777483 : A -> Prop => exists u : A -> Prop, exists v : A -> Prop, (@open_in A _777481 u) /\ ((@open_in A _777481 v) /\ (((@setU A u v) = (@topspace A _777481)) /\ ((@DISJOINT A u v) /\ ((@subset A _777482 u) /\ (@subset A _777483 v)))))).
Proof. exact (REFL (@separated_between A)). Qed.
Definition connected_component_of {_422455 : Type'} : (Topology _422455) -> _422455 -> _422455 -> Prop := fun _778921 : Topology _422455 => fun _778922 : _422455 => fun _778923 : _422455 => exists t : _422455 -> Prop, (@connected_in _422455 _778921 t) /\ ((@IN _422455 _778922 t) /\ (@IN _422455 _778923 t)).
Lemma connected_component_of_def {_422455 : Type'} : (@connected_component_of _422455) = (fun _778921 : Topology _422455 => fun _778922 : _422455 => fun _778923 : _422455 => exists t : _422455 -> Prop, (@connected_in _422455 _778921 t) /\ ((@IN _422455 _778922 t) /\ (@IN _422455 _778923 t))).
Proof. exact (REFL (@connected_component_of _422455)). Qed.
Definition connected_components_of {_422485 : Type'} : (Topology _422485) -> (_422485 -> Prop) -> Prop := fun _778942 : Topology _422485 => @GSPEC (_422485 -> Prop) (fun GEN_PVAR_1650 : _422485 -> Prop => exists x : _422485, @SETSPEC (_422485 -> Prop) GEN_PVAR_1650 (@IN _422485 x (@topspace _422485 _778942)) (@connected_component_of _422485 _778942 x)).
Lemma connected_components_of_def {_422485 : Type'} : (@connected_components_of _422485) = (fun _778942 : Topology _422485 => @GSPEC (_422485 -> Prop) (fun GEN_PVAR_1650 : _422485 -> Prop => exists x : _422485, @SETSPEC (_422485 -> Prop) GEN_PVAR_1650 (@IN _422485 x (@topspace _422485 _778942)) (@connected_component_of _422485 _778942 x))).
Proof. exact (REFL (@connected_components_of _422485)). Qed.
Definition monotone_map {A B : Type'} : (prod (Topology A) (Topology B)) -> (A -> B) -> Prop := fun _790519 : prod (Topology A) (Topology B) => fun _790520 : A -> B => (@subset B (@IMAGE A B _790520 (@topspace A (@fst (Topology A) (Topology B) _790519))) (@topspace B (@snd (Topology A) (Topology B) _790519))) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _790519))) -> @connected_in A (@fst (Topology A) (Topology B) _790519) (@GSPEC A (fun GEN_PVAR_1663 : A => exists x : A, @SETSPEC A GEN_PVAR_1663 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _790519))) /\ ((_790520 x) = y)) x))).
Lemma monotone_map_def {A B : Type'} : (@monotone_map A B) = (fun _790519 : prod (Topology A) (Topology B) => fun _790520 : A -> B => (@subset B (@IMAGE A B _790520 (@topspace A (@fst (Topology A) (Topology B) _790519))) (@topspace B (@snd (Topology A) (Topology B) _790519))) /\ (forall y : B, (@IN B y (@topspace B (@snd (Topology A) (Topology B) _790519))) -> @connected_in A (@fst (Topology A) (Topology B) _790519) (@GSPEC A (fun GEN_PVAR_1663 : A => exists x : A, @SETSPEC A GEN_PVAR_1663 ((@IN A x (@topspace A (@fst (Topology A) (Topology B) _790519))) /\ ((_790520 x) = y)) x)))).
Proof. exact (REFL (@monotone_map A B)). Qed.
Definition neighbourhood_base_at {A : Type'} : A -> ((A -> Prop) -> Prop) -> (Topology A) -> Prop := fun _795660 : A => fun _795661 : (A -> Prop) -> Prop => fun _795662 : Topology A => forall w : A -> Prop, ((@open_in A _795662 w) /\ (@IN A _795660 w)) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _795662 u) /\ ((_795661 v) /\ ((@IN A _795660 u) /\ ((@subset A u v) /\ (@subset A v w)))).
Lemma neighbourhood_base_at_def {A : Type'} : (@neighbourhood_base_at A) = (fun _795660 : A => fun _795661 : (A -> Prop) -> Prop => fun _795662 : Topology A => forall w : A -> Prop, ((@open_in A _795662 w) /\ (@IN A _795660 w)) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _795662 u) /\ ((_795661 v) /\ ((@IN A _795660 u) /\ ((@subset A u v) /\ (@subset A v w))))).
Proof. exact (REFL (@neighbourhood_base_at A)). Qed.
Definition neighbourhood_base_of {_426245 : Type'} : ((_426245 -> Prop) -> Prop) -> (Topology _426245) -> Prop := fun _795681 : (_426245 -> Prop) -> Prop => fun _795682 : Topology _426245 => forall x : _426245, (@IN _426245 x (@topspace _426245 _795682)) -> @neighbourhood_base_at _426245 x _795681 _795682.
Lemma neighbourhood_base_of_def {_426245 : Type'} : (@neighbourhood_base_of _426245) = (fun _795681 : (_426245 -> Prop) -> Prop => fun _795682 : Topology _426245 => forall x : _426245, (@IN _426245 x (@topspace _426245 _795682)) -> @neighbourhood_base_at _426245 x _795681 _795682).
Proof. exact (REFL (@neighbourhood_base_of _426245)). Qed.
Definition t0_space {A : Type'} : (Topology A) -> Prop := fun _796119 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _796119)) /\ ((@IN A y (@topspace A _796119)) /\ (~ (x = y)))) -> exists u : A -> Prop, (@open_in A _796119 u) /\ (~ ((@IN A x u) = (@IN A y u))).
Lemma t0_space_def {A : Type'} : (@t0_space A) = (fun _796119 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _796119)) /\ ((@IN A y (@topspace A _796119)) /\ (~ (x = y)))) -> exists u : A -> Prop, (@open_in A _796119 u) /\ (~ ((@IN A x u) = (@IN A y u)))).
Proof. exact (REFL (@t0_space A)). Qed.
Definition kolmogorov_quotient {A : Type'} : (Topology A) -> A -> A := fun _800030 : Topology A => fun x : A => @ε A (fun y : A => forall u : A -> Prop, (@open_in A _800030 u) -> (@IN A y u) = (@IN A x u)).
Lemma kolmogorov_quotient_def {A : Type'} : (@kolmogorov_quotient A) = (fun _800030 : Topology A => fun x : A => @ε A (fun y : A => forall u : A -> Prop, (@open_in A _800030 u) -> (@IN A y u) = (@IN A x u))).
Proof. exact (REFL (@kolmogorov_quotient A)). Qed.
Definition regular_space {A : Type'} : (Topology A) -> Prop := fun _801295 : Topology A => forall c : A -> Prop, forall a : A, ((@closed_in A _801295 c) /\ (@IN A a (@setD A (@topspace A _801295) c))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _801295 u) /\ ((@open_in A _801295 v) /\ ((@IN A a u) /\ ((@subset A c v) /\ (@DISJOINT A u v)))).
Lemma regular_space_def {A : Type'} : (@regular_space A) = (fun _801295 : Topology A => forall c : A -> Prop, forall a : A, ((@closed_in A _801295 c) /\ (@IN A a (@setD A (@topspace A _801295) c))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _801295 u) /\ ((@open_in A _801295 v) /\ ((@IN A a u) /\ ((@subset A c v) /\ (@DISJOINT A u v))))).
Proof. exact (REFL (@regular_space A)). Qed.
Definition locally_compact_space {_432524 : Type'} : (Topology _432524) -> Prop := fun _809439 : Topology _432524 => forall x : _432524, (@IN _432524 x (@topspace _432524 _809439)) -> exists u : _432524 -> Prop, exists k : _432524 -> Prop, (@open_in _432524 _809439 u) /\ ((@compact_in _432524 _809439 k) /\ ((@IN _432524 x u) /\ (@subset _432524 u k))).
Lemma locally_compact_space_def {_432524 : Type'} : (@locally_compact_space _432524) = (fun _809439 : Topology _432524 => forall x : _432524, (@IN _432524 x (@topspace _432524 _809439)) -> exists u : _432524 -> Prop, exists k : _432524 -> Prop, (@open_in _432524 _809439 u) /\ ((@compact_in _432524 _809439 k) /\ ((@IN _432524 x u) /\ (@subset _432524 u k)))).
Proof. exact (REFL (@locally_compact_space _432524)). Qed.
Definition real_open : (R -> Prop) -> Prop := fun _824698 : R -> Prop => forall x : R, (@IN R x _824698) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall x' : R, (ltr (normr (subr x' x)) e) -> @IN R x' _824698).
Lemma real_open_def : real_open = (fun _824698 : R -> Prop => forall x : R, (@IN R x _824698) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall x' : R, (ltr (normr (subr x' x)) e) -> @IN R x' _824698)).
Proof. exact (REFL real_open). Qed.
Definition real_closed : (R -> Prop) -> Prop := fun _824703 : R -> Prop => real_open (@setD R (@setT R) _824703).
Lemma real_closed_def : real_closed = (fun _824703 : R -> Prop => real_open (@setD R (@setT R) _824703)).
Proof. exact (REFL real_closed). Qed.
Definition euclideanreal : Topology R := @topology R real_open.
Lemma euclideanreal_def : euclideanreal = (@topology R real_open).
Proof. exact (REFL euclideanreal). Qed.
Definition real_euclidean_metric : Metric R := @metric R (@pair (R -> Prop) ((prod R R) -> R) (@setT R) (@GABS ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (normr (subr y x))))).
Lemma real_euclidean_metric_def : real_euclidean_metric = (@metric R (@pair (R -> Prop) ((prod R R) -> R) (@setT R) (@GABS ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (normr (subr y x)))))).
Proof. exact (REFL real_euclidean_metric). Qed.
Definition real_bounded : (R -> Prop) -> Prop := fun _825221 : R -> Prop => exists B : R, forall x : R, (@IN R x _825221) -> ler (normr x) B.
Lemma real_bounded_def : real_bounded = (fun _825221 : R -> Prop => exists B : R, forall x : R, (@IN R x _825221) -> ler (normr x) B).
Proof. exact (REFL real_bounded). Qed.
Definition real_compact : (R -> Prop) -> Prop := fun _826503 : R -> Prop => @compact_in R euclideanreal _826503.
Lemma real_compact_def : real_compact = (fun _826503 : R -> Prop => @compact_in R euclideanreal _826503).
Proof. exact (REFL real_compact). Qed.
Definition atpointof {_439174 : Type'} : (Topology _439174) -> _439174 -> net _439174 := fun _827391 : Topology _439174 => fun _827392 : _439174 => @mk_net _439174 (@pair ((_439174 -> Prop) -> Prop) (_439174 -> Prop) (@GSPEC (_439174 -> Prop) (fun GEN_PVAR_1781 : _439174 -> Prop => exists u : _439174 -> Prop, @SETSPEC (_439174 -> Prop) GEN_PVAR_1781 ((@open_in _439174 _827391 u) /\ (@IN _439174 _827392 u)) u)) (@INSERT _439174 _827392 (@set0 _439174))).
Lemma atpointof_def {_439174 : Type'} : (@atpointof _439174) = (fun _827391 : Topology _439174 => fun _827392 : _439174 => @mk_net _439174 (@pair ((_439174 -> Prop) -> Prop) (_439174 -> Prop) (@GSPEC (_439174 -> Prop) (fun GEN_PVAR_1781 : _439174 -> Prop => exists u : _439174 -> Prop, @SETSPEC (_439174 -> Prop) GEN_PVAR_1781 ((@open_in _439174 _827391 u) /\ (@IN _439174 _827392 u)) u)) (@INSERT _439174 _827392 (@set0 _439174)))).
Proof. exact (REFL (@atpointof _439174)). Qed.
Definition limit {A B : Type'} : (Topology B) -> (A -> B) -> B -> (net A) -> Prop := fun _827731 : Topology B => fun _827732 : A -> B => fun _827733 : B => fun _827734 : net A => (@IN B _827733 (@topspace B _827731)) /\ (forall u : B -> Prop, ((@open_in B _827731 u) /\ (@IN B _827733 u)) -> @eventually A (fun x : A => @IN B (_827732 x) u) _827734).
Lemma limit_def {A B : Type'} : (@limit A B) = (fun _827731 : Topology B => fun _827732 : A -> B => fun _827733 : B => fun _827734 : net A => (@IN B _827733 (@topspace B _827731)) /\ (forall u : B -> Prop, ((@open_in B _827731 u) /\ (@IN B _827733 u)) -> @eventually A (fun x : A => @IN B (_827732 x) u) _827734)).
Proof. exact (REFL (@limit A B)). Qed.
Definition cauchy_in {A : Type'} : (Metric A) -> (nat -> A) -> Prop := fun _831201 : Metric A => fun _831202 : nat -> A => (forall n : nat, @IN A (_831202 n) (@mspace A _831201)) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall n : nat, forall n' : nat, ((leqn N' n) /\ (leqn N' n')) -> ltr (@mdist A _831201 (@pair A A (_831202 n) (_831202 n'))) e).
Lemma cauchy_in_def {A : Type'} : (@cauchy_in A) = (fun _831201 : Metric A => fun _831202 : nat -> A => (forall n : nat, @IN A (_831202 n) (@mspace A _831201)) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall n : nat, forall n' : nat, ((leqn N' n) /\ (leqn N' n')) -> ltr (@mdist A _831201 (@pair A A (_831202 n) (_831202 n'))) e)).
Proof. exact (REFL (@cauchy_in A)). Qed.
Definition mcomplete {A : Type'} : (Metric A) -> Prop := fun _831213 : Metric A => forall s : nat -> A, (@cauchy_in A _831213 s) -> exists x : A, @limit nat A (@mtopology A _831213) s x sequentially.
Lemma mcomplete_def {A : Type'} : (@mcomplete A) = (fun _831213 : Metric A => forall s : nat -> A, (@cauchy_in A _831213 s) -> exists x : A, @limit nat A (@mtopology A _831213) s x sequentially).
Proof. exact (REFL (@mcomplete A)). Qed.
Definition totally_bounded_in {A : Type'} : (Metric A) -> (A -> Prop) -> Prop := fun _835687 : Metric A => fun _835688 : A -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists k : A -> Prop, (@finite_set A k) /\ ((@subset A k _835688) /\ (@subset A _835688 (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_1814 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_1814 (@IN A x k) (@mball A _835687 (@pair A R x e))))))).
Lemma totally_bounded_in_def {A : Type'} : (@totally_bounded_in A) = (fun _835687 : Metric A => fun _835688 : A -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists k : A -> Prop, (@finite_set A k) /\ ((@subset A k _835688) /\ (@subset A _835688 (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_1814 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_1814 (@IN A x k) (@mball A _835687 (@pair A R x e)))))))).
Proof. exact (REFL (@totally_bounded_in A)). Qed.
Definition topcontinuous_at {A B : Type'} : (Topology A) -> (Topology B) -> (A -> B) -> A -> Prop := fun _838892 : Topology A => fun _838893 : Topology B => fun _838894 : A -> B => fun _838895 : A => (@IN A _838895 (@topspace A _838892)) /\ ((forall x : A, (@IN A x (@topspace A _838892)) -> @IN B (_838894 x) (@topspace B _838893)) /\ (forall v : B -> Prop, ((@open_in B _838893 v) /\ (@IN B (_838894 _838895) v)) -> exists u : A -> Prop, (@open_in A _838892 u) /\ ((@IN A _838895 u) /\ (forall y : A, (@IN A y u) -> @IN B (_838894 y) v)))).
Lemma topcontinuous_at_def {A B : Type'} : (@topcontinuous_at A B) = (fun _838892 : Topology A => fun _838893 : Topology B => fun _838894 : A -> B => fun _838895 : A => (@IN A _838895 (@topspace A _838892)) /\ ((forall x : A, (@IN A x (@topspace A _838892)) -> @IN B (_838894 x) (@topspace B _838893)) /\ (forall v : B -> Prop, ((@open_in B _838893 v) /\ (@IN B (_838894 _838895) v)) -> exists u : A -> Prop, (@open_in A _838892 u) /\ ((@IN A _838895 u) /\ (forall y : A, (@IN A y u) -> @IN B (_838894 y) v))))).
Proof. exact (REFL (@topcontinuous_at A B)). Qed.
Definition path_in {A : Type'} : (Topology A) -> (R -> A) -> Prop := fun _840037 : Topology A => fun _840038 : R -> A => @continuous_map R A (@pair (Topology R) (Topology A) (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) _840037) _840038.
Lemma path_in_def {A : Type'} : (@path_in A) = (fun _840037 : Topology A => fun _840038 : R -> A => @continuous_map R A (@pair (Topology R) (Topology A) (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) _840037) _840038).
Proof. exact (REFL (@path_in A)). Qed.
Definition path_connected_space {A : Type'} : (Topology A) -> Prop := fun _840465 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _840465)) /\ (@IN A y (@topspace A _840465))) -> exists g : R -> A, (@path_in A _840465 g) /\ (((g (R_of_nat (NUMERAL O))) = x) /\ ((g (R_of_nat (NUMERAL (BIT1 O)))) = y)).
Lemma path_connected_space_def {A : Type'} : (@path_connected_space A) = (fun _840465 : Topology A => forall x : A, forall y : A, ((@IN A x (@topspace A _840465)) /\ (@IN A y (@topspace A _840465))) -> exists g : R -> A, (@path_in A _840465 g) /\ (((g (R_of_nat (NUMERAL O))) = x) /\ ((g (R_of_nat (NUMERAL (BIT1 O)))) = y))).
Proof. exact (REFL (@path_connected_space A)). Qed.
Definition path_connected_in {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _840470 : Topology A => fun _840471 : A -> Prop => (@subset A _840471 (@topspace A _840470)) /\ (@path_connected_space A (@subtopology A _840470 _840471)).
Lemma path_connected_in_def {A : Type'} : (@path_connected_in A) = (fun _840470 : Topology A => fun _840471 : A -> Prop => (@subset A _840471 (@topspace A _840470)) /\ (@path_connected_space A (@subtopology A _840470 _840471))).
Proof. exact (REFL (@path_connected_in A)). Qed.
Definition path_component_of {_458674 : Type'} : (Topology _458674) -> _458674 -> _458674 -> Prop := fun _842383 : Topology _458674 => fun _842384 : _458674 => fun _842385 : _458674 => exists g : R -> _458674, (@path_in _458674 _842383 g) /\ (((g (R_of_nat (NUMERAL O))) = _842384) /\ ((g (R_of_nat (NUMERAL (BIT1 O)))) = _842385)).
Lemma path_component_of_def {_458674 : Type'} : (@path_component_of _458674) = (fun _842383 : Topology _458674 => fun _842384 : _458674 => fun _842385 : _458674 => exists g : R -> _458674, (@path_in _458674 _842383 g) /\ (((g (R_of_nat (NUMERAL O))) = _842384) /\ ((g (R_of_nat (NUMERAL (BIT1 O)))) = _842385))).
Proof. exact (REFL (@path_component_of _458674)). Qed.
Definition path_components_of {_458701 : Type'} : (Topology _458701) -> (_458701 -> Prop) -> Prop := fun _842404 : Topology _458701 => @GSPEC (_458701 -> Prop) (fun GEN_PVAR_1874 : _458701 -> Prop => exists x : _458701, @SETSPEC (_458701 -> Prop) GEN_PVAR_1874 (@IN _458701 x (@topspace _458701 _842404)) (@path_component_of _458701 _842404 x)).
Lemma path_components_of_def {_458701 : Type'} : (@path_components_of _458701) = (fun _842404 : Topology _458701 => @GSPEC (_458701 -> Prop) (fun GEN_PVAR_1874 : _458701 -> Prop => exists x : _458701, @SETSPEC (_458701 -> Prop) GEN_PVAR_1874 (@IN _458701 x (@topspace _458701 _842404)) (@path_component_of _458701 _842404 x))).
Proof. exact (REFL (@path_components_of _458701)). Qed.
Definition normal_space {A : Type'} : (Topology A) -> Prop := fun _854289 : Topology A => forall s : A -> Prop, forall t : A -> Prop, ((@closed_in A _854289 s) /\ ((@closed_in A _854289 t) /\ (@DISJOINT A s t))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _854289 u) /\ ((@open_in A _854289 v) /\ ((@subset A s u) /\ ((@subset A t v) /\ (@DISJOINT A u v)))).
Lemma normal_space_def {A : Type'} : (@normal_space A) = (fun _854289 : Topology A => forall s : A -> Prop, forall t : A -> Prop, ((@closed_in A _854289 s) /\ ((@closed_in A _854289 t) /\ (@DISJOINT A s t))) -> exists u : A -> Prop, exists v : A -> Prop, (@open_in A _854289 u) /\ ((@open_in A _854289 v) /\ ((@subset A s u) /\ ((@subset A t v) /\ (@DISJOINT A u v))))).
Proof. exact (REFL (@normal_space A)). Qed.
Definition completely_regular_space {A : Type'} : (Topology A) -> Prop := fun _870171 : Topology A => forall s : A -> Prop, forall x : A, ((@closed_in A _870171 s) /\ (@IN A x (@setD A (@topspace A _870171) s))) -> exists f : A -> R, (@continuous_map A R (@pair (Topology A) (Topology R) _870171 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R)))))) f) /\ (((f x) = (R_of_nat (NUMERAL O))) /\ (forall x' : A, (@IN A x' s) -> (f x') = (R_of_nat (NUMERAL (BIT1 O))))).
Lemma completely_regular_space_def {A : Type'} : (@completely_regular_space A) = (fun _870171 : Topology A => forall s : A -> Prop, forall x : A, ((@closed_in A _870171 s) /\ (@IN A x (@setD A (@topspace A _870171) s))) -> exists f : A -> R, (@continuous_map A R (@pair (Topology A) (Topology R) _870171 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R)))))) f) /\ (((f x) = (R_of_nat (NUMERAL O))) /\ (forall x' : A, (@IN A x' s) -> (f x') = (R_of_nat (NUMERAL (BIT1 O)))))).
Proof. exact (REFL (@completely_regular_space A)). Qed.
Definition weakly_locally_path_connected_at {_472077 : Type'} : _472077 -> (Topology _472077) -> Prop := fun _873814 : _472077 => fun _873815 : Topology _472077 => @neighbourhood_base_at _472077 _873814 (@path_connected_in _472077 _873815) _873815.
Lemma weakly_locally_path_connected_at_def {_472077 : Type'} : (@weakly_locally_path_connected_at _472077) = (fun _873814 : _472077 => fun _873815 : Topology _472077 => @neighbourhood_base_at _472077 _873814 (@path_connected_in _472077 _873815) _873815).
Proof. exact (REFL (@weakly_locally_path_connected_at _472077)). Qed.
Definition locally_path_connected_at {_472085 : Type'} : _472085 -> (Topology _472085) -> Prop := fun _873826 : _472085 => fun _873827 : Topology _472085 => @neighbourhood_base_at _472085 _873826 (fun u : _472085 -> Prop => (@open_in _472085 _873827 u) /\ (@path_connected_in _472085 _873827 u)) _873827.
Lemma locally_path_connected_at_def {_472085 : Type'} : (@locally_path_connected_at _472085) = (fun _873826 : _472085 => fun _873827 : Topology _472085 => @neighbourhood_base_at _472085 _873826 (fun u : _472085 -> Prop => (@open_in _472085 _873827 u) /\ (@path_connected_in _472085 _873827 u)) _873827).
Proof. exact (REFL (@locally_path_connected_at _472085)). Qed.
Definition locally_path_connected_space {_472105 : Type'} : (Topology _472105) -> Prop := fun _873838 : Topology _472105 => @neighbourhood_base_of _472105 (@path_connected_in _472105 _873838) _873838.
Lemma locally_path_connected_space_def {_472105 : Type'} : (@locally_path_connected_space _472105) = (fun _873838 : Topology _472105 => @neighbourhood_base_of _472105 (@path_connected_in _472105 _873838) _873838).
Proof. exact (REFL (@locally_path_connected_space _472105)). Qed.
Definition weakly_locally_connected_at {_473830 : Type'} : _473830 -> (Topology _473830) -> Prop := fun _875283 : _473830 => fun _875284 : Topology _473830 => @neighbourhood_base_at _473830 _875283 (@connected_in _473830 _875284) _875284.
Lemma weakly_locally_connected_at_def {_473830 : Type'} : (@weakly_locally_connected_at _473830) = (fun _875283 : _473830 => fun _875284 : Topology _473830 => @neighbourhood_base_at _473830 _875283 (@connected_in _473830 _875284) _875284).
Proof. exact (REFL (@weakly_locally_connected_at _473830)). Qed.
Definition locally_connected_at {_473838 : Type'} : _473838 -> (Topology _473838) -> Prop := fun _875295 : _473838 => fun _875296 : Topology _473838 => @neighbourhood_base_at _473838 _875295 (fun u : _473838 -> Prop => (@open_in _473838 _875296 u) /\ (@connected_in _473838 _875296 u)) _875296.
Lemma locally_connected_at_def {_473838 : Type'} : (@locally_connected_at _473838) = (fun _875295 : _473838 => fun _875296 : Topology _473838 => @neighbourhood_base_at _473838 _875295 (fun u : _473838 -> Prop => (@open_in _473838 _875296 u) /\ (@connected_in _473838 _875296 u)) _875296).
Proof. exact (REFL (@locally_connected_at _473838)). Qed.
Definition locally_connected_space {_473858 : Type'} : (Topology _473858) -> Prop := fun _875307 : Topology _473858 => @neighbourhood_base_of _473858 (@connected_in _473858 _875307) _875307.
Lemma locally_connected_space_def {_473858 : Type'} : (@locally_connected_space _473858) = (fun _875307 : Topology _473858 => @neighbourhood_base_of _473858 (@connected_in _473858 _875307) _875307).
Proof. exact (REFL (@locally_connected_space _473858)). Qed.
Definition quasi_component_of {_475551 : Type'} : (Topology _475551) -> _475551 -> _475551 -> Prop := fun _876695 : Topology _475551 => fun _876696 : _475551 => fun _876697 : _475551 => (@IN _475551 _876696 (@topspace _475551 _876695)) /\ ((@IN _475551 _876697 (@topspace _475551 _876695)) /\ (forall t : _475551 -> Prop, ((@closed_in _475551 _876695 t) /\ (@open_in _475551 _876695 t)) -> (@IN _475551 _876696 t) = (@IN _475551 _876697 t))).
Lemma quasi_component_of_def {_475551 : Type'} : (@quasi_component_of _475551) = (fun _876695 : Topology _475551 => fun _876696 : _475551 => fun _876697 : _475551 => (@IN _475551 _876696 (@topspace _475551 _876695)) /\ ((@IN _475551 _876697 (@topspace _475551 _876695)) /\ (forall t : _475551 -> Prop, ((@closed_in _475551 _876695 t) /\ (@open_in _475551 _876695 t)) -> (@IN _475551 _876696 t) = (@IN _475551 _876697 t)))).
Proof. exact (REFL (@quasi_component_of _475551)). Qed.
Definition quasi_components_of {_475574 : Type'} : (Topology _475574) -> (_475574 -> Prop) -> Prop := fun _876716 : Topology _475574 => @GSPEC (_475574 -> Prop) (fun GEN_PVAR_1974 : _475574 -> Prop => exists x : _475574, @SETSPEC (_475574 -> Prop) GEN_PVAR_1974 (@IN _475574 x (@topspace _475574 _876716)) (@quasi_component_of _475574 _876716 x)).
Lemma quasi_components_of_def {_475574 : Type'} : (@quasi_components_of _475574) = (fun _876716 : Topology _475574 => @GSPEC (_475574 -> Prop) (fun GEN_PVAR_1974 : _475574 -> Prop => exists x : _475574, @SETSPEC (_475574 -> Prop) GEN_PVAR_1974 (@IN _475574 x (@topspace _475574 _876716)) (@quasi_component_of _475574 _876716 x))).
Proof. exact (REFL (@quasi_components_of _475574)). Qed.
Definition k_space {A : Type'} : (Topology A) -> Prop := fun _880865 : Topology A => forall s : A -> Prop, (@subset A s (@topspace A _880865)) -> (@closed_in A _880865 s) = (forall k : A -> Prop, (@compact_in A _880865 k) -> @closed_in A (@subtopology A _880865 k) (@setI A k s)).
Lemma k_space_def {A : Type'} : (@k_space A) = (fun _880865 : Topology A => forall s : A -> Prop, (@subset A s (@topspace A _880865)) -> (@closed_in A _880865 s) = (forall k : A -> Prop, (@compact_in A _880865 k) -> @closed_in A (@subtopology A _880865 k) (@setI A k s))).
Proof. exact (REFL (@k_space A)). Qed.
Definition kification {A : Type'} : (Topology A) -> Topology A := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (Topology A) -> Topology A) (fun kification' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (Topology A) -> Topology A => forall _884186 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), forall top : Topology A, (kification' _884186 top) = (@topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_2014 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_2014 ((@subset A s (@topspace A top)) /\ (forall k : A -> Prop, (@compact_in A top k) -> @open_in A (@subtopology A top k) (@setI A k s))) s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))).
Lemma kification_def {A : Type'} : (@kification A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (Topology A) -> Topology A) (fun kification' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (Topology A) -> Topology A => forall _884186 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), forall top : Topology A, (kification' _884186 top) = (@topology A (@GSPEC (A -> Prop) (fun GEN_PVAR_2014 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_2014 ((@subset A s (@topspace A top)) /\ (forall k : A -> Prop, (@compact_in A top k) -> @open_in A (@subtopology A top k) (@setI A k s))) s)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Proof. exact (REFL (@kification A)). Qed.
Definition alexandroff_compactification {A : Type'} : (Topology A) -> Topology (Datatypes.sum A unit) := fun _885671 : Topology A => @topology (Datatypes.sum A unit) (@setU ((Datatypes.sum A unit) -> Prop) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2016 : (Datatypes.sum A unit) -> Prop => exists u : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2016 (@open_in A _885671 u) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) u))) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2017 : (Datatypes.sum A unit) -> Prop => exists c : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2017 ((@compact_in A _885671 c) /\ (@closed_in A _885671 c)) (@INSERT (Datatypes.sum A unit) (@inr A unit tt) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) (@setD A (@topspace A _885671) c)))))).
Lemma alexandroff_compactification_def {A : Type'} : (@alexandroff_compactification A) = (fun _885671 : Topology A => @topology (Datatypes.sum A unit) (@setU ((Datatypes.sum A unit) -> Prop) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2016 : (Datatypes.sum A unit) -> Prop => exists u : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2016 (@open_in A _885671 u) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) u))) (@GSPEC ((Datatypes.sum A unit) -> Prop) (fun GEN_PVAR_2017 : (Datatypes.sum A unit) -> Prop => exists c : A -> Prop, @SETSPEC ((Datatypes.sum A unit) -> Prop) GEN_PVAR_2017 ((@compact_in A _885671 c) /\ (@closed_in A _885671 c)) (@INSERT (Datatypes.sum A unit) (@inr A unit tt) (@IMAGE A (Datatypes.sum A unit) (@inl A unit) (@setD A (@topspace A _885671) c))))))).
Proof. exact (REFL (@alexandroff_compactification A)). Qed.
Definition homotopic_with {_487090 _487093 : Type'} : ((_487093 -> _487090) -> Prop) -> (prod (Topology _487093) (Topology _487090)) -> (_487093 -> _487090) -> (_487093 -> _487090) -> Prop := fun _895137 : (_487093 -> _487090) -> Prop => fun _895138 : prod (Topology _487093) (Topology _487090) => fun _895139 : _487093 -> _487090 => fun _895140 : _487093 -> _487090 => exists h : (prod R _487093) -> _487090, (@continuous_map (prod R _487093) _487090 (@pair (Topology (prod R _487093)) (Topology _487090) (@prod_topology R _487093 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) (@fst (Topology _487093) (Topology _487090) _895138)) (@snd (Topology _487093) (Topology _487090) _895138)) h) /\ ((forall x : _487093, (h (@pair R _487093 (R_of_nat (NUMERAL O)) x)) = (_895139 x)) /\ ((forall x : _487093, (h (@pair R _487093 (R_of_nat (NUMERAL (BIT1 O))) x)) = (_895140 x)) /\ (forall t : R, (@IN R t (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) -> _895137 (fun x : _487093 => h (@pair R _487093 t x))))).
Lemma homotopic_with_def {_487090 _487093 : Type'} : (@homotopic_with _487090 _487093) = (fun _895137 : (_487093 -> _487090) -> Prop => fun _895138 : prod (Topology _487093) (Topology _487090) => fun _895139 : _487093 -> _487090 => fun _895140 : _487093 -> _487090 => exists h : (prod R _487093) -> _487090, (@continuous_map (prod R _487093) _487090 (@pair (Topology (prod R _487093)) (Topology _487090) (@prod_topology R _487093 (@subtopology R euclideanreal (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) (@fst (Topology _487093) (Topology _487090) _895138)) (@snd (Topology _487093) (Topology _487090) _895138)) h) /\ ((forall x : _487093, (h (@pair R _487093 (R_of_nat (NUMERAL O)) x)) = (_895139 x)) /\ ((forall x : _487093, (h (@pair R _487093 (R_of_nat (NUMERAL (BIT1 O))) x)) = (_895140 x)) /\ (forall t : R, (@IN R t (closed_real_interval (@cons (prod R R) (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))) (@nil (prod R R))))) -> _895137 (fun x : _487093 => h (@pair R _487093 t x)))))).
Proof. exact (REFL (@homotopic_with _487090 _487093)). Qed.
Definition homotopy_equivalent_space {A B : Type'} : (Topology A) -> (Topology B) -> Prop := fun _896006 : Topology A => fun _896007 : Topology B => exists f : A -> B, exists g : B -> A, (@continuous_map A B (@pair (Topology A) (Topology B) _896006 _896007) f) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) _896007 _896006) g) /\ ((@homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _896006 _896006) (@o A B A g f) (@I A)) /\ (@homotopic_with B B (fun x : B -> B => True) (@pair (Topology B) (Topology B) _896007 _896007) (@o B A B f g) (@I B)))).
Lemma homotopy_equivalent_space_def {A B : Type'} : (@homotopy_equivalent_space A B) = (fun _896006 : Topology A => fun _896007 : Topology B => exists f : A -> B, exists g : B -> A, (@continuous_map A B (@pair (Topology A) (Topology B) _896006 _896007) f) /\ ((@continuous_map B A (@pair (Topology B) (Topology A) _896007 _896006) g) /\ ((@homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _896006 _896006) (@o A B A g f) (@I A)) /\ (@homotopic_with B B (fun x : B -> B => True) (@pair (Topology B) (Topology B) _896007 _896007) (@o B A B f g) (@I B))))).
Proof. exact (REFL (@homotopy_equivalent_space A B)). Qed.
Definition contractible_space {A : Type'} : (Topology A) -> Prop := fun _896754 : Topology A => exists a : A, @homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _896754 _896754) (fun x : A => x) (fun x : A => a).
Lemma contractible_space_def {A : Type'} : (@contractible_space A) = (fun _896754 : Topology A => exists a : A, @homotopic_with A A (fun x : A -> A => True) (@pair (Topology A) (Topology A) _896754 _896754) (fun x : A => x) (fun x : A => a)).
Proof. exact (REFL (@contractible_space A)). Qed.
Definition completely_metrizable_space {_490593 : Type'} : (Topology _490593) -> Prop := fun _897966 : Topology _490593 => exists m : Metric _490593, (@mcomplete _490593 m) /\ (_897966 = (@mtopology _490593 m)).
Lemma completely_metrizable_space_def {_490593 : Type'} : (@completely_metrizable_space _490593) = (fun _897966 : Topology _490593 => exists m : Metric _490593, (@mcomplete _490593 m) /\ (_897966 = (@mtopology _490593 m))).
Proof. exact (REFL (@completely_metrizable_space _490593)). Qed.
Definition prod_metric {A B : Type'} : (Metric A) -> (Metric B) -> Metric (prod A B) := fun _901700 : Metric A => fun _901701 : Metric B => @metric (prod A B) (@pair ((prod A B) -> Prop) ((prod (prod A B) (prod A B)) -> R) (@CROSS A B (@mspace A _901700) (@mspace B _901701)) (@GABS ((prod (prod A B) (prod A B)) -> R) (fun f : (prod (prod A B) (prod A B)) -> R => forall x : A, forall y : B, forall x' : A, forall y' : B, @eq R (f (@pair (prod A B) (prod A B) (@pair A B x y) (@pair A B x' y'))) (hol_sqrt (addr (expr (@mdist A _901700 (@pair A A x x')) (NUMERAL (BIT0 (BIT1 O)))) (expr (@mdist B _901701 (@pair B B y y')) (NUMERAL (BIT0 (BIT1 O))))))))).
Lemma prod_metric_def {A B : Type'} : (@prod_metric A B) = (fun _901700 : Metric A => fun _901701 : Metric B => @metric (prod A B) (@pair ((prod A B) -> Prop) ((prod (prod A B) (prod A B)) -> R) (@CROSS A B (@mspace A _901700) (@mspace B _901701)) (@GABS ((prod (prod A B) (prod A B)) -> R) (fun f : (prod (prod A B) (prod A B)) -> R => forall x : A, forall y : B, forall x' : A, forall y' : B, @eq R (f (@pair (prod A B) (prod A B) (@pair A B x y) (@pair A B x' y'))) (hol_sqrt (addr (expr (@mdist A _901700 (@pair A A x x')) (NUMERAL (BIT0 (BIT1 O)))) (expr (@mdist B _901701 (@pair B B y y')) (NUMERAL (BIT0 (BIT1 O)))))))))).
Proof. exact (REFL (@prod_metric A B)). Qed.
Definition lipschitz_continuous_map {_493077 _493089 : Type'} : (prod (Metric _493089) (Metric _493077)) -> (_493089 -> _493077) -> Prop := fun _905457 : prod (Metric _493089) (Metric _493077) => fun _905458 : _493089 -> _493077 => (@subset _493077 (@IMAGE _493089 _493077 _905458 (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457))) (@mspace _493077 (@snd (Metric _493089) (Metric _493077) _905457))) /\ (exists B : R, forall x : _493089, forall y : _493089, ((@IN _493089 x (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457))) /\ (@IN _493089 y (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457)))) -> ler (@mdist _493077 (@snd (Metric _493089) (Metric _493077) _905457) (@pair _493077 _493077 (_905458 x) (_905458 y))) (mulr B (@mdist _493089 (@fst (Metric _493089) (Metric _493077) _905457) (@pair _493089 _493089 x y)))).
Lemma lipschitz_continuous_map_def {_493077 _493089 : Type'} : (@lipschitz_continuous_map _493077 _493089) = (fun _905457 : prod (Metric _493089) (Metric _493077) => fun _905458 : _493089 -> _493077 => (@subset _493077 (@IMAGE _493089 _493077 _905458 (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457))) (@mspace _493077 (@snd (Metric _493089) (Metric _493077) _905457))) /\ (exists B : R, forall x : _493089, forall y : _493089, ((@IN _493089 x (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457))) /\ (@IN _493089 y (@mspace _493089 (@fst (Metric _493089) (Metric _493077) _905457)))) -> ler (@mdist _493077 (@snd (Metric _493089) (Metric _493077) _905457) (@pair _493077 _493077 (_905458 x) (_905458 y))) (mulr B (@mdist _493089 (@fst (Metric _493089) (Metric _493077) _905457) (@pair _493089 _493089 x y))))).
Proof. exact (REFL (@lipschitz_continuous_map _493077 _493089)). Qed.
Definition uniformly_continuous_map {_493639 _493644 : Type'} : (prod (Metric _493644) (Metric _493639)) -> (_493644 -> _493639) -> Prop := fun _905985 : prod (Metric _493644) (Metric _493639) => fun _905986 : _493644 -> _493639 => (@subset _493639 (@IMAGE _493644 _493639 _905986 (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) (@mspace _493639 (@snd (Metric _493644) (Metric _493639) _905985))) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : _493644, forall x' : _493644, ((@IN _493644 x (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) /\ ((@IN _493644 x' (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) /\ (ltr (@mdist _493644 (@fst (Metric _493644) (Metric _493639) _905985) (@pair _493644 _493644 x' x)) d))) -> ltr (@mdist _493639 (@snd (Metric _493644) (Metric _493639) _905985) (@pair _493639 _493639 (_905986 x') (_905986 x))) e)).
Lemma uniformly_continuous_map_def {_493639 _493644 : Type'} : (@uniformly_continuous_map _493639 _493644) = (fun _905985 : prod (Metric _493644) (Metric _493639) => fun _905986 : _493644 -> _493639 => (@subset _493639 (@IMAGE _493644 _493639 _905986 (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) (@mspace _493639 (@snd (Metric _493644) (Metric _493639) _905985))) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : _493644, forall x' : _493644, ((@IN _493644 x (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) /\ ((@IN _493644 x' (@mspace _493644 (@fst (Metric _493644) (Metric _493639) _905985))) /\ (ltr (@mdist _493644 (@fst (Metric _493644) (Metric _493639) _905985) (@pair _493644 _493644 x' x)) d))) -> ltr (@mdist _493639 (@snd (Metric _493644) (Metric _493639) _905985) (@pair _493639 _493639 (_905986 x') (_905986 x))) e))).
Proof. exact (REFL (@uniformly_continuous_map _493639 _493644)). Qed.
Definition cauchy_continuous_map {_494392 _494400 : Type'} : (prod (Metric _494392) (Metric _494400)) -> (_494392 -> _494400) -> Prop := fun _906680 : prod (Metric _494392) (Metric _494400) => fun _906681 : _494392 -> _494400 => forall x : nat -> _494392, (@cauchy_in _494392 (@fst (Metric _494392) (Metric _494400) _906680) x) -> @cauchy_in _494400 (@snd (Metric _494392) (Metric _494400) _906680) (@o nat _494392 _494400 _906681 x).
Lemma cauchy_continuous_map_def {_494392 _494400 : Type'} : (@cauchy_continuous_map _494392 _494400) = (fun _906680 : prod (Metric _494392) (Metric _494400) => fun _906681 : _494392 -> _494400 => forall x : nat -> _494392, (@cauchy_in _494392 (@fst (Metric _494392) (Metric _494400) _906680) x) -> @cauchy_in _494400 (@snd (Metric _494392) (Metric _494400) _906680) (@o nat _494392 _494400 _906681 x)).
Proof. exact (REFL (@cauchy_continuous_map _494392 _494400)). Qed.
Definition capped_metric {A : Type'} : R -> (Metric A) -> Metric A := fun _913164 : R => fun _913165 : Metric A => @COND (Metric A) (ler _913164 (R_of_nat (NUMERAL O))) _913165 (@metric A (@pair (A -> Prop) ((prod A A) -> R) (@mspace A _913165) (@GABS ((prod A A) -> R) (fun f : (prod A A) -> R => forall x : A, forall y : A, @eq R (f (@pair A A x y)) (minr _913164 (@mdist A _913165 (@pair A A x y))))))).
Lemma capped_metric_def {A : Type'} : (@capped_metric A) = (fun _913164 : R => fun _913165 : Metric A => @COND (Metric A) (ler _913164 (R_of_nat (NUMERAL O))) _913165 (@metric A (@pair (A -> Prop) ((prod A A) -> R) (@mspace A _913165) (@GABS ((prod A A) -> R) (fun f : (prod A A) -> R => forall x : A, forall y : A, @eq R (f (@pair A A x y)) (minr _913164 (@mdist A _913165 (@pair A A x y)))))))).
Proof. exact (REFL (@capped_metric A)). Qed.
Definition euclidean_space : nat -> Topology (nat -> R) := fun _934832 : nat => @subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (@GSPEC (nat -> R) (fun GEN_PVAR_2056 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2056 (forall i : nat, (~ (@IN nat i (dotdot (NUMERAL (BIT1 O)) _934832))) -> (x i) = (R_of_nat (NUMERAL O))) x)).
Lemma euclidean_space_def : euclidean_space = (fun _934832 : nat => @subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (@GSPEC (nat -> R) (fun GEN_PVAR_2056 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2056 (forall i : nat, (~ (@IN nat i (dotdot (NUMERAL (BIT1 O)) _934832))) -> (x i) = (R_of_nat (NUMERAL O))) x))).
Proof. exact (REFL euclidean_space). Qed.
Definition nsphere : nat -> Topology (nat -> R) := fun _935051 : nat => @subtopology (nat -> R) (euclidean_space (addn _935051 (NUMERAL (BIT1 O)))) (@GSPEC (nat -> R) (fun GEN_PVAR_2062 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2062 ((@sum nat (dotdot (NUMERAL (BIT1 O)) (addn _935051 (NUMERAL (BIT1 O)))) (fun i : nat => expr (x i) (NUMERAL (BIT0 (BIT1 O))))) = (R_of_nat (NUMERAL (BIT1 O)))) x)).
Lemma nsphere_def : nsphere = (fun _935051 : nat => @subtopology (nat -> R) (euclidean_space (addn _935051 (NUMERAL (BIT1 O)))) (@GSPEC (nat -> R) (fun GEN_PVAR_2062 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2062 ((@sum nat (dotdot (NUMERAL (BIT1 O)) (addn _935051 (NUMERAL (BIT1 O)))) (fun i : nat => expr (x i) (NUMERAL (BIT0 (BIT1 O))))) = (R_of_nat (NUMERAL (BIT1 O)))) x))).
Proof. exact (REFL nsphere). Qed.
Definition funspace {A B : Type'} : (A -> Prop) -> (Metric B) -> Metric (A -> B) := fun _937328 : A -> Prop => fun _937329 : Metric B => @metric (A -> B) (@pair ((A -> B) -> Prop) ((prod (A -> B) (A -> B)) -> R) (@GSPEC (A -> B) (fun GEN_PVAR_2068 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2068 ((forall x : A, (@IN A x _937328) -> @IN B (f x) (@mspace B _937329)) /\ ((@IN (A -> B) f (@EXTENSIONAL A B _937328)) /\ (@mbounded B _937329 (@IMAGE A B f _937328)))) f)) (@GABS ((prod (A -> B) (A -> B)) -> R) (fun f : (prod (A -> B) (A -> B)) -> R => forall f' : A -> B, forall g : A -> B, @eq R (f (@pair (A -> B) (A -> B) f' g)) (@COND R (_937328 = (@set0 A)) (R_of_nat (NUMERAL O)) (sup (@GSPEC R (fun GEN_PVAR_2069 : R => exists x : A, @SETSPEC R GEN_PVAR_2069 (@IN A x _937328) (@mdist B _937329 (@pair B B (f' x) (g x)))))))))).
Lemma funspace_def {A B : Type'} : (@funspace A B) = (fun _937328 : A -> Prop => fun _937329 : Metric B => @metric (A -> B) (@pair ((A -> B) -> Prop) ((prod (A -> B) (A -> B)) -> R) (@GSPEC (A -> B) (fun GEN_PVAR_2068 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2068 ((forall x : A, (@IN A x _937328) -> @IN B (f x) (@mspace B _937329)) /\ ((@IN (A -> B) f (@EXTENSIONAL A B _937328)) /\ (@mbounded B _937329 (@IMAGE A B f _937328)))) f)) (@GABS ((prod (A -> B) (A -> B)) -> R) (fun f : (prod (A -> B) (A -> B)) -> R => forall f' : A -> B, forall g : A -> B, @eq R (f (@pair (A -> B) (A -> B) f' g)) (@COND R (_937328 = (@set0 A)) (R_of_nat (NUMERAL O)) (sup (@GSPEC R (fun GEN_PVAR_2069 : R => exists x : A, @SETSPEC R GEN_PVAR_2069 (@IN A x _937328) (@mdist B _937329 (@pair B B (f' x) (g x))))))))))).
Proof. exact (REFL (@funspace A B)). Qed.
Definition cfunspace {A B : Type'} : (Topology A) -> (Metric B) -> Metric (A -> B) := fun _939097 : Topology A => fun _939098 : Metric B => @submetric (A -> B) (@funspace A B (@topspace A _939097) _939098) (@GSPEC (A -> B) (fun GEN_PVAR_2081 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2081 (@continuous_map A B (@pair (Topology A) (Topology B) _939097 (@mtopology B _939098)) f) f)).
Lemma cfunspace_def {A B : Type'} : (@cfunspace A B) = (fun _939097 : Topology A => fun _939098 : Metric B => @submetric (A -> B) (@funspace A B (@topspace A _939097) _939098) (@GSPEC (A -> B) (fun GEN_PVAR_2081 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_2081 (@continuous_map A B (@pair (Topology A) (Topology B) _939097 (@mtopology B _939098)) f) f))).
Proof. exact (REFL (@cfunspace A B)). Qed.
Definition dimension_le {A : Type'} : (Topology A) -> int -> Prop := fun a0 : Topology A => fun a1 : int => forall dimension_le' : (Topology A) -> int -> Prop, (forall a0' : Topology A, forall a1' : int, ((lez (oppz (int_of_nat (NUMERAL (BIT1 O)))) a1') /\ (forall v : A -> Prop, forall a : A, ((@open_in A a0' v) /\ (@IN A a v)) -> exists u : A -> Prop, (@IN A a u) /\ ((@subset A u v) /\ ((@open_in A a0' u) /\ (dimension_le' (@subtopology A a0' (@frontier_of A a0' u)) (subz a1' (int_of_nat (NUMERAL (BIT1 O))))))))) -> dimension_le' a0' a1') -> dimension_le' a0 a1.
Lemma dimension_le_def {A : Type'} : (@dimension_le A) = (fun a0 : Topology A => fun a1 : int => forall dimension_le' : (Topology A) -> int -> Prop, (forall a0' : Topology A, forall a1' : int, ((lez (oppz (int_of_nat (NUMERAL (BIT1 O)))) a1') /\ (forall v : A -> Prop, forall a : A, ((@open_in A a0' v) /\ (@IN A a v)) -> exists u : A -> Prop, (@IN A a u) /\ ((@subset A u v) /\ ((@open_in A a0' u) /\ (dimension_le' (@subtopology A a0' (@frontier_of A a0' u)) (subz a1' (int_of_nat (NUMERAL (BIT1 O))))))))) -> dimension_le' a0' a1') -> dimension_le' a0 a1).
Proof. exact (REFL (@dimension_le A)). Qed.
Definition standard_simplex : nat -> (nat -> R) -> Prop := fun _986116 : nat => @GSPEC (nat -> R) (fun GEN_PVAR_2117 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2117 ((forall i : nat, (ler (R_of_nat (NUMERAL O)) (x i)) /\ (ler (x i) (R_of_nat (NUMERAL (BIT1 O))))) /\ ((forall i : nat, (ltn _986116 i) -> (x i) = (R_of_nat (NUMERAL O))) /\ ((@sum nat (dotdot (NUMERAL O) _986116) x) = (R_of_nat (NUMERAL (BIT1 O)))))) x).
Lemma standard_simplex_def : standard_simplex = (fun _986116 : nat => @GSPEC (nat -> R) (fun GEN_PVAR_2117 : nat -> R => exists x : nat -> R, @SETSPEC (nat -> R) GEN_PVAR_2117 ((forall i : nat, (ler (R_of_nat (NUMERAL O)) (x i)) /\ (ler (x i) (R_of_nat (NUMERAL (BIT1 O))))) /\ ((forall i : nat, (ltn _986116 i) -> (x i) = (R_of_nat (NUMERAL O))) /\ ((@sum nat (dotdot (NUMERAL O) _986116) x) = (R_of_nat (NUMERAL (BIT1 O)))))) x)).
Proof. exact (REFL standard_simplex). Qed.
Definition simplicial_face : nat -> (nat -> R) -> nat -> R := fun _986843 : nat => fun _986844 : nat -> R => fun i : nat => @COND R (ltn i _986843) (_986844 i) (@COND R (i = _986843) (R_of_nat (NUMERAL O)) (_986844 (subn i (NUMERAL (BIT1 O))))).
Lemma simplicial_face_def : simplicial_face = (fun _986843 : nat => fun _986844 : nat -> R => fun i : nat => @COND R (ltn i _986843) (_986844 i) (@COND R (i = _986843) (R_of_nat (NUMERAL O)) (_986844 (subn i (NUMERAL (BIT1 O)))))).
Proof. exact (REFL simplicial_face). Qed.
Definition singular_simplex {A : Type'} : (prod nat (Topology A)) -> ((nat -> R) -> A) -> Prop := fun _986945 : prod nat (Topology A) => fun _986946 : (nat -> R) -> A => (@continuous_map (nat -> R) A (@pair (Topology (nat -> R)) (Topology A) (@subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (standard_simplex (@fst nat (Topology A) _986945))) (@snd nat (Topology A) _986945)) _986946) /\ (@EXTENSIONAL (nat -> R) A (standard_simplex (@fst nat (Topology A) _986945)) _986946).
Lemma singular_simplex_def {A : Type'} : (@singular_simplex A) = (fun _986945 : prod nat (Topology A) => fun _986946 : (nat -> R) -> A => (@continuous_map (nat -> R) A (@pair (Topology (nat -> R)) (Topology A) (@subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (standard_simplex (@fst nat (Topology A) _986945))) (@snd nat (Topology A) _986945)) _986946) /\ (@EXTENSIONAL (nat -> R) A (standard_simplex (@fst nat (Topology A) _986945)) _986946)).
Proof. exact (REFL (@singular_simplex A)). Qed.
Definition singular_face {_522410 : Type'} : nat -> nat -> ((nat -> R) -> _522410) -> (nat -> R) -> _522410 := fun _987092 : nat => fun _987093 : nat => fun _987094 : (nat -> R) -> _522410 => @RESTRICTION (nat -> R) _522410 (standard_simplex (subn _987092 (NUMERAL (BIT1 O)))) (@o (nat -> R) (nat -> R) _522410 _987094 (simplicial_face _987093)).
Lemma singular_face_def {_522410 : Type'} : (@singular_face _522410) = (fun _987092 : nat => fun _987093 : nat => fun _987094 : (nat -> R) -> _522410 => @RESTRICTION (nat -> R) _522410 (standard_simplex (subn _987092 (NUMERAL (BIT1 O)))) (@o (nat -> R) (nat -> R) _522410 _987094 (simplicial_face _987093))).
Proof. exact (REFL (@singular_face _522410)). Qed.
Definition singular_chain {A : Type'} : (prod nat (Topology A)) -> (frag ((nat -> R) -> A)) -> Prop := fun _987115 : prod nat (Topology A) => fun _987116 : frag ((nat -> R) -> A) => @subset ((nat -> R) -> A) (@frag_support ((nat -> R) -> A) _987116) (@singular_simplex A (@pair nat (Topology A) (@fst nat (Topology A) _987115) (@snd nat (Topology A) _987115))).
Lemma singular_chain_def {A : Type'} : (@singular_chain A) = (fun _987115 : prod nat (Topology A) => fun _987116 : frag ((nat -> R) -> A) => @subset ((nat -> R) -> A) (@frag_support ((nat -> R) -> A) _987116) (@singular_simplex A (@pair nat (Topology A) (@fst nat (Topology A) _987115) (@snd nat (Topology A) _987115)))).
Proof. exact (REFL (@singular_chain A)). Qed.
Definition chain_boundary {A : Type'} : nat -> (frag ((nat -> R) -> A)) -> frag ((nat -> R) -> A) := fun _987369 : nat => fun _987370 : frag ((nat -> R) -> A) => @COND (frag ((nat -> R) -> A)) (_987369 = (NUMERAL O)) (@frag_0 ((nat -> R) -> A)) (@frag_extend ((nat -> R) -> A) ((nat -> R) -> A) (fun f : (nat -> R) -> A => @iterate nat (frag ((nat -> R) -> A)) (@frag_add ((nat -> R) -> A)) (dotdot (NUMERAL O) _987369) (fun k : nat => @frag_cmul ((nat -> R) -> A) (expz (oppz (int_of_nat (NUMERAL (BIT1 O)))) k) (@frag_of ((nat -> R) -> A) (@singular_face A _987369 k f)))) _987370).
Lemma chain_boundary_def {A : Type'} : (@chain_boundary A) = (fun _987369 : nat => fun _987370 : frag ((nat -> R) -> A) => @COND (frag ((nat -> R) -> A)) (_987369 = (NUMERAL O)) (@frag_0 ((nat -> R) -> A)) (@frag_extend ((nat -> R) -> A) ((nat -> R) -> A) (fun f : (nat -> R) -> A => @iterate nat (frag ((nat -> R) -> A)) (@frag_add ((nat -> R) -> A)) (dotdot (NUMERAL O) _987369) (fun k : nat => @frag_cmul ((nat -> R) -> A) (expz (oppz (int_of_nat (NUMERAL (BIT1 O)))) k) (@frag_of ((nat -> R) -> A) (@singular_face A _987369 k f)))) _987370)).
Proof. exact (REFL (@chain_boundary A)). Qed.
Definition mod_subset {_523368 : Type'} : (prod nat (Topology _523368)) -> (frag ((nat -> R) -> _523368)) -> (frag ((nat -> R) -> _523368)) -> Prop := fun _987470 : prod nat (Topology _523368) => fun _987471 : frag ((nat -> R) -> _523368) => fun _987472 : frag ((nat -> R) -> _523368) => @singular_chain _523368 (@pair nat (Topology _523368) (@fst nat (Topology _523368) _987470) (@snd nat (Topology _523368) _987470)) (@frag_sub ((nat -> R) -> _523368) _987471 _987472).
Lemma mod_subset_def {_523368 : Type'} : (@mod_subset _523368) = (fun _987470 : prod nat (Topology _523368) => fun _987471 : frag ((nat -> R) -> _523368) => fun _987472 : frag ((nat -> R) -> _523368) => @singular_chain _523368 (@pair nat (Topology _523368) (@fst nat (Topology _523368) _987470) (@snd nat (Topology _523368) _987470)) (@frag_sub ((nat -> R) -> _523368) _987471 _987472)).
Proof. exact (REFL (@mod_subset _523368)). Qed.
Definition singular_relcycle {_523599 : Type'} : (prod nat (prod (Topology _523599) (_523599 -> Prop))) -> (frag ((nat -> R) -> _523599)) -> Prop := fun _987497 : prod nat (prod (Topology _523599) (_523599 -> Prop)) => fun _987498 : frag ((nat -> R) -> _523599) => (@singular_chain _523599 (@pair nat (Topology _523599) (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) (@fst (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497))) _987498) /\ (@eq2 (frag ((nat -> R) -> _523599)) (@chain_boundary _523599 (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) _987498) (@frag_0 ((nat -> R) -> _523599)) (@mod_subset _523599 (@pair nat (Topology _523599) (subn (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) (NUMERAL (BIT1 O))) (@subtopology _523599 (@fst (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497)) (@snd (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497)))))).
Lemma singular_relcycle_def {_523599 : Type'} : (@singular_relcycle _523599) = (fun _987497 : prod nat (prod (Topology _523599) (_523599 -> Prop)) => fun _987498 : frag ((nat -> R) -> _523599) => (@singular_chain _523599 (@pair nat (Topology _523599) (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) (@fst (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497))) _987498) /\ (@eq2 (frag ((nat -> R) -> _523599)) (@chain_boundary _523599 (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) _987498) (@frag_0 ((nat -> R) -> _523599)) (@mod_subset _523599 (@pair nat (Topology _523599) (subn (@fst nat (prod (Topology _523599) (_523599 -> Prop)) _987497) (NUMERAL (BIT1 O))) (@subtopology _523599 (@fst (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497)) (@snd (Topology _523599) (_523599 -> Prop) (@snd nat (prod (Topology _523599) (_523599 -> Prop)) _987497))))))).
Proof. exact (REFL (@singular_relcycle _523599)). Qed.
Definition singular_relboundary {_524206 : Type'} : (prod nat (prod (Topology _524206) (_524206 -> Prop))) -> (frag ((nat -> R) -> _524206)) -> Prop := fun _987635 : prod nat (prod (Topology _524206) (_524206 -> Prop)) => fun _987636 : frag ((nat -> R) -> _524206) => exists d : frag ((nat -> R) -> _524206), (@singular_chain _524206 (@pair nat (Topology _524206) (addn (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (NUMERAL (BIT1 O))) (@fst (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635))) d) /\ (@eq2 (frag ((nat -> R) -> _524206)) (@chain_boundary _524206 (addn (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (NUMERAL (BIT1 O))) d) _987636 (@mod_subset _524206 (@pair nat (Topology _524206) (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (@subtopology _524206 (@fst (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635)) (@snd (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635)))))).
Lemma singular_relboundary_def {_524206 : Type'} : (@singular_relboundary _524206) = (fun _987635 : prod nat (prod (Topology _524206) (_524206 -> Prop)) => fun _987636 : frag ((nat -> R) -> _524206) => exists d : frag ((nat -> R) -> _524206), (@singular_chain _524206 (@pair nat (Topology _524206) (addn (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (NUMERAL (BIT1 O))) (@fst (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635))) d) /\ (@eq2 (frag ((nat -> R) -> _524206)) (@chain_boundary _524206 (addn (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (NUMERAL (BIT1 O))) d) _987636 (@mod_subset _524206 (@pair nat (Topology _524206) (@fst nat (prod (Topology _524206) (_524206 -> Prop)) _987635) (@subtopology _524206 (@fst (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635)) (@snd (Topology _524206) (_524206 -> Prop) (@snd nat (prod (Topology _524206) (_524206 -> Prop)) _987635))))))).
Proof. exact (REFL (@singular_relboundary _524206)). Qed.
Definition homologous_rel {A : Type'} : (prod nat (prod (Topology A) (A -> Prop))) -> (frag ((nat -> R) -> A)) -> (frag ((nat -> R) -> A)) -> Prop := fun _988015 : prod nat (prod (Topology A) (A -> Prop)) => fun _988016 : frag ((nat -> R) -> A) => fun _988017 : frag ((nat -> R) -> A) => @singular_relboundary A (@pair nat (prod (Topology A) (A -> Prop)) (@fst nat (prod (Topology A) (A -> Prop)) _988015) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _988015)) (@snd (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _988015)))) (@frag_sub ((nat -> R) -> A) _988016 _988017).
Lemma homologous_rel_def {A : Type'} : (@homologous_rel A) = (fun _988015 : prod nat (prod (Topology A) (A -> Prop)) => fun _988016 : frag ((nat -> R) -> A) => fun _988017 : frag ((nat -> R) -> A) => @singular_relboundary A (@pair nat (prod (Topology A) (A -> Prop)) (@fst nat (prod (Topology A) (A -> Prop)) _988015) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _988015)) (@snd (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _988015)))) (@frag_sub ((nat -> R) -> A) _988016 _988017)).
Proof. exact (REFL (@homologous_rel A)). Qed.
Definition simplex_map {A B : Type'} : nat -> (A -> B) -> ((nat -> R) -> A) -> (nat -> R) -> B := fun _989500 : nat => fun _989501 : A -> B => fun _989502 : (nat -> R) -> A => @RESTRICTION (nat -> R) B (standard_simplex _989500) (@o (nat -> R) A B _989501 _989502).
Lemma simplex_map_def {A B : Type'} : (@simplex_map A B) = (fun _989500 : nat => fun _989501 : A -> B => fun _989502 : (nat -> R) -> A => @RESTRICTION (nat -> R) B (standard_simplex _989500) (@o (nat -> R) A B _989501 _989502)).
Proof. exact (REFL (@simplex_map A B)). Qed.
Definition chain_map {A B : Type'} : nat -> (A -> B) -> (frag ((nat -> R) -> A)) -> frag ((nat -> R) -> B) := fun _989940 : nat => fun _989941 : A -> B => fun _989942 : frag ((nat -> R) -> A) => @frag_extend ((nat -> R) -> A) ((nat -> R) -> B) (@o ((nat -> R) -> A) ((nat -> R) -> B) (frag ((nat -> R) -> B)) (@frag_of ((nat -> R) -> B)) (@simplex_map A B _989940 _989941)) _989942.
Lemma chain_map_def {A B : Type'} : (@chain_map A B) = (fun _989940 : nat => fun _989941 : A -> B => fun _989942 : frag ((nat -> R) -> A) => @frag_extend ((nat -> R) -> A) ((nat -> R) -> B) (@o ((nat -> R) -> A) ((nat -> R) -> B) (frag ((nat -> R) -> B)) (@frag_of ((nat -> R) -> B)) (@simplex_map A B _989940 _989941)) _989942).
Proof. exact (REFL (@chain_map A B)). Qed.
Definition oriented_simplex : nat -> (nat -> nat -> R) -> (nat -> R) -> nat -> R := fun _991181 : nat => fun _991182 : nat -> nat -> R => @RESTRICTION (nat -> R) (nat -> R) (standard_simplex _991181) (fun x : nat -> R => fun i : nat => @sum nat (dotdot (NUMERAL O) _991181) (fun j : nat => mulr (_991182 j i) (x j))).
Lemma oriented_simplex_def : oriented_simplex = (fun _991181 : nat => fun _991182 : nat -> nat -> R => @RESTRICTION (nat -> R) (nat -> R) (standard_simplex _991181) (fun x : nat -> R => fun i : nat => @sum nat (dotdot (NUMERAL O) _991181) (fun j : nat => mulr (_991182 j i) (x j)))).
Proof. exact (REFL oriented_simplex). Qed.
Definition simplicial_simplex : (prod nat ((nat -> R) -> Prop)) -> ((nat -> R) -> nat -> R) -> Prop := fun _991193 : prod nat ((nat -> R) -> Prop) => fun _991194 : (nat -> R) -> nat -> R => (@singular_simplex (nat -> R) (@pair nat (Topology (nat -> R)) (@fst nat ((nat -> R) -> Prop) _991193) (@subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (@snd nat ((nat -> R) -> Prop) _991193))) _991194) /\ (exists l : nat -> nat -> R, _991194 = (oriented_simplex (@fst nat ((nat -> R) -> Prop) _991193) l)).
Lemma simplicial_simplex_def : simplicial_simplex = (fun _991193 : prod nat ((nat -> R) -> Prop) => fun _991194 : (nat -> R) -> nat -> R => (@singular_simplex (nat -> R) (@pair nat (Topology (nat -> R)) (@fst nat ((nat -> R) -> Prop) _991193) (@subtopology (nat -> R) (@product_topology R nat (@setT nat) (fun i : nat => euclideanreal)) (@snd nat ((nat -> R) -> Prop) _991193))) _991194) /\ (exists l : nat -> nat -> R, _991194 = (oriented_simplex (@fst nat ((nat -> R) -> Prop) _991193) l))).
Proof. exact (REFL simplicial_simplex). Qed.
Definition simplicial_chain : (prod nat ((nat -> R) -> Prop)) -> (frag ((nat -> R) -> nat -> R)) -> Prop := fun _991218 : prod nat ((nat -> R) -> Prop) => fun _991219 : frag ((nat -> R) -> nat -> R) => @subset ((nat -> R) -> nat -> R) (@frag_support ((nat -> R) -> nat -> R) _991219) (simplicial_simplex (@pair nat ((nat -> R) -> Prop) (@fst nat ((nat -> R) -> Prop) _991218) (@snd nat ((nat -> R) -> Prop) _991218))).
Lemma simplicial_chain_def : simplicial_chain = (fun _991218 : prod nat ((nat -> R) -> Prop) => fun _991219 : frag ((nat -> R) -> nat -> R) => @subset ((nat -> R) -> nat -> R) (@frag_support ((nat -> R) -> nat -> R) _991219) (simplicial_simplex (@pair nat ((nat -> R) -> Prop) (@fst nat ((nat -> R) -> Prop) _991218) (@snd nat ((nat -> R) -> Prop) _991218)))).
Proof. exact (REFL simplicial_chain). Qed.
Definition simplex_cone : nat -> (nat -> R) -> ((nat -> R) -> nat -> R) -> (nat -> R) -> nat -> R := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> nat -> (nat -> R) -> ((nat -> R) -> nat -> R) -> (nat -> R) -> nat -> R) (fun cone : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> nat -> (nat -> R) -> ((nat -> R) -> nat -> R) -> (nat -> R) -> nat -> R => forall _991439 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))), forall p : nat, forall v : nat -> R, forall l : nat -> nat -> R, (cone _991439 p v (oriented_simplex p l)) = (oriented_simplex (addn p (NUMERAL (BIT1 O))) (fun i : nat => @COND (nat -> R) (i = (NUMERAL O)) v (l (subn i (NUMERAL (BIT1 O))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))))))))).
Lemma simplex_cone_def : simplex_cone = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> nat -> (nat -> R) -> ((nat -> R) -> nat -> R) -> (nat -> R) -> nat -> R) (fun cone : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> nat -> (nat -> R) -> ((nat -> R) -> nat -> R) -> (nat -> R) -> nat -> R => forall _991439 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))), forall p : nat, forall v : nat -> R, forall l : nat -> nat -> R, (cone _991439 p v (oriented_simplex p l)) = (oriented_simplex (addn p (NUMERAL (BIT1 O))) (fun i : nat => @COND (nat -> R) (i = (NUMERAL O)) v (l (subn i (NUMERAL (BIT1 O))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))).
Proof. exact (REFL simplex_cone). Qed.
Definition simplicial_cone : nat -> (nat -> R) -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R) := fun _991598 : nat => fun _991599 : nat -> R => @frag_extend ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (@o ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (frag ((nat -> R) -> nat -> R)) (@frag_of ((nat -> R) -> nat -> R)) (simplex_cone _991598 _991599)).
Lemma simplicial_cone_def : simplicial_cone = (fun _991598 : nat => fun _991599 : nat -> R => @frag_extend ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (@o ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (frag ((nat -> R) -> nat -> R)) (@frag_of ((nat -> R) -> nat -> R)) (simplex_cone _991598 _991599))).
Proof. exact (REFL simplicial_cone). Qed.
Definition simplicial_vertex : nat -> ((nat -> R) -> nat -> R) -> nat -> R := fun _991873 : nat => fun _991874 : (nat -> R) -> nat -> R => _991874 (fun j : nat => @COND R (j = _991873) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))).
Lemma simplicial_vertex_def : simplicial_vertex = (fun _991873 : nat => fun _991874 : (nat -> R) -> nat -> R => _991874 (fun j : nat => @COND R (j = _991873) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O)))).
Proof. exact (REFL simplicial_vertex). Qed.
Definition simplicial_subdivision : nat -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R) := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R)) (fun simplicial_subdivision' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R) => forall _991894 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))), ((simplicial_subdivision' _991894 (NUMERAL O)) = (@I (frag ((nat -> R) -> nat -> R)))) /\ (forall p : nat, (simplicial_subdivision' _991894 (S p)) = (@frag_extend ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (fun f : (nat -> R) -> nat -> R => simplicial_cone p (fun i : nat => divr (@sum nat (dotdot (NUMERAL O) (S p)) (fun j : nat => simplicial_vertex j f i)) (addr (R_of_nat p) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (simplicial_subdivision' _991894 p (@chain_boundary (nat -> R) (S p) (@frag_of ((nat -> R) -> nat -> R) f))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))))))).
Lemma simplicial_subdivision_def : simplicial_subdivision = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R)) (fun simplicial_subdivision' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (frag ((nat -> R) -> nat -> R)) -> frag ((nat -> R) -> nat -> R) => forall _991894 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))), ((simplicial_subdivision' _991894 (NUMERAL O)) = (@I (frag ((nat -> R) -> nat -> R)))) /\ (forall p : nat, (simplicial_subdivision' _991894 (S p)) = (@frag_extend ((nat -> R) -> nat -> R) ((nat -> R) -> nat -> R) (fun f : (nat -> R) -> nat -> R => simplicial_cone p (fun i : nat => divr (@sum nat (dotdot (NUMERAL O) (S p)) (fun j : nat => simplicial_vertex j f i)) (addr (R_of_nat p) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (simplicial_subdivision' _991894 p (@chain_boundary (nat -> R) (S p) (@frag_of ((nat -> R) -> nat -> R) f))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))))))).
Proof. exact (REFL simplicial_subdivision). Qed.
Definition singular_subdivision {_537744 : Type'} : nat -> (frag ((nat -> R) -> _537744)) -> frag ((nat -> R) -> _537744) := fun _992799 : nat => @frag_extend ((nat -> R) -> _537744) ((nat -> R) -> _537744) (fun f : (nat -> R) -> _537744 => @chain_map (nat -> R) _537744 _992799 f (simplicial_subdivision _992799 (@frag_of ((nat -> R) -> nat -> R) (@RESTRICTION (nat -> R) (nat -> R) (standard_simplex _992799) (@I (nat -> R)))))).
Lemma singular_subdivision_def {_537744 : Type'} : (@singular_subdivision _537744) = (fun _992799 : nat => @frag_extend ((nat -> R) -> _537744) ((nat -> R) -> _537744) (fun f : (nat -> R) -> _537744 => @chain_map (nat -> R) _537744 _992799 f (simplicial_subdivision _992799 (@frag_of ((nat -> R) -> nat -> R) (@RESTRICTION (nat -> R) (nat -> R) (standard_simplex _992799) (@I (nat -> R))))))).
Proof. exact (REFL (@singular_subdivision _537744)). Qed.
Definition chain_group {A : Type'} : (prod nat (Topology A)) -> hol_Group (frag ((nat -> R) -> A)) := fun _1000742 : prod nat (Topology A) => @free_abelian_group ((nat -> R) -> A) (@singular_simplex A (@pair nat (Topology A) (@fst nat (Topology A) _1000742) (@snd nat (Topology A) _1000742))).
Lemma chain_group_def {A : Type'} : (@chain_group A) = (fun _1000742 : prod nat (Topology A) => @free_abelian_group ((nat -> R) -> A) (@singular_simplex A (@pair nat (Topology A) (@fst nat (Topology A) _1000742) (@snd nat (Topology A) _1000742)))).
Proof. exact (REFL (@chain_group A)). Qed.
Definition relcycle_group {A : Type'} : (prod nat (prod (Topology A) (A -> Prop))) -> hol_Group (frag ((nat -> R) -> A)) := fun _1000751 : prod nat (prod (Topology A) (A -> Prop)) => @subgroup_generated (frag ((nat -> R) -> A)) (@chain_group A (@pair nat (Topology A) (@fst nat (prod (Topology A) (A -> Prop)) _1000751) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751)))) (@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) (@fst nat (prod (Topology A) (A -> Prop)) _1000751) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751)) (@snd (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751))))).
Lemma relcycle_group_def {A : Type'} : (@relcycle_group A) = (fun _1000751 : prod nat (prod (Topology A) (A -> Prop)) => @subgroup_generated (frag ((nat -> R) -> A)) (@chain_group A (@pair nat (Topology A) (@fst nat (prod (Topology A) (A -> Prop)) _1000751) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751)))) (@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) (@fst nat (prod (Topology A) (A -> Prop)) _1000751) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751)) (@snd (Topology A) (A -> Prop) (@snd nat (prod (Topology A) (A -> Prop)) _1000751)))))).
Proof. exact (REFL (@relcycle_group A)). Qed.
Definition relative_homology_group {A : Type'} : (prod int (prod (Topology A) (A -> Prop))) -> hol_Group ((frag ((nat -> R) -> A)) -> Prop) := fun _1000764 : prod int (prod (Topology A) (A -> Prop)) => @COND (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (ltz (@fst int (prod (Topology A) (A -> Prop)) _1000764) (int_of_nat (NUMERAL O))) (@singleton_group ((frag ((nat -> R) -> A)) -> Prop) (@ARB ((frag ((nat -> R) -> A)) -> Prop))) (@quotient_group (frag ((nat -> R) -> A)) (@relcycle_group A (@pair nat (prod (Topology A) (A -> Prop)) (num_of_int (@fst int (prod (Topology A) (A -> Prop)) _1000764)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764)) (@snd (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764))))) (@singular_relboundary A (@pair nat (prod (Topology A) (A -> Prop)) (num_of_int (@fst int (prod (Topology A) (A -> Prop)) _1000764)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764)) (@snd (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764)))))).
Lemma relative_homology_group_def {A : Type'} : (@relative_homology_group A) = (fun _1000764 : prod int (prod (Topology A) (A -> Prop)) => @COND (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (ltz (@fst int (prod (Topology A) (A -> Prop)) _1000764) (int_of_nat (NUMERAL O))) (@singleton_group ((frag ((nat -> R) -> A)) -> Prop) (@ARB ((frag ((nat -> R) -> A)) -> Prop))) (@quotient_group (frag ((nat -> R) -> A)) (@relcycle_group A (@pair nat (prod (Topology A) (A -> Prop)) (num_of_int (@fst int (prod (Topology A) (A -> Prop)) _1000764)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764)) (@snd (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764))))) (@singular_relboundary A (@pair nat (prod (Topology A) (A -> Prop)) (num_of_int (@fst int (prod (Topology A) (A -> Prop)) _1000764)) (@pair (Topology A) (A -> Prop) (@fst (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764)) (@snd (Topology A) (A -> Prop) (@snd int (prod (Topology A) (A -> Prop)) _1000764))))))).
Proof. exact (REFL (@relative_homology_group A)). Qed.
Definition homology_group {A : Type'} : (prod int (Topology A)) -> hol_Group ((frag ((nat -> R) -> A)) -> Prop) := fun _1000777 : prod int (Topology A) => @relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) (@fst int (Topology A) _1000777) (@pair (Topology A) (A -> Prop) (@snd int (Topology A) _1000777) (@set0 A))).
Lemma homology_group_def {A : Type'} : (@homology_group A) = (fun _1000777 : prod int (Topology A) => @relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) (@fst int (Topology A) _1000777) (@pair (Topology A) (A -> Prop) (@snd int (Topology A) _1000777) (@set0 A)))).
Proof. exact (REFL (@homology_group A)). Qed.
Definition hom_boundary {A : Type'} : int -> (prod (Topology A) (A -> Prop)) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop) (fun d : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop => forall _1001403 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))), (forall p : int, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, (~ (@IN ((frag ((nat -> R) -> A)) -> Prop) c (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))) -> (d _1001403 p (@pair (Topology A) (A -> Prop) top s) c) = (@g0 ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s))))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, @group_homomorphism ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s)))) (d _1001403 p (@pair (Topology A) (A -> Prop) top s))) /\ ((forall p : nat, forall top : Topology A, forall s : A -> Prop, forall c : frag ((nat -> R) -> A), ((@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c) /\ (leqn (NUMERAL (BIT1 O)) p)) -> (d _1001403 (int_of_nat p) (@pair (Topology A) (A -> Prop) top s) (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) (subn p (NUMERAL (BIT1 O))) (@pair (Topology A) (A -> Prop) (@subtopology A top s) (@set0 A))) (@chain_boundary A p c))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, (d _1001403 p (@pair (Topology A) (A -> Prop) top s)) = (d _1001403 p (@pair (Topology A) (A -> Prop) top (@setI A (@topspace A top) s)))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, @IN ((frag ((nat -> R) -> A)) -> Prop) (d _1001403 p (@pair (Topology A) (A -> Prop) top s) c) (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s))))) /\ (forall p : int, (lez p (int_of_nat (NUMERAL O))) -> (d _1001403 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : (frag ((nat -> R) -> A)) -> Prop => @ARB ((frag ((nat -> R) -> A)) -> Prop)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O))))))))))))))))))).
Lemma hom_boundary_def {A : Type'} : (@hom_boundary A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop) (fun d : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop => forall _1001403 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))), (forall p : int, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, (~ (@IN ((frag ((nat -> R) -> A)) -> Prop) c (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))) -> (d _1001403 p (@pair (Topology A) (A -> Prop) top s) c) = (@g0 ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s))))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, @group_homomorphism ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s)))) (d _1001403 p (@pair (Topology A) (A -> Prop) top s))) /\ ((forall p : nat, forall top : Topology A, forall s : A -> Prop, forall c : frag ((nat -> R) -> A), ((@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c) /\ (leqn (NUMERAL (BIT1 O)) p)) -> (d _1001403 (int_of_nat p) (@pair (Topology A) (A -> Prop) top s) (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) (subn p (NUMERAL (BIT1 O))) (@pair (Topology A) (A -> Prop) (@subtopology A top s) (@set0 A))) (@chain_boundary A p c))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, (d _1001403 p (@pair (Topology A) (A -> Prop) top s)) = (d _1001403 p (@pair (Topology A) (A -> Prop) top (@setI A (@topspace A top) s)))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, @IN ((frag ((nat -> R) -> A)) -> Prop) (d _1001403 p (@pair (Topology A) (A -> Prop) top s) c) (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (subz p (int_of_nat (NUMERAL (BIT1 O)))) (@subtopology A top s))))) /\ (forall p : int, (lez p (int_of_nat (NUMERAL O))) -> (d _1001403 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : (frag ((nat -> R) -> A)) -> Prop => @ARB ((frag ((nat -> R) -> A)) -> Prop)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))))))))))))))).
Proof. exact (REFL (@hom_boundary A)). Qed.
Definition hom_induced {A B : Type'} : int -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> B)) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> B)) -> Prop) (fun hom_relmap' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> B)) -> Prop => forall _1006189 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : (frag ((nat -> R) -> A)) -> Prop, (~ ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@subset B (@IMAGE A B f (@setI A (@topspace A top) s)) t) /\ (@IN ((frag ((nat -> R) -> A)) -> Prop) c (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))))) -> (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) = (@g0 ((frag ((nat -> R) -> B)) -> Prop) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, @group_homomorphism ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> B)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> B)) -> Prop)) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)))) (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f)) /\ ((forall p : nat, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : frag ((nat -> R) -> A), ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@subset B (@IMAGE A B f (@setI A (@topspace A top) s)) t) /\ (@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c))) -> (hom_relmap' _1006189 (int_of_nat p) (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel B (@pair nat (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)) (@chain_map A B p f c))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t)) = (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top (@setI A (@topspace A top) s)) (@pair (Topology B) (B -> Prop) top' (@setI B (@topspace B top') t)))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall f : A -> B, forall t : B -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, @IN ((frag ((nat -> R) -> B)) -> Prop) (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) (@gcar ((frag ((nat -> R) -> B)) -> Prop) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ (forall p : int, (ltz p (int_of_nat (NUMERAL O))) -> (hom_relmap' _1006189 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : prod (Topology B) (B -> Prop) => fun s : A -> B => fun t : (frag ((nat -> R) -> A)) -> Prop => @ARB ((frag ((nat -> R) -> B)) -> Prop)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Lemma hom_induced_def {A B : Type'} : (@hom_induced A B) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> B)) -> Prop) (fun hom_relmap' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> int -> (prod (Topology A) (A -> Prop)) -> (prod (Topology B) (B -> Prop)) -> (A -> B) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> B)) -> Prop => forall _1006189 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : (frag ((nat -> R) -> A)) -> Prop, (~ ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@subset B (@IMAGE A B f (@setI A (@topspace A top) s)) t) /\ (@IN ((frag ((nat -> R) -> A)) -> Prop) c (@gcar ((frag ((nat -> R) -> A)) -> Prop) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)))))))) -> (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) = (@g0 ((frag ((nat -> R) -> B)) -> Prop) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, @group_homomorphism ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> B)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> B)) -> Prop)) (@relative_homology_group A (@pair int (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s))) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)))) (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f)) /\ ((forall p : nat, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, forall f : A -> B, forall c : frag ((nat -> R) -> A), ((@continuous_map A B (@pair (Topology A) (Topology B) top top') f) /\ ((@subset B (@IMAGE A B f (@setI A (@topspace A top) s)) t) /\ (@singular_relcycle A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c))) -> (hom_relmap' _1006189 (int_of_nat p) (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f (@homologous_rel A (@pair nat (prod (Topology A) (A -> Prop)) p (@pair (Topology A) (A -> Prop) top s)) c)) = (@homologous_rel B (@pair nat (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t)) (@chain_map A B p f c))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall t : B -> Prop, (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t)) = (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top (@setI A (@topspace A top) s)) (@pair (Topology B) (B -> Prop) top' (@setI B (@topspace B top') t)))) /\ ((forall p : int, forall top : Topology A, forall s : A -> Prop, forall top' : Topology B, forall f : A -> B, forall t : B -> Prop, forall c : (frag ((nat -> R) -> A)) -> Prop, @IN ((frag ((nat -> R) -> B)) -> Prop) (hom_relmap' _1006189 p (@pair (Topology A) (A -> Prop) top s) (@pair (Topology B) (B -> Prop) top' t) f c) (@gcar ((frag ((nat -> R) -> B)) -> Prop) (@relative_homology_group B (@pair int (prod (Topology B) (B -> Prop)) p (@pair (Topology B) (B -> Prop) top' t))))) /\ (forall p : int, (ltz p (int_of_nat (NUMERAL O))) -> (hom_relmap' _1006189 p) = (fun q : prod (Topology A) (A -> Prop) => fun r : prod (Topology B) (B -> Prop) => fun s : A -> B => fun t : (frag ((nat -> R) -> A)) -> Prop => @ARB ((frag ((nat -> R) -> B)) -> Prop)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))))))))).
Proof. exact (REFL (@hom_induced A B)). Qed.
Definition hom_relboundary {A : Type'} : int -> (prod (Topology A) (prod (A -> Prop) (A -> Prop))) -> ((frag ((nat -> R) -> A)) -> Prop) -> (frag ((nat -> R) -> A)) -> Prop := fun _1022427 : int => fun _1022428 : prod (Topology A) (prod (A -> Prop) (A -> Prop)) => @o ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) (@hom_induced A A (subz _1022427 (int_of_nat (NUMERAL (BIT1 O)))) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (@set0 A)) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (@snd (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (fun x : A => x)) (@hom_boundary A _1022427 (@pair (Topology A) (A -> Prop) (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428)))).
Lemma hom_relboundary_def {A : Type'} : (@hom_relboundary A) = (fun _1022427 : int => fun _1022428 : prod (Topology A) (prod (A -> Prop) (A -> Prop)) => @o ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> A)) -> Prop) (@hom_induced A A (subz _1022427 (int_of_nat (NUMERAL (BIT1 O)))) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (@set0 A)) (@pair (Topology A) (A -> Prop) (@subtopology A (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (@snd (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))) (fun x : A => x)) (@hom_boundary A _1022427 (@pair (Topology A) (A -> Prop) (@fst (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428) (@fst (A -> Prop) (A -> Prop) (@snd (Topology A) (prod (A -> Prop) (A -> Prop)) _1022428))))).
Proof. exact (REFL (@hom_relboundary A)). Qed.
Definition reduced_homology_group {A : Type'} : (prod int (Topology A)) -> hol_Group ((frag ((nat -> R) -> A)) -> Prop) := fun _1023943 : prod int (Topology A) => @subgroup_generated ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (@fst int (Topology A) _1023943) (@snd int (Topology A) _1023943))) (@group_kernel ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> unit)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> unit)) -> Prop)) (@homology_group A (@pair int (Topology A) (@fst int (Topology A) _1023943) (@snd int (Topology A) _1023943))) (@homology_group unit (@pair int (Topology unit) (@fst int (Topology A) _1023943) (@discrete_topology unit (@INSERT unit tt (@set0 unit)))))) (@hom_induced A unit (@fst int (Topology A) _1023943) (@pair (Topology A) (A -> Prop) (@snd int (Topology A) _1023943) (@set0 A)) (@pair (Topology unit) (unit -> Prop) (@discrete_topology unit (@INSERT unit tt (@set0 unit))) (@set0 unit)) (fun x : A => tt))).
Lemma reduced_homology_group_def {A : Type'} : (@reduced_homology_group A) = (fun _1023943 : prod int (Topology A) => @subgroup_generated ((frag ((nat -> R) -> A)) -> Prop) (@homology_group A (@pair int (Topology A) (@fst int (Topology A) _1023943) (@snd int (Topology A) _1023943))) (@group_kernel ((frag ((nat -> R) -> A)) -> Prop) ((frag ((nat -> R) -> unit)) -> Prop) (@pair (hol_Group ((frag ((nat -> R) -> A)) -> Prop)) (hol_Group ((frag ((nat -> R) -> unit)) -> Prop)) (@homology_group A (@pair int (Topology A) (@fst int (Topology A) _1023943) (@snd int (Topology A) _1023943))) (@homology_group unit (@pair int (Topology unit) (@fst int (Topology A) _1023943) (@discrete_topology unit (@INSERT unit tt (@set0 unit)))))) (@hom_induced A unit (@fst int (Topology A) _1023943) (@pair (Topology A) (A -> Prop) (@snd int (Topology A) _1023943) (@set0 A)) (@pair (Topology unit) (unit -> Prop) (@discrete_topology unit (@INSERT unit tt (@set0 unit))) (@set0 unit)) (fun x : A => tt)))).
Proof. exact (REFL (@reduced_homology_group A)). Qed.
Definition brouwer_degree2 : nat -> ((nat -> R) -> nat -> R) -> int := fun _1030023 : nat => fun _1030024 : (nat -> R) -> nat -> R => @ε int (fun d : int => forall x : (frag ((nat -> R) -> nat -> R)) -> Prop, (@IN ((frag ((nat -> R) -> nat -> R)) -> Prop) x (@gcar ((frag ((nat -> R) -> nat -> R)) -> Prop) (@reduced_homology_group (nat -> R) (@pair int (Topology (nat -> R)) (int_of_nat _1030023) (nsphere _1030023))))) -> (@hom_induced (nat -> R) (nat -> R) (int_of_nat _1030023) (@pair (Topology (nat -> R)) ((nat -> R) -> Prop) (nsphere _1030023) (@set0 (nat -> R))) (@pair (Topology (nat -> R)) ((nat -> R) -> Prop) (nsphere _1030023) (@set0 (nat -> R))) _1030024 x) = (@group_zpow ((frag ((nat -> R) -> nat -> R)) -> Prop) (@reduced_homology_group (nat -> R) (@pair int (Topology (nat -> R)) (int_of_nat _1030023) (nsphere _1030023))) x d)).
Lemma brouwer_degree2_def : brouwer_degree2 = (fun _1030023 : nat => fun _1030024 : (nat -> R) -> nat -> R => @ε int (fun d : int => forall x : (frag ((nat -> R) -> nat -> R)) -> Prop, (@IN ((frag ((nat -> R) -> nat -> R)) -> Prop) x (@gcar ((frag ((nat -> R) -> nat -> R)) -> Prop) (@reduced_homology_group (nat -> R) (@pair int (Topology (nat -> R)) (int_of_nat _1030023) (nsphere _1030023))))) -> (@hom_induced (nat -> R) (nat -> R) (int_of_nat _1030023) (@pair (Topology (nat -> R)) ((nat -> R) -> Prop) (nsphere _1030023) (@set0 (nat -> R))) (@pair (Topology (nat -> R)) ((nat -> R) -> Prop) (nsphere _1030023) (@set0 (nat -> R))) _1030024 x) = (@group_zpow ((frag ((nat -> R) -> nat -> R)) -> Prop) (@reduced_homology_group (nat -> R) (@pair int (Topology (nat -> R)) (int_of_nat _1030023) (nsphere _1030023))) x d))).
Proof. exact (REFL brouwer_degree2). Qed.
Definition vector_add {N' : Type'} : (cart R N') -> (cart R N') -> cart R N' := fun _1113078 : cart R N' => fun _1113079 : cart R N' => @lambda R N' (fun i : nat => addr (@dollar R N' _1113078 i) (@dollar R N' _1113079 i)).
Lemma vector_add_def {N' : Type'} : (@vector_add N') = (fun _1113078 : cart R N' => fun _1113079 : cart R N' => @lambda R N' (fun i : nat => addr (@dollar R N' _1113078 i) (@dollar R N' _1113079 i))).
Proof. exact (REFL (@vector_add N')). Qed.
Definition vector_neg {N' : Type'} : (cart R N') -> cart R N' := fun _1113102 : cart R N' => @lambda R N' (fun i : nat => oppr (@dollar R N' _1113102 i)).
Lemma vector_neg_def {N' : Type'} : (@vector_neg N') = (fun _1113102 : cart R N' => @lambda R N' (fun i : nat => oppr (@dollar R N' _1113102 i))).
Proof. exact (REFL (@vector_neg N')). Qed.
Definition percent {N' : Type'} : R -> (cart R N') -> cart R N' := fun _1113107 : R => fun _1113108 : cart R N' => @lambda R N' (fun i : nat => mulr _1113107 (@dollar R N' _1113108 i)).
Lemma percent_def {N' : Type'} : (@percent N') = (fun _1113107 : R => fun _1113108 : cart R N' => @lambda R N' (fun i : nat => mulr _1113107 (@dollar R N' _1113108 i))).
Proof. exact (REFL (@percent N')). Qed.
Definition vec {N' : Type'} : nat -> cart R N' := fun _1113119 : nat => @lambda R N' (fun i : nat => R_of_nat _1113119).
Lemma vec_def {N' : Type'} : (@vec N') = (fun _1113119 : nat => @lambda R N' (fun i : nat => R_of_nat _1113119)).
Proof. exact (REFL (@vec N')). Qed.
Definition basis {_595400 : Type'} : nat -> cart R _595400 := fun _1117363 : nat => @lambda R _595400 (fun i : nat => @COND R (i = _1117363) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))).
Lemma basis_def {_595400 : Type'} : (@basis _595400) = (fun _1117363 : nat => @lambda R _595400 (fun i : nat => @COND R (i = _1117363) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O)))).
Proof. exact (REFL (@basis _595400)). Qed.
Definition orthogonal {_596102 : Type'} : (cart R _596102) -> (cart R _596102) -> Prop := fun _1117569 : cart R _596102 => fun _1117570 : cart R _596102 => (@dot _596102 _1117569 _1117570) = (R_of_nat (NUMERAL O)).
Lemma orthogonal_def {_596102 : Type'} : (@orthogonal _596102) = (fun _1117569 : cart R _596102 => fun _1117570 : cart R _596102 => (@dot _596102 _1117569 _1117570) = (R_of_nat (NUMERAL O))).
Proof. exact (REFL (@orthogonal _596102)). Qed.
Definition linear {M N' : Type'} : ((cart R M) -> cart R N') -> Prop := fun _1117747 : (cart R M) -> cart R N' => (forall x : cart R M, forall y : cart R M, (_1117747 (@vector_add M x y)) = (@vector_add N' (_1117747 x) (_1117747 y))) /\ (forall c : R, forall x : cart R M, (_1117747 (@percent M c x)) = (@percent N' c (_1117747 x))).
Lemma linear_def {M N' : Type'} : (@linear M N') = (fun _1117747 : (cart R M) -> cart R N' => (forall x : cart R M, forall y : cart R M, (_1117747 (@vector_add M x y)) = (@vector_add N' (_1117747 x) (_1117747 y))) /\ (forall c : R, forall x : cart R M, (_1117747 (@percent M c x)) = (@percent N' c (_1117747 x)))).
Proof. exact (REFL (@linear M N')). Qed.
Definition bilinear {_598275 _598276 _598286 : Type'} : ((cart R _598286) -> (cart R _598275) -> cart R _598276) -> Prop := fun _1118069 : (cart R _598286) -> (cart R _598275) -> cart R _598276 => (forall x : cart R _598286, @linear _598275 _598276 (fun y : cart R _598275 => _1118069 x y)) /\ (forall y : cart R _598275, @linear _598286 _598276 (fun x : cart R _598286 => _1118069 x y)).
Lemma bilinear_def {_598275 _598276 _598286 : Type'} : (@bilinear _598275 _598276 _598286) = (fun _1118069 : (cart R _598286) -> (cart R _598275) -> cart R _598276 => (forall x : cart R _598286, @linear _598275 _598276 (fun y : cart R _598275 => _1118069 x y)) /\ (forall y : cart R _598275, @linear _598286 _598276 (fun x : cart R _598286 => _1118069 x y))).
Proof. exact (REFL (@bilinear _598275 _598276 _598286)). Qed.
Definition adjoint {M N' : Type'} : ((cart R M) -> cart R N') -> (cart R N') -> cart R M := fun _1118641 : (cart R M) -> cart R N' => @ε ((cart R N') -> cart R M) (fun f' : (cart R N') -> cart R M => forall x : cart R M, forall y : cart R N', (@dot N' (_1118641 x) y) = (@dot M x (f' y))).
Lemma adjoint_def {M N' : Type'} : (@adjoint M N') = (fun _1118641 : (cart R M) -> cart R N' => @ε ((cart R N') -> cart R M) (fun f' : (cart R N') -> cart R M => forall x : cart R M, forall y : cart R N', (@dot N' (_1118641 x) y) = (@dot M x (f' y)))).
Proof. exact (REFL (@adjoint M N')). Qed.
Definition __ {M N' : Type'} : R -> (cart (cart R N') M) -> cart (cart R N') M := fun _1118844 : R => fun _1118845 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => mulr _1118844 (@dollar R N' (@dollar (cart R N') M _1118845 i) j))).
Lemma ___def {M N' : Type'} : (@__ M N') = (fun _1118844 : R => fun _1118845 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => mulr _1118844 (@dollar R N' (@dollar (cart R N') M _1118845 i) j)))).
Proof. exact (REFL (@__ M N')). Qed.
Definition matrix_neg {M N' : Type'} : (cart (cart R N') M) -> cart (cart R N') M := fun _1118856 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => oppr (@dollar R N' (@dollar (cart R N') M _1118856 i) j))).
Lemma matrix_neg_def {M N' : Type'} : (@matrix_neg M N') = (fun _1118856 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => oppr (@dollar R N' (@dollar (cart R N') M _1118856 i) j)))).
Proof. exact (REFL (@matrix_neg M N')). Qed.
Definition matrix_add {M N' : Type'} : (cart (cart R N') M) -> (cart (cart R N') M) -> cart (cart R N') M := fun _1118861 : cart (cart R N') M => fun _1118862 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => addr (@dollar R N' (@dollar (cart R N') M _1118861 i) j) (@dollar R N' (@dollar (cart R N') M _1118862 i) j))).
Lemma matrix_add_def {M N' : Type'} : (@matrix_add M N') = (fun _1118861 : cart (cart R N') M => fun _1118862 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => addr (@dollar R N' (@dollar (cart R N') M _1118861 i) j) (@dollar R N' (@dollar (cart R N') M _1118862 i) j)))).
Proof. exact (REFL (@matrix_add M N')). Qed.
Definition matrix_sub {M N' : Type'} : (cart (cart R N') M) -> (cart (cart R N') M) -> cart (cart R N') M := fun _1118873 : cart (cart R N') M => fun _1118874 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => subr (@dollar R N' (@dollar (cart R N') M _1118873 i) j) (@dollar R N' (@dollar (cart R N') M _1118874 i) j))).
Lemma matrix_sub_def {M N' : Type'} : (@matrix_sub M N') = (fun _1118873 : cart (cart R N') M => fun _1118874 : cart (cart R N') M => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => subr (@dollar R N' (@dollar (cart R N') M _1118873 i) j) (@dollar R N' (@dollar (cart R N') M _1118874 i) j)))).
Proof. exact (REFL (@matrix_sub M N')). Qed.
Definition matrix_mul {M N' P : Type'} : (cart (cart R N') M) -> (cart (cart R P) N') -> cart (cart R P) M := fun _1118885 : cart (cart R N') M => fun _1118886 : cart (cart R P) N' => @lambda (cart R P) M (fun i : nat => @lambda R P (fun j : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun k : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118885 i) k) (@dollar R P (@dollar (cart R P) N' _1118886 k) j)))).
Lemma matrix_mul_def {M N' P : Type'} : (@matrix_mul M N' P) = (fun _1118885 : cart (cart R N') M => fun _1118886 : cart (cart R P) N' => @lambda (cart R P) M (fun i : nat => @lambda R P (fun j : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun k : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118885 i) k) (@dollar R P (@dollar (cart R P) N' _1118886 k) j))))).
Proof. exact (REFL (@matrix_mul M N' P)). Qed.
Definition matrix_vector_mul {M N' : Type'} : (cart (cart R N') M) -> (cart R N') -> cart R M := fun _1118897 : cart (cart R N') M => fun _1118898 : cart R N' => @lambda R M (fun i : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun j : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118897 i) j) (@dollar R N' _1118898 j))).
Lemma matrix_vector_mul_def {M N' : Type'} : (@matrix_vector_mul M N') = (fun _1118897 : cart (cart R N') M => fun _1118898 : cart R N' => @lambda R M (fun i : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun j : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118897 i) j) (@dollar R N' _1118898 j)))).
Proof. exact (REFL (@matrix_vector_mul M N')). Qed.
Definition vector_matrix_mul {M N' : Type'} : (cart R M) -> (cart (cart R N') M) -> cart R N' := fun _1118909 : cart R M => fun _1118910 : cart (cart R N') M => @lambda R N' (fun j : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex M (@setT M))) (fun i : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118910 i) j) (@dollar R M _1118909 i))).
Lemma vector_matrix_mul_def {M N' : Type'} : (@vector_matrix_mul M N') = (fun _1118909 : cart R M => fun _1118910 : cart (cart R N') M => @lambda R N' (fun j : nat => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex M (@setT M))) (fun i : nat => mulr (@dollar R N' (@dollar (cart R N') M _1118910 i) j) (@dollar R M _1118909 i)))).
Proof. exact (REFL (@vector_matrix_mul M N')). Qed.
Definition mat {M N' : Type'} : nat -> cart (cart R N') M := fun _1118921 : nat => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => @COND R (i = j) (R_of_nat _1118921) (R_of_nat (NUMERAL O)))).
Lemma mat_def {M N' : Type'} : (@mat M N') = (fun _1118921 : nat => @lambda (cart R N') M (fun i : nat => @lambda R N' (fun j : nat => @COND R (i = j) (R_of_nat _1118921) (R_of_nat (NUMERAL O))))).
Proof. exact (REFL (@mat M N')). Qed.
Definition transp {M N' : Type'} : (cart (cart R N') M) -> cart (cart R M) N' := fun _1118926 : cart (cart R N') M => @lambda (cart R M) N' (fun i : nat => @lambda R M (fun j : nat => @dollar R N' (@dollar (cart R N') M _1118926 j) i)).
Lemma transp_def {M N' : Type'} : (@transp M N') = (fun _1118926 : cart (cart R N') M => @lambda (cart R M) N' (fun i : nat => @lambda R M (fun j : nat => @dollar R N' (@dollar (cart R N') M _1118926 j) i))).
Proof. exact (REFL (@transp M N')). Qed.
Definition row {M N' : Type'} : nat -> (cart (cart R N') M) -> cart R N' := fun _1118931 : nat => fun _1118932 : cart (cart R N') M => @lambda R N' (fun j : nat => @dollar R N' (@dollar (cart R N') M _1118932 _1118931) j).
Lemma row_def {M N' : Type'} : (@row M N') = (fun _1118931 : nat => fun _1118932 : cart (cart R N') M => @lambda R N' (fun j : nat => @dollar R N' (@dollar (cart R N') M _1118932 _1118931) j)).
Proof. exact (REFL (@row M N')). Qed.
Definition column {M N' : Type'} : nat -> (cart (cart R N') M) -> cart R M := fun _1118943 : nat => fun _1118944 : cart (cart R N') M => @lambda R M (fun i : nat => @dollar R N' (@dollar (cart R N') M _1118944 i) _1118943).
Lemma column_def {M N' : Type'} : (@column M N') = (fun _1118943 : nat => fun _1118944 : cart (cart R N') M => @lambda R M (fun i : nat => @dollar R N' (@dollar (cart R N') M _1118944 i) _1118943)).
Proof. exact (REFL (@column M N')). Qed.
Definition rows {M N' : Type'} : (cart (cart R N') M) -> (cart R N') -> Prop := fun _1118955 : cart (cart R N') M => @GSPEC (cart R N') (fun GEN_PVAR_2385 : cart R N' => exists i : nat, @SETSPEC (cart R N') GEN_PVAR_2385 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex M (@setT M)))) (@row M N' i _1118955)).
Lemma rows_def {M N' : Type'} : (@rows M N') = (fun _1118955 : cart (cart R N') M => @GSPEC (cart R N') (fun GEN_PVAR_2385 : cart R N' => exists i : nat, @SETSPEC (cart R N') GEN_PVAR_2385 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex M (@setT M)))) (@row M N' i _1118955))).
Proof. exact (REFL (@rows M N')). Qed.
Definition columns {M N' : Type'} : (cart (cart R N') M) -> (cart R M) -> Prop := fun _1118960 : cart (cart R N') M => @GSPEC (cart R M) (fun GEN_PVAR_2386 : cart R M => exists i : nat, @SETSPEC (cart R M) GEN_PVAR_2386 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) (@column M N' i _1118960)).
Lemma columns_def {M N' : Type'} : (@columns M N') = (fun _1118960 : cart (cart R N') M => @GSPEC (cart R M) (fun GEN_PVAR_2386 : cart R M => exists i : nat, @SETSPEC (cart R M) GEN_PVAR_2386 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) (@column M N' i _1118960))).
Proof. exact (REFL (@columns M N')). Qed.
Definition symmetric_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1119025 : cart (cart R N') N' => (@transp N' N' _1119025) = _1119025.
Lemma symmetric_matrix_def {N' : Type'} : (@symmetric_matrix N') = (fun _1119025 : cart (cart R N') N' => (@transp N' N' _1119025) = _1119025).
Proof. exact (REFL (@symmetric_matrix N')). Qed.
Definition normal_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1119030 : cart (cart R N') N' => (@matrix_mul N' N' N' (@transp N' N' _1119030) _1119030) = (@matrix_mul N' N' N' _1119030 (@transp N' N' _1119030)).
Lemma normal_matrix_def {N' : Type'} : (@normal_matrix N') = (fun _1119030 : cart (cart R N') N' => (@matrix_mul N' N' N' (@transp N' N' _1119030) _1119030) = (@matrix_mul N' N' N' _1119030 (@transp N' N' _1119030))).
Proof. exact (REFL (@normal_matrix N')). Qed.
Definition invertible {M N' : Type'} : (cart (cart R N') M) -> Prop := fun _1119552 : cart (cart R N') M => exists A' : cart (cart R M) N', ((@matrix_mul M N' M _1119552 A') = (@mat M M (NUMERAL (BIT1 O)))) /\ ((@matrix_mul N' M N' A' _1119552) = (@mat N' N' (NUMERAL (BIT1 O)))).
Lemma invertible_def {M N' : Type'} : (@invertible M N') = (fun _1119552 : cart (cart R N') M => exists A' : cart (cart R M) N', ((@matrix_mul M N' M _1119552 A') = (@mat M M (NUMERAL (BIT1 O)))) /\ ((@matrix_mul N' M N' A' _1119552) = (@mat N' N' (NUMERAL (BIT1 O))))).
Proof. exact (REFL (@invertible M N')). Qed.
Definition matrix {M N' : Type'} : ((cart R M) -> cart R N') -> cart (cart R M) N' := fun _1119769 : (cart R M) -> cart R N' => @lambda (cart R M) N' (fun i : nat => @lambda R M (fun j : nat => @dollar R N' (_1119769 (@basis M j)) i)).
Lemma matrix_def {M N' : Type'} : (@matrix M N') = (fun _1119769 : (cart R M) -> cart R N' => @lambda (cart R M) N' (fun i : nat => @lambda R M (fun j : nat => @dollar R N' (_1119769 (@basis M j)) i))).
Proof. exact (REFL (@matrix M N')). Qed.
Definition onorm {M N' : Type'} : ((cart R M) -> cart R N') -> R := fun _1119857 : (cart R M) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_2387 : R => exists x : cart R M, @SETSPEC R GEN_PVAR_2387 ((@vector_norm M x) = (R_of_nat (NUMERAL (BIT1 O)))) (@vector_norm N' (_1119857 x)))).
Lemma onorm_def {M N' : Type'} : (@onorm M N') = (fun _1119857 : (cart R M) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_2387 : R => exists x : cart R M, @SETSPEC R GEN_PVAR_2387 ((@vector_norm M x) = (R_of_nat (NUMERAL (BIT1 O)))) (@vector_norm N' (_1119857 x))))).
Proof. exact (REFL (@onorm M N')). Qed.
Definition lift : R -> cart R unit := fun _1121693 : R => @lambda R unit (fun i : nat => _1121693).
Lemma lift_def : lift = (fun _1121693 : R => @lambda R unit (fun i : nat => _1121693)).
Proof. exact (REFL lift). Qed.
Definition drop : (cart R unit) -> R := fun _1121698 : cart R unit => @dollar R unit _1121698 (NUMERAL (BIT1 O)).
Lemma drop_def : drop = (fun _1121698 : cart R unit => @dollar R unit _1121698 (NUMERAL (BIT1 O))).
Proof. exact (REFL drop). Qed.
Definition indicator {M : Type'} : ((cart R M) -> Prop) -> (cart R M) -> cart R unit := fun _1123466 : (cart R M) -> Prop => fun x : cart R M => @COND (cart R unit) (@IN (cart R M) x _1123466) (@vec unit (NUMERAL (BIT1 O))) (@vec unit (NUMERAL O)).
Lemma indicator_def {M : Type'} : (@indicator M) = (fun _1123466 : (cart R M) -> Prop => fun x : cart R M => @COND (cart R unit) (@IN (cart R M) x _1123466) (@vec unit (NUMERAL (BIT1 O))) (@vec unit (NUMERAL O))).
Proof. exact (REFL (@indicator M)). Qed.
Definition dropout {M N' : Type'} : nat -> (cart R M) -> cart R N' := fun _1123989 : nat => fun _1123990 : cart R M => @lambda R N' (fun i : nat => @COND R ((ltn i _1123989) /\ (leqn i (@dimindex M (@setT M)))) (@dollar R M _1123990 i) (@COND R (leqn (addn i (NUMERAL (BIT1 O))) (@dimindex M (@setT M))) (@dollar R M _1123990 (addn i (NUMERAL (BIT1 O)))) (R_of_nat (NUMERAL O)))).
Lemma dropout_def {M N' : Type'} : (@dropout M N') = (fun _1123989 : nat => fun _1123990 : cart R M => @lambda R N' (fun i : nat => @COND R ((ltn i _1123989) /\ (leqn i (@dimindex M (@setT M)))) (@dollar R M _1123990 i) (@COND R (leqn (addn i (NUMERAL (BIT1 O))) (@dimindex M (@setT M))) (@dollar R M _1123990 (addn i (NUMERAL (BIT1 O)))) (R_of_nat (NUMERAL O))))).
Proof. exact (REFL (@dropout M N')). Qed.
Definition pushin {_612312 _612313 _612324 : Type'} : nat -> _612313 -> (cart _612313 _612324) -> cart _612313 _612312 := fun _1124001 : nat => fun _1124002 : _612313 => fun _1124003 : cart _612313 _612324 => @lambda _612313 _612312 (fun i : nat => @COND _612313 (ltn i _1124001) (@dollar _612313 _612324 _1124003 i) (@COND _612313 (i = _1124001) _1124002 (@dollar _612313 _612324 _1124003 (subn i (NUMERAL (BIT1 O)))))).
Lemma pushin_def {_612312 _612313 _612324 : Type'} : (@pushin _612312 _612313 _612324) = (fun _1124001 : nat => fun _1124002 : _612313 => fun _1124003 : cart _612313 _612324 => @lambda _612313 _612312 (fun i : nat => @COND _612313 (ltn i _1124001) (@dollar _612313 _612324 _1124003 i) (@COND _612313 (i = _1124001) _1124002 (@dollar _612313 _612324 _1124003 (subn i (NUMERAL (BIT1 O))))))).
Proof. exact (REFL (@pushin _612312 _612313 _612324)). Qed.
Definition subspace {_613426 : Type'} : ((cart R _613426) -> Prop) -> Prop := fun _1124405 : (cart R _613426) -> Prop => (@IN (cart R _613426) (@vec _613426 (NUMERAL O)) _1124405) /\ ((forall x : cart R _613426, forall y : cart R _613426, ((@IN (cart R _613426) x _1124405) /\ (@IN (cart R _613426) y _1124405)) -> @IN (cart R _613426) (@vector_add _613426 x y) _1124405) /\ (forall c : R, forall x : cart R _613426, (@IN (cart R _613426) x _1124405) -> @IN (cart R _613426) (@percent _613426 c x) _1124405)).
Lemma subspace_def {_613426 : Type'} : (@subspace _613426) = (fun _1124405 : (cart R _613426) -> Prop => (@IN (cart R _613426) (@vec _613426 (NUMERAL O)) _1124405) /\ ((forall x : cart R _613426, forall y : cart R _613426, ((@IN (cart R _613426) x _1124405) /\ (@IN (cart R _613426) y _1124405)) -> @IN (cart R _613426) (@vector_add _613426 x y) _1124405) /\ (forall c : R, forall x : cart R _613426, (@IN (cart R _613426) x _1124405) -> @IN (cart R _613426) (@percent _613426 c x) _1124405))).
Proof. exact (REFL (@subspace _613426)). Qed.
Definition span {_613438 : Type'} : ((cart R _613438) -> Prop) -> (cart R _613438) -> Prop := fun _1124410 : (cart R _613438) -> Prop => @hull (cart R _613438) (@subspace _613438) _1124410.
Lemma span_def {_613438 : Type'} : (@span _613438) = (fun _1124410 : (cart R _613438) -> Prop => @hull (cart R _613438) (@subspace _613438) _1124410).
Proof. exact (REFL (@span _613438)). Qed.
Definition dependent {_613456 : Type'} : ((cart R _613456) -> Prop) -> Prop := fun _1124415 : (cart R _613456) -> Prop => exists a : cart R _613456, (@IN (cart R _613456) a _1124415) /\ (@IN (cart R _613456) a (@span _613456 (@DELETE (cart R _613456) _1124415 a))).
Lemma dependent_def {_613456 : Type'} : (@dependent _613456) = (fun _1124415 : (cart R _613456) -> Prop => exists a : cart R _613456, (@IN (cart R _613456) a _1124415) /\ (@IN (cart R _613456) a (@span _613456 (@DELETE (cart R _613456) _1124415 a)))).
Proof. exact (REFL (@dependent _613456)). Qed.
Definition independent {_613466 : Type'} : ((cart R _613466) -> Prop) -> Prop := fun _1124420 : (cart R _613466) -> Prop => ~ (@dependent _613466 _1124420).
Lemma independent_def {_613466 : Type'} : (@independent _613466) = (fun _1124420 : (cart R _613466) -> Prop => ~ (@dependent _613466 _1124420)).
Proof. exact (REFL (@independent _613466)). Qed.
Definition dim {N' : Type'} : ((cart R N') -> Prop) -> nat := fun _1133139 : (cart R N') -> Prop => @ε nat (fun n : nat => exists b : (cart R N') -> Prop, (@subset (cart R N') b _1133139) /\ ((@independent N' b) /\ ((@subset (cart R N') _1133139 (@span N' b)) /\ (@HAS_SIZE (cart R N') b n)))).
Lemma dim_def {N' : Type'} : (@dim N') = (fun _1133139 : (cart R N') -> Prop => @ε nat (fun n : nat => exists b : (cart R N') -> Prop, (@subset (cart R N') b _1133139) /\ ((@independent N' b) /\ ((@subset (cart R N') _1133139 (@span N' b)) /\ (@HAS_SIZE (cart R N') b n))))).
Proof. exact (REFL (@dim N')). Qed.
Definition euclidean_matroid {N' : Type'} : Matroid (cart R N') := @matroid (cart R N') (@pair ((cart R N') -> Prop) (((cart R N') -> Prop) -> (cart R N') -> Prop) (@setT (cart R N')) (@span N')).
Lemma euclidean_matroid_def {N' : Type'} : (@euclidean_matroid N') = (@matroid (cart R N') (@pair ((cart R N') -> Prop) (((cart R N') -> Prop) -> (cart R N') -> Prop) (@setT (cart R N')) (@span N'))).
Proof. exact (REFL (@euclidean_matroid N')). Qed.
Definition rowvector {N' : Type'} : (cart R N') -> cart (cart R N') unit := fun _1148211 : cart R N' => @lambda (cart R N') unit (fun i : nat => @lambda R N' (fun j : nat => @dollar R N' _1148211 j)).
Lemma rowvector_def {N' : Type'} : (@rowvector N') = (fun _1148211 : cart R N' => @lambda (cart R N') unit (fun i : nat => @lambda R N' (fun j : nat => @dollar R N' _1148211 j))).
Proof. exact (REFL (@rowvector N')). Qed.
Definition columnvector {N' : Type'} : (cart R N') -> cart (cart R unit) N' := fun _1148216 : cart R N' => @lambda (cart R unit) N' (fun i : nat => @lambda R unit (fun j : nat => @dollar R N' _1148216 i)).
Lemma columnvector_def {N' : Type'} : (@columnvector N') = (fun _1148216 : cart R N' => @lambda (cart R unit) N' (fun i : nat => @lambda R unit (fun j : nat => @dollar R N' _1148216 i))).
Proof. exact (REFL (@columnvector N')). Qed.
Definition rank {M N' : Type'} : (cart (cart R M) N') -> nat := fun _1148442 : cart (cart R M) N' => @dim N' (@columns N' M _1148442).
Lemma rank_def {M N' : Type'} : (@rank M N') = (fun _1148442 : cart (cart R M) N' => @dim N' (@columns N' M _1148442)).
Proof. exact (REFL (@rank M N')). Qed.
Definition matrix_inv {M N' : Type'} : (cart (cart R M) N') -> cart (cart R N') M := fun _1166373 : cart (cart R M) N' => @matrix N' M (fun y : cart R N' => @ε (cart R M) (fun x : cart R M => (forall w : cart R M, ((@matrix_vector_mul N' M _1166373 w) = (@vec N' (NUMERAL O))) -> @orthogonal M x w) /\ (forall z : cart R M, @orthogonal N' (@vector_sub N' y (@matrix_vector_mul N' M _1166373 x)) (@matrix_vector_mul N' M _1166373 z)))).
Lemma matrix_inv_def {M N' : Type'} : (@matrix_inv M N') = (fun _1166373 : cart (cart R M) N' => @matrix N' M (fun y : cart R N' => @ε (cart R M) (fun x : cart R M => (forall w : cart R M, ((@matrix_vector_mul N' M _1166373 w) = (@vec N' (NUMERAL O))) -> @orthogonal M x w) /\ (forall z : cart R M, @orthogonal N' (@vector_sub N' y (@matrix_vector_mul N' M _1166373 x)) (@matrix_vector_mul N' M _1166373 z))))).
Proof. exact (REFL (@matrix_inv M N')). Qed.
Definition infnorm {N' : Type'} : (cart R N') -> R := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (cart R N') -> R) (fun infnorm' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (cart R N') -> R => forall _1168851 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall x : cart R N', (infnorm' _1168851 x) = (sup (@GSPEC R (fun GEN_PVAR_2493 : R => exists i : nat, @SETSPEC R GEN_PVAR_2493 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) (normr (@dollar R N' x i)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))).
Lemma infnorm_def {N' : Type'} : (@infnorm N') = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (cart R N') -> R) (fun infnorm' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (cart R N') -> R => forall _1168851 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall x : cart R N', (infnorm' _1168851 x) = (sup (@GSPEC R (fun GEN_PVAR_2493 : R => exists i : nat, @SETSPEC R GEN_PVAR_2493 ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) (normr (@dollar R N' x i)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))).
Proof. exact (REFL (@infnorm N')). Qed.
Definition collinear {_646845 : Type'} : ((cart R _646845) -> Prop) -> Prop := fun _1169279 : (cart R _646845) -> Prop => exists u : cart R _646845, forall x : cart R _646845, forall y : cart R _646845, ((@IN (cart R _646845) x _1169279) /\ (@IN (cart R _646845) y _1169279)) -> exists c : R, (@vector_sub _646845 x y) = (@percent _646845 c u).
Lemma collinear_def {_646845 : Type'} : (@collinear _646845) = (fun _1169279 : (cart R _646845) -> Prop => exists u : cart R _646845, forall x : cart R _646845, forall y : cart R _646845, ((@IN (cart R _646845) x _1169279) /\ (@IN (cart R _646845) y _1169279)) -> exists c : R, (@vector_sub _646845 x y) = (@percent _646845 c u)).
Proof. exact (REFL (@collinear _646845)). Qed.
Definition between {_648532 : Type'} : (cart R _648532) -> (prod (cart R _648532) (cart R _648532)) -> Prop := fun _1170807 : cart R _648532 => fun _1170808 : prod (cart R _648532) (cart R _648532) => (@distance _648532 (@pair (cart R _648532) (cart R _648532) (@fst (cart R _648532) (cart R _648532) _1170808) (@snd (cart R _648532) (cart R _648532) _1170808))) = (addr (@distance _648532 (@pair (cart R _648532) (cart R _648532) (@fst (cart R _648532) (cart R _648532) _1170808) _1170807)) (@distance _648532 (@pair (cart R _648532) (cart R _648532) _1170807 (@snd (cart R _648532) (cart R _648532) _1170808)))).
Lemma between_def {_648532 : Type'} : (@between _648532) = (fun _1170807 : cart R _648532 => fun _1170808 : prod (cart R _648532) (cart R _648532) => (@distance _648532 (@pair (cart R _648532) (cart R _648532) (@fst (cart R _648532) (cart R _648532) _1170808) (@snd (cart R _648532) (cart R _648532) _1170808))) = (addr (@distance _648532 (@pair (cart R _648532) (cart R _648532) (@fst (cart R _648532) (cart R _648532) _1170808) _1170807)) (@distance _648532 (@pair (cart R _648532) (cart R _648532) _1170807 (@snd (cart R _648532) (cart R _648532) _1170808))))).
Proof. exact (REFL (@between _648532)). Qed.
Definition midpoint {_649703 : Type'} : (prod (cart R _649703) (cart R _649703)) -> cart R _649703 := fun _1171471 : prod (cart R _649703) (cart R _649703) => @percent _649703 (invr (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) (@vector_add _649703 (@fst (cart R _649703) (cart R _649703) _1171471) (@snd (cart R _649703) (cart R _649703) _1171471)).
Lemma midpoint_def {_649703 : Type'} : (@midpoint _649703) = (fun _1171471 : prod (cart R _649703) (cart R _649703) => @percent _649703 (invr (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) (@vector_add _649703 (@fst (cart R _649703) (cart R _649703) _1171471) (@snd (cart R _649703) (cart R _649703) _1171471))).
Proof. exact (REFL (@midpoint _649703)). Qed.
Definition open_interval {N' : Type'} : (prod (cart R N') (cart R N')) -> (cart R N') -> Prop := fun _1171554 : prod (cart R N') (cart R N') => @GSPEC (cart R N') (fun GEN_PVAR_2498 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2498 (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> (ltr (@dollar R N' (@fst (cart R N') (cart R N') _1171554) i) (@dollar R N' x i)) /\ (ltr (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') _1171554) i))) x).
Lemma open_interval_def {N' : Type'} : (@open_interval N') = (fun _1171554 : prod (cart R N') (cart R N') => @GSPEC (cart R N') (fun GEN_PVAR_2498 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2498 (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> (ltr (@dollar R N' (@fst (cart R N') (cart R N') _1171554) i) (@dollar R N' x i)) /\ (ltr (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') _1171554) i))) x)).
Proof. exact (REFL (@open_interval N')). Qed.
Definition closed_interval {N' : Type'} : (seq (prod (cart R N') (cart R N'))) -> (cart R N') -> Prop := fun _1171563 : seq (prod (cart R N') (cart R N')) => @GSPEC (cart R N') (fun GEN_PVAR_2499 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2499 (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> (ler (@dollar R N' (@fst (cart R N') (cart R N') (@HD (prod (cart R N') (cart R N')) _1171563)) i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') (@HD (prod (cart R N') (cart R N')) _1171563)) i))) x).
Lemma closed_interval_def {N' : Type'} : (@closed_interval N') = (fun _1171563 : seq (prod (cart R N') (cart R N')) => @GSPEC (cart R N') (fun GEN_PVAR_2499 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_2499 (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> (ler (@dollar R N' (@fst (cart R N') (cart R N') (@HD (prod (cart R N') (cart R N')) _1171563)) i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' (@snd (cart R N') (cart R N') (@HD (prod (cart R N') (cart R N')) _1171563)) i))) x)).
Proof. exact (REFL (@closed_interval N')). Qed.
Definition trace {N' : Type'} : (cart (cart R N') N') -> R := fun _1178989 : cart (cart R N') N' => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @dollar R N' (@dollar (cart R N') N' _1178989 i) i).
Lemma trace_def {N' : Type'} : (@trace N') = (fun _1178989 : cart (cart R N') N' => @sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @dollar R N' (@dollar (cart R N') N' _1178989 i) i)).
Proof. exact (REFL (@trace N')). Qed.
Definition det {N' : Type'} : (cart (cart R N') N') -> R := fun _1179002 : cart (cart R N') N' => @sum (nat -> nat) (@GSPEC (nat -> nat) (fun GEN_PVAR_2514 : nat -> nat => exists p : nat -> nat, @SETSPEC (nat -> nat) GEN_PVAR_2514 (@permutes nat p (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) p)) (fun p : nat -> nat => mulr (@sign nat p) (@product nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @dollar R N' (@dollar (cart R N') N' _1179002 i) (p i)))).
Lemma det_def {N' : Type'} : (@det N') = (fun _1179002 : cart (cart R N') N' => @sum (nat -> nat) (@GSPEC (nat -> nat) (fun GEN_PVAR_2514 : nat -> nat => exists p : nat -> nat, @SETSPEC (nat -> nat) GEN_PVAR_2514 (@permutes nat p (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) p)) (fun p : nat -> nat => mulr (@sign nat p) (@product nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @dollar R N' (@dollar (cart R N') N' _1179002 i) (p i))))).
Proof. exact (REFL (@det N')). Qed.
Definition cofactor {N' : Type'} : (cart (cart R N') N') -> cart (cart R N') N' := fun _1184151 : cart (cart R N') N' => @lambda (cart R N') N' (fun i : nat => @lambda R N' (fun j : nat => @det N' (@lambda (cart R N') N' (fun k : nat => @lambda R N' (fun l : nat => @COND R ((k = i) /\ (l = j)) (R_of_nat (NUMERAL (BIT1 O))) (@COND R ((k = i) \/ (l = j)) (R_of_nat (NUMERAL O)) (@dollar R N' (@dollar (cart R N') N' _1184151 k) l))))))).
Lemma cofactor_def {N' : Type'} : (@cofactor N') = (fun _1184151 : cart (cart R N') N' => @lambda (cart R N') N' (fun i : nat => @lambda R N' (fun j : nat => @det N' (@lambda (cart R N') N' (fun k : nat => @lambda R N' (fun l : nat => @COND R ((k = i) /\ (l = j)) (R_of_nat (NUMERAL (BIT1 O))) (@COND R ((k = i) \/ (l = j)) (R_of_nat (NUMERAL O)) (@dollar R N' (@dollar (cart R N') N' _1184151 k) l)))))))).
Proof. exact (REFL (@cofactor N')). Qed.
Definition diagonal_matrix {M N' : Type'} : (cart (cart R N') M) -> Prop := fun _1190955 : cart (cart R N') M => forall i : nat, forall j : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ ((leqn i (@dimindex M (@setT M))) /\ ((leqn (NUMERAL (BIT1 O)) j) /\ ((leqn j (@dimindex N' (@setT N'))) /\ (~ (i = j)))))) -> (@dollar R N' (@dollar (cart R N') M _1190955 i) j) = (R_of_nat (NUMERAL O)).
Lemma diagonal_matrix_def {M N' : Type'} : (@diagonal_matrix M N') = (fun _1190955 : cart (cart R N') M => forall i : nat, forall j : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ ((leqn i (@dimindex M (@setT M))) /\ ((leqn (NUMERAL (BIT1 O)) j) /\ ((leqn j (@dimindex N' (@setT N'))) /\ (~ (i = j)))))) -> (@dollar R N' (@dollar (cart R N') M _1190955 i) j) = (R_of_nat (NUMERAL O))).
Proof. exact (REFL (@diagonal_matrix M N')). Qed.
Definition positive_semidefinite {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1191775 : cart (cart R N') N' => (@symmetric_matrix N' _1191775) /\ (forall x : cart R N', ler (R_of_nat (NUMERAL O)) (@dot N' x (@matrix_vector_mul N' N' _1191775 x))).
Lemma positive_semidefinite_def {N' : Type'} : (@positive_semidefinite N') = (fun _1191775 : cart (cart R N') N' => (@symmetric_matrix N' _1191775) /\ (forall x : cart R N', ler (R_of_nat (NUMERAL O)) (@dot N' x (@matrix_vector_mul N' N' _1191775 x)))).
Proof. exact (REFL (@positive_semidefinite N')). Qed.
Definition positive_definite {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1192399 : cart (cart R N') N' => (@symmetric_matrix N' _1192399) /\ (forall x : cart R N', (~ (x = (@vec N' (NUMERAL O)))) -> ltr (R_of_nat (NUMERAL O)) (@dot N' x (@matrix_vector_mul N' N' _1192399 x))).
Lemma positive_definite_def {N' : Type'} : (@positive_definite N') = (fun _1192399 : cart (cart R N') N' => (@symmetric_matrix N' _1192399) /\ (forall x : cart R N', (~ (x = (@vec N' (NUMERAL O)))) -> ltr (R_of_nat (NUMERAL O)) (@dot N' x (@matrix_vector_mul N' N' _1192399 x)))).
Proof. exact (REFL (@positive_definite N')). Qed.
Definition orthogonal_transformation {N' : Type'} : ((cart R N') -> cart R N') -> Prop := fun _1193108 : (cart R N') -> cart R N' => (@linear N' N' _1193108) /\ (forall v : cart R N', forall w : cart R N', (@dot N' (_1193108 v) (_1193108 w)) = (@dot N' v w)).
Lemma orthogonal_transformation_def {N' : Type'} : (@orthogonal_transformation N') = (fun _1193108 : (cart R N') -> cart R N' => (@linear N' N' _1193108) /\ (forall v : cart R N', forall w : cart R N', (@dot N' (_1193108 v) (_1193108 w)) = (@dot N' v w))).
Proof. exact (REFL (@orthogonal_transformation N')). Qed.
Definition orthogonal_matrix {N' : Type'} : (cart (cart R N') N') -> Prop := fun _1193273 : cart (cart R N') N' => ((@matrix_mul N' N' N' (@transp N' N' _1193273) _1193273) = (@mat N' N' (NUMERAL (BIT1 O)))) /\ ((@matrix_mul N' N' N' _1193273 (@transp N' N' _1193273)) = (@mat N' N' (NUMERAL (BIT1 O)))).
Lemma orthogonal_matrix_def {N' : Type'} : (@orthogonal_matrix N') = (fun _1193273 : cart (cart R N') N' => ((@matrix_mul N' N' N' (@transp N' N' _1193273) _1193273) = (@mat N' N' (NUMERAL (BIT1 O)))) /\ ((@matrix_mul N' N' N' _1193273 (@transp N' N' _1193273)) = (@mat N' N' (NUMERAL (BIT1 O))))).
Proof. exact (REFL (@orthogonal_matrix N')). Qed.
Definition rotation_matrix {_681649 : Type'} : (cart (cart R _681649) _681649) -> Prop := fun _1201330 : cart (cart R _681649) _681649 => (@orthogonal_matrix _681649 _1201330) /\ ((@det _681649 _1201330) = (R_of_nat (NUMERAL (BIT1 O)))).
Lemma rotation_matrix_def {_681649 : Type'} : (@rotation_matrix _681649) = (fun _1201330 : cart (cart R _681649) _681649 => (@orthogonal_matrix _681649 _1201330) /\ ((@det _681649 _1201330) = (R_of_nat (NUMERAL (BIT1 O))))).
Proof. exact (REFL (@rotation_matrix _681649)). Qed.
Definition rotoinversion_matrix {_681664 : Type'} : (cart (cart R _681664) _681664) -> Prop := fun _1201335 : cart (cart R _681664) _681664 => (@orthogonal_matrix _681664 _1201335) /\ ((@det _681664 _1201335) = (oppr (R_of_nat (NUMERAL (BIT1 O))))).
Lemma rotoinversion_matrix_def {_681664 : Type'} : (@rotoinversion_matrix _681664) = (fun _1201335 : cart (cart R _681664) _681664 => (@orthogonal_matrix _681664 _1201335) /\ ((@det _681664 _1201335) = (oppr (R_of_nat (NUMERAL (BIT1 O)))))).
Proof. exact (REFL (@rotoinversion_matrix _681664)). Qed.
Definition reflect_along {N' : Type'} : (cart R N') -> (cart R N') -> cart R N' := fun _1206029 : cart R N' => fun _1206030 : cart R N' => @vector_sub N' _1206030 (@percent N' (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (divr (@dot N' _1206030 _1206029) (@dot N' _1206029 _1206029))) _1206029).
Lemma reflect_along_def {N' : Type'} : (@reflect_along N') = (fun _1206029 : cart R N' => fun _1206030 : cart R N' => @vector_sub N' _1206030 (@percent N' (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (divr (@dot N' _1206030 _1206029) (@dot N' _1206029 _1206029))) _1206029)).
Proof. exact (REFL (@reflect_along N')). Qed.
Definition _open {_689620 : Type'} : ((cart R _689620) -> Prop) -> Prop := fun _1208192 : (cart R _689620) -> Prop => forall x : cart R _689620, (@IN (cart R _689620) x _1208192) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall x' : cart R _689620, (ltr (@distance _689620 (@pair (cart R _689620) (cart R _689620) x' x)) e) -> @IN (cart R _689620) x' _1208192).
Lemma _open_def {_689620 : Type'} : (@_open _689620) = (fun _1208192 : (cart R _689620) -> Prop => forall x : cart R _689620, (@IN (cart R _689620) x _1208192) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall x' : cart R _689620, (ltr (@distance _689620 (@pair (cart R _689620) (cart R _689620) x' x)) e) -> @IN (cart R _689620) x' _1208192)).
Proof. exact (REFL (@_open _689620)). Qed.
Definition euclidean {_689636 : Type'} : Topology (cart R _689636) := @topology (cart R _689636) (@_open _689636).
Lemma euclidean_def {_689636 : Type'} : (@euclidean _689636) = (@topology (cart R _689636) (@_open _689636)).
Proof. exact (REFL (@euclidean _689636)). Qed.
Definition euclidean_metric {N' : Type'} : Metric (cart R N') := @metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@setT (cart R N')) (@distance N')).
Lemma euclidean_metric_def {N' : Type'} : (@euclidean_metric N') = (@metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@setT (cart R N')) (@distance N'))).
Proof. exact (REFL (@euclidean_metric N')). Qed.
Definition closed {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1208222 : (cart R N') -> Prop => @_open N' (@setD (cart R N') (@setT (cart R N')) _1208222).
Lemma closed_def {N' : Type'} : (@closed N') = (fun _1208222 : (cart R N') -> Prop => @_open N' (@setD (cart R N') (@setT (cart R N')) _1208222)).
Proof. exact (REFL (@closed N')). Qed.
Definition ball {_691388 : Type'} : (prod (cart R _691388) R) -> (cart R _691388) -> Prop := fun _1208619 : prod (cart R _691388) R => @GSPEC (cart R _691388) (fun GEN_PVAR_2710 : cart R _691388 => exists y : cart R _691388, @SETSPEC (cart R _691388) GEN_PVAR_2710 (ltr (@distance _691388 (@pair (cart R _691388) (cart R _691388) (@fst (cart R _691388) R _1208619) y)) (@snd (cart R _691388) R _1208619)) y).
Lemma ball_def {_691388 : Type'} : (@ball _691388) = (fun _1208619 : prod (cart R _691388) R => @GSPEC (cart R _691388) (fun GEN_PVAR_2710 : cart R _691388 => exists y : cart R _691388, @SETSPEC (cart R _691388) GEN_PVAR_2710 (ltr (@distance _691388 (@pair (cart R _691388) (cart R _691388) (@fst (cart R _691388) R _1208619) y)) (@snd (cart R _691388) R _1208619)) y)).
Proof. exact (REFL (@ball _691388)). Qed.
Definition cball {_691481 : Type'} : (prod (cart R _691481) R) -> (cart R _691481) -> Prop := fun _1208628 : prod (cart R _691481) R => @GSPEC (cart R _691481) (fun GEN_PVAR_2711 : cart R _691481 => exists y : cart R _691481, @SETSPEC (cart R _691481) GEN_PVAR_2711 (ler (@distance _691481 (@pair (cart R _691481) (cart R _691481) (@fst (cart R _691481) R _1208628) y)) (@snd (cart R _691481) R _1208628)) y).
Lemma cball_def {_691481 : Type'} : (@cball _691481) = (fun _1208628 : prod (cart R _691481) R => @GSPEC (cart R _691481) (fun GEN_PVAR_2711 : cart R _691481 => exists y : cart R _691481, @SETSPEC (cart R _691481) GEN_PVAR_2711 (ler (@distance _691481 (@pair (cart R _691481) (cart R _691481) (@fst (cart R _691481) R _1208628) y)) (@snd (cart R _691481) R _1208628)) y)).
Proof. exact (REFL (@cball _691481)). Qed.
Definition sphere {_691574 : Type'} : (prod (cart R _691574) R) -> (cart R _691574) -> Prop := fun _1208637 : prod (cart R _691574) R => @GSPEC (cart R _691574) (fun GEN_PVAR_2712 : cart R _691574 => exists y : cart R _691574, @SETSPEC (cart R _691574) GEN_PVAR_2712 ((@distance _691574 (@pair (cart R _691574) (cart R _691574) (@fst (cart R _691574) R _1208637) y)) = (@snd (cart R _691574) R _1208637)) y).
Lemma sphere_def {_691574 : Type'} : (@sphere _691574) = (fun _1208637 : prod (cart R _691574) R => @GSPEC (cart R _691574) (fun GEN_PVAR_2712 : cart R _691574 => exists y : cart R _691574, @SETSPEC (cart R _691574) GEN_PVAR_2712 ((@distance _691574 (@pair (cart R _691574) (cart R _691574) (@fst (cart R _691574) R _1208637) y)) = (@snd (cart R _691574) R _1208637)) y)).
Proof. exact (REFL (@sphere _691574)). Qed.
Definition manhattan {N' : Type'} : Metric (cart R N') := @metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@setT (cart R N')) (@GABS ((prod (cart R N') (cart R N')) -> R) (fun f : (prod (cart R N') (cart R N')) -> R => forall x : cart R N', forall y : cart R N', @eq R (f (@pair (cart R N') (cart R N') x y)) (@sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => normr (subr (@dollar R N' x i) (@dollar R N' y i))))))).
Lemma manhattan_def {N' : Type'} : (@manhattan N') = (@metric (cart R N') (@pair ((cart R N') -> Prop) ((prod (cart R N') (cart R N')) -> R) (@setT (cart R N')) (@GABS ((prod (cart R N') (cart R N')) -> R) (fun f : (prod (cart R N') (cart R N')) -> R => forall x : cart R N', forall y : cart R N', @eq R (f (@pair (cart R N') (cart R N') x y)) (@sum nat (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => normr (subr (@dollar R N' x i) (@dollar R N' y i)))))))).
Proof. exact (REFL (@manhattan N')). Qed.
Definition closed_segment {_694885 : Type'} : (seq (prod (cart R _694885) (cart R _694885))) -> (cart R _694885) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) -> (seq (prod (cart R _694885) (cart R _694885))) -> (cart R _694885) -> Prop) (fun closed_segment' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) -> (seq (prod (cart R _694885) (cart R _694885))) -> (cart R _694885) -> Prop => forall _1210835 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))), forall a : cart R _694885, forall b : cart R _694885, (closed_segment' _1210835 (@cons (prod (cart R _694885) (cart R _694885)) (@pair (cart R _694885) (cart R _694885) a b) (@nil (prod (cart R _694885) (cart R _694885))))) = (@GSPEC (cart R _694885) (fun GEN_PVAR_2714 : cart R _694885 => exists u : R, @SETSPEC (cart R _694885) GEN_PVAR_2714 ((ler (R_of_nat (NUMERAL O)) u) /\ (ler u (R_of_nat (NUMERAL (BIT1 O))))) (@vector_add _694885 (@percent _694885 (subr (R_of_nat (NUMERAL (BIT1 O))) u) a) (@percent _694885 u b))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))))))))))).
Lemma closed_segment_def {_694885 : Type'} : (@closed_segment _694885) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) -> (seq (prod (cart R _694885) (cart R _694885))) -> (cart R _694885) -> Prop) (fun closed_segment' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) -> (seq (prod (cart R _694885) (cart R _694885))) -> (cart R _694885) -> Prop => forall _1210835 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))), forall a : cart R _694885, forall b : cart R _694885, (closed_segment' _1210835 (@cons (prod (cart R _694885) (cart R _694885)) (@pair (cart R _694885) (cart R _694885) a b) (@nil (prod (cart R _694885) (cart R _694885))))) = (@GSPEC (cart R _694885) (fun GEN_PVAR_2714 : cart R _694885 => exists u : R, @SETSPEC (cart R _694885) GEN_PVAR_2714 ((ler (R_of_nat (NUMERAL O)) u) /\ (ler u (R_of_nat (NUMERAL (BIT1 O))))) (@vector_add _694885 (@percent _694885 (subr (R_of_nat (NUMERAL (BIT1 O))) u) a) (@percent _694885 u b))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))))))))))))).
Proof. exact (REFL (@closed_segment _694885)). Qed.
Definition open_segment {_694902 : Type'} : (prod (cart R _694902) (cart R _694902)) -> (cart R _694902) -> Prop := fun _1210836 : prod (cart R _694902) (cart R _694902) => @setD (cart R _694902) (@closed_segment _694902 (@cons (prod (cart R _694902) (cart R _694902)) (@pair (cart R _694902) (cart R _694902) (@fst (cart R _694902) (cart R _694902) _1210836) (@snd (cart R _694902) (cart R _694902) _1210836)) (@nil (prod (cart R _694902) (cart R _694902))))) (@INSERT (cart R _694902) (@fst (cart R _694902) (cart R _694902) _1210836) (@INSERT (cart R _694902) (@snd (cart R _694902) (cart R _694902) _1210836) (@set0 (cart R _694902)))).
Lemma open_segment_def {_694902 : Type'} : (@open_segment _694902) = (fun _1210836 : prod (cart R _694902) (cart R _694902) => @setD (cart R _694902) (@closed_segment _694902 (@cons (prod (cart R _694902) (cart R _694902)) (@pair (cart R _694902) (cart R _694902) (@fst (cart R _694902) (cart R _694902) _1210836) (@snd (cart R _694902) (cart R _694902) _1210836)) (@nil (prod (cart R _694902) (cart R _694902))))) (@INSERT (cart R _694902) (@fst (cart R _694902) (cart R _694902) _1210836) (@INSERT (cart R _694902) (@snd (cart R _694902) (cart R _694902) _1210836) (@set0 (cart R _694902))))).
Proof. exact (REFL (@open_segment _694902)). Qed.
Definition connected {_697371 : Type'} : ((cart R _697371) -> Prop) -> Prop := fun _1211946 : (cart R _697371) -> Prop => ~ (exists e1 : (cart R _697371) -> Prop, exists e2 : (cart R _697371) -> Prop, (@_open _697371 e1) /\ ((@_open _697371 e2) /\ ((@subset (cart R _697371) _1211946 (@setU (cart R _697371) e1 e2)) /\ (((@setI (cart R _697371) e1 (@setI (cart R _697371) e2 _1211946)) = (@set0 (cart R _697371))) /\ ((~ ((@setI (cart R _697371) e1 _1211946) = (@set0 (cart R _697371)))) /\ (~ ((@setI (cart R _697371) e2 _1211946) = (@set0 (cart R _697371))))))))).
Lemma connected_def {_697371 : Type'} : (@connected _697371) = (fun _1211946 : (cart R _697371) -> Prop => ~ (exists e1 : (cart R _697371) -> Prop, exists e2 : (cart R _697371) -> Prop, (@_open _697371 e1) /\ ((@_open _697371 e2) /\ ((@subset (cart R _697371) _1211946 (@setU (cart R _697371) e1 e2)) /\ (((@setI (cart R _697371) e1 (@setI (cart R _697371) e2 _1211946)) = (@set0 (cart R _697371))) /\ ((~ ((@setI (cart R _697371) e1 _1211946) = (@set0 (cart R _697371)))) /\ (~ ((@setI (cart R _697371) e2 _1211946) = (@set0 (cart R _697371)))))))))).
Proof. exact (REFL (@connected _697371)). Qed.
Definition limit_point_of {_699948 : Type'} : (cart R _699948) -> ((cart R _699948) -> Prop) -> Prop := fun _1214369 : cart R _699948 => fun _1214370 : (cart R _699948) -> Prop => forall t : (cart R _699948) -> Prop, ((@IN (cart R _699948) _1214369 t) /\ (@_open _699948 t)) -> exists y : cart R _699948, (~ (y = _1214369)) /\ ((@IN (cart R _699948) y _1214370) /\ (@IN (cart R _699948) y t)).
Lemma limit_point_of_def {_699948 : Type'} : (@limit_point_of _699948) = (fun _1214369 : cart R _699948 => fun _1214370 : (cart R _699948) -> Prop => forall t : (cart R _699948) -> Prop, ((@IN (cart R _699948) _1214369 t) /\ (@_open _699948 t)) -> exists y : cart R _699948, (~ (y = _1214369)) /\ ((@IN (cart R _699948) y _1214370) /\ (@IN (cart R _699948) y t))).
Proof. exact (REFL (@limit_point_of _699948)). Qed.
Definition interior {_701237 : Type'} : ((cart R _701237) -> Prop) -> (cart R _701237) -> Prop := fun _1215203 : (cart R _701237) -> Prop => @GSPEC (cart R _701237) (fun GEN_PVAR_2727 : cart R _701237 => exists x : cart R _701237, @SETSPEC (cart R _701237) GEN_PVAR_2727 (exists t : (cart R _701237) -> Prop, (@_open _701237 t) /\ ((@IN (cart R _701237) x t) /\ (@subset (cart R _701237) t _1215203))) x).
Lemma interior_def {_701237 : Type'} : (@interior _701237) = (fun _1215203 : (cart R _701237) -> Prop => @GSPEC (cart R _701237) (fun GEN_PVAR_2727 : cart R _701237 => exists x : cart R _701237, @SETSPEC (cart R _701237) GEN_PVAR_2727 (exists t : (cart R _701237) -> Prop, (@_open _701237 t) /\ ((@IN (cart R _701237) x t) /\ (@subset (cart R _701237) t _1215203))) x)).
Proof. exact (REFL (@interior _701237)). Qed.
Definition closure {_701871 : Type'} : ((cart R _701871) -> Prop) -> (cart R _701871) -> Prop := fun _1215633 : (cart R _701871) -> Prop => @setU (cart R _701871) _1215633 (@GSPEC (cart R _701871) (fun GEN_PVAR_2729 : cart R _701871 => exists x : cart R _701871, @SETSPEC (cart R _701871) GEN_PVAR_2729 (@limit_point_of _701871 x _1215633) x)).
Lemma closure_def {_701871 : Type'} : (@closure _701871) = (fun _1215633 : (cart R _701871) -> Prop => @setU (cart R _701871) _1215633 (@GSPEC (cart R _701871) (fun GEN_PVAR_2729 : cart R _701871 => exists x : cart R _701871, @SETSPEC (cart R _701871) GEN_PVAR_2729 (@limit_point_of _701871 x _1215633) x))).
Proof. exact (REFL (@closure _701871)). Qed.
Definition frontier {_704202 : Type'} : ((cart R _704202) -> Prop) -> (cart R _704202) -> Prop := fun _1216365 : (cart R _704202) -> Prop => @setD (cart R _704202) (@closure _704202 _1216365) (@interior _704202 _1216365).
Lemma frontier_def {_704202 : Type'} : (@frontier _704202) = (fun _1216365 : (cart R _704202) -> Prop => @setD (cart R _704202) (@closure _704202 _1216365) (@interior _704202 _1216365)).
Proof. exact (REFL (@frontier _704202)). Qed.
Definition _at {_705960 : Type'} : (cart R _705960) -> net (cart R _705960) := fun _1218541 : cart R _705960 => @atpointof (cart R _705960) (@euclidean _705960) _1218541.
Lemma _at_def {_705960 : Type'} : (@_at _705960) = (fun _1218541 : cart R _705960 => @atpointof (cart R _705960) (@euclidean _705960) _1218541).
Proof. exact (REFL (@_at _705960)). Qed.
Definition at_infinity {_706003 : Type'} : net (cart R _706003) := @mk_net (cart R _706003) (@pair (((cart R _706003) -> Prop) -> Prop) ((cart R _706003) -> Prop) (@GSPEC ((cart R _706003) -> Prop) (fun GEN_PVAR_2739 : (cart R _706003) -> Prop => exists b : R, @SETSPEC ((cart R _706003) -> Prop) GEN_PVAR_2739 (@IN R b (@setT R)) (@GSPEC (cart R _706003) (fun GEN_PVAR_2738 : cart R _706003 => exists x : cart R _706003, @SETSPEC (cart R _706003) GEN_PVAR_2738 (ler b (@vector_norm _706003 x)) x)))) (@set0 (cart R _706003))).
Lemma at_infinity_def {_706003 : Type'} : (@at_infinity _706003) = (@mk_net (cart R _706003) (@pair (((cart R _706003) -> Prop) -> Prop) ((cart R _706003) -> Prop) (@GSPEC ((cart R _706003) -> Prop) (fun GEN_PVAR_2739 : (cart R _706003) -> Prop => exists b : R, @SETSPEC ((cart R _706003) -> Prop) GEN_PVAR_2739 (@IN R b (@setT R)) (@GSPEC (cart R _706003) (fun GEN_PVAR_2738 : cart R _706003 => exists x : cart R _706003, @SETSPEC (cart R _706003) GEN_PVAR_2738 (ler b (@vector_norm _706003 x)) x)))) (@set0 (cart R _706003)))).
Proof. exact (REFL (@at_infinity _706003)). Qed.
Definition at_posinfinity : net R := @mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2742 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2742 (@IN R a (@setT R)) (@GSPEC R (fun GEN_PVAR_2741 : R => exists x : R, @SETSPEC R GEN_PVAR_2741 (ler a x) x)))) (@set0 R)).
Lemma at_posinfinity_def : at_posinfinity = (@mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2742 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2742 (@IN R a (@setT R)) (@GSPEC R (fun GEN_PVAR_2741 : R => exists x : R, @SETSPEC R GEN_PVAR_2741 (ler a x) x)))) (@set0 R))).
Proof. exact (REFL at_posinfinity). Qed.
Definition at_neginfinity : net R := @mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2745 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2745 (@IN R a (@setT R)) (@GSPEC R (fun GEN_PVAR_2744 : R => exists x : R, @SETSPEC R GEN_PVAR_2744 (ler x a) x)))) (@set0 R)).
Lemma at_neginfinity_def : at_neginfinity = (@mk_net R (@pair ((R -> Prop) -> Prop) (R -> Prop) (@GSPEC (R -> Prop) (fun GEN_PVAR_2745 : R -> Prop => exists a : R, @SETSPEC (R -> Prop) GEN_PVAR_2745 (@IN R a (@setT R)) (@GSPEC R (fun GEN_PVAR_2744 : R => exists x : R, @SETSPEC R GEN_PVAR_2744 (ler x a) x)))) (@set0 R))).
Proof. exact (REFL at_neginfinity). Qed.
Definition in_direction {_706136 : Type'} : (cart R _706136) -> (cart R _706136) -> net (cart R _706136) := fun _1218546 : cart R _706136 => fun _1218547 : cart R _706136 => @within (cart R _706136) (@_at _706136 _1218546) (@GSPEC (cart R _706136) (fun GEN_PVAR_2746 : cart R _706136 => exists b : cart R _706136, @SETSPEC (cart R _706136) GEN_PVAR_2746 (exists c : R, (ler (R_of_nat (NUMERAL O)) c) /\ ((@vector_sub _706136 b _1218546) = (@percent _706136 c _1218547))) b)).
Lemma in_direction_def {_706136 : Type'} : (@in_direction _706136) = (fun _1218546 : cart R _706136 => fun _1218547 : cart R _706136 => @within (cart R _706136) (@_at _706136 _1218546) (@GSPEC (cart R _706136) (fun GEN_PVAR_2746 : cart R _706136 => exists b : cart R _706136, @SETSPEC (cart R _706136) GEN_PVAR_2746 (exists c : R, (ler (R_of_nat (NUMERAL O)) c) /\ ((@vector_sub _706136 b _1218546) = (@percent _706136 c _1218547))) b))).
Proof. exact (REFL (@in_direction _706136)). Qed.
Definition lim {_708144 _708145 : Type'} : (net _708145) -> (_708145 -> cart R _708144) -> cart R _708144 := fun _1218998 : net _708145 => fun _1218999 : _708145 -> cart R _708144 => @ε (cart R _708144) (fun l : cart R _708144 => @FImp _708144 _708145 _1218999 l _1218998).
Lemma lim_def {_708144 _708145 : Type'} : (@lim _708144 _708145) = (fun _1218998 : net _708145 => fun _1218999 : _708145 -> cart R _708144 => @ε (cart R _708144) (fun l : cart R _708144 => @FImp _708144 _708145 _1218999 l _1218998)).
Proof. exact (REFL (@lim _708144 _708145)). Qed.
Definition condensation_point_of {_710994 : Type'} : (cart R _710994) -> ((cart R _710994) -> Prop) -> Prop := fun _1220140 : cart R _710994 => fun _1220141 : (cart R _710994) -> Prop => forall t : (cart R _710994) -> Prop, ((@IN (cart R _710994) _1220140 t) /\ (@_open _710994 t)) -> ~ (@COUNTABLE (cart R _710994) (@setI (cart R _710994) _1220141 t)).
Lemma condensation_point_of_def {_710994 : Type'} : (@condensation_point_of _710994) = (fun _1220140 : cart R _710994 => fun _1220141 : (cart R _710994) -> Prop => forall t : (cart R _710994) -> Prop, ((@IN (cart R _710994) _1220140 t) /\ (@_open _710994 t)) -> ~ (@COUNTABLE (cart R _710994) (@setI (cart R _710994) _1220141 t))).
Proof. exact (REFL (@condensation_point_of _710994)). Qed.
Definition bounded {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1223728 : (cart R N') -> Prop => exists a : R, forall x : cart R N', (@IN (cart R N') x _1223728) -> ler (@vector_norm N' x) a.
Lemma bounded_def {N' : Type'} : (@bounded N') = (fun _1223728 : (cart R N') -> Prop => exists a : R, forall x : cart R N', (@IN (cart R N') x _1223728) -> ler (@vector_norm N' x) a).
Proof. exact (REFL (@bounded N')). Qed.
Definition compact {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1225825 : (cart R N') -> Prop => forall f : nat -> cart R N', (forall n : nat, @IN (cart R N') (f n) _1225825) -> exists l : cart R N', exists r : nat -> nat, (@IN (cart R N') l _1225825) /\ ((forall m : nat, forall n : nat, (ltn m n) -> ltn (r m) (r n)) /\ (@FImp N' nat (@o nat nat (cart R N') f r) l sequentially)).
Lemma compact_def {N' : Type'} : (@compact N') = (fun _1225825 : (cart R N') -> Prop => forall f : nat -> cart R N', (forall n : nat, @IN (cart R N') (f n) _1225825) -> exists l : cart R N', exists r : nat -> nat, (@IN (cart R N') l _1225825) /\ ((forall m : nat, forall n : nat, (ltn m n) -> ltn (r m) (r n)) /\ (@FImp N' nat (@o nat nat (cart R N') f r) l sequentially))).
Proof. exact (REFL (@compact N')). Qed.
Definition cauchy {N' : Type'} : (nat -> cart R N') -> Prop := fun _1225978 : nat -> cart R N' => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N'' : nat, forall m : nat, forall n : nat, ((geqn m N'') /\ (geqn n N'')) -> ltr (@distance N' (@pair (cart R N') (cart R N') (_1225978 m) (_1225978 n))) e.
Lemma cauchy_def {N' : Type'} : (@cauchy N') = (fun _1225978 : nat -> cart R N' => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N'' : nat, forall m : nat, forall n : nat, ((geqn m N'') /\ (geqn n N'')) -> ltr (@distance N' (@pair (cart R N') (cart R N') (_1225978 m) (_1225978 n))) e).
Proof. exact (REFL (@cauchy N')). Qed.
Definition complete {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1225985 : (cart R N') -> Prop => forall f : nat -> cart R N', ((forall n : nat, @IN (cart R N') (f n) _1225985) /\ (@cauchy N' f)) -> exists l : cart R N', (@IN (cart R N') l _1225985) /\ (@FImp N' nat f l sequentially).
Lemma complete_def {N' : Type'} : (@complete N') = (fun _1225985 : (cart R N') -> Prop => forall f : nat -> cart R N', ((forall n : nat, @IN (cart R N') (f n) _1225985) /\ (@cauchy N' f)) -> exists l : cart R N', (@IN (cart R N') l _1225985) /\ (@FImp N' nat f l sequentially)).
Proof. exact (REFL (@complete N')). Qed.
Definition continuous {_727217 _727219 : Type'} : (_727219 -> cart R _727217) -> (net _727219) -> Prop := fun _1228556 : _727219 -> cart R _727217 => fun _1228557 : net _727219 => @FImp _727217 _727219 _1228556 (_1228556 (@netlimit _727219 _1228557)) _1228557.
Lemma continuous_def {_727217 _727219 : Type'} : (@continuous _727217 _727219) = (fun _1228556 : _727219 -> cart R _727217 => fun _1228557 : net _727219 => @FImp _727217 _727219 _1228556 (_1228556 (@netlimit _727219 _1228557)) _1228557).
Proof. exact (REFL (@continuous _727217 _727219)). Qed.
Definition continuous_on {_728452 _728461 : Type'} : ((cart R _728452) -> cart R _728461) -> ((cart R _728452) -> Prop) -> Prop := fun _1229690 : (cart R _728452) -> cart R _728461 => fun _1229691 : (cart R _728452) -> Prop => forall x : cart R _728452, (@IN (cart R _728452) x _1229691) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x' : cart R _728452, ((@IN (cart R _728452) x' _1229691) /\ (ltr (@distance _728452 (@pair (cart R _728452) (cart R _728452) x' x)) d)) -> ltr (@distance _728461 (@pair (cart R _728461) (cart R _728461) (_1229690 x') (_1229690 x))) e).
Lemma continuous_on_def {_728452 _728461 : Type'} : (@continuous_on _728452 _728461) = (fun _1229690 : (cart R _728452) -> cart R _728461 => fun _1229691 : (cart R _728452) -> Prop => forall x : cart R _728452, (@IN (cart R _728452) x _1229691) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x' : cart R _728452, ((@IN (cart R _728452) x' _1229691) /\ (ltr (@distance _728452 (@pair (cart R _728452) (cart R _728452) x' x)) d)) -> ltr (@distance _728461 (@pair (cart R _728461) (cart R _728461) (_1229690 x') (_1229690 x))) e)).
Proof. exact (REFL (@continuous_on _728452 _728461)). Qed.
Definition uniformly_continuous_on {_728523 _728532 : Type'} : ((cart R _728523) -> cart R _728532) -> ((cart R _728523) -> Prop) -> Prop := fun _1229702 : (cart R _728523) -> cart R _728532 => fun _1229703 : (cart R _728523) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : cart R _728523, forall x' : cart R _728523, ((@IN (cart R _728523) x _1229703) /\ ((@IN (cart R _728523) x' _1229703) /\ (ltr (@distance _728523 (@pair (cart R _728523) (cart R _728523) x' x)) d))) -> ltr (@distance _728532 (@pair (cart R _728532) (cart R _728532) (_1229702 x') (_1229702 x))) e).
Lemma uniformly_continuous_on_def {_728523 _728532 : Type'} : (@uniformly_continuous_on _728523 _728532) = (fun _1229702 : (cart R _728523) -> cart R _728532 => fun _1229703 : (cart R _728523) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : cart R _728523, forall x' : cart R _728523, ((@IN (cart R _728523) x _1229703) /\ ((@IN (cart R _728523) x' _1229703) /\ (ltr (@distance _728523 (@pair (cart R _728523) (cart R _728523) x' x)) d))) -> ltr (@distance _728532 (@pair (cart R _728532) (cart R _728532) (_1229702 x') (_1229702 x))) e)).
Proof. exact (REFL (@uniformly_continuous_on _728523 _728532)). Qed.
Definition connected_component {_755424 : Type'} : ((cart R _755424) -> Prop) -> (cart R _755424) -> (cart R _755424) -> Prop := fun _1258797 : (cart R _755424) -> Prop => fun _1258798 : cart R _755424 => fun _1258799 : cart R _755424 => exists t : (cart R _755424) -> Prop, (@connected _755424 t) /\ ((@subset (cart R _755424) t _1258797) /\ ((@IN (cart R _755424) _1258798 t) /\ (@IN (cart R _755424) _1258799 t))).
Lemma connected_component_def {_755424 : Type'} : (@connected_component _755424) = (fun _1258797 : (cart R _755424) -> Prop => fun _1258798 : cart R _755424 => fun _1258799 : cart R _755424 => exists t : (cart R _755424) -> Prop, (@connected _755424 t) /\ ((@subset (cart R _755424) t _1258797) /\ ((@IN (cart R _755424) _1258798 t) /\ (@IN (cart R _755424) _1258799 t)))).
Proof. exact (REFL (@connected_component _755424)). Qed.
Definition components {N' : Type'} : ((cart R N') -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1259403 : (cart R N') -> Prop => @GSPEC ((cart R N') -> Prop) (fun GEN_PVAR_3076 : (cart R N') -> Prop => exists x : cart R N', @SETSPEC ((cart R N') -> Prop) GEN_PVAR_3076 (@IN (cart R N') x _1259403) (@connected_component N' _1259403 x)).
Lemma components_def {N' : Type'} : (@components N') = (fun _1259403 : (cart R N') -> Prop => @GSPEC ((cart R N') -> Prop) (fun GEN_PVAR_3076 : (cart R N') -> Prop => exists x : cart R N', @SETSPEC ((cart R N') -> Prop) GEN_PVAR_3076 (@IN (cart R N') x _1259403) (@connected_component N' _1259403 x))).
Proof. exact (REFL (@components N')). Qed.
Definition diameter {_765180 : Type'} : ((cart R _765180) -> Prop) -> R := fun _1266976 : (cart R _765180) -> Prop => @COND R (_1266976 = (@set0 (cart R _765180))) (R_of_nat (NUMERAL O)) (sup (@GSPEC R (fun GEN_PVAR_3108 : R => exists x : cart R _765180, exists y : cart R _765180, @SETSPEC R GEN_PVAR_3108 ((@IN (cart R _765180) x _1266976) /\ (@IN (cart R _765180) y _1266976)) (@vector_norm _765180 (@vector_sub _765180 x y))))).
Lemma diameter_def {_765180 : Type'} : (@diameter _765180) = (fun _1266976 : (cart R _765180) -> Prop => @COND R (_1266976 = (@set0 (cart R _765180))) (R_of_nat (NUMERAL O)) (sup (@GSPEC R (fun GEN_PVAR_3108 : R => exists x : cart R _765180, exists y : cart R _765180, @SETSPEC R GEN_PVAR_3108 ((@IN (cart R _765180) x _1266976) /\ (@IN (cart R _765180) y _1266976)) (@vector_norm _765180 (@vector_sub _765180 x y)))))).
Proof. exact (REFL (@diameter _765180)). Qed.
Definition is_interval {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1274220 : (cart R N') -> Prop => forall a : cart R N', forall b : cart R N', forall x : cart R N', ((@IN (cart R N') a _1274220) /\ ((@IN (cart R N') b _1274220) /\ (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> ((ler (@dollar R N' a i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' b i))) \/ ((ler (@dollar R N' b i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' a i)))))) -> @IN (cart R N') x _1274220.
Lemma is_interval_def {N' : Type'} : (@is_interval N') = (fun _1274220 : (cart R N') -> Prop => forall a : cart R N', forall b : cart R N', forall x : cart R N', ((@IN (cart R N') a _1274220) /\ ((@IN (cart R N') b _1274220) /\ (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> ((ler (@dollar R N' a i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' b i))) \/ ((ler (@dollar R N' b i) (@dollar R N' x i)) /\ (ler (@dollar R N' x i) (@dollar R N' a i)))))) -> @IN (cart R N') x _1274220).
Proof. exact (REFL (@is_interval N')). Qed.
Definition homeomorphism {_788309 _788310 : Type'} : (prod ((cart R _788309) -> Prop) ((cart R _788310) -> Prop)) -> (prod ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309)) -> Prop := fun _1281761 : prod ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) => fun _1281762 : prod ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) => (forall x : cart R _788309, (@IN (cart R _788309) x (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) -> (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 x)) = x) /\ (((@IMAGE (cart R _788309) (cart R _788310) (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) = (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ ((@continuous_on _788309 _788310 (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ ((forall y : cart R _788310, (@IN (cart R _788310) y (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) -> (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 y)) = y) /\ (((@IMAGE (cart R _788310) (cart R _788309) (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) = (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ (@continuous_on _788310 _788309 (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)))))).
Lemma homeomorphism_def {_788309 _788310 : Type'} : (@homeomorphism _788309 _788310) = (fun _1281761 : prod ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) => fun _1281762 : prod ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) => (forall x : cart R _788309, (@IN (cart R _788309) x (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) -> (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 x)) = x) /\ (((@IMAGE (cart R _788309) (cart R _788310) (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) = (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ ((@continuous_on _788309 _788310 (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ ((forall y : cart R _788310, (@IN (cart R _788310) y (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) -> (@fst ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762 y)) = y) /\ (((@IMAGE (cart R _788310) (cart R _788309) (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) = (@fst ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761)) /\ (@continuous_on _788310 _788309 (@snd ((cart R _788309) -> cart R _788310) ((cart R _788310) -> cart R _788309) _1281762) (@snd ((cart R _788309) -> Prop) ((cart R _788310) -> Prop) _1281761))))))).
Proof. exact (REFL (@homeomorphism _788309 _788310)). Qed.
Definition homeomorphic {_788326 _788327 : Type'} : ((cart R _788327) -> Prop) -> ((cart R _788326) -> Prop) -> Prop := fun _1281783 : (cart R _788327) -> Prop => fun _1281784 : (cart R _788326) -> Prop => exists f : (cart R _788327) -> cart R _788326, exists g : (cart R _788326) -> cart R _788327, @homeomorphism _788327 _788326 (@pair ((cart R _788327) -> Prop) ((cart R _788326) -> Prop) _1281783 _1281784) (@pair ((cart R _788327) -> cart R _788326) ((cart R _788326) -> cart R _788327) f g).
Lemma homeomorphic_def {_788326 _788327 : Type'} : (@homeomorphic _788326 _788327) = (fun _1281783 : (cart R _788327) -> Prop => fun _1281784 : (cart R _788326) -> Prop => exists f : (cart R _788327) -> cart R _788326, exists g : (cart R _788326) -> cart R _788327, @homeomorphism _788327 _788326 (@pair ((cart R _788327) -> Prop) ((cart R _788326) -> Prop) _1281783 _1281784) (@pair ((cart R _788327) -> cart R _788326) ((cart R _788326) -> cart R _788327) f g)).
Proof. exact (REFL (@homeomorphic _788326 _788327)). Qed.
Definition infsum {_820806 : Type'} : (nat -> Prop) -> (nat -> cart R _820806) -> cart R _820806 := fun _1333494 : nat -> Prop => fun _1333495 : nat -> cart R _820806 => @ε (cart R _820806) (fun l : cart R _820806 => @sums _820806 _1333495 l _1333494).
Lemma infsum_def {_820806 : Type'} : (@infsum _820806) = (fun _1333494 : nat -> Prop => fun _1333495 : nat -> cart R _820806 => @ε (cart R _820806) (fun l : cart R _820806 => @sums _820806 _1333495 l _1333494)).
Proof. exact (REFL (@infsum _820806)). Qed.
Definition summable {_820820 : Type'} : (nat -> Prop) -> (nat -> cart R _820820) -> Prop := fun _1333506 : nat -> Prop => fun _1333507 : nat -> cart R _820820 => exists l : cart R _820820, @sums _820820 _1333507 l _1333506.
Lemma summable_def {_820820 : Type'} : (@summable _820820) = (fun _1333506 : nat -> Prop => fun _1333507 : nat -> cart R _820820 => exists l : cart R _820820, @sums _820820 _1333507 l _1333506).
Proof. exact (REFL (@summable _820820)). Qed.
Definition closest_point {_833655 : Type'} : ((cart R _833655) -> Prop) -> (cart R _833655) -> cart R _833655 := fun _1341435 : (cart R _833655) -> Prop => fun _1341436 : cart R _833655 => @ε (cart R _833655) (fun x : cart R _833655 => (@IN (cart R _833655) x _1341435) /\ (forall y : cart R _833655, (@IN (cart R _833655) y _1341435) -> ler (@distance _833655 (@pair (cart R _833655) (cart R _833655) _1341436 x)) (@distance _833655 (@pair (cart R _833655) (cart R _833655) _1341436 y)))).
Lemma closest_point_def {_833655 : Type'} : (@closest_point _833655) = (fun _1341435 : (cart R _833655) -> Prop => fun _1341436 : cart R _833655 => @ε (cart R _833655) (fun x : cart R _833655 => (@IN (cart R _833655) x _1341435) /\ (forall y : cart R _833655, (@IN (cart R _833655) y _1341435) -> ler (@distance _833655 (@pair (cart R _833655) (cart R _833655) _1341436 x)) (@distance _833655 (@pair (cart R _833655) (cart R _833655) _1341436 y))))).
Proof. exact (REFL (@closest_point _833655)). Qed.
Definition setdist {_834627 : Type'} : (prod ((cart R _834627) -> Prop) ((cart R _834627) -> Prop)) -> R := fun _1342295 : prod ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) => @COND R (((@fst ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295) = (@set0 (cart R _834627))) \/ ((@snd ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295) = (@set0 (cart R _834627)))) (R_of_nat (NUMERAL O)) (inf (@GSPEC R (fun GEN_PVAR_3332 : R => exists x : cart R _834627, exists y : cart R _834627, @SETSPEC R GEN_PVAR_3332 ((@IN (cart R _834627) x (@fst ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295)) /\ (@IN (cart R _834627) y (@snd ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295))) (@distance _834627 (@pair (cart R _834627) (cart R _834627) x y))))).
Lemma setdist_def {_834627 : Type'} : (@setdist _834627) = (fun _1342295 : prod ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) => @COND R (((@fst ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295) = (@set0 (cart R _834627))) \/ ((@snd ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295) = (@set0 (cart R _834627)))) (R_of_nat (NUMERAL O)) (inf (@GSPEC R (fun GEN_PVAR_3332 : R => exists x : cart R _834627, exists y : cart R _834627, @SETSPEC R GEN_PVAR_3332 ((@IN (cart R _834627) x (@fst ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295)) /\ (@IN (cart R _834627) y (@snd ((cart R _834627) -> Prop) ((cart R _834627) -> Prop) _1342295))) (@distance _834627 (@pair (cart R _834627) (cart R _834627) x y)))))).
Proof. exact (REFL (@setdist _834627)). Qed.
Definition hausdist {N' : Type'} : (prod ((cart R N') -> Prop) ((cart R N') -> Prop)) -> R := fun _1348219 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => @LET (R -> Prop) R (fun ds : R -> Prop => @LET_END R (@COND R ((~ (ds = (@set0 R))) /\ (exists b : R, forall d : R, (@IN R d ds) -> ler d b)) (sup ds) (R_of_nat (NUMERAL O)))) (@setU R (@GSPEC R (fun GEN_PVAR_3360 : R => exists x : cart R N', @SETSPEC R GEN_PVAR_3360 (@IN (cart R N') x (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') x (@set0 (cart R N'))) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219))))) (@GSPEC R (fun GEN_PVAR_3361 : R => exists y : cart R N', @SETSPEC R GEN_PVAR_3361 (@IN (cart R N') y (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') y (@set0 (cart R N'))) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219)))))).
Lemma hausdist_def {N' : Type'} : (@hausdist N') = (fun _1348219 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => @LET (R -> Prop) R (fun ds : R -> Prop => @LET_END R (@COND R ((~ (ds = (@set0 R))) /\ (exists b : R, forall d : R, (@IN R d ds) -> ler d b)) (sup ds) (R_of_nat (NUMERAL O)))) (@setU R (@GSPEC R (fun GEN_PVAR_3360 : R => exists x : cart R N', @SETSPEC R GEN_PVAR_3360 (@IN (cart R N') x (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') x (@set0 (cart R N'))) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219))))) (@GSPEC R (fun GEN_PVAR_3361 : R => exists y : cart R N', @SETSPEC R GEN_PVAR_3361 (@IN (cart R N') y (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219)) (@setdist N' (@pair ((cart R N') -> Prop) ((cart R N') -> Prop) (@INSERT (cart R N') y (@set0 (cart R N'))) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _1348219))))))).
Proof. exact (REFL (@hausdist N')). Qed.
Definition locally {N' : Type'} : (((cart R N') -> Prop) -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1370243 : ((cart R N') -> Prop) -> Prop => fun _1370244 : (cart R N') -> Prop => forall w : (cart R N') -> Prop, forall x : cart R N', ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1370244) w) /\ (@IN (cart R N') x w)) -> exists u : (cart R N') -> Prop, exists v : (cart R N') -> Prop, (@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1370244) u) /\ ((_1370243 v) /\ ((@IN (cart R N') x u) /\ ((@subset (cart R N') u v) /\ (@subset (cart R N') v w)))).
Lemma locally_def {N' : Type'} : (@locally N') = (fun _1370243 : ((cart R N') -> Prop) -> Prop => fun _1370244 : (cart R N') -> Prop => forall w : (cart R N') -> Prop, forall x : cart R N', ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1370244) w) /\ (@IN (cart R N') x w)) -> exists u : (cart R N') -> Prop, exists v : (cart R N') -> Prop, (@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1370244) u) /\ ((_1370243 v) /\ ((@IN (cart R N') x u) /\ ((@subset (cart R N') u v) /\ (@subset (cart R N') v w))))).
Proof. exact (REFL (@locally N')). Qed.
Definition gdelta {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1382444 : (cart R N') -> Prop => @INTERSECTION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@_open N') _1382444.
Lemma gdelta_def {N' : Type'} : (@gdelta N') = (fun _1382444 : (cart R N') -> Prop => @INTERSECTION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@_open N') _1382444).
Proof. exact (REFL (@gdelta N')). Qed.
Definition fsigma {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1382449 : (cart R N') -> Prop => @UNION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@closed N') _1382449.
Lemma fsigma_def {N' : Type'} : (@fsigma N') = (fun _1382449 : (cart R N') -> Prop => @UNION_OF (cart R N') (@COUNTABLE ((cart R N') -> Prop)) (@closed N') _1382449).
Proof. exact (REFL (@fsigma N')). Qed.
Definition borel {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun a : (cart R N') -> Prop => forall borel' : ((cart R N') -> Prop) -> Prop, (forall a' : (cart R N') -> Prop, ((@_open N' a') \/ ((exists s : (cart R N') -> Prop, (a' = (@setD (cart R N') (@setT (cart R N')) s)) /\ (borel' s)) \/ (exists u : ((cart R N') -> Prop) -> Prop, (a' = (@UNIONS (cart R N') u)) /\ ((@COUNTABLE ((cart R N') -> Prop) u) /\ (forall s : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) s u) -> borel' s))))) -> borel' a') -> borel' a.
Lemma borel_def {N' : Type'} : (@borel N') = (fun a : (cart R N') -> Prop => forall borel' : ((cart R N') -> Prop) -> Prop, (forall a' : (cart R N') -> Prop, ((@_open N' a') \/ ((exists s : (cart R N') -> Prop, (a' = (@setD (cart R N') (@setT (cart R N')) s)) /\ (borel' s)) \/ (exists u : ((cart R N') -> Prop) -> Prop, (a' = (@UNIONS (cart R N') u)) /\ ((@COUNTABLE ((cart R N') -> Prop) u) /\ (forall s : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) s u) -> borel' s))))) -> borel' a') -> borel' a).
Proof. exact (REFL (@borel N')). Qed.
Definition baire {M N' : Type'} : nat -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> nat -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop) (fun baire' : (prod nat (prod nat (prod nat (prod nat nat)))) -> nat -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop => forall _1398696 : prod nat (prod nat (prod nat (prod nat nat))), (forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1398696 (NUMERAL O) s f) = (@continuous_on M N' f s)) /\ (forall n : nat, forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1398696 (S n) s f) = (exists g : nat -> (cart R M) -> cart R N', (forall k : nat, baire' _1398696 n s (g k)) /\ (forall x : cart R M, (@IN (cart R M) x s) -> @FImp N' nat (fun k : nat => g k x) (f x) sequentially)))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))).
Lemma baire_def {M N' : Type'} : (@baire M N') = (@ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> nat -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop) (fun baire' : (prod nat (prod nat (prod nat (prod nat nat)))) -> nat -> ((cart R M) -> Prop) -> ((cart R M) -> cart R N') -> Prop => forall _1398696 : prod nat (prod nat (prod nat (prod nat nat))), (forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1398696 (NUMERAL O) s f) = (@continuous_on M N' f s)) /\ (forall n : nat, forall s : (cart R M) -> Prop, forall f : (cart R M) -> cart R N', (baire' _1398696 (S n) s f) = (exists g : nat -> (cart R M) -> cart R N', (forall k : nat, baire' _1398696 n s (g k)) /\ (forall x : cart R M, (@IN (cart R M) x s) -> @FImp N' nat (fun k : nat => g k x) (f x) sequentially)))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))).
Proof. exact (REFL (@baire M N')). Qed.
Definition borel_measurable_on {M N' : Type'} : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun a0 : (cart R M) -> cart R N' => fun a1 : (cart R M) -> Prop => forall borel_measurable_on' : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop, (forall a0' : (cart R M) -> cart R N', forall a1' : (cart R M) -> Prop, ((@continuous_on M N' a0' a1') \/ (exists f : nat -> (cart R M) -> cart R N', (forall n : nat, borel_measurable_on' (f n) a1') /\ (forall x : cart R M, (@IN (cart R M) x a1') -> @FImp N' nat (fun n : nat => f n x) (a0' x) sequentially))) -> borel_measurable_on' a0' a1') -> borel_measurable_on' a0 a1.
Lemma borel_measurable_on_def {M N' : Type'} : (@borel_measurable_on M N') = (fun a0 : (cart R M) -> cart R N' => fun a1 : (cart R M) -> Prop => forall borel_measurable_on' : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop, (forall a0' : (cart R M) -> cart R N', forall a1' : (cart R M) -> Prop, ((@continuous_on M N' a0' a1') \/ (exists f : nat -> (cart R M) -> cart R N', (forall n : nat, borel_measurable_on' (f n) a1') /\ (forall x : cart R M, (@IN (cart R M) x a1') -> @FImp N' nat (fun n : nat => f n x) (a0' x) sequentially))) -> borel_measurable_on' a0' a1') -> borel_measurable_on' a0 a1).
Proof. exact (REFL (@borel_measurable_on M N')). Qed.
Definition analytic {_894557 : Type'} : ((cart R _894557) -> Prop) -> Prop := fun _1420779 : (cart R _894557) -> Prop => @suslin (cart R _894557) (@compact _894557) _1420779.
Lemma analytic_def {_894557 : Type'} : (@analytic _894557) = (fun _1420779 : (cart R _894557) -> Prop => @suslin (cart R _894557) (@compact _894557) _1420779).
Proof. exact (REFL (@analytic _894557)). Qed.
Definition affine {_901576 : Type'} : ((cart R _901576) -> Prop) -> Prop := fun _1428551 : (cart R _901576) -> Prop => forall x : cart R _901576, forall y : cart R _901576, forall u : R, forall v : R, ((@IN (cart R _901576) x _1428551) /\ ((@IN (cart R _901576) y _1428551) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))) -> @IN (cart R _901576) (@vector_add _901576 (@percent _901576 u x) (@percent _901576 v y)) _1428551.
Lemma affine_def {_901576 : Type'} : (@affine _901576) = (fun _1428551 : (cart R _901576) -> Prop => forall x : cart R _901576, forall y : cart R _901576, forall u : R, forall v : R, ((@IN (cart R _901576) x _1428551) /\ ((@IN (cart R _901576) y _1428551) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))) -> @IN (cart R _901576) (@vector_add _901576 (@percent _901576 u x) (@percent _901576 v y)) _1428551).
Proof. exact (REFL (@affine _901576)). Qed.
Definition convex {_907414 : Type'} : ((cart R _907414) -> Prop) -> Prop := fun _1433066 : (cart R _907414) -> Prop => forall x : cart R _907414, forall y : cart R _907414, forall u : R, forall v : R, ((@IN (cart R _907414) x _1433066) /\ ((@IN (cart R _907414) y _1433066) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> @IN (cart R _907414) (@vector_add _907414 (@percent _907414 u x) (@percent _907414 v y)) _1433066.
Lemma convex_def {_907414 : Type'} : (@convex _907414) = (fun _1433066 : (cart R _907414) -> Prop => forall x : cart R _907414, forall y : cart R _907414, forall u : R, forall v : R, ((@IN (cart R _907414) x _1433066) /\ ((@IN (cart R _907414) y _1433066) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> @IN (cart R _907414) (@vector_add _907414 (@percent _907414 u x) (@percent _907414 v y)) _1433066).
Proof. exact (REFL (@convex _907414)). Qed.
Definition conic {_910406 : Type'} : ((cart R _910406) -> Prop) -> Prop := fun _1434915 : (cart R _910406) -> Prop => forall x : cart R _910406, forall c : R, ((@IN (cart R _910406) x _1434915) /\ (ler (R_of_nat (NUMERAL O)) c)) -> @IN (cart R _910406) (@percent _910406 c x) _1434915.
Lemma conic_def {_910406 : Type'} : (@conic _910406) = (fun _1434915 : (cart R _910406) -> Prop => forall x : cart R _910406, forall c : R, ((@IN (cart R _910406) x _1434915) /\ (ler (R_of_nat (NUMERAL O)) c)) -> @IN (cart R _910406) (@percent _910406 c x) _1434915).
Proof. exact (REFL (@conic _910406)). Qed.
Definition affine_dependent {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1436428 : (cart R N') -> Prop => exists x : cart R N', (@IN (cart R N') x _1436428) /\ (@IN (cart R N') x (@hull (cart R N') (@affine N') (@DELETE (cart R N') _1436428 x))).
Lemma affine_dependent_def {N' : Type'} : (@affine_dependent N') = (fun _1436428 : (cart R N') -> Prop => exists x : cart R N', (@IN (cart R N') x _1436428) /\ (@IN (cart R N') x (@hull (cart R N') (@affine N') (@DELETE (cart R N') _1436428 x)))).
Proof. exact (REFL (@affine_dependent N')). Qed.
Definition coplanar {_913120 : Type'} : ((cart R _913120) -> Prop) -> Prop := fun _1437346 : (cart R _913120) -> Prop => exists u : cart R _913120, exists v : cart R _913120, exists w : cart R _913120, @subset (cart R _913120) _1437346 (@hull (cart R _913120) (@affine _913120) (@INSERT (cart R _913120) u (@INSERT (cart R _913120) v (@INSERT (cart R _913120) w (@set0 (cart R _913120)))))).
Lemma coplanar_def {_913120 : Type'} : (@coplanar _913120) = (fun _1437346 : (cart R _913120) -> Prop => exists u : cart R _913120, exists v : cart R _913120, exists w : cart R _913120, @subset (cart R _913120) _1437346 (@hull (cart R _913120) (@affine _913120) (@INSERT (cart R _913120) u (@INSERT (cart R _913120) v (@INSERT (cart R _913120) w (@set0 (cart R _913120))))))).
Proof. exact (REFL (@coplanar _913120)). Qed.
Definition convex_on {_914314 : Type'} : ((cart R _914314) -> R) -> ((cart R _914314) -> Prop) -> Prop := fun _1438588 : (cart R _914314) -> R => fun _1438589 : (cart R _914314) -> Prop => forall x : cart R _914314, forall y : cart R _914314, forall u : R, forall v : R, ((@IN (cart R _914314) x _1438589) /\ ((@IN (cart R _914314) y _1438589) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (_1438588 (@vector_add _914314 (@percent _914314 u x) (@percent _914314 v y))) (addr (mulr u (_1438588 x)) (mulr v (_1438588 y))).
Lemma convex_on_def {_914314 : Type'} : (@convex_on _914314) = (fun _1438588 : (cart R _914314) -> R => fun _1438589 : (cart R _914314) -> Prop => forall x : cart R _914314, forall y : cart R _914314, forall u : R, forall v : R, ((@IN (cart R _914314) x _1438589) /\ ((@IN (cart R _914314) y _1438589) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (_1438588 (@vector_add _914314 (@percent _914314 u x) (@percent _914314 v y))) (addr (mulr u (_1438588 x)) (mulr v (_1438588 y)))).
Proof. exact (REFL (@convex_on _914314)). Qed.
Definition aff_dim {_927154 : Type'} : ((cart R _927154) -> Prop) -> int := fun _1449834 : (cart R _927154) -> Prop => @ε int (fun d : int => exists b : (cart R _927154) -> Prop, ((@hull (cart R _927154) (@affine _927154) b) = (@hull (cart R _927154) (@affine _927154) _1449834)) /\ ((~ (@affine_dependent _927154 b)) /\ ((int_of_nat (@CARD (cart R _927154) b)) = (addz d (int_of_nat (NUMERAL (BIT1 O))))))).
Lemma aff_dim_def {_927154 : Type'} : (@aff_dim _927154) = (fun _1449834 : (cart R _927154) -> Prop => @ε int (fun d : int => exists b : (cart R _927154) -> Prop, ((@hull (cart R _927154) (@affine _927154) b) = (@hull (cart R _927154) (@affine _927154) _1449834)) /\ ((~ (@affine_dependent _927154 b)) /\ ((int_of_nat (@CARD (cart R _927154) b)) = (addz d (int_of_nat (NUMERAL (BIT1 O)))))))).
Proof. exact (REFL (@aff_dim _927154)). Qed.
Definition polar_dual {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1480024 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4503 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4503 (forall u : cart R N', (@IN (cart R N') u _1480024) -> ger (@dot N' u x) (oppr (R_of_nat (NUMERAL (BIT1 O))))) x).
Lemma polar_dual_def {N' : Type'} : (@polar_dual N') = (fun _1480024 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4503 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4503 (forall u : cart R N', (@IN (cart R N') u _1480024) -> ger (@dot N' u x) (oppr (R_of_nat (NUMERAL (BIT1 O))))) x)).
Proof. exact (REFL (@polar_dual N')). Qed.
Definition convex_cone {_960421 : Type'} : ((cart R _960421) -> Prop) -> Prop := fun _1506785 : (cart R _960421) -> Prop => (~ (_1506785 = (@set0 (cart R _960421)))) /\ ((@convex _960421 _1506785) /\ (@conic _960421 _1506785)).
Lemma convex_cone_def {_960421 : Type'} : (@convex_cone _960421) = (fun _1506785 : (cart R _960421) -> Prop => (~ (_1506785 = (@set0 (cart R _960421)))) /\ ((@convex _960421 _1506785) /\ (@conic _960421 _1506785))).
Proof. exact (REFL (@convex_cone _960421)). Qed.
Definition epigraph {N' : Type'} : ((cart R N') -> Prop) -> ((cart R N') -> R) -> (cart R (finite_sum N' unit)) -> Prop := fun _1509934 : (cart R N') -> Prop => fun _1509935 : (cart R N') -> R => @GSPEC (cart R (finite_sum N' unit)) (fun GEN_PVAR_4578 : cart R (finite_sum N' unit) => exists xy : cart R (finite_sum N' unit), @SETSPEC (cart R (finite_sum N' unit)) GEN_PVAR_4578 ((@IN (cart R N') (@fstcart R N' unit xy) _1509934) /\ (ler (_1509935 (@fstcart R N' unit xy)) (drop (@sndcart R N' unit xy)))) xy).
Lemma epigraph_def {N' : Type'} : (@epigraph N') = (fun _1509934 : (cart R N') -> Prop => fun _1509935 : (cart R N') -> R => @GSPEC (cart R (finite_sum N' unit)) (fun GEN_PVAR_4578 : cart R (finite_sum N' unit) => exists xy : cart R (finite_sum N' unit), @SETSPEC (cart R (finite_sum N' unit)) GEN_PVAR_4578 ((@IN (cart R N') (@fstcart R N' unit xy) _1509934) /\ (ler (_1509935 (@fstcart R N' unit xy)) (drop (@sndcart R N' unit xy)))) xy)).
Proof. exact (REFL (@epigraph N')). Qed.
Definition starlike {_965402 : Type'} : ((cart R _965402) -> Prop) -> Prop := fun _1511914 : (cart R _965402) -> Prop => exists a : cart R _965402, (@IN (cart R _965402) a _1511914) /\ (forall x : cart R _965402, (@IN (cart R _965402) x _1511914) -> @subset (cart R _965402) (@closed_segment _965402 (@cons (prod (cart R _965402) (cart R _965402)) (@pair (cart R _965402) (cart R _965402) a x) (@nil (prod (cart R _965402) (cart R _965402))))) _1511914).
Lemma starlike_def {_965402 : Type'} : (@starlike _965402) = (fun _1511914 : (cart R _965402) -> Prop => exists a : cart R _965402, (@IN (cart R _965402) a _1511914) /\ (forall x : cart R _965402, (@IN (cart R _965402) x _1511914) -> @subset (cart R _965402) (@closed_segment _965402 (@cons (prod (cart R _965402) (cart R _965402)) (@pair (cart R _965402) (cart R _965402) a x) (@nil (prod (cart R _965402) (cart R _965402))))) _1511914)).
Proof. exact (REFL (@starlike _965402)). Qed.
Definition relative_interior {_969051 : Type'} : ((cart R _969051) -> Prop) -> (cart R _969051) -> Prop := fun _1514008 : (cart R _969051) -> Prop => @GSPEC (cart R _969051) (fun GEN_PVAR_4598 : cart R _969051 => exists x : cart R _969051, @SETSPEC (cart R _969051) GEN_PVAR_4598 (exists t : (cart R _969051) -> Prop, (@open_in (cart R _969051) (@subtopology (cart R _969051) (@euclidean _969051) (@hull (cart R _969051) (@affine _969051) _1514008)) t) /\ ((@IN (cart R _969051) x t) /\ (@subset (cart R _969051) t _1514008))) x).
Lemma relative_interior_def {_969051 : Type'} : (@relative_interior _969051) = (fun _1514008 : (cart R _969051) -> Prop => @GSPEC (cart R _969051) (fun GEN_PVAR_4598 : cart R _969051 => exists x : cart R _969051, @SETSPEC (cart R _969051) GEN_PVAR_4598 (exists t : (cart R _969051) -> Prop, (@open_in (cart R _969051) (@subtopology (cart R _969051) (@euclidean _969051) (@hull (cart R _969051) (@affine _969051) _1514008)) t) /\ ((@IN (cart R _969051) x t) /\ (@subset (cart R _969051) t _1514008))) x)).
Proof. exact (REFL (@relative_interior _969051)). Qed.
Definition relative_frontier {_969071 : Type'} : ((cart R _969071) -> Prop) -> (cart R _969071) -> Prop := fun _1514013 : (cart R _969071) -> Prop => @setD (cart R _969071) (@closure _969071 _1514013) (@relative_interior _969071 _1514013).
Lemma relative_frontier_def {_969071 : Type'} : (@relative_frontier _969071) = (fun _1514013 : (cart R _969071) -> Prop => @setD (cart R _969071) (@closure _969071 _1514013) (@relative_interior _969071 _1514013)).
Proof. exact (REFL (@relative_frontier _969071)). Qed.
Definition barycentre {_1006268 : Type'} : ((cart R _1006268) -> Prop) -> cart R _1006268 := fun _1551627 : (cart R _1006268) -> Prop => @COND (cart R _1006268) (@finite_set (cart R _1006268) _1551627) (@vsum (cart R _1006268) _1006268 _1551627 (fun x : cart R _1006268 => @percent _1006268 (invr (R_of_nat (@CARD (cart R _1006268) _1551627))) x)) (@vec _1006268 (NUMERAL O)).
Lemma barycentre_def {_1006268 : Type'} : (@barycentre _1006268) = (fun _1551627 : (cart R _1006268) -> Prop => @COND (cart R _1006268) (@finite_set (cart R _1006268) _1551627) (@vsum (cart R _1006268) _1006268 _1551627 (fun x : cart R _1006268 => @percent _1006268 (invr (R_of_nat (@CARD (cart R _1006268) _1551627))) x)) (@vec _1006268 (NUMERAL O))).
Proof. exact (REFL (@barycentre _1006268)). Qed.
Definition path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1557035 : (cart R unit) -> cart R N' => @continuous_on unit N' _1557035 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma path_def {N' : Type'} : (@path N') = (fun _1557035 : (cart R unit) -> cart R N' => @continuous_on unit N' _1557035 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (REFL (@path N')). Qed.
Definition pathstart {N' : Type'} : ((cart R unit) -> cart R N') -> cart R N' := fun _1557040 : (cart R unit) -> cart R N' => _1557040 (@vec unit (NUMERAL O)).
Lemma pathstart_def {N' : Type'} : (@pathstart N') = (fun _1557040 : (cart R unit) -> cart R N' => _1557040 (@vec unit (NUMERAL O))).
Proof. exact (REFL (@pathstart N')). Qed.
Definition pathfinish {N' : Type'} : ((cart R unit) -> cart R N') -> cart R N' := fun _1557045 : (cart R unit) -> cart R N' => _1557045 (@vec unit (NUMERAL (BIT1 O))).
Lemma pathfinish_def {N' : Type'} : (@pathfinish N') = (fun _1557045 : (cart R unit) -> cart R N' => _1557045 (@vec unit (NUMERAL (BIT1 O)))).
Proof. exact (REFL (@pathfinish N')). Qed.
Definition path_image {N' : Type'} : ((cart R unit) -> cart R N') -> (cart R N') -> Prop := fun _1557050 : (cart R unit) -> cart R N' => @IMAGE (cart R unit) (cart R N') _1557050 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma path_image_def {N' : Type'} : (@path_image N') = (fun _1557050 : (cart R unit) -> cart R N' => @IMAGE (cart R unit) (cart R N') _1557050 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (REFL (@path_image N')). Qed.
Definition reversepath {N' : Type'} : ((cart R unit) -> cart R N') -> (cart R unit) -> cart R N' := fun _1557055 : (cart R unit) -> cart R N' => fun x : cart R unit => _1557055 (@vector_sub unit (@vec unit (NUMERAL (BIT1 O))) x).
Lemma reversepath_def {N' : Type'} : (@reversepath N') = (fun _1557055 : (cart R unit) -> cart R N' => fun x : cart R unit => _1557055 (@vector_sub unit (@vec unit (NUMERAL (BIT1 O))) x)).
Proof. exact (REFL (@reversepath N')). Qed.
Definition addadd {_1010721 : Type'} : ((cart R unit) -> _1010721) -> ((cart R unit) -> _1010721) -> (cart R unit) -> _1010721 := fun _1557060 : (cart R unit) -> _1010721 => fun _1557061 : (cart R unit) -> _1010721 => fun x : cart R unit => @COND _1010721 (ler (drop x) (divr (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (_1557060 (@percent unit (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x)) (_1557061 (@vector_sub unit (@percent unit (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x) (@vec unit (NUMERAL (BIT1 O))))).
Lemma addadd_def {_1010721 : Type'} : (@addadd _1010721) = (fun _1557060 : (cart R unit) -> _1010721 => fun _1557061 : (cart R unit) -> _1010721 => fun x : cart R unit => @COND _1010721 (ler (drop x) (divr (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (_1557060 (@percent unit (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x)) (_1557061 (@vector_sub unit (@percent unit (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x) (@vec unit (NUMERAL (BIT1 O)))))).
Proof. exact (REFL (@addadd _1010721)). Qed.
Definition simple_path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1557072 : (cart R unit) -> cart R N' => (@path N' _1557072) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1557072 x) = (_1557072 y)))) -> (x = y) \/ (((x = (@vec unit (NUMERAL O))) /\ (y = (@vec unit (NUMERAL (BIT1 O))))) \/ ((x = (@vec unit (NUMERAL (BIT1 O)))) /\ (y = (@vec unit (NUMERAL O)))))).
Lemma simple_path_def {N' : Type'} : (@simple_path N') = (fun _1557072 : (cart R unit) -> cart R N' => (@path N' _1557072) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1557072 x) = (_1557072 y)))) -> (x = y) \/ (((x = (@vec unit (NUMERAL O))) /\ (y = (@vec unit (NUMERAL (BIT1 O))))) \/ ((x = (@vec unit (NUMERAL (BIT1 O)))) /\ (y = (@vec unit (NUMERAL O))))))).
Proof. exact (REFL (@simple_path N')). Qed.
Definition arc {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _1557077 : (cart R unit) -> cart R N' => (@path N' _1557077) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1557077 x) = (_1557077 y)))) -> x = y).
Lemma arc_def {N' : Type'} : (@arc N') = (fun _1557077 : (cart R unit) -> cart R N' => (@path N' _1557077) /\ (forall x : cart R unit, forall y : cart R unit, ((@IN (cart R unit) x (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((@IN (cart R unit) y (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) /\ ((_1557077 x) = (_1557077 y)))) -> x = y)).
Proof. exact (REFL (@arc N')). Qed.
Definition shiftpath {N' : Type'} : (cart R unit) -> ((cart R unit) -> cart R N') -> (cart R unit) -> cart R N' := fun _1562117 : cart R unit => fun _1562118 : (cart R unit) -> cart R N' => fun x : cart R unit => @COND (cart R N') (ler (drop (@vector_add unit _1562117 x)) (R_of_nat (NUMERAL (BIT1 O)))) (_1562118 (@vector_add unit _1562117 x)) (_1562118 (@vector_add unit _1562117 (@vector_sub unit x (@vec unit (NUMERAL (BIT1 O)))))).
Lemma shiftpath_def {N' : Type'} : (@shiftpath N') = (fun _1562117 : cart R unit => fun _1562118 : (cart R unit) -> cart R N' => fun x : cart R unit => @COND (cart R N') (ler (drop (@vector_add unit _1562117 x)) (R_of_nat (NUMERAL (BIT1 O)))) (_1562118 (@vector_add unit _1562117 x)) (_1562118 (@vector_add unit _1562117 (@vector_sub unit x (@vec unit (NUMERAL (BIT1 O))))))).
Proof. exact (REFL (@shiftpath N')). Qed.
Definition subpath {_1016871 : Type'} : (cart R unit) -> (cart R unit) -> ((cart R unit) -> _1016871) -> (cart R unit) -> _1016871 := fun _1562279 : cart R unit => fun _1562280 : cart R unit => fun _1562281 : (cart R unit) -> _1016871 => fun x : cart R unit => _1562281 (@vector_add unit _1562279 (@percent unit (drop (@vector_sub unit _1562280 _1562279)) x)).
Lemma subpath_def {_1016871 : Type'} : (@subpath _1016871) = (fun _1562279 : cart R unit => fun _1562280 : cart R unit => fun _1562281 : (cart R unit) -> _1016871 => fun x : cart R unit => _1562281 (@vector_add unit _1562279 (@percent unit (drop (@vector_sub unit _1562280 _1562279)) x))).
Proof. exact (REFL (@subpath _1016871)). Qed.
Definition linepath {_1021062 : Type'} : (prod (cart R _1021062) (cart R _1021062)) -> (cart R unit) -> cart R _1021062 := fun _1569733 : prod (cart R _1021062) (cart R _1021062) => fun x : cart R unit => @vector_add _1021062 (@percent _1021062 (subr (R_of_nat (NUMERAL (BIT1 O))) (drop x)) (@fst (cart R _1021062) (cart R _1021062) _1569733)) (@percent _1021062 (drop x) (@snd (cart R _1021062) (cart R _1021062) _1569733)).
Lemma linepath_def {_1021062 : Type'} : (@linepath _1021062) = (fun _1569733 : prod (cart R _1021062) (cart R _1021062) => fun x : cart R unit => @vector_add _1021062 (@percent _1021062 (subr (R_of_nat (NUMERAL (BIT1 O))) (drop x)) (@fst (cart R _1021062) (cart R _1021062) _1569733)) (@percent _1021062 (drop x) (@snd (cart R _1021062) (cart R _1021062) _1569733))).
Proof. exact (REFL (@linepath _1021062)). Qed.
Definition path_component {_1023227 : Type'} : ((cart R _1023227) -> Prop) -> (cart R _1023227) -> (cart R _1023227) -> Prop := fun _1577685 : (cart R _1023227) -> Prop => fun _1577686 : cart R _1023227 => fun _1577687 : cart R _1023227 => exists g : (cart R unit) -> cart R _1023227, (@path _1023227 g) /\ ((@subset (cart R _1023227) (@path_image _1023227 g) _1577685) /\ (((@pathstart _1023227 g) = _1577686) /\ ((@pathfinish _1023227 g) = _1577687))).
Lemma path_component_def {_1023227 : Type'} : (@path_component _1023227) = (fun _1577685 : (cart R _1023227) -> Prop => fun _1577686 : cart R _1023227 => fun _1577687 : cart R _1023227 => exists g : (cart R unit) -> cart R _1023227, (@path _1023227 g) /\ ((@subset (cart R _1023227) (@path_image _1023227 g) _1577685) /\ (((@pathstart _1023227 g) = _1577686) /\ ((@pathfinish _1023227 g) = _1577687)))).
Proof. exact (REFL (@path_component _1023227)). Qed.
Definition path_components {_1023269 : Type'} : ((cart R _1023269) -> Prop) -> ((cart R _1023269) -> Prop) -> Prop := fun _1577706 : (cart R _1023269) -> Prop => @GSPEC ((cart R _1023269) -> Prop) (fun GEN_PVAR_4704 : (cart R _1023269) -> Prop => exists x : cart R _1023269, @SETSPEC ((cart R _1023269) -> Prop) GEN_PVAR_4704 (@IN (cart R _1023269) x _1577706) (@path_component _1023269 _1577706 x)).
Lemma path_components_def {_1023269 : Type'} : (@path_components _1023269) = (fun _1577706 : (cart R _1023269) -> Prop => @GSPEC ((cart R _1023269) -> Prop) (fun GEN_PVAR_4704 : (cart R _1023269) -> Prop => exists x : cart R _1023269, @SETSPEC ((cart R _1023269) -> Prop) GEN_PVAR_4704 (@IN (cart R _1023269) x _1577706) (@path_component _1023269 _1577706 x))).
Proof. exact (REFL (@path_components _1023269)). Qed.
Definition path_connected {_1023767 : Type'} : ((cart R _1023767) -> Prop) -> Prop := fun _1577903 : (cart R _1023767) -> Prop => forall x : cart R _1023767, forall y : cart R _1023767, ((@IN (cart R _1023767) x _1577903) /\ (@IN (cart R _1023767) y _1577903)) -> exists g : (cart R unit) -> cart R _1023767, (@path _1023767 g) /\ ((@subset (cart R _1023767) (@path_image _1023767 g) _1577903) /\ (((@pathstart _1023767 g) = x) /\ ((@pathfinish _1023767 g) = y))).
Lemma path_connected_def {_1023767 : Type'} : (@path_connected _1023767) = (fun _1577903 : (cart R _1023767) -> Prop => forall x : cart R _1023767, forall y : cart R _1023767, ((@IN (cart R _1023767) x _1577903) /\ (@IN (cart R _1023767) y _1577903)) -> exists g : (cart R unit) -> cart R _1023767, (@path _1023767 g) /\ ((@subset (cart R _1023767) (@path_image _1023767 g) _1577903) /\ (((@pathstart _1023767 g) = x) /\ ((@pathfinish _1023767 g) = y)))).
Proof. exact (REFL (@path_connected _1023767)). Qed.
Definition inside {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1760834 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4971 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4971 ((~ (@IN (cart R N') x _1760834)) /\ (@bounded N' (@connected_component N' (@setD (cart R N') (@setT (cart R N')) _1760834) x))) x).
Lemma inside_def {N' : Type'} : (@inside N') = (fun _1760834 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4971 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4971 ((~ (@IN (cart R N') x _1760834)) /\ (@bounded N' (@connected_component N' (@setD (cart R N') (@setT (cart R N')) _1760834) x))) x)).
Proof. exact (REFL (@inside N')). Qed.
Definition outside {N' : Type'} : ((cart R N') -> Prop) -> (cart R N') -> Prop := fun _1760839 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4972 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4972 ((~ (@IN (cart R N') x _1760839)) /\ (~ (@bounded N' (@connected_component N' (@setD (cart R N') (@setT (cart R N')) _1760839) x)))) x).
Lemma outside_def {N' : Type'} : (@outside N') = (fun _1760839 : (cart R N') -> Prop => @GSPEC (cart R N') (fun GEN_PVAR_4972 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_4972 ((~ (@IN (cart R N') x _1760839)) /\ (~ (@bounded N' (@connected_component N' (@setD (cart R N') (@setT (cart R N')) _1760839) x)))) x)).
Proof. exact (REFL (@outside N')). Qed.
Definition homotopic_paths {_1103102 : Type'} : ((cart R _1103102) -> Prop) -> ((cart R unit) -> cart R _1103102) -> ((cart R unit) -> cart R _1103102) -> Prop := fun _1766878 : (cart R _1103102) -> Prop => fun _1766879 : (cart R unit) -> cart R _1103102 => fun _1766880 : (cart R unit) -> cart R _1103102 => @homotopic_with (cart R _1103102) (cart R unit) (fun r : (cart R unit) -> cart R _1103102 => ((@pathstart _1103102 r) = (@pathstart _1103102 _1766879)) /\ ((@pathfinish _1103102 r) = (@pathfinish _1103102 _1766879))) (@pair (Topology (cart R unit)) (Topology (cart R _1103102)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1103102) (@euclidean _1103102) _1766878)) _1766879 _1766880.
Lemma homotopic_paths_def {_1103102 : Type'} : (@homotopic_paths _1103102) = (fun _1766878 : (cart R _1103102) -> Prop => fun _1766879 : (cart R unit) -> cart R _1103102 => fun _1766880 : (cart R unit) -> cart R _1103102 => @homotopic_with (cart R _1103102) (cart R unit) (fun r : (cart R unit) -> cart R _1103102 => ((@pathstart _1103102 r) = (@pathstart _1103102 _1766879)) /\ ((@pathfinish _1103102 r) = (@pathfinish _1103102 _1766879))) (@pair (Topology (cart R unit)) (Topology (cart R _1103102)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1103102) (@euclidean _1103102) _1766878)) _1766879 _1766880).
Proof. exact (REFL (@homotopic_paths _1103102)). Qed.
Definition homotopic_loops {_1105705 : Type'} : ((cart R _1105705) -> Prop) -> ((cart R unit) -> cart R _1105705) -> ((cart R unit) -> cart R _1105705) -> Prop := fun _1770670 : (cart R _1105705) -> Prop => fun _1770671 : (cart R unit) -> cart R _1105705 => fun _1770672 : (cart R unit) -> cart R _1105705 => @homotopic_with (cart R _1105705) (cart R unit) (fun r : (cart R unit) -> cart R _1105705 => (@pathfinish _1105705 r) = (@pathstart _1105705 r)) (@pair (Topology (cart R unit)) (Topology (cart R _1105705)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1105705) (@euclidean _1105705) _1770670)) _1770671 _1770672.
Lemma homotopic_loops_def {_1105705 : Type'} : (@homotopic_loops _1105705) = (fun _1770670 : (cart R _1105705) -> Prop => fun _1770671 : (cart R unit) -> cart R _1105705 => fun _1770672 : (cart R unit) -> cart R _1105705 => @homotopic_with (cart R _1105705) (cart R unit) (fun r : (cart R unit) -> cart R _1105705 => (@pathfinish _1105705 r) = (@pathstart _1105705 r)) (@pair (Topology (cart R unit)) (Topology (cart R _1105705)) (@subtopology (cart R unit) (@euclidean unit) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) (@subtopology (cart R _1105705) (@euclidean _1105705) _1770670)) _1770671 _1770672).
Proof. exact (REFL (@homotopic_loops _1105705)). Qed.
Definition simply_connected {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _1778398 : (cart R N') -> Prop => forall p : (cart R unit) -> cart R N', forall q : (cart R unit) -> cart R N', ((@path N' p) /\ (((@pathfinish N' p) = (@pathstart N' p)) /\ ((@subset (cart R N') (@path_image N' p) _1778398) /\ ((@path N' q) /\ (((@pathfinish N' q) = (@pathstart N' q)) /\ (@subset (cart R N') (@path_image N' q) _1778398)))))) -> @homotopic_loops N' _1778398 p q.
Lemma simply_connected_def {N' : Type'} : (@simply_connected N') = (fun _1778398 : (cart R N') -> Prop => forall p : (cart R unit) -> cart R N', forall q : (cart R unit) -> cart R N', ((@path N' p) /\ (((@pathfinish N' p) = (@pathstart N' p)) /\ ((@subset (cart R N') (@path_image N' p) _1778398) /\ ((@path N' q) /\ (((@pathfinish N' q) = (@pathstart N' q)) /\ (@subset (cart R N') (@path_image N' q) _1778398)))))) -> @homotopic_loops N' _1778398 p q).
Proof. exact (REFL (@simply_connected N')). Qed.
Definition fundamental_group {N' : Type'} : (prod ((cart R N') -> Prop) (cart R N')) -> (((cart R unit) -> cart R N') -> Prop) -> Prop := fun _1780141 : prod ((cart R N') -> Prop) (cart R N') => @GSPEC (((cart R unit) -> cart R N') -> Prop) (fun GEN_PVAR_4998 : ((cart R unit) -> cart R N') -> Prop => exists p : (cart R unit) -> cart R N', @SETSPEC (((cart R unit) -> cart R N') -> Prop) GEN_PVAR_4998 ((@path N' p) /\ ((@subset (cart R N') (@path_image N' p) (@fst ((cart R N') -> Prop) (cart R N') _1780141)) /\ (((@pathstart N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1780141)) /\ ((@pathfinish N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1780141))))) (@homotopic_paths N' (@fst ((cart R N') -> Prop) (cart R N') _1780141) p)).
Lemma fundamental_group_def {N' : Type'} : (@fundamental_group N') = (fun _1780141 : prod ((cart R N') -> Prop) (cart R N') => @GSPEC (((cart R unit) -> cart R N') -> Prop) (fun GEN_PVAR_4998 : ((cart R unit) -> cart R N') -> Prop => exists p : (cart R unit) -> cart R N', @SETSPEC (((cart R unit) -> cart R N') -> Prop) GEN_PVAR_4998 ((@path N' p) /\ ((@subset (cart R N') (@path_image N' p) (@fst ((cart R N') -> Prop) (cart R N') _1780141)) /\ (((@pathstart N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1780141)) /\ ((@pathfinish N' p) = (@snd ((cart R N') -> Prop) (cart R N') _1780141))))) (@homotopic_paths N' (@fst ((cart R N') -> Prop) (cart R N') _1780141) p))).
Proof. exact (REFL (@fundamental_group N')). Qed.
Definition homotopy_equivalent {M N' : Type'} : ((cart R M) -> Prop) -> ((cart R N') -> Prop) -> Prop := fun _1781826 : (cart R M) -> Prop => fun _1781827 : (cart R N') -> Prop => exists f : (cart R M) -> cart R N', exists g : (cart R N') -> cart R M, (@continuous_on M N' f _1781826) /\ ((@subset (cart R N') (@IMAGE (cart R M) (cart R N') f _1781826) _1781827) /\ ((@continuous_on N' M g _1781827) /\ ((@subset (cart R M) (@IMAGE (cart R N') (cart R M) g _1781827) _1781826) /\ ((@homotopic_with (cart R M) (cart R M) (fun x : (cart R M) -> cart R M => True) (@pair (Topology (cart R M)) (Topology (cart R M)) (@subtopology (cart R M) (@euclidean M) _1781826) (@subtopology (cart R M) (@euclidean M) _1781826)) (@o (cart R M) (cart R N') (cart R M) g f) (@I (cart R M))) /\ (@homotopic_with (cart R N') (cart R N') (fun x : (cart R N') -> cart R N' => True) (@pair (Topology (cart R N')) (Topology (cart R N')) (@subtopology (cart R N') (@euclidean N') _1781827) (@subtopology (cart R N') (@euclidean N') _1781827)) (@o (cart R N') (cart R M) (cart R N') f g) (@I (cart R N'))))))).
Lemma homotopy_equivalent_def {M N' : Type'} : (@homotopy_equivalent M N') = (fun _1781826 : (cart R M) -> Prop => fun _1781827 : (cart R N') -> Prop => exists f : (cart R M) -> cart R N', exists g : (cart R N') -> cart R M, (@continuous_on M N' f _1781826) /\ ((@subset (cart R N') (@IMAGE (cart R M) (cart R N') f _1781826) _1781827) /\ ((@continuous_on N' M g _1781827) /\ ((@subset (cart R M) (@IMAGE (cart R N') (cart R M) g _1781827) _1781826) /\ ((@homotopic_with (cart R M) (cart R M) (fun x : (cart R M) -> cart R M => True) (@pair (Topology (cart R M)) (Topology (cart R M)) (@subtopology (cart R M) (@euclidean M) _1781826) (@subtopology (cart R M) (@euclidean M) _1781826)) (@o (cart R M) (cart R N') (cart R M) g f) (@I (cart R M))) /\ (@homotopic_with (cart R N') (cart R N') (fun x : (cart R N') -> cart R N' => True) (@pair (Topology (cart R N')) (Topology (cart R N')) (@subtopology (cart R N') (@euclidean N') _1781827) (@subtopology (cart R N') (@euclidean N') _1781827)) (@o (cart R N') (cart R M) (cart R N') f g) (@I (cart R N')))))))).
Proof. exact (REFL (@homotopy_equivalent M N')). Qed.
Definition contractible {_1117822 : Type'} : ((cart R _1117822) -> Prop) -> Prop := fun _1788180 : (cart R _1117822) -> Prop => exists a : cart R _1117822, @homotopic_with (cart R _1117822) (cart R _1117822) (fun x : (cart R _1117822) -> cart R _1117822 => True) (@pair (Topology (cart R _1117822)) (Topology (cart R _1117822)) (@subtopology (cart R _1117822) (@euclidean _1117822) _1788180) (@subtopology (cart R _1117822) (@euclidean _1117822) _1788180)) (fun x : cart R _1117822 => x) (fun x : cart R _1117822 => a).
Lemma contractible_def {_1117822 : Type'} : (@contractible _1117822) = (fun _1788180 : (cart R _1117822) -> Prop => exists a : cart R _1117822, @homotopic_with (cart R _1117822) (cart R _1117822) (fun x : (cart R _1117822) -> cart R _1117822 => True) (@pair (Topology (cart R _1117822)) (Topology (cart R _1117822)) (@subtopology (cart R _1117822) (@euclidean _1117822) _1788180) (@subtopology (cart R _1117822) (@euclidean _1117822) _1788180)) (fun x : cart R _1117822 => x) (fun x : cart R _1117822 => a)).
Proof. exact (REFL (@contractible _1117822)). Qed.
Definition dimension {N' : Type'} : ((cart R N') -> Prop) -> int := fun _1810042 : (cart R N') -> Prop => @COND int (_1810042 = (@set0 (cart R N'))) (oppz (int_of_nat (NUMERAL (BIT1 O)))) (int_of_nat (minimal (fun n : nat => @dimension_le (cart R N') (@subtopology (cart R N') (@euclidean N') _1810042) (int_of_nat n)))).
Lemma dimension_def {N' : Type'} : (@dimension N') = (fun _1810042 : (cart R N') -> Prop => @COND int (_1810042 = (@set0 (cart R N'))) (oppz (int_of_nat (NUMERAL (BIT1 O)))) (int_of_nat (minimal (fun n : nat => @dimension_le (cart R N') (@subtopology (cart R N') (@euclidean N') _1810042) (int_of_nat n))))).
Proof. exact (REFL (@dimension N')). Qed.
Definition covering_space {M N' : Type'} : (prod ((cart R M) -> Prop) ((cart R M) -> cart R N')) -> ((cart R N') -> Prop) -> Prop := fun _1822867 : prod ((cart R M) -> Prop) ((cart R M) -> cart R N') => fun _1822868 : (cart R N') -> Prop => (@continuous_on M N' (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) /\ (((@IMAGE (cart R M) (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) = _1822868) /\ (forall x : cart R N', (@IN (cart R N') x _1822868) -> exists t : (cart R N') -> Prop, (@IN (cart R N') x t) /\ ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1822868) t) /\ (exists v : ((cart R M) -> Prop) -> Prop, ((@UNIONS (cart R M) v) = (@GSPEC (cart R M) (fun GEN_PVAR_5060 : cart R M => exists x' : cart R M, @SETSPEC (cart R M) GEN_PVAR_5060 ((@IN (cart R M) x' (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) /\ (@IN (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867 x') t)) x'))) /\ ((forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> @open_in (cart R M) (@subtopology (cart R M) (@euclidean M) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) u) /\ ((@pairwise ((cart R M) -> Prop) (@DISJOINT (cart R M)) v) /\ (forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> exists q : (cart R N') -> cart R M, @homeomorphism M N' (@pair ((cart R M) -> Prop) ((cart R N') -> Prop) u t) (@pair ((cart R M) -> cart R N') ((cart R N') -> cart R M) (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) q)))))))).
Lemma covering_space_def {M N' : Type'} : (@covering_space M N') = (fun _1822867 : prod ((cart R M) -> Prop) ((cart R M) -> cart R N') => fun _1822868 : (cart R N') -> Prop => (@continuous_on M N' (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) /\ (((@IMAGE (cart R M) (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) = _1822868) /\ (forall x : cart R N', (@IN (cart R N') x _1822868) -> exists t : (cart R N') -> Prop, (@IN (cart R N') x t) /\ ((@open_in (cart R N') (@subtopology (cart R N') (@euclidean N') _1822868) t) /\ (exists v : ((cart R M) -> Prop) -> Prop, ((@UNIONS (cart R M) v) = (@GSPEC (cart R M) (fun GEN_PVAR_5060 : cart R M => exists x' : cart R M, @SETSPEC (cart R M) GEN_PVAR_5060 ((@IN (cart R M) x' (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) /\ (@IN (cart R N') (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867 x') t)) x'))) /\ ((forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> @open_in (cart R M) (@subtopology (cart R M) (@euclidean M) (@fst ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867)) u) /\ ((@pairwise ((cart R M) -> Prop) (@DISJOINT (cart R M)) v) /\ (forall u : (cart R M) -> Prop, (@IN ((cart R M) -> Prop) u v) -> exists q : (cart R N') -> cart R M, @homeomorphism M N' (@pair ((cart R M) -> Prop) ((cart R N') -> Prop) u t) (@pair ((cart R M) -> cart R N') ((cart R N') -> cart R M) (@snd ((cart R M) -> Prop) ((cart R M) -> cart R N') _1822867) q))))))))).
Proof. exact (REFL (@covering_space M N')). Qed.
Definition face_of {_1155202 : Type'} : ((cart R _1155202) -> Prop) -> ((cart R _1155202) -> Prop) -> Prop := fun _1979298 : (cart R _1155202) -> Prop => fun _1979299 : (cart R _1155202) -> Prop => (@subset (cart R _1155202) _1979298 _1979299) /\ ((@convex _1155202 _1979298) /\ (forall a : cart R _1155202, forall b : cart R _1155202, forall x : cart R _1155202, ((@IN (cart R _1155202) a _1979299) /\ ((@IN (cart R _1155202) b _1979299) /\ ((@IN (cart R _1155202) x _1979298) /\ (@IN (cart R _1155202) x (@open_segment _1155202 (@pair (cart R _1155202) (cart R _1155202) a b)))))) -> (@IN (cart R _1155202) a _1979298) /\ (@IN (cart R _1155202) b _1979298))).
Lemma face_of_def {_1155202 : Type'} : (@face_of _1155202) = (fun _1979298 : (cart R _1155202) -> Prop => fun _1979299 : (cart R _1155202) -> Prop => (@subset (cart R _1155202) _1979298 _1979299) /\ ((@convex _1155202 _1979298) /\ (forall a : cart R _1155202, forall b : cart R _1155202, forall x : cart R _1155202, ((@IN (cart R _1155202) a _1979299) /\ ((@IN (cart R _1155202) b _1979299) /\ ((@IN (cart R _1155202) x _1979298) /\ (@IN (cart R _1155202) x (@open_segment _1155202 (@pair (cart R _1155202) (cart R _1155202) a b)))))) -> (@IN (cart R _1155202) a _1979298) /\ (@IN (cart R _1155202) b _1979298)))).
Proof. exact (REFL (@face_of _1155202)). Qed.
Definition exposed_face_of {_1161617 : Type'} : ((cart R _1161617) -> Prop) -> ((cart R _1161617) -> Prop) -> Prop := fun _1989818 : (cart R _1161617) -> Prop => fun _1989819 : (cart R _1161617) -> Prop => (@face_of _1161617 _1989818 _1989819) /\ (exists a : cart R _1161617, exists b : R, (@subset (cart R _1161617) _1989819 (@GSPEC (cart R _1161617) (fun GEN_PVAR_5206 : cart R _1161617 => exists x : cart R _1161617, @SETSPEC (cart R _1161617) GEN_PVAR_5206 (ler (@dot _1161617 a x) b) x))) /\ (_1989818 = (@setI (cart R _1161617) _1989819 (@GSPEC (cart R _1161617) (fun GEN_PVAR_5207 : cart R _1161617 => exists x : cart R _1161617, @SETSPEC (cart R _1161617) GEN_PVAR_5207 ((@dot _1161617 a x) = b) x))))).
Lemma exposed_face_of_def {_1161617 : Type'} : (@exposed_face_of _1161617) = (fun _1989818 : (cart R _1161617) -> Prop => fun _1989819 : (cart R _1161617) -> Prop => (@face_of _1161617 _1989818 _1989819) /\ (exists a : cart R _1161617, exists b : R, (@subset (cart R _1161617) _1989819 (@GSPEC (cart R _1161617) (fun GEN_PVAR_5206 : cart R _1161617 => exists x : cart R _1161617, @SETSPEC (cart R _1161617) GEN_PVAR_5206 (ler (@dot _1161617 a x) b) x))) /\ (_1989818 = (@setI (cart R _1161617) _1989819 (@GSPEC (cart R _1161617) (fun GEN_PVAR_5207 : cart R _1161617 => exists x : cart R _1161617, @SETSPEC (cart R _1161617) GEN_PVAR_5207 ((@dot _1161617 a x) = b) x)))))).
Proof. exact (REFL (@exposed_face_of _1161617)). Qed.
Definition extreme_point_of {_1163215 : Type'} : (cart R _1163215) -> ((cart R _1163215) -> Prop) -> Prop := fun _1990563 : cart R _1163215 => fun _1990564 : (cart R _1163215) -> Prop => (@IN (cart R _1163215) _1990563 _1990564) /\ (forall a : cart R _1163215, forall b : cart R _1163215, ((@IN (cart R _1163215) a _1990564) /\ (@IN (cart R _1163215) b _1990564)) -> ~ (@IN (cart R _1163215) _1990563 (@open_segment _1163215 (@pair (cart R _1163215) (cart R _1163215) a b)))).
Lemma extreme_point_of_def {_1163215 : Type'} : (@extreme_point_of _1163215) = (fun _1990563 : cart R _1163215 => fun _1990564 : (cart R _1163215) -> Prop => (@IN (cart R _1163215) _1990563 _1990564) /\ (forall a : cart R _1163215, forall b : cart R _1163215, ((@IN (cart R _1163215) a _1990564) /\ (@IN (cart R _1163215) b _1990564)) -> ~ (@IN (cart R _1163215) _1990563 (@open_segment _1163215 (@pair (cart R _1163215) (cart R _1163215) a b))))).
Proof. exact (REFL (@extreme_point_of _1163215)). Qed.
Definition facet_of {_1168169 : Type'} : ((cart R _1168169) -> Prop) -> ((cart R _1168169) -> Prop) -> Prop := fun _2000773 : (cart R _1168169) -> Prop => fun _2000774 : (cart R _1168169) -> Prop => (@face_of _1168169 _2000773 _2000774) /\ ((~ (_2000773 = (@set0 (cart R _1168169)))) /\ ((@aff_dim _1168169 _2000773) = (subz (@aff_dim _1168169 _2000774) (int_of_nat (NUMERAL (BIT1 O)))))).
Lemma facet_of_def {_1168169 : Type'} : (@facet_of _1168169) = (fun _2000773 : (cart R _1168169) -> Prop => fun _2000774 : (cart R _1168169) -> Prop => (@face_of _1168169 _2000773 _2000774) /\ ((~ (_2000773 = (@set0 (cart R _1168169)))) /\ ((@aff_dim _1168169 _2000773) = (subz (@aff_dim _1168169 _2000774) (int_of_nat (NUMERAL (BIT1 O))))))).
Proof. exact (REFL (@facet_of _1168169)). Qed.
Definition edge_of {_1169413 : Type'} : ((cart R _1169413) -> Prop) -> ((cart R _1169413) -> Prop) -> Prop := fun _2003023 : (cart R _1169413) -> Prop => fun _2003024 : (cart R _1169413) -> Prop => (@face_of _1169413 _2003023 _2003024) /\ ((@aff_dim _1169413 _2003023) = (int_of_nat (NUMERAL (BIT1 O)))).
Lemma edge_of_def {_1169413 : Type'} : (@edge_of _1169413) = (fun _2003023 : (cart R _1169413) -> Prop => fun _2003024 : (cart R _1169413) -> Prop => (@face_of _1169413 _2003023 _2003024) /\ ((@aff_dim _1169413 _2003023) = (int_of_nat (NUMERAL (BIT1 O))))).
Proof. exact (REFL (@edge_of _1169413)). Qed.
Definition polytope {_1175731 : Type'} : ((cart R _1175731) -> Prop) -> Prop := fun _2008609 : (cart R _1175731) -> Prop => exists v : (cart R _1175731) -> Prop, (@finite_set (cart R _1175731) v) /\ (_2008609 = (@hull (cart R _1175731) (@convex _1175731) v)).
Lemma polytope_def {_1175731 : Type'} : (@polytope _1175731) = (fun _2008609 : (cart R _1175731) -> Prop => exists v : (cart R _1175731) -> Prop, (@finite_set (cart R _1175731) v) /\ (_2008609 = (@hull (cart R _1175731) (@convex _1175731) v))).
Proof. exact (REFL (@polytope _1175731)). Qed.
Definition polyhedron {_1177455 : Type'} : ((cart R _1177455) -> Prop) -> Prop := fun _2009201 : (cart R _1177455) -> Prop => exists f : ((cart R _1177455) -> Prop) -> Prop, (@finite_set ((cart R _1177455) -> Prop) f) /\ ((_2009201 = (@INTERS (cart R _1177455) f)) /\ (forall h : (cart R _1177455) -> Prop, (@IN ((cart R _1177455) -> Prop) h f) -> exists a : cart R _1177455, exists b : R, (~ (a = (@vec _1177455 (NUMERAL O)))) /\ (h = (@GSPEC (cart R _1177455) (fun GEN_PVAR_5307 : cart R _1177455 => exists x : cart R _1177455, @SETSPEC (cart R _1177455) GEN_PVAR_5307 (ler (@dot _1177455 a x) b) x))))).
Lemma polyhedron_def {_1177455 : Type'} : (@polyhedron _1177455) = (fun _2009201 : (cart R _1177455) -> Prop => exists f : ((cart R _1177455) -> Prop) -> Prop, (@finite_set ((cart R _1177455) -> Prop) f) /\ ((_2009201 = (@INTERS (cart R _1177455) f)) /\ (forall h : (cart R _1177455) -> Prop, (@IN ((cart R _1177455) -> Prop) h f) -> exists a : cart R _1177455, exists b : R, (~ (a = (@vec _1177455 (NUMERAL O)))) /\ (h = (@GSPEC (cart R _1177455) (fun GEN_PVAR_5307 : cart R _1177455 => exists x : cart R _1177455, @SETSPEC (cart R _1177455) GEN_PVAR_5307 (ler (@dot _1177455 a x) b) x)))))).
Proof. exact (REFL (@polyhedron _1177455)). Qed.
Definition simplex {_1191896 : Type'} : int -> ((cart R _1191896) -> Prop) -> Prop := fun _2264490 : int => fun _2264491 : (cart R _1191896) -> Prop => exists c : (cart R _1191896) -> Prop, (~ (@affine_dependent _1191896 c)) /\ (((int_of_nat (@CARD (cart R _1191896) c)) = (addz _2264490 (int_of_nat (NUMERAL (BIT1 O))))) /\ (_2264491 = (@hull (cart R _1191896) (@convex _1191896) c))).
Lemma simplex_def {_1191896 : Type'} : (@simplex _1191896) = (fun _2264490 : int => fun _2264491 : (cart R _1191896) -> Prop => exists c : (cart R _1191896) -> Prop, (~ (@affine_dependent _1191896 c)) /\ (((int_of_nat (@CARD (cart R _1191896) c)) = (addz _2264490 (int_of_nat (NUMERAL (BIT1 O))))) /\ (_2264491 = (@hull (cart R _1191896) (@convex _1191896) c)))).
Proof. exact (REFL (@simplex _1191896)). Qed.
Definition simplicial_complex {_1194124 : Type'} : (((cart R _1194124) -> Prop) -> Prop) -> Prop := fun _2268290 : ((cart R _1194124) -> Prop) -> Prop => (@finite_set ((cart R _1194124) -> Prop) _2268290) /\ ((forall s : (cart R _1194124) -> Prop, (@IN ((cart R _1194124) -> Prop) s _2268290) -> exists n : int, @simplex _1194124 n s) /\ ((forall f : (cart R _1194124) -> Prop, forall s : (cart R _1194124) -> Prop, ((@IN ((cart R _1194124) -> Prop) s _2268290) /\ (@face_of _1194124 f s)) -> @IN ((cart R _1194124) -> Prop) f _2268290) /\ (forall s : (cart R _1194124) -> Prop, forall s' : (cart R _1194124) -> Prop, ((@IN ((cart R _1194124) -> Prop) s _2268290) /\ (@IN ((cart R _1194124) -> Prop) s' _2268290)) -> (@face_of _1194124 (@setI (cart R _1194124) s s') s) /\ (@face_of _1194124 (@setI (cart R _1194124) s s') s')))).
Lemma simplicial_complex_def {_1194124 : Type'} : (@simplicial_complex _1194124) = (fun _2268290 : ((cart R _1194124) -> Prop) -> Prop => (@finite_set ((cart R _1194124) -> Prop) _2268290) /\ ((forall s : (cart R _1194124) -> Prop, (@IN ((cart R _1194124) -> Prop) s _2268290) -> exists n : int, @simplex _1194124 n s) /\ ((forall f : (cart R _1194124) -> Prop, forall s : (cart R _1194124) -> Prop, ((@IN ((cart R _1194124) -> Prop) s _2268290) /\ (@face_of _1194124 f s)) -> @IN ((cart R _1194124) -> Prop) f _2268290) /\ (forall s : (cart R _1194124) -> Prop, forall s' : (cart R _1194124) -> Prop, ((@IN ((cart R _1194124) -> Prop) s _2268290) /\ (@IN ((cart R _1194124) -> Prop) s' _2268290)) -> (@face_of _1194124 (@setI (cart R _1194124) s s') s) /\ (@face_of _1194124 (@setI (cart R _1194124) s s') s'))))).
Proof. exact (REFL (@simplicial_complex _1194124)). Qed.
Definition triangulation {N' : Type'} : (((cart R N') -> Prop) -> Prop) -> Prop := fun _2268295 : ((cart R N') -> Prop) -> Prop => (@finite_set ((cart R N') -> Prop) _2268295) /\ ((forall t : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) t _2268295) -> exists n : int, @simplex N' n t) /\ (forall t : (cart R N') -> Prop, forall t' : (cart R N') -> Prop, ((@IN ((cart R N') -> Prop) t _2268295) /\ (@IN ((cart R N') -> Prop) t' _2268295)) -> (@face_of N' (@setI (cart R N') t t') t) /\ (@face_of N' (@setI (cart R N') t t') t'))).
Lemma triangulation_def {N' : Type'} : (@triangulation N') = (fun _2268295 : ((cart R N') -> Prop) -> Prop => (@finite_set ((cart R N') -> Prop) _2268295) /\ ((forall t : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) t _2268295) -> exists n : int, @simplex N' n t) /\ (forall t : (cart R N') -> Prop, forall t' : (cart R N') -> Prop, ((@IN ((cart R N') -> Prop) t _2268295) /\ (@IN ((cart R N') -> Prop) t' _2268295)) -> (@face_of N' (@setI (cart R N') t t') t) /\ (@face_of N' (@setI (cart R N') t t') t')))).
Proof. exact (REFL (@triangulation N')). Qed.
Definition brouwer_degree1 {N' : Type'} : nat -> ((cart R N') -> cart R N') -> int := fun _2310794 : nat => fun _2310795 : (cart R N') -> cart R N' => @COND int ((leqn (NUMERAL (BIT1 O)) _2310794) /\ (leqn _2310794 (@dimindex N' (@setT N')))) (brouwer_degree2 (subn _2310794 (NUMERAL (BIT1 O))) (@o (nat -> R) (cart R N') (nat -> R) (fun x : cart R N' => fun i : nat => @COND R ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i _2310794)) (@dollar R N' x i) (R_of_nat (NUMERAL O))) (@o (nat -> R) (cart R N') (cart R N') _2310795 (fun x : nat -> R => @lambda R N' (fun i : nat => @COND R ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i _2310794)) (x i) (R_of_nat (NUMERAL O))))))) (int_of_nat (NUMERAL (BIT1 O))).
Lemma brouwer_degree1_def {N' : Type'} : (@brouwer_degree1 N') = (fun _2310794 : nat => fun _2310795 : (cart R N') -> cart R N' => @COND int ((leqn (NUMERAL (BIT1 O)) _2310794) /\ (leqn _2310794 (@dimindex N' (@setT N')))) (brouwer_degree2 (subn _2310794 (NUMERAL (BIT1 O))) (@o (nat -> R) (cart R N') (nat -> R) (fun x : cart R N' => fun i : nat => @COND R ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i _2310794)) (@dollar R N' x i) (R_of_nat (NUMERAL O))) (@o (nat -> R) (cart R N') (cart R N') _2310795 (fun x : nat -> R => @lambda R N' (fun i : nat => @COND R ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i _2310794)) (x i) (R_of_nat (NUMERAL O))))))) (int_of_nat (NUMERAL (BIT1 O)))).
Proof. exact (REFL (@brouwer_degree1 N')). Qed.
Definition brouwer_degree {N' : Type'} : ((cart R N') -> cart R N') -> int := fun _2310806 : (cart R N') -> cart R N' => @brouwer_degree1 N' (@dimindex N' (@setT N')) _2310806.
Lemma brouwer_degree_def {N' : Type'} : (@brouwer_degree N') = (fun _2310806 : (cart R N') -> cart R N' => @brouwer_degree1 N' (@dimindex N' (@setT N')) _2310806).
Proof. exact (REFL (@brouwer_degree N')). Qed.
Definition retraction {N' : Type'} : (prod ((cart R N') -> Prop) ((cart R N') -> Prop)) -> ((cart R N') -> cart R N') -> Prop := fun _2317196 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => fun _2317197 : (cart R N') -> cart R N' => (@subset (cart R N') (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ ((@continuous_on N' N' _2317197 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ ((@subset (cart R N') (@IMAGE (cart R N') (cart R N') _2317197 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ (forall x : cart R N', (@IN (cart R N') x (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) -> (_2317197 x) = x))).
Lemma retraction_def {N' : Type'} : (@retraction N') = (fun _2317196 : prod ((cart R N') -> Prop) ((cart R N') -> Prop) => fun _2317197 : (cart R N') -> cart R N' => (@subset (cart R N') (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196) (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ ((@continuous_on N' N' _2317197 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ ((@subset (cart R N') (@IMAGE (cart R N') (cart R N') _2317197 (@fst ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) /\ (forall x : cart R N', (@IN (cart R N') x (@snd ((cart R N') -> Prop) ((cart R N') -> Prop) _2317196)) -> (_2317197 x) = x)))).
Proof. exact (REFL (@retraction N')). Qed.
Definition retract_of {_1202609 : Type'} : ((cart R _1202609) -> Prop) -> ((cart R _1202609) -> Prop) -> Prop := fun _2317213 : (cart R _1202609) -> Prop => fun _2317214 : (cart R _1202609) -> Prop => exists r : (cart R _1202609) -> cart R _1202609, @retraction _1202609 (@pair ((cart R _1202609) -> Prop) ((cart R _1202609) -> Prop) _2317214 _2317213) r.
Lemma retract_of_def {_1202609 : Type'} : (@retract_of _1202609) = (fun _2317213 : (cart R _1202609) -> Prop => fun _2317214 : (cart R _1202609) -> Prop => exists r : (cart R _1202609) -> cart R _1202609, @retraction _1202609 (@pair ((cart R _1202609) -> Prop) ((cart R _1202609) -> Prop) _2317214 _2317213) r).
Proof. exact (REFL (@retract_of _1202609)). Qed.
Definition AR {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _2362912 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2362912 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> @retract_of (finite_sum N' unit) s' u.
Lemma AR_def {N' : Type'} : (@AR N') = (fun _2362912 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2362912 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> @retract_of (finite_sum N' unit) s' u).
Proof. exact (REFL (@AR N')). Qed.
Definition ANR {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _2362917 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2362917 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> exists t : (cart R (finite_sum N' unit)) -> Prop, (@open_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) t) /\ (@retract_of (finite_sum N' unit) s' t).
Lemma ANR_def {N' : Type'} : (@ANR N') = (fun _2362917 : (cart R N') -> Prop => forall u : (cart R (finite_sum N' unit)) -> Prop, forall s' : (cart R (finite_sum N' unit)) -> Prop, ((@homeomorphic (finite_sum N' unit) N' _2362917 s') /\ (@closed_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) s')) -> exists t : (cart R (finite_sum N' unit)) -> Prop, (@open_in (cart R (finite_sum N' unit)) (@subtopology (cart R (finite_sum N' unit)) (@euclidean (finite_sum N' unit)) u) t) /\ (@retract_of (finite_sum N' unit) s' t)).
Proof. exact (REFL (@ANR N')). Qed.
Definition ENR {_1211657 : Type'} : ((cart R _1211657) -> Prop) -> Prop := fun _2362922 : (cart R _1211657) -> Prop => exists u : (cart R _1211657) -> Prop, (@_open _1211657 u) /\ (@retract_of _1211657 _2362922 u).
Lemma ENR_def {_1211657 : Type'} : (@ENR _1211657) = (fun _2362922 : (cart R _1211657) -> Prop => exists u : (cart R _1211657) -> Prop, (@_open _1211657 u) /\ (@retract_of _1211657 _2362922 u)).
Proof. exact (REFL (@ENR _1211657)). Qed.
Definition interval_bij {N' : Type'} : (prod (cart R N') (cart R N')) -> (prod (cart R N') (cart R N')) -> (cart R N') -> cart R N' := fun _2460822 : prod (cart R N') (cart R N') => fun _2460823 : prod (cart R N') (cart R N') => fun _2460824 : cart R N' => @lambda R N' (fun i : nat => addr (@dollar R N' (@fst (cart R N') (cart R N') _2460823) i) (mulr (divr (subr (@dollar R N' _2460824 i) (@dollar R N' (@fst (cart R N') (cart R N') _2460822) i)) (subr (@dollar R N' (@snd (cart R N') (cart R N') _2460822) i) (@dollar R N' (@fst (cart R N') (cart R N') _2460822) i))) (subr (@dollar R N' (@snd (cart R N') (cart R N') _2460823) i) (@dollar R N' (@fst (cart R N') (cart R N') _2460823) i)))).
Lemma interval_bij_def {N' : Type'} : (@interval_bij N') = (fun _2460822 : prod (cart R N') (cart R N') => fun _2460823 : prod (cart R N') (cart R N') => fun _2460824 : cart R N' => @lambda R N' (fun i : nat => addr (@dollar R N' (@fst (cart R N') (cart R N') _2460823) i) (mulr (divr (subr (@dollar R N' _2460824 i) (@dollar R N' (@fst (cart R N') (cart R N') _2460822) i)) (subr (@dollar R N' (@snd (cart R N') (cart R N') _2460822) i) (@dollar R N' (@fst (cart R N') (cart R N') _2460822) i))) (subr (@dollar R N' (@snd (cart R N') (cart R N') _2460823) i) (@dollar R N' (@fst (cart R N') (cart R N') _2460823) i))))).
Proof. exact (REFL (@interval_bij N')). Qed.
Definition has_derivative {_1242316 _1242319 : Type'} : ((cart R _1242319) -> cart R _1242316) -> ((cart R _1242319) -> cart R _1242316) -> (net (cart R _1242319)) -> Prop := fun _2496512 : (cart R _1242319) -> cart R _1242316 => fun _2496513 : (cart R _1242319) -> cart R _1242316 => fun _2496514 : net (cart R _1242319) => (@linear _1242319 _1242316 _2496513) /\ (@FImp _1242316 (cart R _1242319) (fun y : cart R _1242319 => @percent _1242316 (invr (@vector_norm _1242319 (@vector_sub _1242319 y (@netlimit (cart R _1242319) _2496514)))) (@vector_sub _1242316 (_2496512 y) (@vector_add _1242316 (_2496512 (@netlimit (cart R _1242319) _2496514)) (_2496513 (@vector_sub _1242319 y (@netlimit (cart R _1242319) _2496514)))))) (@vec _1242316 (NUMERAL O)) _2496514).
Lemma has_derivative_def {_1242316 _1242319 : Type'} : (@has_derivative _1242316 _1242319) = (fun _2496512 : (cart R _1242319) -> cart R _1242316 => fun _2496513 : (cart R _1242319) -> cart R _1242316 => fun _2496514 : net (cart R _1242319) => (@linear _1242319 _1242316 _2496513) /\ (@FImp _1242316 (cart R _1242319) (fun y : cart R _1242319 => @percent _1242316 (invr (@vector_norm _1242319 (@vector_sub _1242319 y (@netlimit (cart R _1242319) _2496514)))) (@vector_sub _1242316 (_2496512 y) (@vector_add _1242316 (_2496512 (@netlimit (cart R _1242319) _2496514)) (_2496513 (@vector_sub _1242319 y (@netlimit (cart R _1242319) _2496514)))))) (@vec _1242316 (NUMERAL O)) _2496514)).
Proof. exact (REFL (@has_derivative _1242316 _1242319)). Qed.
Definition differentiable {_1244272 _1244273 : Type'} : ((cart R _1244273) -> cart R _1244272) -> (net (cart R _1244273)) -> Prop := fun _2496830 : (cart R _1244273) -> cart R _1244272 => fun _2496831 : net (cart R _1244273) => exists f' : (cart R _1244273) -> cart R _1244272, @has_derivative _1244272 _1244273 _2496830 f' _2496831.
Lemma differentiable_def {_1244272 _1244273 : Type'} : (@differentiable _1244272 _1244273) = (fun _2496830 : (cart R _1244273) -> cart R _1244272 => fun _2496831 : net (cart R _1244273) => exists f' : (cart R _1244273) -> cart R _1244272, @has_derivative _1244272 _1244273 _2496830 f' _2496831).
Proof. exact (REFL (@differentiable _1244272 _1244273)). Qed.
Definition differentiable_on {_1244290 _1244296 : Type'} : ((cart R _1244296) -> cart R _1244290) -> ((cart R _1244296) -> Prop) -> Prop := fun _2496842 : (cart R _1244296) -> cart R _1244290 => fun _2496843 : (cart R _1244296) -> Prop => forall x : cart R _1244296, (@IN (cart R _1244296) x _2496843) -> @differentiable _1244290 _1244296 _2496842 (@within (cart R _1244296) (@_at _1244296 x) _2496843).
Lemma differentiable_on_def {_1244290 _1244296 : Type'} : (@differentiable_on _1244290 _1244296) = (fun _2496842 : (cart R _1244296) -> cart R _1244290 => fun _2496843 : (cart R _1244296) -> Prop => forall x : cart R _1244296, (@IN (cart R _1244296) x _2496843) -> @differentiable _1244290 _1244296 _2496842 (@within (cart R _1244296) (@_at _1244296 x) _2496843)).
Proof. exact (REFL (@differentiable_on _1244290 _1244296)). Qed.
Definition frechet_derivative {_1244650 _1244651 : Type'} : ((cart R _1244651) -> cart R _1244650) -> (net (cart R _1244651)) -> (cart R _1244651) -> cart R _1244650 := fun _2497472 : (cart R _1244651) -> cart R _1244650 => fun _2497473 : net (cart R _1244651) => @ε ((cart R _1244651) -> cart R _1244650) (fun f' : (cart R _1244651) -> cart R _1244650 => @has_derivative _1244650 _1244651 _2497472 f' _2497473).
Lemma frechet_derivative_def {_1244650 _1244651 : Type'} : (@frechet_derivative _1244650 _1244651) = (fun _2497472 : (cart R _1244651) -> cart R _1244650 => fun _2497473 : net (cart R _1244651) => @ε ((cart R _1244651) -> cart R _1244650) (fun f' : (cart R _1244651) -> cart R _1244650 => @has_derivative _1244650 _1244651 _2497472 f' _2497473)).
Proof. exact (REFL (@frechet_derivative _1244650 _1244651)). Qed.
Definition jacobian {_1244709 _1244710 : Type'} : ((cart R _1244709) -> cart R _1244710) -> (net (cart R _1244709)) -> cart (cart R _1244709) _1244710 := fun _2497484 : (cart R _1244709) -> cart R _1244710 => fun _2497485 : net (cart R _1244709) => @matrix _1244709 _1244710 (@frechet_derivative _1244710 _1244709 _2497484 _2497485).
Lemma jacobian_def {_1244709 _1244710 : Type'} : (@jacobian _1244709 _1244710) = (fun _2497484 : (cart R _1244709) -> cart R _1244710 => fun _2497485 : net (cart R _1244709) => @matrix _1244709 _1244710 (@frechet_derivative _1244710 _1244709 _2497484 _2497485)).
Proof. exact (REFL (@jacobian _1244709 _1244710)). Qed.
Definition has_vector_derivative {_1273796 : Type'} : ((cart R unit) -> cart R _1273796) -> (cart R _1273796) -> (net (cart R unit)) -> Prop := fun _2662134 : (cart R unit) -> cart R _1273796 => fun _2662135 : cart R _1273796 => fun _2662136 : net (cart R unit) => @has_derivative _1273796 unit _2662134 (fun x : cart R unit => @percent _1273796 (drop x) _2662135) _2662136.
Lemma has_vector_derivative_def {_1273796 : Type'} : (@has_vector_derivative _1273796) = (fun _2662134 : (cart R unit) -> cart R _1273796 => fun _2662135 : cart R _1273796 => fun _2662136 : net (cart R unit) => @has_derivative _1273796 unit _2662134 (fun x : cart R unit => @percent _1273796 (drop x) _2662135) _2662136).
Proof. exact (REFL (@has_vector_derivative _1273796)). Qed.
Definition vector_derivative {N' : Type'} : ((cart R unit) -> cart R N') -> (net (cart R unit)) -> cart R N' := fun _2662155 : (cart R unit) -> cart R N' => fun _2662156 : net (cart R unit) => @ε (cart R N') (fun f' : cart R N' => @has_vector_derivative N' _2662155 f' _2662156).
Lemma vector_derivative_def {N' : Type'} : (@vector_derivative N') = (fun _2662155 : (cart R unit) -> cart R N' => fun _2662156 : net (cart R unit) => @ε (cart R N') (fun f' : cart R N' => @has_vector_derivative N' _2662155 f' _2662156)).
Proof. exact (REFL (@vector_derivative N')). Qed.
Definition bitset : nat -> nat -> Prop := fun _2664400 : nat => @GSPEC nat (fun GEN_PVAR_5739 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_5739 (oddn (divn _2664400 (expn (NUMERAL (BIT0 (BIT1 O))) i))) i).
Lemma bitset_def : bitset = (fun _2664400 : nat => @GSPEC nat (fun GEN_PVAR_5739 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_5739 (oddn (divn _2664400 (expn (NUMERAL (BIT0 (BIT1 O))) i))) i)).
Proof. exact (REFL bitset). Qed.
Definition binarysum : (nat -> Prop) -> nat := fun _2664405 : nat -> Prop => @nsum nat _2664405 (fun i : nat => expn (NUMERAL (BIT0 (BIT1 O))) i).
Lemma binarysum_def : binarysum = (fun _2664405 : nat -> Prop => @nsum nat _2664405 (fun i : nat => expn (NUMERAL (BIT0 (BIT1 O))) i)).
Proof. exact (REFL binarysum). Qed.
Definition setcode : (nat -> Prop) -> nat := fun _2665271 : nat -> Prop => addn (NUMERAL (BIT1 O)) (binarysum (@IMAGE nat nat predn _2665271)).
Lemma setcode_def : setcode = (fun _2665271 : nat -> Prop => addn (NUMERAL (BIT1 O)) (binarysum (@IMAGE nat nat predn _2665271))).
Proof. exact (REFL setcode). Qed.
Definition codeset : nat -> nat -> Prop := fun _2665276 : nat => @IMAGE nat nat S (bitset (subn _2665276 (NUMERAL (BIT1 O)))).
Lemma codeset_def : codeset = (fun _2665276 : nat => @IMAGE nat nat S (bitset (subn _2665276 (NUMERAL (BIT1 O))))).
Proof. exact (REFL codeset). Qed.
Definition dollardollar {N' : Type'} : (cart R (Multivector N')) -> (nat -> Prop) -> R := fun _2665602 : cart R (Multivector N') => fun _2665603 : nat -> Prop => @dollar R (Multivector N') _2665602 (setcode _2665603).
Lemma dollardollar_def {N' : Type'} : (@dollardollar N') = (fun _2665602 : cart R (Multivector N') => fun _2665603 : nat -> Prop => @dollar R (Multivector N') _2665602 (setcode _2665603)).
Proof. exact (REFL (@dollardollar N')). Qed.
Definition lambdas {N' : Type'} : ((nat -> Prop) -> R) -> cart R (Multivector N') := fun _2665614 : (nat -> Prop) -> R => @lambda R (Multivector N') (fun i : nat => _2665614 (codeset i)).
Lemma lambdas_def {N' : Type'} : (@lambdas N') = (fun _2665614 : (nat -> Prop) -> R => @lambda R (Multivector N') (fun i : nat => _2665614 (codeset i))).
Proof. exact (REFL (@lambdas N')). Qed.
Definition mbasis {_1279902 : Type'} : (nat -> Prop) -> cart R (Multivector _1279902) := fun _2665657 : nat -> Prop => @lambdas _1279902 (fun s : nat -> Prop => @COND R (_2665657 = s) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))).
Lemma mbasis_def {_1279902 : Type'} : (@mbasis _1279902) = (fun _2665657 : nat -> Prop => @lambdas _1279902 (fun s : nat -> Prop => @COND R (_2665657 = s) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O)))).
Proof. exact (REFL (@mbasis _1279902)). Qed.
Definition multivec {N' : Type'} : (cart R N') -> cart R (Multivector N') := fun _2665933 : cart R N' => @vsum nat (Multivector N') (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @percent (Multivector N') (@dollar R N' _2665933 i) (@mbasis N' (@INSERT nat i (@set0 nat)))).
Lemma multivec_def {N' : Type'} : (@multivec N') = (fun _2665933 : cart R N' => @vsum nat (Multivector N') (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N'))) (fun i : nat => @percent (Multivector N') (@dollar R N' _2665933 i) (@mbasis N' (@INSERT nat i (@set0 nat))))).
Proof. exact (REFL (@multivec N')). Qed.
Definition multivector {N' : Type'} : nat -> (cart R (Multivector N')) -> Prop := fun _2665938 : nat => fun _2665939 : cart R (Multivector N') => forall s : nat -> Prop, ((@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ (~ ((@dollardollar N' _2665939 s) = (R_of_nat (NUMERAL O))))) -> @HAS_SIZE nat s _2665938.
Lemma multivector_def {N' : Type'} : (@multivector N') = (fun _2665938 : nat => fun _2665939 : cart R (Multivector N') => forall s : nat -> Prop, ((@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ (~ ((@dollardollar N' _2665939 s) = (R_of_nat (NUMERAL O))))) -> @HAS_SIZE nat s _2665938).
Proof. exact (REFL (@multivector N')). Qed.
Definition grade {N' : Type'} : nat -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2665950 : nat => fun _2665951 : cart R (Multivector N') => @lambdas N' (fun s : nat -> Prop => @COND R (@HAS_SIZE nat s _2665950) (@dollardollar N' _2665951 s) (R_of_nat (NUMERAL O))).
Lemma grade_def {N' : Type'} : (@grade N') = (fun _2665950 : nat => fun _2665951 : cart R (Multivector N') => @lambdas N' (fun s : nat -> Prop => @COND R (@HAS_SIZE nat s _2665950) (@dollardollar N' _2665951 s) (R_of_nat (NUMERAL O)))).
Proof. exact (REFL (@grade N')). Qed.
Definition Product {N' : Type'} : ((nat -> Prop) -> (nat -> Prop) -> R) -> ((nat -> Prop) -> (nat -> Prop) -> nat -> Prop) -> (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2665966 : (nat -> Prop) -> (nat -> Prop) -> R => fun _2665967 : (nat -> Prop) -> (nat -> Prop) -> nat -> Prop => fun _2665968 : cart R (Multivector N') => fun _2665969 : cart R (Multivector N') => @vsum (nat -> Prop) (Multivector N') (@GSPEC (nat -> Prop) (fun GEN_PVAR_5752 : nat -> Prop => exists s : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5752 (@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s)) (fun s : nat -> Prop => @vsum (nat -> Prop) (Multivector N') (@GSPEC (nat -> Prop) (fun GEN_PVAR_5753 : nat -> Prop => exists s' : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5753 (@subset nat s' (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s')) (fun t : nat -> Prop => @percent (Multivector N') (mulr (@dollardollar N' _2665968 s) (mulr (@dollardollar N' _2665969 t) (_2665966 s t))) (@mbasis N' (_2665967 s t)))).
Lemma Product_def {N' : Type'} : (@Product N') = (fun _2665966 : (nat -> Prop) -> (nat -> Prop) -> R => fun _2665967 : (nat -> Prop) -> (nat -> Prop) -> nat -> Prop => fun _2665968 : cart R (Multivector N') => fun _2665969 : cart R (Multivector N') => @vsum (nat -> Prop) (Multivector N') (@GSPEC (nat -> Prop) (fun GEN_PVAR_5752 : nat -> Prop => exists s : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5752 (@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s)) (fun s : nat -> Prop => @vsum (nat -> Prop) (Multivector N') (@GSPEC (nat -> Prop) (fun GEN_PVAR_5753 : nat -> Prop => exists s' : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5753 (@subset nat s' (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s')) (fun t : nat -> Prop => @percent (Multivector N') (mulr (@dollardollar N' _2665968 s) (mulr (@dollardollar N' _2665969 t) (_2665966 s t))) (@mbasis N' (_2665967 s t))))).
Proof. exact (REFL (@Product N')). Qed.
Definition geom_mul {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2667145 : cart R (Multivector N') => fun _2667146 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5755 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5755 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667145 _2667146.
Lemma geom_mul_def {N' : Type'} : (@geom_mul N') = (fun _2667145 : cart R (Multivector N') => fun _2667146 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5755 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5755 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667145 _2667146).
Proof. exact (REFL (@geom_mul N')). Qed.
Definition outer {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2667229 : cart R (Multivector N') => fun _2667230 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => @COND R (~ ((@setI nat s t) = (@set0 nat))) (R_of_nat (NUMERAL O)) (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5756 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5756 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j)))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667229 _2667230.
Lemma outer_def {N' : Type'} : (@outer N') = (fun _2667229 : cart R (Multivector N') => fun _2667230 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => @COND R (~ ((@setI nat s t) = (@set0 nat))) (R_of_nat (NUMERAL O)) (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5756 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5756 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j)))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667229 _2667230).
Proof. exact (REFL (@outer N')). Qed.
Definition inner {N' : Type'} : (cart R (Multivector N')) -> (cart R (Multivector N')) -> cart R (Multivector N') := fun _2667415 : cart R (Multivector N') => fun _2667416 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => @COND R ((s = (@set0 nat)) \/ ((t = (@set0 nat)) \/ (~ (((@setD nat s t) = (@set0 nat)) /\ (~ ((@setD nat t s) = (@set0 nat))))))) (R_of_nat (NUMERAL O)) (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5758 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5758 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j)))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667415 _2667416.
Lemma inner_def {N' : Type'} : (@inner N') = (fun _2667415 : cart R (Multivector N') => fun _2667416 : cart R (Multivector N') => @Product N' (fun s : nat -> Prop => fun t : nat -> Prop => @COND R ((s = (@set0 nat)) \/ ((t = (@set0 nat)) \/ (~ (((@setD nat s t) = (@set0 nat)) /\ (~ ((@setD nat t s) = (@set0 nat))))))) (R_of_nat (NUMERAL O)) (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (@CARD (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_5758 : prod nat nat => exists i : nat, exists j : nat, @SETSPEC (prod nat nat) GEN_PVAR_5758 ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) /\ ((@IN nat i s) /\ ((@IN nat j t) /\ (gtn i j))))) (@pair nat nat i j)))))) (fun s : nat -> Prop => fun t : nat -> Prop => @setU nat (@setD nat s t) (@setD nat t s)) _2667415 _2667416).
Proof. exact (REFL (@inner N')). Qed.
Definition seqiterate {_1283247 : Type'} : (_1283247 -> _1283247 -> _1283247) -> (nat -> Prop) -> (nat -> _1283247) -> _1283247 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (_1283247 -> _1283247 -> _1283247) -> (nat -> Prop) -> (nat -> _1283247) -> _1283247) (fun h : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (_1283247 -> _1283247 -> _1283247) -> (nat -> Prop) -> (nat -> _1283247) -> _1283247 => forall _2669056 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), forall op : _1283247 -> _1283247 -> _1283247, forall f : nat -> _1283247, forall s : nat -> Prop, (h _2669056 op s f) = (@COND _1283247 ((@INFINITE nat s) \/ (s = (@set0 nat))) (@neutral _1283247 op) (@LET nat _1283247 (fun i : nat => @LET_END _1283247 (@COND _1283247 (s = (@INSERT nat i (@set0 nat))) (f i) (op (f i) (h _2669056 op (@DELETE nat s i) f)))) (minimal (fun x : nat => @IN nat x s))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))))))).
Lemma seqiterate_def {_1283247 : Type'} : (@seqiterate _1283247) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (_1283247 -> _1283247 -> _1283247) -> (nat -> Prop) -> (nat -> _1283247) -> _1283247) (fun h : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) -> (_1283247 -> _1283247 -> _1283247) -> (nat -> Prop) -> (nat -> _1283247) -> _1283247 => forall _2669056 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))), forall op : _1283247 -> _1283247 -> _1283247, forall f : nat -> _1283247, forall s : nat -> Prop, (h _2669056 op s f) = (@COND _1283247 ((@INFINITE nat s) \/ (s = (@set0 nat))) (@neutral _1283247 op) (@LET nat _1283247 (fun i : nat => @LET_END _1283247 (@COND _1283247 (s = (@INSERT nat i (@set0 nat))) (f i) (op (f i) (h _2669056 op (@DELETE nat s i) f)))) (minimal (fun x : nat => @IN nat x s))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))))))).
Proof. exact (REFL (@seqiterate _1283247)). Qed.
Definition outermorphism {N' P : Type'} : ((cart R N') -> cart R P) -> (cart R (Multivector N')) -> cart R (Multivector P) := fun _2669326 : (cart R N') -> cart R P => fun _2669327 : cart R (Multivector N') => @vsum (nat -> Prop) (Multivector P) (@GSPEC (nat -> Prop) (fun GEN_PVAR_5766 : nat -> Prop => exists s : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5766 (@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s)) (fun s : nat -> Prop => @percent (Multivector P) (@dollardollar N' _2669327 s) (@seqiterate (cart R (Multivector P)) (@outer P) s (@o nat (cart R P) (cart R (Multivector P)) (@multivec P) (@o nat (cart R N') (cart R P) _2669326 (@basis N'))))).
Lemma outermorphism_def {N' P : Type'} : (@outermorphism N' P) = (fun _2669326 : (cart R N') -> cart R P => fun _2669327 : cart R (Multivector N') => @vsum (nat -> Prop) (Multivector P) (@GSPEC (nat -> Prop) (fun GEN_PVAR_5766 : nat -> Prop => exists s : nat -> Prop, @SETSPEC (nat -> Prop) GEN_PVAR_5766 (@subset nat s (dotdot (NUMERAL (BIT1 O)) (@dimindex N' (@setT N')))) s)) (fun s : nat -> Prop => @percent (Multivector P) (@dollardollar N' _2669327 s) (@seqiterate (cart R (Multivector P)) (@outer P) s (@o nat (cart R P) (cart R (Multivector P)) (@multivec P) (@o nat (cart R N') (cart R P) _2669326 (@basis N')))))).
Proof. exact (REFL (@outermorphism N' P)). Qed.
Definition reversion {N' : Type'} : (cart R (Multivector N')) -> cart R (Multivector N') := fun _2669445 : cart R (Multivector N') => @lambdas N' (fun s : nat -> Prop => mulr (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (divn (muln (@CARD nat s) (subn (@CARD nat s) (NUMERAL (BIT1 O)))) (NUMERAL (BIT0 (BIT1 O))))) (@dollardollar N' _2669445 s)).
Lemma reversion_def {N' : Type'} : (@reversion N') = (fun _2669445 : cart R (Multivector N') => @lambdas N' (fun s : nat -> Prop => mulr (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (divn (muln (@CARD nat s) (subn (@CARD nat s) (NUMERAL (BIT1 O)))) (NUMERAL (BIT0 (BIT1 O))))) (@dollardollar N' _2669445 s))).
Proof. exact (REFL (@reversion N')). Qed.
Definition interval_upperbound {M : Type'} : ((cart R M) -> Prop) -> cart R M := fun _2669760 : (cart R M) -> Prop => @lambda R M (fun i : nat => sup (@GSPEC R (fun GEN_PVAR_5770 : R => exists a : R, @SETSPEC R GEN_PVAR_5770 (exists x : cart R M, (@IN (cart R M) x _2669760) /\ ((@dollar R M x i) = a)) a))).
Lemma interval_upperbound_def {M : Type'} : (@interval_upperbound M) = (fun _2669760 : (cart R M) -> Prop => @lambda R M (fun i : nat => sup (@GSPEC R (fun GEN_PVAR_5770 : R => exists a : R, @SETSPEC R GEN_PVAR_5770 (exists x : cart R M, (@IN (cart R M) x _2669760) /\ ((@dollar R M x i) = a)) a)))).
Proof. exact (REFL (@interval_upperbound M)). Qed.
Definition interval_lowerbound {M : Type'} : ((cart R M) -> Prop) -> cart R M := fun _2669765 : (cart R M) -> Prop => @lambda R M (fun i : nat => inf (@GSPEC R (fun GEN_PVAR_5771 : R => exists a : R, @SETSPEC R GEN_PVAR_5771 (exists x : cart R M, (@IN (cart R M) x _2669765) /\ ((@dollar R M x i) = a)) a))).
Lemma interval_lowerbound_def {M : Type'} : (@interval_lowerbound M) = (fun _2669765 : (cart R M) -> Prop => @lambda R M (fun i : nat => inf (@GSPEC R (fun GEN_PVAR_5771 : R => exists a : R, @SETSPEC R GEN_PVAR_5771 (exists x : cart R M, (@IN (cart R M) x _2669765) /\ ((@dollar R M x i) = a)) a)))).
Proof. exact (REFL (@interval_lowerbound M)). Qed.
Definition content {M : Type'} : ((cart R M) -> Prop) -> R := fun _2669872 : (cart R M) -> Prop => @COND R (_2669872 = (@set0 (cart R M))) (R_of_nat (NUMERAL O)) (@product nat (dotdot (NUMERAL (BIT1 O)) (@dimindex M (@setT M))) (fun i : nat => subr (@dollar R M (@interval_upperbound M _2669872) i) (@dollar R M (@interval_lowerbound M _2669872) i))).
Lemma content_def {M : Type'} : (@content M) = (fun _2669872 : (cart R M) -> Prop => @COND R (_2669872 = (@set0 (cart R M))) (R_of_nat (NUMERAL O)) (@product nat (dotdot (NUMERAL (BIT1 O)) (@dimindex M (@setT M))) (fun i : nat => subr (@dollar R M (@interval_upperbound M _2669872) i) (@dollar R M (@interval_lowerbound M _2669872) i)))).
Proof. exact (REFL (@content M)). Qed.
Definition gauge {_1286059 : Type'} : ((cart R _1286059) -> (cart R _1286059) -> Prop) -> Prop := fun _2670706 : (cart R _1286059) -> (cart R _1286059) -> Prop => forall x : cart R _1286059, (@IN (cart R _1286059) x (_2670706 x)) /\ (@_open _1286059 (_2670706 x)).
Lemma gauge_def {_1286059 : Type'} : (@gauge _1286059) = (fun _2670706 : (cart R _1286059) -> (cart R _1286059) -> Prop => forall x : cart R _1286059, (@IN (cart R _1286059) x (_2670706 x)) /\ (@_open _1286059 (_2670706 x))).
Proof. exact (REFL (@gauge _1286059)). Qed.
Definition division_of {_1286363 : Type'} : (((cart R _1286363) -> Prop) -> Prop) -> ((cart R _1286363) -> Prop) -> Prop := fun _2670745 : ((cart R _1286363) -> Prop) -> Prop => fun _2670746 : (cart R _1286363) -> Prop => (@finite_set ((cart R _1286363) -> Prop) _2670745) /\ ((forall k : (cart R _1286363) -> Prop, (@IN ((cart R _1286363) -> Prop) k _2670745) -> (@subset (cart R _1286363) k _2670746) /\ ((~ (k = (@set0 (cart R _1286363)))) /\ (exists a : cart R _1286363, exists b : cart R _1286363, k = (@closed_interval _1286363 (@cons (prod (cart R _1286363) (cart R _1286363)) (@pair (cart R _1286363) (cart R _1286363) a b) (@nil (prod (cart R _1286363) (cart R _1286363)))))))) /\ ((forall k1 : (cart R _1286363) -> Prop, forall k2 : (cart R _1286363) -> Prop, ((@IN ((cart R _1286363) -> Prop) k1 _2670745) /\ ((@IN ((cart R _1286363) -> Prop) k2 _2670745) /\ (~ (k1 = k2)))) -> (@setI (cart R _1286363) (@interior _1286363 k1) (@interior _1286363 k2)) = (@set0 (cart R _1286363))) /\ ((@UNIONS (cart R _1286363) _2670745) = _2670746))).
Lemma division_of_def {_1286363 : Type'} : (@division_of _1286363) = (fun _2670745 : ((cart R _1286363) -> Prop) -> Prop => fun _2670746 : (cart R _1286363) -> Prop => (@finite_set ((cart R _1286363) -> Prop) _2670745) /\ ((forall k : (cart R _1286363) -> Prop, (@IN ((cart R _1286363) -> Prop) k _2670745) -> (@subset (cart R _1286363) k _2670746) /\ ((~ (k = (@set0 (cart R _1286363)))) /\ (exists a : cart R _1286363, exists b : cart R _1286363, k = (@closed_interval _1286363 (@cons (prod (cart R _1286363) (cart R _1286363)) (@pair (cart R _1286363) (cart R _1286363) a b) (@nil (prod (cart R _1286363) (cart R _1286363)))))))) /\ ((forall k1 : (cart R _1286363) -> Prop, forall k2 : (cart R _1286363) -> Prop, ((@IN ((cart R _1286363) -> Prop) k1 _2670745) /\ ((@IN ((cart R _1286363) -> Prop) k2 _2670745) /\ (~ (k1 = k2)))) -> (@setI (cart R _1286363) (@interior _1286363 k1) (@interior _1286363 k2)) = (@set0 (cart R _1286363))) /\ ((@UNIONS (cart R _1286363) _2670745) = _2670746)))).
Proof. exact (REFL (@division_of _1286363)). Qed.
Definition tagged_partial_division_of {_1291918 : Type'} : ((prod (cart R _1291918) ((cart R _1291918) -> Prop)) -> Prop) -> ((cart R _1291918) -> Prop) -> Prop := fun _2701857 : (prod (cart R _1291918) ((cart R _1291918) -> Prop)) -> Prop => fun _2701858 : (cart R _1291918) -> Prop => (@finite_set (prod (cart R _1291918) ((cart R _1291918) -> Prop)) _2701857) /\ ((forall x : cart R _1291918, forall k : (cart R _1291918) -> Prop, (@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x k) _2701857) -> (@IN (cart R _1291918) x k) /\ ((@subset (cart R _1291918) k _2701858) /\ (exists a : cart R _1291918, exists b : cart R _1291918, k = (@closed_interval _1291918 (@cons (prod (cart R _1291918) (cart R _1291918)) (@pair (cart R _1291918) (cart R _1291918) a b) (@nil (prod (cart R _1291918) (cart R _1291918)))))))) /\ (forall x1 : cart R _1291918, forall k1 : (cart R _1291918) -> Prop, forall x2 : cart R _1291918, forall k2 : (cart R _1291918) -> Prop, ((@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x1 k1) _2701857) /\ ((@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x2 k2) _2701857) /\ (~ ((@pair (cart R _1291918) ((cart R _1291918) -> Prop) x1 k1) = (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x2 k2))))) -> (@setI (cart R _1291918) (@interior _1291918 k1) (@interior _1291918 k2)) = (@set0 (cart R _1291918)))).
Lemma tagged_partial_division_of_def {_1291918 : Type'} : (@tagged_partial_division_of _1291918) = (fun _2701857 : (prod (cart R _1291918) ((cart R _1291918) -> Prop)) -> Prop => fun _2701858 : (cart R _1291918) -> Prop => (@finite_set (prod (cart R _1291918) ((cart R _1291918) -> Prop)) _2701857) /\ ((forall x : cart R _1291918, forall k : (cart R _1291918) -> Prop, (@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x k) _2701857) -> (@IN (cart R _1291918) x k) /\ ((@subset (cart R _1291918) k _2701858) /\ (exists a : cart R _1291918, exists b : cart R _1291918, k = (@closed_interval _1291918 (@cons (prod (cart R _1291918) (cart R _1291918)) (@pair (cart R _1291918) (cart R _1291918) a b) (@nil (prod (cart R _1291918) (cart R _1291918)))))))) /\ (forall x1 : cart R _1291918, forall k1 : (cart R _1291918) -> Prop, forall x2 : cart R _1291918, forall k2 : (cart R _1291918) -> Prop, ((@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x1 k1) _2701857) /\ ((@IN (prod (cart R _1291918) ((cart R _1291918) -> Prop)) (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x2 k2) _2701857) /\ (~ ((@pair (cart R _1291918) ((cart R _1291918) -> Prop) x1 k1) = (@pair (cart R _1291918) ((cart R _1291918) -> Prop) x2 k2))))) -> (@setI (cart R _1291918) (@interior _1291918 k1) (@interior _1291918 k2)) = (@set0 (cart R _1291918))))).
Proof. exact (REFL (@tagged_partial_division_of _1291918)). Qed.
Definition tagged_division_of {_1291929 : Type'} : ((prod (cart R _1291929) ((cart R _1291929) -> Prop)) -> Prop) -> ((cart R _1291929) -> Prop) -> Prop := fun _2701869 : (prod (cart R _1291929) ((cart R _1291929) -> Prop)) -> Prop => fun _2701870 : (cart R _1291929) -> Prop => (@tagged_partial_division_of _1291929 _2701869 _2701870) /\ ((@UNIONS (cart R _1291929) (@GSPEC ((cart R _1291929) -> Prop) (fun GEN_PVAR_5795 : (cart R _1291929) -> Prop => exists k : (cart R _1291929) -> Prop, @SETSPEC ((cart R _1291929) -> Prop) GEN_PVAR_5795 (exists x : cart R _1291929, @IN (prod (cart R _1291929) ((cart R _1291929) -> Prop)) (@pair (cart R _1291929) ((cart R _1291929) -> Prop) x k) _2701869) k))) = _2701870).
Lemma tagged_division_of_def {_1291929 : Type'} : (@tagged_division_of _1291929) = (fun _2701869 : (prod (cart R _1291929) ((cart R _1291929) -> Prop)) -> Prop => fun _2701870 : (cart R _1291929) -> Prop => (@tagged_partial_division_of _1291929 _2701869 _2701870) /\ ((@UNIONS (cart R _1291929) (@GSPEC ((cart R _1291929) -> Prop) (fun GEN_PVAR_5795 : (cart R _1291929) -> Prop => exists k : (cart R _1291929) -> Prop, @SETSPEC ((cart R _1291929) -> Prop) GEN_PVAR_5795 (exists x : cart R _1291929, @IN (prod (cart R _1291929) ((cart R _1291929) -> Prop)) (@pair (cart R _1291929) ((cart R _1291929) -> Prop) x k) _2701869) k))) = _2701870)).
Proof. exact (REFL (@tagged_division_of _1291929)). Qed.
Definition fine {_1293535 _1293536 : Type'} : (_1293536 -> _1293535 -> Prop) -> ((prod _1293536 (_1293535 -> Prop)) -> Prop) -> Prop := fun _2708673 : _1293536 -> _1293535 -> Prop => fun _2708674 : (prod _1293536 (_1293535 -> Prop)) -> Prop => forall x : _1293536, forall k : _1293535 -> Prop, (@IN (prod _1293536 (_1293535 -> Prop)) (@pair _1293536 (_1293535 -> Prop) x k) _2708674) -> @subset _1293535 k (_2708673 x).
Lemma fine_def {_1293535 _1293536 : Type'} : (@fine _1293535 _1293536) = (fun _2708673 : _1293536 -> _1293535 -> Prop => fun _2708674 : (prod _1293536 (_1293535 -> Prop)) -> Prop => forall x : _1293536, forall k : _1293535 -> Prop, (@IN (prod _1293536 (_1293535 -> Prop)) (@pair _1293536 (_1293535 -> Prop) x k) _2708674) -> @subset _1293535 k (_2708673 x)).
Proof. exact (REFL (@fine _1293535 _1293536)). Qed.
Definition has_integral_compact_interval {_1293789 _1293821 : Type'} : ((cart R _1293789) -> cart R _1293821) -> (cart R _1293821) -> ((cart R _1293789) -> Prop) -> Prop := fun _2708761 : (cart R _1293789) -> cart R _1293821 => fun _2708762 : cart R _1293821 => fun _2708763 : (cart R _1293789) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : (cart R _1293789) -> (cart R _1293789) -> Prop, (@gauge _1293789 d) /\ (forall p : (prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> Prop, ((@tagged_division_of _1293789 p _2708763) /\ (@fine (cart R _1293789) (cart R _1293789) d p)) -> ltr (@vector_norm _1293821 (@vector_sub _1293821 (@vsum (prod (cart R _1293789) ((cart R _1293789) -> Prop)) _1293821 p (@GABS ((prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> cart R _1293821) (fun f : (prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> cart R _1293821 => forall x : cart R _1293789, forall k : (cart R _1293789) -> Prop, @eq (cart R _1293821) (f (@pair (cart R _1293789) ((cart R _1293789) -> Prop) x k)) (@percent _1293821 (@content _1293789 k) (_2708761 x))))) _2708762)) e).
Lemma has_integral_compact_interval_def {_1293789 _1293821 : Type'} : (@has_integral_compact_interval _1293789 _1293821) = (fun _2708761 : (cart R _1293789) -> cart R _1293821 => fun _2708762 : cart R _1293821 => fun _2708763 : (cart R _1293789) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : (cart R _1293789) -> (cart R _1293789) -> Prop, (@gauge _1293789 d) /\ (forall p : (prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> Prop, ((@tagged_division_of _1293789 p _2708763) /\ (@fine (cart R _1293789) (cart R _1293789) d p)) -> ltr (@vector_norm _1293821 (@vector_sub _1293821 (@vsum (prod (cart R _1293789) ((cart R _1293789) -> Prop)) _1293821 p (@GABS ((prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> cart R _1293821) (fun f : (prod (cart R _1293789) ((cart R _1293789) -> Prop)) -> cart R _1293821 => forall x : cart R _1293789, forall k : (cart R _1293789) -> Prop, @eq (cart R _1293821) (f (@pair (cart R _1293789) ((cart R _1293789) -> Prop) x k)) (@percent _1293821 (@content _1293789 k) (_2708761 x))))) _2708762)) e)).
Proof. exact (REFL (@has_integral_compact_interval _1293789 _1293821)). Qed.
Definition has_integral {_1293958 _1293962 : Type'} : ((cart R _1293958) -> cart R _1293962) -> (cart R _1293962) -> ((cart R _1293958) -> Prop) -> Prop := fun _2708782 : (cart R _1293958) -> cart R _1293962 => fun _2708783 : cart R _1293962 => fun _2708784 : (cart R _1293958) -> Prop => @COND Prop (exists a : cart R _1293958, exists b : cart R _1293958, _2708784 = (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) (@has_integral_compact_interval _1293958 _1293962 _2708782 _2708783 _2708784) (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists B : R, (ltr (R_of_nat (NUMERAL O)) B) /\ (forall a : cart R _1293958, forall b : cart R _1293958, (@subset (cart R _1293958) (@ball _1293958 (@pair (cart R _1293958) R (@vec _1293958 (NUMERAL O)) B)) (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) -> exists z : cart R _1293962, (@has_integral_compact_interval _1293958 _1293962 (fun x : cart R _1293958 => @COND (cart R _1293962) (@IN (cart R _1293958) x _2708784) (_2708782 x) (@vec _1293962 (NUMERAL O))) z (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) /\ (ltr (@vector_norm _1293962 (@vector_sub _1293962 z _2708783)) e))).
Lemma has_integral_def {_1293958 _1293962 : Type'} : (@has_integral _1293958 _1293962) = (fun _2708782 : (cart R _1293958) -> cart R _1293962 => fun _2708783 : cart R _1293962 => fun _2708784 : (cart R _1293958) -> Prop => @COND Prop (exists a : cart R _1293958, exists b : cart R _1293958, _2708784 = (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) (@has_integral_compact_interval _1293958 _1293962 _2708782 _2708783 _2708784) (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists B : R, (ltr (R_of_nat (NUMERAL O)) B) /\ (forall a : cart R _1293958, forall b : cart R _1293958, (@subset (cart R _1293958) (@ball _1293958 (@pair (cart R _1293958) R (@vec _1293958 (NUMERAL O)) B)) (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) -> exists z : cart R _1293962, (@has_integral_compact_interval _1293958 _1293962 (fun x : cart R _1293958 => @COND (cart R _1293962) (@IN (cart R _1293958) x _2708784) (_2708782 x) (@vec _1293962 (NUMERAL O))) z (@closed_interval _1293958 (@cons (prod (cart R _1293958) (cart R _1293958)) (@pair (cart R _1293958) (cart R _1293958) a b) (@nil (prod (cart R _1293958) (cart R _1293958)))))) /\ (ltr (@vector_norm _1293962 (@vector_sub _1293962 z _2708783)) e)))).
Proof. exact (REFL (@has_integral _1293958 _1293962)). Qed.
Definition integrable_on {_1294226 _1294227 : Type'} : ((cart R _1294227) -> cart R _1294226) -> ((cart R _1294227) -> Prop) -> Prop := fun _2709264 : (cart R _1294227) -> cart R _1294226 => fun _2709265 : (cart R _1294227) -> Prop => exists y : cart R _1294226, @has_integral _1294227 _1294226 _2709264 y _2709265.
Lemma integrable_on_def {_1294226 _1294227 : Type'} : (@integrable_on _1294226 _1294227) = (fun _2709264 : (cart R _1294227) -> cart R _1294226 => fun _2709265 : (cart R _1294227) -> Prop => exists y : cart R _1294226, @has_integral _1294227 _1294226 _2709264 y _2709265).
Proof. exact (REFL (@integrable_on _1294226 _1294227)). Qed.
Definition integral {_1294241 _1294242 : Type'} : ((cart R _1294242) -> Prop) -> ((cart R _1294242) -> cart R _1294241) -> cart R _1294241 := fun _2709276 : (cart R _1294242) -> Prop => fun _2709277 : (cart R _1294242) -> cart R _1294241 => @ε (cart R _1294241) (fun y : cart R _1294241 => @has_integral _1294242 _1294241 _2709277 y _2709276).
Lemma integral_def {_1294241 _1294242 : Type'} : (@integral _1294241 _1294242) = (fun _2709276 : (cart R _1294242) -> Prop => fun _2709277 : (cart R _1294242) -> cart R _1294241 => @ε (cart R _1294241) (fun y : cart R _1294241 => @has_integral _1294242 _1294241 _2709277 y _2709276)).
Proof. exact (REFL (@integral _1294241 _1294242)). Qed.
Definition operative {A N' : Type'} : (A -> A -> A) -> (((cart R N') -> Prop) -> A) -> Prop := fun _2726196 : A -> A -> A => fun _2726197 : ((cart R N') -> Prop) -> A => (forall a : cart R N', forall b : cart R N', ((@content N' (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (R_of_nat (NUMERAL O))) -> (_2726197 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (@neutral A _2726196)) /\ (forall a : cart R N', forall b : cart R N', forall c : R, forall k : nat, ((leqn (NUMERAL (BIT1 O)) k) /\ (leqn k (@dimindex N' (@setT N')))) -> (_2726197 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (_2726196 (_2726197 (@setI (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5871 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5871 (ler (@dollar R N' x k) c) x)))) (_2726197 (@setI (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5872 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5872 (ger (@dollar R N' x k) c) x)))))).
Lemma operative_def {A N' : Type'} : (@operative A N') = (fun _2726196 : A -> A -> A => fun _2726197 : ((cart R N') -> Prop) -> A => (forall a : cart R N', forall b : cart R N', ((@content N' (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (R_of_nat (NUMERAL O))) -> (_2726197 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (@neutral A _2726196)) /\ (forall a : cart R N', forall b : cart R N', forall c : R, forall k : nat, ((leqn (NUMERAL (BIT1 O)) k) /\ (leqn k (@dimindex N' (@setT N')))) -> (_2726197 (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N')))))) = (_2726196 (_2726197 (@setI (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5871 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5871 (ler (@dollar R N' x k) c) x)))) (_2726197 (@setI (cart R N') (@closed_interval N' (@cons (prod (cart R N') (cart R N')) (@pair (cart R N') (cart R N') a b) (@nil (prod (cart R N') (cart R N'))))) (@GSPEC (cart R N') (fun GEN_PVAR_5872 : cart R N' => exists x : cart R N', @SETSPEC (cart R N') GEN_PVAR_5872 (ger (@dollar R N' x k) c) x))))))).
Proof. exact (REFL (@operative A N')). Qed.
Definition lifted {_1303253 _1303255 : Type'} : (_1303255 -> _1303255 -> _1303253) -> (option _1303255) -> (option _1303255) -> option _1303253 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_1303255 -> _1303255 -> _1303253) -> (option _1303255) -> (option _1303255) -> option _1303253) (fun lifted' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_1303255 -> _1303255 -> _1303253) -> (option _1303255) -> (option _1303255) -> option _1303253 => forall _2727518 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall op : _1303255 -> _1303255 -> _1303253, forall __ : option _1303255, (lifted' _2727518 op (@None _1303255) __) = (@None _1303253)) /\ ((forall op : _1303255 -> _1303255 -> _1303253, forall __ : option _1303255, (lifted' _2727518 op __ (@None _1303255)) = (@None _1303253)) /\ (forall op : _1303255 -> _1303255 -> _1303253, forall x : _1303255, forall y : _1303255, (lifted' _2727518 op (@Some _1303255 x) (@Some _1303255 y)) = (@Some _1303253 (op x y))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))).
Lemma lifted_def {_1303253 _1303255 : Type'} : (@lifted _1303253 _1303255) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_1303255 -> _1303255 -> _1303253) -> (option _1303255) -> (option _1303255) -> option _1303253) (fun lifted' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (_1303255 -> _1303255 -> _1303253) -> (option _1303255) -> (option _1303255) -> option _1303253 => forall _2727518 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall op : _1303255 -> _1303255 -> _1303253, forall __ : option _1303255, (lifted' _2727518 op (@None _1303255) __) = (@None _1303253)) /\ ((forall op : _1303255 -> _1303255 -> _1303253, forall __ : option _1303255, (lifted' _2727518 op __ (@None _1303255)) = (@None _1303253)) /\ (forall op : _1303255 -> _1303255 -> _1303253, forall x : _1303255, forall y : _1303255, (lifted' _2727518 op (@Some _1303255 x) (@Some _1303255 y)) = (@Some _1303253 (op x y))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))).
Proof. exact (REFL (@lifted _1303253 _1303255)). Qed.
Definition division_points {N' : Type'} : ((cart R N') -> Prop) -> (((cart R N') -> Prop) -> Prop) -> (prod nat R) -> Prop := fun _2728059 : (cart R N') -> Prop => fun _2728060 : ((cart R N') -> Prop) -> Prop => @GSPEC (prod nat R) (fun GEN_PVAR_5873 : prod nat R => exists j : nat, exists x : R, @SETSPEC (prod nat R) GEN_PVAR_5873 ((leqn (NUMERAL (BIT1 O)) j) /\ ((leqn j (@dimindex N' (@setT N'))) /\ ((ltr (@dollar R N' (@interval_lowerbound N' _2728059) j) x) /\ ((ltr x (@dollar R N' (@interval_upperbound N' _2728059) j)) /\ (exists i : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) i _2728060) /\ (((@dollar R N' (@interval_lowerbound N' i) j) = x) \/ ((@dollar R N' (@interval_upperbound N' i) j) = x))))))) (@pair nat R j x)).
Lemma division_points_def {N' : Type'} : (@division_points N') = (fun _2728059 : (cart R N') -> Prop => fun _2728060 : ((cart R N') -> Prop) -> Prop => @GSPEC (prod nat R) (fun GEN_PVAR_5873 : prod nat R => exists j : nat, exists x : R, @SETSPEC (prod nat R) GEN_PVAR_5873 ((leqn (NUMERAL (BIT1 O)) j) /\ ((leqn j (@dimindex N' (@setT N'))) /\ ((ltr (@dollar R N' (@interval_lowerbound N' _2728059) j) x) /\ ((ltr x (@dollar R N' (@interval_upperbound N' _2728059) j)) /\ (exists i : (cart R N') -> Prop, (@IN ((cart R N') -> Prop) i _2728060) /\ (((@dollar R N' (@interval_lowerbound N' i) j) = x) \/ ((@dollar R N' (@interval_upperbound N' i) j) = x))))))) (@pair nat R j x))).
Proof. exact (REFL (@division_points N')). Qed.
Definition negligible {_1309210 : Type'} : ((cart R _1309210) -> Prop) -> Prop := fun _2746581 : (cart R _1309210) -> Prop => forall a : cart R _1309210, forall b : cart R _1309210, @has_integral _1309210 unit (@indicator _1309210 _2746581) (@vec unit (NUMERAL O)) (@closed_interval _1309210 (@cons (prod (cart R _1309210) (cart R _1309210)) (@pair (cart R _1309210) (cart R _1309210) a b) (@nil (prod (cart R _1309210) (cart R _1309210))))).
Lemma negligible_def {_1309210 : Type'} : (@negligible _1309210) = (fun _2746581 : (cart R _1309210) -> Prop => forall a : cart R _1309210, forall b : cart R _1309210, @has_integral _1309210 unit (@indicator _1309210 _2746581) (@vec unit (NUMERAL O)) (@closed_interval _1309210 (@cons (prod (cart R _1309210) (cart R _1309210)) (@pair (cart R _1309210) (cart R _1309210) a b) (@nil (prod (cart R _1309210) (cart R _1309210)))))).
Proof. exact (REFL (@negligible _1309210)). Qed.
Definition set_variation {M N' : Type'} : ((cart R M) -> Prop) -> (((cart R M) -> Prop) -> cart R N') -> R := fun _2797550 : (cart R M) -> Prop => fun _2797551 : ((cart R M) -> Prop) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_5997 : R => exists d : ((cart R M) -> Prop) -> Prop, @SETSPEC R GEN_PVAR_5997 (exists t : (cart R M) -> Prop, (@division_of M d t) /\ (@subset (cart R M) t _2797550)) (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2797551 k))))).
Lemma set_variation_def {M N' : Type'} : (@set_variation M N') = (fun _2797550 : (cart R M) -> Prop => fun _2797551 : ((cart R M) -> Prop) -> cart R N' => sup (@GSPEC R (fun GEN_PVAR_5997 : R => exists d : ((cart R M) -> Prop) -> Prop, @SETSPEC R GEN_PVAR_5997 (exists t : (cart R M) -> Prop, (@division_of M d t) /\ (@subset (cart R M) t _2797550)) (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2797551 k)))))).
Proof. exact (REFL (@set_variation M N')). Qed.
Definition has_bounded_setvariation_on {M N' : Type'} : (((cart R M) -> Prop) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _2797562 : ((cart R M) -> Prop) -> cart R N' => fun _2797563 : (cart R M) -> Prop => exists B : R, forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ (@subset (cart R M) t _2797563)) -> ler (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2797562 k))) B.
Lemma has_bounded_setvariation_on_def {M N' : Type'} : (@has_bounded_setvariation_on M N') = (fun _2797562 : ((cart R M) -> Prop) -> cart R N' => fun _2797563 : (cart R M) -> Prop => exists B : R, forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ (@subset (cart R M) t _2797563)) -> ler (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2797562 k))) B).
Proof. exact (REFL (@has_bounded_setvariation_on M N')). Qed.
Definition absolutely_integrable_on {_1342849 _1342854 : Type'} : ((cart R _1342854) -> cart R _1342849) -> ((cart R _1342854) -> Prop) -> Prop := fun _2804060 : (cart R _1342854) -> cart R _1342849 => fun _2804061 : (cart R _1342854) -> Prop => (@integrable_on _1342849 _1342854 _2804060 _2804061) /\ (@integrable_on unit _1342854 (fun x : cart R _1342854 => lift (@vector_norm _1342849 (_2804060 x))) _2804061).
Lemma absolutely_integrable_on_def {_1342849 _1342854 : Type'} : (@absolutely_integrable_on _1342849 _1342854) = (fun _2804060 : (cart R _1342854) -> cart R _1342849 => fun _2804061 : (cart R _1342854) -> Prop => (@integrable_on _1342849 _1342854 _2804060 _2804061) /\ (@integrable_on unit _1342854 (fun x : cart R _1342854 => lift (@vector_norm _1342849 (_2804060 x))) _2804061)).
Proof. exact (REFL (@absolutely_integrable_on _1342849 _1342854)). Qed.
Definition equiintegrable_on {M N' : Type'} : (((cart R M) -> cart R N') -> Prop) -> ((cart R M) -> Prop) -> Prop := fun _2855914 : ((cart R M) -> cart R N') -> Prop => fun _2855915 : (cart R M) -> Prop => (forall f : (cart R M) -> cart R N', (@IN ((cart R M) -> cart R N') f _2855914) -> @integrable_on N' M f _2855915) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : (cart R M) -> (cart R M) -> Prop, (@gauge M d) /\ (forall f : (cart R M) -> cart R N', forall p : (prod (cart R M) ((cart R M) -> Prop)) -> Prop, ((@IN ((cart R M) -> cart R N') f _2855914) /\ ((@tagged_division_of M p _2855915) /\ (@fine (cart R M) (cart R M) d p))) -> ltr (@vector_norm N' (@vector_sub N' (@vsum (prod (cart R M) ((cart R M) -> Prop)) N' p (@GABS ((prod (cart R M) ((cart R M) -> Prop)) -> cart R N') (fun f' : (prod (cart R M) ((cart R M) -> Prop)) -> cart R N' => forall x : cart R M, forall k : (cart R M) -> Prop, @eq (cart R N') (f' (@pair (cart R M) ((cart R M) -> Prop) x k)) (@percent N' (@content M k) (f x))))) (@integral N' M _2855915 f))) e)).
Lemma equiintegrable_on_def {M N' : Type'} : (@equiintegrable_on M N') = (fun _2855914 : ((cart R M) -> cart R N') -> Prop => fun _2855915 : (cart R M) -> Prop => (forall f : (cart R M) -> cart R N', (@IN ((cart R M) -> cart R N') f _2855914) -> @integrable_on N' M f _2855915) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : (cart R M) -> (cart R M) -> Prop, (@gauge M d) /\ (forall f : (cart R M) -> cart R N', forall p : (prod (cart R M) ((cart R M) -> Prop)) -> Prop, ((@IN ((cart R M) -> cart R N') f _2855914) /\ ((@tagged_division_of M p _2855915) /\ (@fine (cart R M) (cart R M) d p))) -> ltr (@vector_norm N' (@vector_sub N' (@vsum (prod (cart R M) ((cart R M) -> Prop)) N' p (@GABS ((prod (cart R M) ((cart R M) -> Prop)) -> cart R N') (fun f' : (prod (cart R M) ((cart R M) -> Prop)) -> cart R N' => forall x : cart R M, forall k : (cart R M) -> Prop, @eq (cart R N') (f' (@pair (cart R M) ((cart R M) -> Prop) x k)) (@percent N' (@content M k) (f x))))) (@integral N' M _2855915 f))) e))).
Proof. exact (REFL (@equiintegrable_on M N')). Qed.
Definition has_bounded_variation_on {N' : Type'} : ((cart R unit) -> cart R N') -> ((cart R unit) -> Prop) -> Prop := fun _2916660 : (cart R unit) -> cart R N' => fun _2916661 : (cart R unit) -> Prop => @has_bounded_setvariation_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2916660 (@interval_upperbound unit k)) (_2916660 (@interval_lowerbound unit k))) _2916661.
Lemma has_bounded_variation_on_def {N' : Type'} : (@has_bounded_variation_on N') = (fun _2916660 : (cart R unit) -> cart R N' => fun _2916661 : (cart R unit) -> Prop => @has_bounded_setvariation_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2916660 (@interval_upperbound unit k)) (_2916660 (@interval_lowerbound unit k))) _2916661).
Proof. exact (REFL (@has_bounded_variation_on N')). Qed.
Definition vector_variation {N' : Type'} : ((cart R unit) -> Prop) -> ((cart R unit) -> cart R N') -> R := fun _2916672 : (cart R unit) -> Prop => fun _2916673 : (cart R unit) -> cart R N' => @set_variation unit N' _2916672 (fun k : (cart R unit) -> Prop => @vector_sub N' (_2916673 (@interval_upperbound unit k)) (_2916673 (@interval_lowerbound unit k))).
Lemma vector_variation_def {N' : Type'} : (@vector_variation N') = (fun _2916672 : (cart R unit) -> Prop => fun _2916673 : (cart R unit) -> cart R N' => @set_variation unit N' _2916672 (fun k : (cart R unit) -> Prop => @vector_sub N' (_2916673 (@interval_upperbound unit k)) (_2916673 (@interval_lowerbound unit k)))).
Proof. exact (REFL (@vector_variation N')). Qed.
Definition absolutely_setcontinuous_on {M N' : Type'} : (((cart R M) -> Prop) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _2959129 : ((cart R M) -> Prop) -> cart R N' => fun _2959130 : (cart R M) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists r : R, (ltr (R_of_nat (NUMERAL O)) r) /\ (forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ ((@subset (cart R M) t _2959130) /\ (ltr (@sum ((cart R M) -> Prop) d (@content M)) r))) -> ltr (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2959129 k))) e).
Lemma absolutely_setcontinuous_on_def {M N' : Type'} : (@absolutely_setcontinuous_on M N') = (fun _2959129 : ((cart R M) -> Prop) -> cart R N' => fun _2959130 : (cart R M) -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists r : R, (ltr (R_of_nat (NUMERAL O)) r) /\ (forall d : ((cart R M) -> Prop) -> Prop, forall t : (cart R M) -> Prop, ((@division_of M d t) /\ ((@subset (cart R M) t _2959130) /\ (ltr (@sum ((cart R M) -> Prop) d (@content M)) r))) -> ltr (@sum ((cart R M) -> Prop) d (fun k : (cart R M) -> Prop => @vector_norm N' (_2959129 k))) e)).
Proof. exact (REFL (@absolutely_setcontinuous_on M N')). Qed.
Definition absolutely_continuous_on {N' : Type'} : ((cart R unit) -> cart R N') -> ((cart R unit) -> Prop) -> Prop := fun _2970803 : (cart R unit) -> cart R N' => fun _2970804 : (cart R unit) -> Prop => @absolutely_setcontinuous_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2970803 (@interval_upperbound unit k)) (_2970803 (@interval_lowerbound unit k))) _2970804.
Lemma absolutely_continuous_on_def {N' : Type'} : (@absolutely_continuous_on N') = (fun _2970803 : (cart R unit) -> cart R N' => fun _2970804 : (cart R unit) -> Prop => @absolutely_setcontinuous_on unit N' (fun k : (cart R unit) -> Prop => @vector_sub N' (_2970803 (@interval_upperbound unit k)) (_2970803 (@interval_lowerbound unit k))) _2970804).
Proof. exact (REFL (@absolutely_continuous_on N')). Qed.
Definition rectifiable_path {N' : Type'} : ((cart R unit) -> cart R N') -> Prop := fun _2974737 : (cart R unit) -> cart R N' => (@path N' _2974737) /\ (@has_bounded_variation_on N' _2974737 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))).
Lemma rectifiable_path_def {N' : Type'} : (@rectifiable_path N') = (fun _2974737 : (cart R unit) -> cart R N' => (@path N' _2974737) /\ (@has_bounded_variation_on N' _2974737 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))))).
Proof. exact (REFL (@rectifiable_path N')). Qed.
Definition path_length {N' : Type'} : ((cart R unit) -> cart R N') -> R := fun _2974742 : (cart R unit) -> cart R N' => @vector_variation N' (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))) _2974742.
Lemma path_length_def {N' : Type'} : (@path_length N') = (fun _2974742 : (cart R unit) -> cart R N' => @vector_variation N' (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))) _2974742).
Proof. exact (REFL (@path_length N')). Qed.
Definition has_measure {_1429150 : Type'} : ((cart R _1429150) -> Prop) -> R -> Prop := fun _2988675 : (cart R _1429150) -> Prop => fun _2988676 : R => @has_integral _1429150 unit (fun x : cart R _1429150 => @vec unit (NUMERAL (BIT1 O))) (lift _2988676) _2988675.
Lemma has_measure_def {_1429150 : Type'} : (@has_measure _1429150) = (fun _2988675 : (cart R _1429150) -> Prop => fun _2988676 : R => @has_integral _1429150 unit (fun x : cart R _1429150 => @vec unit (NUMERAL (BIT1 O))) (lift _2988676) _2988675).
Proof. exact (REFL (@has_measure _1429150)). Qed.
Definition measurable {_1429166 : Type'} : ((cart R _1429166) -> Prop) -> Prop := fun _2988687 : (cart R _1429166) -> Prop => exists m : R, @has_measure _1429166 _2988687 m.
Lemma measurable_def {_1429166 : Type'} : (@measurable _1429166) = (fun _2988687 : (cart R _1429166) -> Prop => exists m : R, @has_measure _1429166 _2988687 m).
Proof. exact (REFL (@measurable _1429166)). Qed.
Definition measure {_1429178 : Type'} : ((cart R _1429178) -> Prop) -> R := fun _2988692 : (cart R _1429178) -> Prop => @ε R (fun m : R => @has_measure _1429178 _2988692 m).
Lemma measure_def {_1429178 : Type'} : (@measure _1429178) = (fun _2988692 : (cart R _1429178) -> Prop => @ε R (fun m : R => @has_measure _1429178 _2988692 m)).
Proof. exact (REFL (@measure _1429178)). Qed.
Definition measurable_on {M N' : Type'} : ((cart R M) -> cart R N') -> ((cart R M) -> Prop) -> Prop := fun _3065637 : (cart R M) -> cart R N' => fun _3065638 : (cart R M) -> Prop => exists k : (cart R M) -> Prop, exists g : nat -> (cart R M) -> cart R N', (@negligible M k) /\ ((forall n : nat, @continuous_on M N' (g n) (@setT (cart R M))) /\ (forall x : cart R M, (~ (@IN (cart R M) x k)) -> @FImp N' nat (fun n : nat => g n x) (@COND (cart R N') (@IN (cart R M) x _3065638) (_3065637 x) (@vec N' (NUMERAL O))) sequentially)).
Lemma measurable_on_def {M N' : Type'} : (@measurable_on M N') = (fun _3065637 : (cart R M) -> cart R N' => fun _3065638 : (cart R M) -> Prop => exists k : (cart R M) -> Prop, exists g : nat -> (cart R M) -> cart R N', (@negligible M k) /\ ((forall n : nat, @continuous_on M N' (g n) (@setT (cart R M))) /\ (forall x : cart R M, (~ (@IN (cart R M) x k)) -> @FImp N' nat (fun n : nat => g n x) (@COND (cart R N') (@IN (cart R M) x _3065638) (_3065637 x) (@vec N' (NUMERAL O))) sequentially))).
Proof. exact (REFL (@measurable_on M N')). Qed.
Definition lebesgue_measurable {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3065649 : (cart R N') -> Prop => @measurable_on N' unit (@indicator N' _3065649) (@setT (cart R N')).
Lemma lebesgue_measurable_def {N' : Type'} : (@lebesgue_measurable N') = (fun _3065649 : (cart R N') -> Prop => @measurable_on N' unit (@indicator N' _3065649) (@setT (cart R N'))).
Proof. exact (REFL (@lebesgue_measurable N')). Qed.
Definition Re : (cart R (tybit0 unit)) -> R := fun _3330377 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3330377 (NUMERAL (BIT1 O)).
Lemma Re_def : Re = (fun _3330377 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3330377 (NUMERAL (BIT1 O))).
Proof. exact (REFL Re). Qed.
Definition Im : (cart R (tybit0 unit)) -> R := fun _3330382 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3330382 (NUMERAL (BIT0 (BIT1 O))).
Lemma Im_def : Im = (fun _3330382 : cart R (tybit0 unit) => @dollar R (tybit0 unit) _3330382 (NUMERAL (BIT0 (BIT1 O)))).
Proof. exact (REFL Im). Qed.
Definition complex : (prod R R) -> cart R (tybit0 unit) := fun _3330387 : prod R R => @vector R (tybit0 unit) (@cons R (@fst R R _3330387) (@cons R (@snd R R _3330387) (@nil R))).
Lemma complex_def : complex = (fun _3330387 : prod R R => @vector R (tybit0 unit) (@cons R (@fst R R _3330387) (@cons R (@snd R R _3330387) (@nil R)))).
Proof. exact (REFL complex). Qed.
Definition Cx : R -> cart R (tybit0 unit) := fun _3330396 : R => complex (@pair R R _3330396 (R_of_nat (NUMERAL O))).
Lemma Cx_def : Cx = (fun _3330396 : R => complex (@pair R R _3330396 (R_of_nat (NUMERAL O)))).
Proof. exact (REFL Cx). Qed.
Definition ii : cart R (tybit0 unit) := complex (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O)))).
Lemma ii_def : ii = (complex (@pair R R (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O))))).
Proof. exact (REFL ii). Qed.
Definition complex_mul : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3330401 : cart R (tybit0 unit) => fun _3330402 : cart R (tybit0 unit) => complex (@pair R R (subr (mulr (Re _3330401) (Re _3330402)) (mulr (Im _3330401) (Im _3330402))) (addr (mulr (Re _3330401) (Im _3330402)) (mulr (Im _3330401) (Re _3330402)))).
Lemma complex_mul_def : complex_mul = (fun _3330401 : cart R (tybit0 unit) => fun _3330402 : cart R (tybit0 unit) => complex (@pair R R (subr (mulr (Re _3330401) (Re _3330402)) (mulr (Im _3330401) (Im _3330402))) (addr (mulr (Re _3330401) (Im _3330402)) (mulr (Im _3330401) (Re _3330402))))).
Proof. exact (REFL complex_mul). Qed.
Definition complex_inv : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3330413 : cart R (tybit0 unit) => complex (@pair R R (divr (Re _3330413) (addr (expr (Re _3330413) (NUMERAL (BIT0 (BIT1 O)))) (expr (Im _3330413) (NUMERAL (BIT0 (BIT1 O)))))) (divr (oppr (Im _3330413)) (addr (expr (Re _3330413) (NUMERAL (BIT0 (BIT1 O)))) (expr (Im _3330413) (NUMERAL (BIT0 (BIT1 O))))))).
Lemma complex_inv_def : complex_inv = (fun _3330413 : cart R (tybit0 unit) => complex (@pair R R (divr (Re _3330413) (addr (expr (Re _3330413) (NUMERAL (BIT0 (BIT1 O)))) (expr (Im _3330413) (NUMERAL (BIT0 (BIT1 O)))))) (divr (oppr (Im _3330413)) (addr (expr (Re _3330413) (NUMERAL (BIT0 (BIT1 O)))) (expr (Im _3330413) (NUMERAL (BIT0 (BIT1 O)))))))).
Proof. exact (REFL complex_inv). Qed.
Definition complex_div : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3330418 : cart R (tybit0 unit) => fun _3330419 : cart R (tybit0 unit) => complex_mul _3330418 (complex_inv _3330419).
Lemma complex_div_def : complex_div = (fun _3330418 : cart R (tybit0 unit) => fun _3330419 : cart R (tybit0 unit) => complex_mul _3330418 (complex_inv _3330419)).
Proof. exact (REFL complex_div). Qed.
Definition complex_pow : (cart R (tybit0 unit)) -> nat -> cart R (tybit0 unit) := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (cart R (tybit0 unit)) -> nat -> cart R (tybit0 unit)) (fun complex_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (cart R (tybit0 unit)) -> nat -> cart R (tybit0 unit) => forall _3330814 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall x : cart R (tybit0 unit), (complex_pow' _3330814 x (NUMERAL O)) = (Cx (R_of_nat (NUMERAL (BIT1 O))))) /\ (forall x : cart R (tybit0 unit), forall n : nat, (complex_pow' _3330814 x (S n)) = (complex_mul x (complex_pow' _3330814 x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))))))))).
Lemma complex_pow_def : complex_pow = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (cart R (tybit0 unit)) -> nat -> cart R (tybit0 unit)) (fun complex_pow' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) -> (cart R (tybit0 unit)) -> nat -> cart R (tybit0 unit) => forall _3330814 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))), (forall x : cart R (tybit0 unit), (complex_pow' _3330814 x (NUMERAL O)) = (Cx (R_of_nat (NUMERAL (BIT1 O))))) /\ (forall x : cart R (tybit0 unit), forall n : nat, (complex_pow' _3330814 x (S n)) = (complex_mul x (complex_pow' _3330814 x n)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))))))))).
Proof. exact (REFL complex_pow). Qed.
Definition cnj : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3331249 : cart R (tybit0 unit) => complex (@pair R R (Re _3331249) (oppr (Im _3331249))).
Lemma cnj_def : cnj = (fun _3331249 : cart R (tybit0 unit) => complex (@pair R R (Re _3331249) (oppr (Im _3331249)))).
Proof. exact (REFL cnj). Qed.
Definition csqrt : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3331314 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) ((Im _3331314) = (R_of_nat (NUMERAL O))) (@COND (cart R (tybit0 unit)) (ler (R_of_nat (NUMERAL O)) (Re _3331314)) (complex (@pair R R (hol_sqrt (Re _3331314)) (R_of_nat (NUMERAL O)))) (complex (@pair R R (R_of_nat (NUMERAL O)) (hol_sqrt (oppr (Re _3331314)))))) (complex (@pair R R (hol_sqrt (divr (addr (@vector_norm (tybit0 unit) _3331314) (Re _3331314)) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (mulr (divr (Im _3331314) (normr (Im _3331314))) (hol_sqrt (divr (subr (@vector_norm (tybit0 unit) _3331314) (Re _3331314)) (R_of_nat (NUMERAL (BIT0 (BIT1 O))))))))).
Lemma csqrt_def : csqrt = (fun _3331314 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) ((Im _3331314) = (R_of_nat (NUMERAL O))) (@COND (cart R (tybit0 unit)) (ler (R_of_nat (NUMERAL O)) (Re _3331314)) (complex (@pair R R (hol_sqrt (Re _3331314)) (R_of_nat (NUMERAL O)))) (complex (@pair R R (R_of_nat (NUMERAL O)) (hol_sqrt (oppr (Re _3331314)))))) (complex (@pair R R (hol_sqrt (divr (addr (@vector_norm (tybit0 unit) _3331314) (Re _3331314)) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (mulr (divr (Im _3331314) (normr (Im _3331314))) (hol_sqrt (divr (subr (@vector_norm (tybit0 unit) _3331314) (Re _3331314)) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))))))).
Proof. exact (REFL csqrt). Qed.
Definition real : (cart R (tybit0 unit)) -> Prop := fun _3331675 : cart R (tybit0 unit) => (Im _3331675) = (R_of_nat (NUMERAL O)).
Lemma real_def : real = (fun _3331675 : cart R (tybit0 unit) => (Im _3331675) = (R_of_nat (NUMERAL O))).
Proof. exact (REFL real). Qed.
Definition cproduct {_1611071 : Type'} : (_1611071 -> Prop) -> (_1611071 -> cart R (tybit0 unit)) -> cart R (tybit0 unit) := @iterate _1611071 (cart R (tybit0 unit)) complex_mul.
Lemma cproduct_def {_1611071 : Type'} : (@cproduct _1611071) = (@iterate _1611071 (cart R (tybit0 unit)) complex_mul).
Proof. exact (REFL (@cproduct _1611071)). Qed.
Definition has_complex_derivative : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> (net (cart R (tybit0 unit))) -> Prop := fun _3334939 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334940 : cart R (tybit0 unit) => fun _3334941 : net (cart R (tybit0 unit)) => @has_derivative (tybit0 unit) (tybit0 unit) _3334939 (fun x : cart R (tybit0 unit) => complex_mul _3334940 x) _3334941.
Lemma has_complex_derivative_def : has_complex_derivative = (fun _3334939 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334940 : cart R (tybit0 unit) => fun _3334941 : net (cart R (tybit0 unit)) => @has_derivative (tybit0 unit) (tybit0 unit) _3334939 (fun x : cart R (tybit0 unit) => complex_mul _3334940 x) _3334941).
Proof. exact (REFL has_complex_derivative). Qed.
Definition complex_differentiable : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (net (cart R (tybit0 unit))) -> Prop := fun _3334960 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334961 : net (cart R (tybit0 unit)) => exists f' : cart R (tybit0 unit), has_complex_derivative _3334960 f' _3334961.
Lemma complex_differentiable_def : complex_differentiable = (fun _3334960 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334961 : net (cart R (tybit0 unit)) => exists f' : cart R (tybit0 unit), has_complex_derivative _3334960 f' _3334961).
Proof. exact (REFL complex_differentiable). Qed.
Definition complex_derivative : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3334972 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334973 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun f' : cart R (tybit0 unit) => has_complex_derivative _3334972 f' (@_at (tybit0 unit) _3334973)).
Lemma complex_derivative_def : complex_derivative = (fun _3334972 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3334973 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun f' : cart R (tybit0 unit) => has_complex_derivative _3334972 f' (@_at (tybit0 unit) _3334973))).
Proof. exact (REFL complex_derivative). Qed.
Definition higher_complex_derivative : nat -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) -> nat -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit)) (fun higher_complex_derivative' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) -> nat -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) => forall _3335368 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))), (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), (higher_complex_derivative' _3335368 (NUMERAL O) f) = f) /\ (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall n : nat, (higher_complex_derivative' _3335368 (S n) f) = (complex_derivative (higher_complex_derivative' _3335368 n f)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))))))))).
Lemma higher_complex_derivative_def : higher_complex_derivative = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) -> nat -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit)) (fun higher_complex_derivative' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))))) -> nat -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) => forall _3335368 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))), (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), (higher_complex_derivative' _3335368 (NUMERAL O) f) = f) /\ (forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall n : nat, (higher_complex_derivative' _3335368 (S n) f) = (complex_derivative (higher_complex_derivative' _3335368 n f)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))))))))))).
Proof. exact (REFL higher_complex_derivative). Qed.
Definition holomorphic_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> Prop) -> Prop := fun _3335369 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3335370 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3335370) -> exists f' : cart R (tybit0 unit), has_complex_derivative _3335369 f' (@within (cart R (tybit0 unit)) (@_at (tybit0 unit) x) _3335370).
Lemma holomorphic_on_def : holomorphic_on = (fun _3335369 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3335370 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3335370) -> exists f' : cart R (tybit0 unit), has_complex_derivative _3335369 f' (@within (cart R (tybit0 unit)) (@_at (tybit0 unit) x) _3335370)).
Proof. exact (REFL holomorphic_on). Qed.
Definition analytic_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> Prop) -> Prop := fun _3337572 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3337573 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3337573) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (holomorphic_on _3337572 (@ball (tybit0 unit) (@pair (cart R (tybit0 unit)) R x e))).
Lemma analytic_on_def : analytic_on = (fun _3337572 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3337573 : (cart R (tybit0 unit)) -> Prop => forall x : cart R (tybit0 unit), (@IN (cart R (tybit0 unit)) x _3337573) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (holomorphic_on _3337572 (@ball (tybit0 unit) (@pair (cart R (tybit0 unit)) R x e)))).
Proof. exact (REFL analytic_on). Qed.
Definition cexp : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3343190 : cart R (tybit0 unit) => @infsum (tybit0 unit) (from (NUMERAL O)) (fun n : nat => complex_div (complex_pow _3343190 n) (Cx (R_of_nat (factorial n)))).
Lemma cexp_def : cexp = (fun _3343190 : cart R (tybit0 unit) => @infsum (tybit0 unit) (from (NUMERAL O)) (fun n : nat => complex_div (complex_pow _3343190 n) (Cx (R_of_nat (factorial n))))).
Proof. exact (REFL cexp). Qed.
Definition ccos : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3343360 : cart R (tybit0 unit) => complex_div (@vector_add (tybit0 unit) (cexp (complex_mul ii _3343360)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3343360))) (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O))))).
Lemma ccos_def : ccos = (fun _3343360 : cart R (tybit0 unit) => complex_div (@vector_add (tybit0 unit) (cexp (complex_mul ii _3343360)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3343360))) (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))).
Proof. exact (REFL ccos). Qed.
Definition csin : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3343365 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) (cexp (complex_mul ii _3343365)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3343365))) (complex_mul (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) ii).
Lemma csin_def : csin = (fun _3343365 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) (cexp (complex_mul ii _3343365)) (cexp (complex_mul (@vector_neg (tybit0 unit) ii) _3343365))) (complex_mul (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) ii)).
Proof. exact (REFL csin). Qed.
Definition exp : R -> R := fun _3343370 : R => Re (cexp (Cx _3343370)).
Lemma exp_def : exp = (fun _3343370 : R => Re (cexp (Cx _3343370))).
Proof. exact (REFL exp). Qed.
Definition sin : R -> R := fun _3343500 : R => Re (csin (Cx _3343500)).
Lemma sin_def : sin = (fun _3343500 : R => Re (csin (Cx _3343500))).
Proof. exact (REFL sin). Qed.
Definition cos : R -> R := fun _3343505 : R => Re (ccos (Cx _3343505)).
Lemma cos_def : cos = (fun _3343505 : R => Re (ccos (Cx _3343505))).
Proof. exact (REFL cos). Qed.
Definition log : R -> R := fun _3343606 : R => @ε R (fun x : R => (exp x) = _3343606).
Lemma log_def : log = (fun _3343606 : R => @ε R (fun x : R => (exp x) = _3343606)).
Proof. exact (REFL log). Qed.
Definition pi : R := @ε R (fun p : R => (ltr (R_of_nat (NUMERAL O)) p) /\ (((sin p) = (R_of_nat (NUMERAL O))) /\ (forall x : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x p)) -> ~ ((sin x) = (R_of_nat (NUMERAL O)))))).
Lemma pi_def : pi = (@ε R (fun p : R => (ltr (R_of_nat (NUMERAL O)) p) /\ (((sin p) = (R_of_nat (NUMERAL O))) /\ (forall x : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x p)) -> ~ ((sin x) = (R_of_nat (NUMERAL O))))))).
Proof. exact (REFL pi). Qed.
Definition Arg : (cart R (tybit0 unit)) -> R := fun _3344639 : cart R (tybit0 unit) => @COND R (_3344639 = (Cx (R_of_nat (NUMERAL O)))) (R_of_nat (NUMERAL O)) (@ε R (fun t : R => (ler (R_of_nat (NUMERAL O)) t) /\ ((ltr t (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi)) /\ (_3344639 = (complex_mul (Cx (@vector_norm (tybit0 unit) _3344639)) (cexp (complex_mul ii (Cx t)))))))).
Lemma Arg_def : Arg = (fun _3344639 : cart R (tybit0 unit) => @COND R (_3344639 = (Cx (R_of_nat (NUMERAL O)))) (R_of_nat (NUMERAL O)) (@ε R (fun t : R => (ler (R_of_nat (NUMERAL O)) t) /\ ((ltr t (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi)) /\ (_3344639 = (complex_mul (Cx (@vector_norm (tybit0 unit) _3344639)) (cexp (complex_mul ii (Cx t))))))))).
Proof. exact (REFL Arg). Qed.
Definition rotate2d : R -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3344907 : R => fun _3344908 : cart R (tybit0 unit) => @vector R (tybit0 unit) (@cons R (subr (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT1 O))) (cos _3344907)) (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT0 (BIT1 O)))) (sin _3344907))) (@cons R (addr (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT1 O))) (sin _3344907)) (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT0 (BIT1 O)))) (cos _3344907))) (@nil R))).
Lemma rotate2d_def : rotate2d = (fun _3344907 : R => fun _3344908 : cart R (tybit0 unit) => @vector R (tybit0 unit) (@cons R (subr (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT1 O))) (cos _3344907)) (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT0 (BIT1 O)))) (sin _3344907))) (@cons R (addr (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT1 O))) (sin _3344907)) (mulr (@dollar R (tybit0 unit) _3344908 (NUMERAL (BIT0 (BIT1 O)))) (cos _3344907))) (@nil R)))).
Proof. exact (REFL rotate2d). Qed.
Definition ctan : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3345579 : cart R (tybit0 unit) => complex_div (csin _3345579) (ccos _3345579).
Lemma ctan_def : ctan = (fun _3345579 : cart R (tybit0 unit) => complex_div (csin _3345579) (ccos _3345579)).
Proof. exact (REFL ctan). Qed.
Definition tan : R -> R := fun _3345782 : R => Re (ctan (Cx _3345782)).
Lemma tan_def : tan = (fun _3345782 : R => Re (ctan (Cx _3345782))).
Proof. exact (REFL tan). Qed.
Definition clog : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3346099 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun w : cart R (tybit0 unit) => ((cexp w) = _3346099) /\ ((ltr (oppr pi) (Im w)) /\ (ler (Im w) pi))).
Lemma clog_def : clog = (fun _3346099 : cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun w : cart R (tybit0 unit) => ((cexp w) = _3346099) /\ ((ltr (oppr pi) (Im w)) /\ (ler (Im w) pi)))).
Proof. exact (REFL clog). Qed.
Definition cpow : (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3347100 : cart R (tybit0 unit) => fun _3347101 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) (_3347100 = (Cx (R_of_nat (NUMERAL O)))) (Cx (R_of_nat (NUMERAL O))) (cexp (complex_mul _3347101 (clog _3347100))).
Lemma cpow_def : cpow = (fun _3347100 : cart R (tybit0 unit) => fun _3347101 : cart R (tybit0 unit) => @COND (cart R (tybit0 unit)) (_3347100 = (Cx (R_of_nat (NUMERAL O)))) (Cx (R_of_nat (NUMERAL O))) (cexp (complex_mul _3347101 (clog _3347100)))).
Proof. exact (REFL cpow). Qed.
Definition unwinding : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3347302 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) _3347302 (clog (cexp _3347302))) (complex_mul (Cx (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi)) ii).
Lemma unwinding_def : unwinding = (fun _3347302 : cart R (tybit0 unit) => complex_div (@vector_sub (tybit0 unit) _3347302 (clog (cexp _3347302))) (complex_mul (Cx (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi)) ii)).
Proof. exact (REFL unwinding). Qed.
Definition catn : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3347307 : cart R (tybit0 unit) => complex_mul (complex_div ii (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (clog (complex_div (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul ii _3347307)) (@vector_add (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul ii _3347307)))).
Lemma catn_def : catn = (fun _3347307 : cart R (tybit0 unit) => complex_mul (complex_div ii (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) (clog (complex_div (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul ii _3347307)) (@vector_add (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul ii _3347307))))).
Proof. exact (REFL catn). Qed.
Definition atn : R -> R := fun _3347851 : R => Re (catn (Cx _3347851)).
Lemma atn_def : atn = (fun _3347851 : R => Re (catn (Cx _3347851))).
Proof. exact (REFL atn). Qed.
Definition casn : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3348226 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) (complex_mul ii _3348226) (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_pow _3348226 (NUMERAL (BIT0 (BIT1 O)))))))).
Lemma casn_def : casn = (fun _3348226 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) (complex_mul ii _3348226) (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_pow _3348226 (NUMERAL (BIT0 (BIT1 O))))))))).
Proof. exact (REFL casn). Qed.
Definition cacs : (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3348720 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) _3348720 (complex_mul ii (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_pow _3348720 (NUMERAL (BIT0 (BIT1 O))))))))).
Lemma cacs_def : cacs = (fun _3348720 : cart R (tybit0 unit) => complex_mul (@vector_neg (tybit0 unit) ii) (clog (@vector_add (tybit0 unit) _3348720 (complex_mul ii (csqrt (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_pow _3348720 (NUMERAL (BIT0 (BIT1 O)))))))))).
Proof. exact (REFL cacs). Qed.
Definition asn : R -> R := fun _3349255 : R => Re (casn (Cx _3349255)).
Lemma asn_def : asn = (fun _3349255 : R => Re (casn (Cx _3349255))).
Proof. exact (REFL asn). Qed.
Definition acs : R -> R := fun _3349340 : R => Re (cacs (Cx _3349340)).
Lemma acs_def : acs = (fun _3349340 : R => Re (cacs (Cx _3349340))).
Proof. exact (REFL acs). Qed.
Definition root : nat -> R -> R := fun _3349850 : nat => fun _3349851 : R => mulr (sgr _3349851) (exp (divr (log (normr _3349851)) (R_of_nat _3349850))).
Lemma root_def : root = (fun _3349850 : nat => fun _3349851 : R => mulr (sgr _3349851) (exp (divr (log (normr _3349851)) (R_of_nat _3349850)))).
Proof. exact (REFL root). Qed.
Definition rpow : R -> R -> R := fun _3350200 : R => fun _3350201 : R => @COND R (ltr (R_of_nat (NUMERAL O)) _3350200) (exp (mulr _3350201 (log _3350200))) (@COND R (_3350200 = (R_of_nat (NUMERAL O))) (@COND R (_3350201 = (R_of_nat (NUMERAL O))) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))) (@COND R (exists m : nat, exists n : nat, (oddn m) /\ ((oddn n) /\ ((normr _3350201) = (divr (R_of_nat m) (R_of_nat n))))) (oppr (exp (mulr _3350201 (log (oppr _3350200))))) (exp (mulr _3350201 (log (oppr _3350200)))))).
Lemma rpow_def : rpow = (fun _3350200 : R => fun _3350201 : R => @COND R (ltr (R_of_nat (NUMERAL O)) _3350200) (exp (mulr _3350201 (log _3350200))) (@COND R (_3350200 = (R_of_nat (NUMERAL O))) (@COND R (_3350201 = (R_of_nat (NUMERAL O))) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))) (@COND R (exists m : nat, exists n : nat, (oddn m) /\ ((oddn n) /\ ((normr _3350201) = (divr (R_of_nat m) (R_of_nat n))))) (oppr (exp (mulr _3350201 (log (oppr _3350200))))) (exp (mulr _3350201 (log (oppr _3350200))))))).
Proof. exact (REFL rpow). Qed.
Definition longarrow {_1675867 : Type'} : (_1675867 -> R) -> R -> (net _1675867) -> Prop := fun _3353859 : _1675867 -> R => fun _3353860 : R => fun _3353861 : net _1675867 => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> @eventually _1675867 (fun x : _1675867 => ltr (normr (subr (_3353859 x) _3353860)) e) _3353861.
Lemma longarrow_def {_1675867 : Type'} : (@longarrow _1675867) = (fun _3353859 : _1675867 -> R => fun _3353860 : R => fun _3353861 : net _1675867 => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> @eventually _1675867 (fun x : _1675867 => ltr (normr (subr (_3353859 x) _3353860)) e) _3353861).
Proof. exact (REFL (@longarrow _1675867)). Qed.
Definition reallim {_1675881 : Type'} : (net _1675881) -> (_1675881 -> R) -> R := fun _3353880 : net _1675881 => fun _3353881 : _1675881 -> R => @ε R (fun l : R => @longarrow _1675881 _3353881 l _3353880).
Lemma reallim_def {_1675881 : Type'} : (@reallim _1675881) = (fun _3353880 : net _1675881 => fun _3353881 : _1675881 -> R => @ε R (fun l : R => @longarrow _1675881 _3353881 l _3353880)).
Proof. exact (REFL (@reallim _1675881)). Qed.
Definition real_sums : (nat -> R) -> R -> (nat -> Prop) -> Prop := fun _3354375 : nat -> R => fun _3354376 : R => fun _3354377 : nat -> Prop => @longarrow nat (fun n : nat => @sum nat (@setI nat _3354377 (dotdot (NUMERAL O) n)) _3354375) _3354376 sequentially.
Lemma real_sums_def : real_sums = (fun _3354375 : nat -> R => fun _3354376 : R => fun _3354377 : nat -> Prop => @longarrow nat (fun n : nat => @sum nat (@setI nat _3354377 (dotdot (NUMERAL O) n)) _3354375) _3354376 sequentially).
Proof. exact (REFL real_sums). Qed.
Definition real_infsum : (nat -> Prop) -> (nat -> R) -> R := fun _3354396 : nat -> Prop => fun _3354397 : nat -> R => @ε R (fun l : R => real_sums _3354397 l _3354396).
Lemma real_infsum_def : real_infsum = (fun _3354396 : nat -> Prop => fun _3354397 : nat -> R => @ε R (fun l : R => real_sums _3354397 l _3354396)).
Proof. exact (REFL real_infsum). Qed.
Definition real_summable : (nat -> Prop) -> (nat -> R) -> Prop := fun _3354408 : nat -> Prop => fun _3354409 : nat -> R => exists l : R, real_sums _3354409 l _3354408.
Lemma real_summable_def : real_summable = (fun _3354408 : nat -> Prop => fun _3354409 : nat -> R => exists l : R, real_sums _3354409 l _3354408).
Proof. exact (REFL real_summable). Qed.
Definition atreal : R -> net R := fun _3355835 : R => @atpointof R euclideanreal _3355835.
Lemma atreal_def : atreal = (fun _3355835 : R => @atpointof R euclideanreal _3355835).
Proof. exact (REFL atreal). Qed.
Definition real_continuous {_1686079 : Type'} : (_1686079 -> R) -> (net _1686079) -> Prop := fun _3356650 : _1686079 -> R => fun _3356651 : net _1686079 => @longarrow _1686079 _3356650 (_3356650 (@netlimit _1686079 _3356651)) _3356651.
Lemma real_continuous_def {_1686079 : Type'} : (@real_continuous _1686079) = (fun _3356650 : _1686079 -> R => fun _3356651 : net _1686079 => @longarrow _1686079 _3356650 (_3356650 (@netlimit _1686079 _3356651)) _3356651).
Proof. exact (REFL (@real_continuous _1686079)). Qed.
Definition real_continuous_on : (R -> R) -> (R -> Prop) -> Prop := fun _3358010 : R -> R => fun _3358011 : R -> Prop => forall x : R, (@IN R x _3358011) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x' : R, ((@IN R x' _3358011) /\ (ltr (normr (subr x' x)) d)) -> ltr (normr (subr (_3358010 x') (_3358010 x))) e).
Lemma real_continuous_on_def : real_continuous_on = (fun _3358010 : R -> R => fun _3358011 : R -> Prop => forall x : R, (@IN R x _3358011) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x' : R, ((@IN R x' _3358011) /\ (ltr (normr (subr x' x)) d)) -> ltr (normr (subr (_3358010 x') (_3358010 x))) e)).
Proof. exact (REFL real_continuous_on). Qed.
Definition real_uniformly_continuous_on : (R -> R) -> (R -> Prop) -> Prop := fun _3358435 : R -> R => fun _3358436 : R -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall x' : R, ((@IN R x _3358436) /\ ((@IN R x' _3358436) /\ (ltr (normr (subr x' x)) d))) -> ltr (normr (subr (_3358435 x') (_3358435 x))) e).
Lemma real_uniformly_continuous_on_def : real_uniformly_continuous_on = (fun _3358435 : R -> R => fun _3358436 : R -> Prop => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall x' : R, ((@IN R x _3358436) /\ ((@IN R x' _3358436) /\ (ltr (normr (subr x' x)) d))) -> ltr (normr (subr (_3358435 x') (_3358435 x))) e)).
Proof. exact (REFL real_uniformly_continuous_on). Qed.
Definition has_real_derivative : (R -> R) -> R -> (net R) -> Prop := fun _3358525 : R -> R => fun _3358526 : R => fun _3358527 : net R => @longarrow R (fun x : R => mulr (invr (subr x (@netlimit R _3358527))) (subr (_3358525 x) (addr (_3358525 (@netlimit R _3358527)) (mulr _3358526 (subr x (@netlimit R _3358527)))))) (R_of_nat (NUMERAL O)) _3358527.
Lemma has_real_derivative_def : has_real_derivative = (fun _3358525 : R -> R => fun _3358526 : R => fun _3358527 : net R => @longarrow R (fun x : R => mulr (invr (subr x (@netlimit R _3358527))) (subr (_3358525 x) (addr (_3358525 (@netlimit R _3358527)) (mulr _3358526 (subr x (@netlimit R _3358527)))))) (R_of_nat (NUMERAL O)) _3358527).
Proof. exact (REFL has_real_derivative). Qed.
Definition real_differentiable : (R -> R) -> (net R) -> Prop := fun _3358546 : R -> R => fun _3358547 : net R => exists f' : R, has_real_derivative _3358546 f' _3358547.
Lemma real_differentiable_def : real_differentiable = (fun _3358546 : R -> R => fun _3358547 : net R => exists f' : R, has_real_derivative _3358546 f' _3358547).
Proof. exact (REFL real_differentiable). Qed.
Definition real_derivative : (R -> R) -> R -> R := fun _3358558 : R -> R => fun _3358559 : R => @ε R (fun f' : R => has_real_derivative _3358558 f' (atreal _3358559)).
Lemma real_derivative_def : real_derivative = (fun _3358558 : R -> R => fun _3358559 : R => @ε R (fun f' : R => has_real_derivative _3358558 f' (atreal _3358559))).
Proof. exact (REFL real_derivative). Qed.
Definition higher_real_derivative : nat -> (R -> R) -> R -> R := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (R -> R) -> R -> R) (fun higher_real_derivative' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (R -> R) -> R -> R => forall _3358954 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))), (forall f : R -> R, (higher_real_derivative' _3358954 (NUMERAL O) f) = f) /\ (forall f : R -> R, forall n : nat, (higher_real_derivative' _3358954 (S n) f) = (real_derivative (higher_real_derivative' _3358954 n f)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))))))).
Lemma higher_real_derivative_def : higher_real_derivative = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (R -> R) -> R -> R) (fun higher_real_derivative' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))))) -> nat -> (R -> R) -> R -> R => forall _3358954 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))), (forall f : R -> R, (higher_real_derivative' _3358954 (NUMERAL O) f) = f) /\ (forall f : R -> R, forall n : nat, (higher_real_derivative' _3358954 (S n) f) = (real_derivative (higher_real_derivative' _3358954 n f)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))))))))).
Proof. exact (REFL higher_real_derivative). Qed.
Definition real_differentiable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3358955 : R -> R => fun _3358956 : R -> Prop => forall x : R, (@IN R x _3358956) -> exists f' : R, has_real_derivative _3358955 f' (@within R (atreal x) _3358956).
Lemma real_differentiable_on_def : real_differentiable_on = (fun _3358955 : R -> R => fun _3358956 : R -> Prop => forall x : R, (@IN R x _3358956) -> exists f' : R, has_real_derivative _3358955 f' (@within R (atreal x) _3358956)).
Proof. exact (REFL real_differentiable_on). Qed.
Definition has_limsup {A : Type'} : (A -> R) -> R -> (net A) -> Prop := fun _3363008 : A -> R => fun _3363009 : R => fun _3363010 : net A => (@trivial_limit A _3363010) \/ (has_inf (@GSPEC R (fun GEN_PVAR_8465 : R => exists b : R, @SETSPEC R GEN_PVAR_8465 (@eventually A (fun x : A => ler (_3363008 x) b) _3363010) b)) _3363009).
Lemma has_limsup_def {A : Type'} : (@has_limsup A) = (fun _3363008 : A -> R => fun _3363009 : R => fun _3363010 : net A => (@trivial_limit A _3363010) \/ (has_inf (@GSPEC R (fun GEN_PVAR_8465 : R => exists b : R, @SETSPEC R GEN_PVAR_8465 (@eventually A (fun x : A => ler (_3363008 x) b) _3363010) b)) _3363009)).
Proof. exact (REFL (@has_limsup A)). Qed.
Definition has_liminf {A : Type'} : (A -> R) -> R -> (net A) -> Prop := fun _3363029 : A -> R => fun _3363030 : R => fun _3363031 : net A => (@trivial_limit A _3363031) \/ (has_sup (@GSPEC R (fun GEN_PVAR_8466 : R => exists b : R, @SETSPEC R GEN_PVAR_8466 (@eventually A (fun x : A => ler b (_3363029 x)) _3363031) b)) _3363030).
Lemma has_liminf_def {A : Type'} : (@has_liminf A) = (fun _3363029 : A -> R => fun _3363030 : R => fun _3363031 : net A => (@trivial_limit A _3363031) \/ (has_sup (@GSPEC R (fun GEN_PVAR_8466 : R => exists b : R, @SETSPEC R GEN_PVAR_8466 (@eventually A (fun x : A => ler b (_3363029 x)) _3363031) b)) _3363030)).
Proof. exact (REFL (@has_liminf A)). Qed.
Definition closed_real_segment : (seq (prod R R)) -> R -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) -> (seq (prod R R)) -> R -> Prop) (fun closed_real_segment' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) -> (seq (prod R R)) -> R -> Prop => forall _3365054 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))), forall a : R, forall b : R, (closed_real_segment' _3365054 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_8483 : R => exists u : R, @SETSPEC R GEN_PVAR_8483 ((ler (R_of_nat (NUMERAL O)) u) /\ (ler u (R_of_nat (NUMERAL (BIT1 O))))) (addr (mulr (subr (R_of_nat (NUMERAL (BIT1 O))) u) a) (mulr u b))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))))))))))))))))))))).
Lemma closed_real_segment_def : closed_real_segment = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) -> (seq (prod R R)) -> R -> Prop) (fun closed_real_segment' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))))) -> (seq (prod R R)) -> R -> Prop => forall _3365054 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))), forall a : R, forall b : R, (closed_real_segment' _3365054 (@cons (prod R R) (@pair R R a b) (@nil (prod R R)))) = (@GSPEC R (fun GEN_PVAR_8483 : R => exists u : R, @SETSPEC R GEN_PVAR_8483 ((ler (R_of_nat (NUMERAL O)) u) /\ (ler u (R_of_nat (NUMERAL (BIT1 O))))) (addr (mulr (subr (R_of_nat (NUMERAL (BIT1 O))) u) a) (mulr u b))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O))))))))))))))))))))))))))).
Proof. exact (REFL closed_real_segment). Qed.
Definition open_real_segment : (prod R R) -> R -> Prop := fun _3365055 : prod R R => @setD R (closed_real_segment (@cons (prod R R) (@pair R R (@fst R R _3365055) (@snd R R _3365055)) (@nil (prod R R)))) (@INSERT R (@fst R R _3365055) (@INSERT R (@snd R R _3365055) (@set0 R))).
Lemma open_real_segment_def : open_real_segment = (fun _3365055 : prod R R => @setD R (closed_real_segment (@cons (prod R R) (@pair R R (@fst R R _3365055) (@snd R R _3365055)) (@nil (prod R R)))) (@INSERT R (@fst R R _3365055) (@INSERT R (@snd R R _3365055) (@set0 R)))).
Proof. exact (REFL open_real_segment). Qed.
Definition real_convex_on : (R -> R) -> (R -> Prop) -> Prop := fun _3365397 : R -> R => fun _3365398 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3365398) /\ ((@IN R y _3365398) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (_3365397 (addr (mulr u x) (mulr v y))) (addr (mulr u (_3365397 x)) (mulr v (_3365397 y))).
Lemma real_convex_on_def : real_convex_on = (fun _3365397 : R -> R => fun _3365398 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3365398) /\ ((@IN R y _3365398) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (_3365397 (addr (mulr u x) (mulr v y))) (addr (mulr u (_3365397 x)) (mulr v (_3365397 y)))).
Proof. exact (REFL real_convex_on). Qed.
Definition log_convex_on {N' : Type'} : ((cart R N') -> R) -> ((cart R N') -> Prop) -> Prop := fun _3366642 : (cart R N') -> R => fun _3366643 : (cart R N') -> Prop => forall x : cart R N', forall y : cart R N', forall u : R, forall v : R, ((@IN (cart R N') x _3366643) /\ ((@IN (cart R N') y _3366643) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> (ler (R_of_nat (NUMERAL O)) (_3366642 (@vector_add N' (@percent N' u x) (@percent N' v y)))) /\ (ler (_3366642 (@vector_add N' (@percent N' u x) (@percent N' v y))) (mulr (rpow (_3366642 x) u) (rpow (_3366642 y) v))).
Lemma log_convex_on_def {N' : Type'} : (@log_convex_on N') = (fun _3366642 : (cart R N') -> R => fun _3366643 : (cart R N') -> Prop => forall x : cart R N', forall y : cart R N', forall u : R, forall v : R, ((@IN (cart R N') x _3366643) /\ ((@IN (cart R N') y _3366643) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> (ler (R_of_nat (NUMERAL O)) (_3366642 (@vector_add N' (@percent N' u x) (@percent N' v y)))) /\ (ler (_3366642 (@vector_add N' (@percent N' u x) (@percent N' v y))) (mulr (rpow (_3366642 x) u) (rpow (_3366642 y) v)))).
Proof. exact (REFL (@log_convex_on N')). Qed.
Definition real_log_convex_on : (R -> R) -> (R -> Prop) -> Prop := fun _3367488 : R -> R => fun _3367489 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3367489) /\ ((@IN R y _3367489) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> (ler (R_of_nat (NUMERAL O)) (_3367488 (addr (mulr u x) (mulr v y)))) /\ (ler (_3367488 (addr (mulr u x) (mulr v y))) (mulr (rpow (_3367488 x) u) (rpow (_3367488 y) v))).
Lemma real_log_convex_on_def : real_log_convex_on = (fun _3367488 : R -> R => fun _3367489 : R -> Prop => forall x : R, forall y : R, forall u : R, forall v : R, ((@IN R x _3367489) /\ ((@IN R y _3367489) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> (ler (R_of_nat (NUMERAL O)) (_3367488 (addr (mulr u x) (mulr v y)))) /\ (ler (_3367488 (addr (mulr u x) (mulr v y))) (mulr (rpow (_3367488 x) u) (rpow (_3367488 y) v)))).
Proof. exact (REFL real_log_convex_on). Qed.
Definition has_real_integral : (R -> R) -> R -> (R -> Prop) -> Prop := fun _3368369 : R -> R => fun _3368370 : R => fun _3368371 : R -> Prop => @has_integral unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3368369 drop)) (lift _3368370) (@IMAGE R (cart R unit) lift _3368371).
Lemma has_real_integral_def : has_real_integral = (fun _3368369 : R -> R => fun _3368370 : R => fun _3368371 : R -> Prop => @has_integral unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3368369 drop)) (lift _3368370) (@IMAGE R (cart R unit) lift _3368371)).
Proof. exact (REFL has_real_integral). Qed.
Definition real_integrable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3368390 : R -> R => fun _3368391 : R -> Prop => exists y : R, has_real_integral _3368390 y _3368391.
Lemma real_integrable_on_def : real_integrable_on = (fun _3368390 : R -> R => fun _3368391 : R -> Prop => exists y : R, has_real_integral _3368390 y _3368391).
Proof. exact (REFL real_integrable_on). Qed.
Definition real_integral : (R -> Prop) -> (R -> R) -> R := fun _3368402 : R -> Prop => fun _3368403 : R -> R => @ε R (fun y : R => has_real_integral _3368403 y _3368402).
Lemma real_integral_def : real_integral = (fun _3368402 : R -> Prop => fun _3368403 : R -> R => @ε R (fun y : R => has_real_integral _3368403 y _3368402)).
Proof. exact (REFL real_integral). Qed.
Definition real_negligible : (R -> Prop) -> Prop := fun _3368414 : R -> Prop => @negligible unit (@IMAGE R (cart R unit) lift _3368414).
Lemma real_negligible_def : real_negligible = (fun _3368414 : R -> Prop => @negligible unit (@IMAGE R (cart R unit) lift _3368414)).
Proof. exact (REFL real_negligible). Qed.
Definition absolutely_real_integrable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3368419 : R -> R => fun _3368420 : R -> Prop => (real_integrable_on _3368419 _3368420) /\ (real_integrable_on (fun x : R => normr (_3368419 x)) _3368420).
Lemma absolutely_real_integrable_on_def : absolutely_real_integrable_on = (fun _3368419 : R -> R => fun _3368420 : R -> Prop => (real_integrable_on _3368419 _3368420) /\ (real_integrable_on (fun x : R => normr (_3368419 x)) _3368420)).
Proof. exact (REFL absolutely_real_integrable_on). Qed.
Definition has_real_measure : (R -> Prop) -> R -> Prop := fun _3368431 : R -> Prop => fun _3368432 : R => has_real_integral (fun x : R => R_of_nat (NUMERAL (BIT1 O))) _3368432 _3368431.
Lemma has_real_measure_def : has_real_measure = (fun _3368431 : R -> Prop => fun _3368432 : R => has_real_integral (fun x : R => R_of_nat (NUMERAL (BIT1 O))) _3368432 _3368431).
Proof. exact (REFL has_real_measure). Qed.
Definition real_measurable : (R -> Prop) -> Prop := fun _3368443 : R -> Prop => exists m : R, has_real_measure _3368443 m.
Lemma real_measurable_def : real_measurable = (fun _3368443 : R -> Prop => exists m : R, has_real_measure _3368443 m).
Proof. exact (REFL real_measurable). Qed.
Definition real_measure : (R -> Prop) -> R := fun _3368448 : R -> Prop => @ε R (fun m : R => has_real_measure _3368448 m).
Lemma real_measure_def : real_measure = (fun _3368448 : R -> Prop => @ε R (fun m : R => has_real_measure _3368448 m)).
Proof. exact (REFL real_measure). Qed.
Definition slice {_1738408 _1738429 : Type'} : nat -> R -> ((cart R _1738429) -> Prop) -> (cart R _1738408) -> Prop := fun _3374555 : nat => fun _3374556 : R => fun _3374557 : (cart R _1738429) -> Prop => @IMAGE (cart R _1738429) (cart R _1738408) (@dropout _1738429 _1738408 _3374555) (@setI (cart R _1738429) _3374557 (@GSPEC (cart R _1738429) (fun GEN_PVAR_8546 : cart R _1738429 => exists x : cart R _1738429, @SETSPEC (cart R _1738429) GEN_PVAR_8546 ((@dollar R _1738429 x _3374555) = _3374556) x))).
Lemma slice_def {_1738408 _1738429 : Type'} : (@slice _1738408 _1738429) = (fun _3374555 : nat => fun _3374556 : R => fun _3374557 : (cart R _1738429) -> Prop => @IMAGE (cart R _1738429) (cart R _1738408) (@dropout _1738429 _1738408 _3374555) (@setI (cart R _1738429) _3374557 (@GSPEC (cart R _1738429) (fun GEN_PVAR_8546 : cart R _1738429 => exists x : cart R _1738429, @SETSPEC (cart R _1738429) GEN_PVAR_8546 ((@dollar R _1738429 x _3374555) = _3374556) x)))).
Proof. exact (REFL (@slice _1738408 _1738429)). Qed.
Definition bernstein : nat -> nat -> R -> R := fun _3383813 : nat => fun _3383814 : nat => fun _3383815 : R => mulr (R_of_nat (binom (@pair nat nat _3383813 _3383814))) (mulr (expr _3383815 _3383814) (expr (subr (R_of_nat (NUMERAL (BIT1 O))) _3383815) (subn _3383813 _3383814))).
Lemma bernstein_def : bernstein = (fun _3383813 : nat => fun _3383814 : nat => fun _3383815 : R => mulr (R_of_nat (binom (@pair nat nat _3383813 _3383814))) (mulr (expr _3383815 _3383814) (expr (subr (R_of_nat (NUMERAL (BIT1 O))) _3383815) (subn _3383813 _3383814)))).
Proof. exact (REFL bernstein). Qed.
Definition real_polynomial_function {N' : Type'} : ((cart R N') -> R) -> Prop := fun a : (cart R N') -> R => forall real_polynomial_function' : ((cart R N') -> R) -> Prop, (forall a' : (cart R N') -> R, ((exists i : nat, (a' = (fun x : cart R N' => @dollar R N' x i)) /\ ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N'))))) \/ ((exists c : R, a' = (fun x : cart R N' => c)) \/ ((exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => addr (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g))) \/ (exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => mulr (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g)))))) -> real_polynomial_function' a') -> real_polynomial_function' a.
Lemma real_polynomial_function_def {N' : Type'} : (@real_polynomial_function N') = (fun a : (cart R N') -> R => forall real_polynomial_function' : ((cart R N') -> R) -> Prop, (forall a' : (cart R N') -> R, ((exists i : nat, (a' = (fun x : cart R N' => @dollar R N' x i)) /\ ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N'))))) \/ ((exists c : R, a' = (fun x : cart R N' => c)) \/ ((exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => addr (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g))) \/ (exists f : (cart R N') -> R, exists g : (cart R N') -> R, (a' = (fun x : cart R N' => mulr (f x) (g x))) /\ ((real_polynomial_function' f) /\ (real_polynomial_function' g)))))) -> real_polynomial_function' a') -> real_polynomial_function' a).
Proof. exact (REFL (@real_polynomial_function N')). Qed.
Definition vector_polynomial_function {M N' : Type'} : ((cart R M) -> cart R N') -> Prop := fun _3397249 : (cart R M) -> cart R N' => forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> @real_polynomial_function M (fun x : cart R M => @dollar R N' (_3397249 x) i).
Lemma vector_polynomial_function_def {M N' : Type'} : (@vector_polynomial_function M N') = (fun _3397249 : (cart R M) -> cart R N' => forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> @real_polynomial_function M (fun x : cart R M => @dollar R N' (_3397249 x) i)).
Proof. exact (REFL (@vector_polynomial_function M N')). Qed.
Definition bernoulli : nat -> R -> R := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> nat -> R -> R) (fun bernoulli' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> nat -> R -> R => forall _3400038 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), (forall x : R, (bernoulli' _3400038 (NUMERAL O) x) = (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall n : nat, forall x : R, (bernoulli' _3400038 (addn n (NUMERAL (BIT1 O))) x) = (subr (expr x (addn n (NUMERAL (BIT1 O)))) (divr (@sum nat (dotdot (NUMERAL O) n) (fun k : nat => mulr (R_of_nat (binom (@pair nat nat (addn n (NUMERAL (BIT0 (BIT1 O)))) k))) (bernoulli' _3400038 k x))) (addr (R_of_nat n) (R_of_nat (NUMERAL (BIT0 (BIT1 O))))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))).
Lemma bernoulli_def : bernoulli = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> nat -> R -> R) (fun bernoulli' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> nat -> R -> R => forall _3400038 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), (forall x : R, (bernoulli' _3400038 (NUMERAL O) x) = (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall n : nat, forall x : R, (bernoulli' _3400038 (addn n (NUMERAL (BIT1 O))) x) = (subr (expr x (addn n (NUMERAL (BIT1 O)))) (divr (@sum nat (dotdot (NUMERAL O) n) (fun k : nat => mulr (R_of_nat (binom (@pair nat nat (addn n (NUMERAL (BIT0 (BIT1 O)))) k))) (bernoulli' _3400038 k x))) (addr (R_of_nat n) (R_of_nat (NUMERAL (BIT0 (BIT1 O))))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))).
Proof. exact (REFL bernoulli). Qed.
Definition real_measurable_on : (R -> R) -> (R -> Prop) -> Prop := fun _3401446 : R -> R => fun _3401447 : R -> Prop => @measurable_on unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3401446 drop)) (@IMAGE R (cart R unit) lift _3401447).
Lemma real_measurable_on_def : real_measurable_on = (fun _3401446 : R -> R => fun _3401447 : R -> Prop => @measurable_on unit unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3401446 drop)) (@IMAGE R (cart R unit) lift _3401447)).
Proof. exact (REFL real_measurable_on). Qed.
Definition real_lebesgue_measurable : (R -> Prop) -> Prop := fun _3401458 : R -> Prop => real_measurable_on (fun x : R => @COND R (@IN R x _3401458) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))) (@setT R).
Lemma real_lebesgue_measurable_def : real_lebesgue_measurable = (fun _3401458 : R -> Prop => real_measurable_on (fun x : R => @COND R (@IN R x _3401458) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))) (@setT R)).
Proof. exact (REFL real_lebesgue_measurable). Qed.
Definition has_bounded_real_variation_on : (R -> R) -> (R -> Prop) -> Prop := fun _3405389 : R -> R => fun _3405390 : R -> Prop => @has_bounded_variation_on unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3405389 drop)) (@IMAGE R (cart R unit) lift _3405390).
Lemma has_bounded_real_variation_on_def : has_bounded_real_variation_on = (fun _3405389 : R -> R => fun _3405390 : R -> Prop => @has_bounded_variation_on unit (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3405389 drop)) (@IMAGE R (cart R unit) lift _3405390)).
Proof. exact (REFL has_bounded_real_variation_on). Qed.
Definition real_variation : (R -> Prop) -> (R -> R) -> R := fun _3405401 : R -> Prop => fun _3405402 : R -> R => @vector_variation unit (@IMAGE R (cart R unit) lift _3405401) (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3405402 drop)).
Lemma real_variation_def : real_variation = (fun _3405401 : R -> Prop => fun _3405402 : R -> R => @vector_variation unit (@IMAGE R (cart R unit) lift _3405401) (@o (cart R unit) R (cart R unit) lift (@o (cart R unit) R R _3405402 drop))).
Proof. exact (REFL real_variation). Qed.
Definition borsukian {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3568505 : (cart R N') -> Prop => forall f : (cart R N') -> cart R (tybit0 unit), ((@continuous_on N' (tybit0 unit) f _3568505) /\ (@subset (cart R (tybit0 unit)) (@IMAGE (cart R N') (cart R (tybit0 unit)) f _3568505) (@setD (cart R (tybit0 unit)) (@setT (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_nat (NUMERAL O))) (@set0 (cart R (tybit0 unit))))))) -> exists a : cart R (tybit0 unit), @homotopic_with (cart R (tybit0 unit)) (cart R N') (fun h : (cart R N') -> cart R (tybit0 unit) => True) (@pair (Topology (cart R N')) (Topology (cart R (tybit0 unit))) (@subtopology (cart R N') (@euclidean N') _3568505) (@subtopology (cart R (tybit0 unit)) (@euclidean (tybit0 unit)) (@setD (cart R (tybit0 unit)) (@setT (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_nat (NUMERAL O))) (@set0 (cart R (tybit0 unit))))))) f (fun x : cart R N' => a).
Lemma borsukian_def {N' : Type'} : (@borsukian N') = (fun _3568505 : (cart R N') -> Prop => forall f : (cart R N') -> cart R (tybit0 unit), ((@continuous_on N' (tybit0 unit) f _3568505) /\ (@subset (cart R (tybit0 unit)) (@IMAGE (cart R N') (cart R (tybit0 unit)) f _3568505) (@setD (cart R (tybit0 unit)) (@setT (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_nat (NUMERAL O))) (@set0 (cart R (tybit0 unit))))))) -> exists a : cart R (tybit0 unit), @homotopic_with (cart R (tybit0 unit)) (cart R N') (fun h : (cart R N') -> cart R (tybit0 unit) => True) (@pair (Topology (cart R N')) (Topology (cart R (tybit0 unit))) (@subtopology (cart R N') (@euclidean N') _3568505) (@subtopology (cart R (tybit0 unit)) (@euclidean (tybit0 unit)) (@setD (cart R (tybit0 unit)) (@setT (cart R (tybit0 unit))) (@INSERT (cart R (tybit0 unit)) (Cx (R_of_nat (NUMERAL O))) (@set0 (cart R (tybit0 unit))))))) f (fun x : cart R N' => a)).
Proof. exact (REFL (@borsukian N')). Qed.
Definition unicoherent {N' : Type'} : ((cart R N') -> Prop) -> Prop := fun _3574979 : (cart R N') -> Prop => forall s : (cart R N') -> Prop, forall t : (cart R N') -> Prop, ((@connected N' s) /\ ((@connected N' t) /\ (((@setU (cart R N') s t) = _3574979) /\ ((@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3574979) s) /\ (@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3574979) t))))) -> @connected N' (@setI (cart R N') s t).
Lemma unicoherent_def {N' : Type'} : (@unicoherent N') = (fun _3574979 : (cart R N') -> Prop => forall s : (cart R N') -> Prop, forall t : (cart R N') -> Prop, ((@connected N' s) /\ ((@connected N' t) /\ (((@setU (cart R N') s t) = _3574979) /\ ((@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3574979) s) /\ (@closed_in (cart R N') (@subtopology (cart R N') (@euclidean N') _3574979) t))))) -> @connected N' (@setI (cart R N') s t)).
Proof. exact (REFL (@unicoherent N')). Qed.
Definition piecewise_differentiable_on {_1810044 _1810071 : Type'} : ((cart R _1810071) -> cart R _1810044) -> ((cart R _1810071) -> Prop) -> Prop := fun _3641191 : (cart R _1810071) -> cart R _1810044 => fun _3641192 : (cart R _1810071) -> Prop => (@continuous_on _1810071 _1810044 _3641191 _3641192) /\ (exists s : (cart R _1810071) -> Prop, (@finite_set (cart R _1810071) s) /\ (forall x : cart R _1810071, (@IN (cart R _1810071) x (@setD (cart R _1810071) _3641192 s)) -> @differentiable _1810044 _1810071 _3641191 (@_at _1810071 x))).
Lemma piecewise_differentiable_on_def {_1810044 _1810071 : Type'} : (@piecewise_differentiable_on _1810044 _1810071) = (fun _3641191 : (cart R _1810071) -> cart R _1810044 => fun _3641192 : (cart R _1810071) -> Prop => (@continuous_on _1810071 _1810044 _3641191 _3641192) /\ (exists s : (cart R _1810071) -> Prop, (@finite_set (cart R _1810071) s) /\ (forall x : cart R _1810071, (@IN (cart R _1810071) x (@setD (cart R _1810071) _3641192 s)) -> @differentiable _1810044 _1810071 _3641191 (@_at _1810071 x)))).
Proof. exact (REFL (@piecewise_differentiable_on _1810044 _1810071)). Qed.
Definition valid_path : ((cart R unit) -> cart R (tybit0 unit)) -> Prop := fun _3641954 : (cart R unit) -> cart R (tybit0 unit) => @piecewise_differentiable_on (tybit0 unit) unit _3641954 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))).
Lemma valid_path_def : valid_path = (fun _3641954 : (cart R unit) -> cart R (tybit0 unit) => @piecewise_differentiable_on (tybit0 unit) unit _3641954 (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))).
Proof. exact (REFL valid_path). Qed.
Definition closed_path {_1810814 : Type'} : ((cart R unit) -> cart R _1810814) -> Prop := fun _3641959 : (cart R unit) -> cart R _1810814 => (@pathstart _1810814 _3641959) = (@pathfinish _1810814 _3641959).
Lemma closed_path_def {_1810814 : Type'} : (@closed_path _1810814) = (fun _3641959 : (cart R unit) -> cart R _1810814 => (@pathstart _1810814 _3641959) = (@pathfinish _1810814 _3641959)).
Proof. exact (REFL (@closed_path _1810814)). Qed.
Definition has_path_integral : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop) (fun has_path_integral' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop => forall _3642588 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall i : cart R (tybit0 unit), forall g : (cart R unit) -> cart R (tybit0 unit), (has_path_integral' _3642588 f i g) = (@has_integral unit (tybit0 unit) (fun x : cart R unit => complex_mul (f (g x)) (@vector_derivative (tybit0 unit) g (@within (cart R unit) (@_at unit x) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))))) i (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))))))))))).
Lemma has_path_integral_def : has_path_integral = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop) (fun has_path_integral' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))))) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop => forall _3642588 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))), forall f : (cart R (tybit0 unit)) -> cart R (tybit0 unit), forall i : cart R (tybit0 unit), forall g : (cart R unit) -> cart R (tybit0 unit), (has_path_integral' _3642588 f i g) = (@has_integral unit (tybit0 unit) (fun x : cart R unit => complex_mul (f (g x)) (@vector_derivative (tybit0 unit) g (@within (cart R unit) (@_at unit x) (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))))) i (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))))))))))).
Proof. exact (REFL has_path_integral). Qed.
Definition path_integral : ((cart R unit) -> cart R (tybit0 unit)) -> ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3642589 : (cart R unit) -> cart R (tybit0 unit) => fun _3642590 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun i : cart R (tybit0 unit) => has_path_integral _3642590 i _3642589).
Lemma path_integral_def : path_integral = (fun _3642589 : (cart R unit) -> cart R (tybit0 unit) => fun _3642590 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => @ε (cart R (tybit0 unit)) (fun i : cart R (tybit0 unit) => has_path_integral _3642590 i _3642589)).
Proof. exact (REFL path_integral). Qed.
Definition path_integrable_on : ((cart R (tybit0 unit)) -> cart R (tybit0 unit)) -> ((cart R unit) -> cart R (tybit0 unit)) -> Prop := fun _3642601 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3642602 : (cart R unit) -> cart R (tybit0 unit) => exists i : cart R (tybit0 unit), has_path_integral _3642601 i _3642602.
Lemma path_integrable_on_def : path_integrable_on = (fun _3642601 : (cart R (tybit0 unit)) -> cart R (tybit0 unit) => fun _3642602 : (cart R unit) -> cart R (tybit0 unit) => exists i : cart R (tybit0 unit), has_path_integral _3642601 i _3642602).
Proof. exact (REFL path_integrable_on). Qed.
Definition winding_number : (prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit))) -> cart R (tybit0 unit) := fun _3678754 : prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) => @ε (cart R (tybit0 unit)) (fun n : cart R (tybit0 unit) => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists p : (cart R unit) -> cart R (tybit0 unit), (valid_path p) /\ ((~ (@IN (cart R (tybit0 unit)) (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754) (@path_image (tybit0 unit) p))) /\ (((@pathstart (tybit0 unit) p) = (@pathstart (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754))) /\ (((@pathfinish (tybit0 unit) p) = (@pathfinish (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754))) /\ ((forall t : cart R unit, (@IN (cart R unit) t (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) -> ltr (@vector_norm (tybit0 unit) (@vector_sub (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754 t) (p t))) e) /\ ((path_integral p (fun w : cart R (tybit0 unit) => complex_div (Cx (R_of_nat (NUMERAL (BIT1 O)))) (@vector_sub (tybit0 unit) w (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754)))) = (complex_mul (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) (complex_mul (Cx pi) (complex_mul ii n))))))))).
Lemma winding_number_def : winding_number = (fun _3678754 : prod ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) => @ε (cart R (tybit0 unit)) (fun n : cart R (tybit0 unit) => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists p : (cart R unit) -> cart R (tybit0 unit), (valid_path p) /\ ((~ (@IN (cart R (tybit0 unit)) (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754) (@path_image (tybit0 unit) p))) /\ (((@pathstart (tybit0 unit) p) = (@pathstart (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754))) /\ (((@pathfinish (tybit0 unit) p) = (@pathfinish (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754))) /\ ((forall t : cart R unit, (@IN (cart R unit) t (@closed_interval unit (@cons (prod (cart R unit) (cart R unit)) (@pair (cart R unit) (cart R unit) (@vec unit (NUMERAL O)) (@vec unit (NUMERAL (BIT1 O)))) (@nil (prod (cart R unit) (cart R unit)))))) -> ltr (@vector_norm (tybit0 unit) (@vector_sub (tybit0 unit) (@fst ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754 t) (p t))) e) /\ ((path_integral p (fun w : cart R (tybit0 unit) => complex_div (Cx (R_of_nat (NUMERAL (BIT1 O)))) (@vector_sub (tybit0 unit) w (@snd ((cart R unit) -> cart R (tybit0 unit)) (cart R (tybit0 unit)) _3678754)))) = (complex_mul (Cx (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) (complex_mul (Cx pi) (complex_mul ii n)))))))))).
Proof. exact (REFL winding_number). Qed.
Definition complex_integer : (cart R (tybit0 unit)) -> Prop := fun _3682779 : cart R (tybit0 unit) => (Rint (Re _3682779)) /\ ((Im _3682779) = (R_of_nat (NUMERAL O))).
Lemma complex_integer_def : complex_integer = (fun _3682779 : cart R (tybit0 unit) => (Rint (Re _3682779)) /\ ((Im _3682779) = (R_of_nat (NUMERAL O)))).
Proof. exact (REFL complex_integer). Qed.
Definition partcirclepath : (prod (cart R (tybit0 unit)) (prod R (prod R R))) -> (cart R unit) -> cart R (tybit0 unit) := fun _3701160 : prod (cart R (tybit0 unit)) (prod R (prod R R)) => fun x : cart R unit => @vector_add (tybit0 unit) (@fst (cart R (tybit0 unit)) (prod R (prod R R)) _3701160) (complex_mul (Cx (@fst R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160))) (cexp (complex_mul ii (@linepath (tybit0 unit) (@pair (cart R (tybit0 unit)) (cart R (tybit0 unit)) (Cx (@fst R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160)))) (Cx (@snd R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160))))) x)))).
Lemma partcirclepath_def : partcirclepath = (fun _3701160 : prod (cart R (tybit0 unit)) (prod R (prod R R)) => fun x : cart R unit => @vector_add (tybit0 unit) (@fst (cart R (tybit0 unit)) (prod R (prod R R)) _3701160) (complex_mul (Cx (@fst R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160))) (cexp (complex_mul ii (@linepath (tybit0 unit) (@pair (cart R (tybit0 unit)) (cart R (tybit0 unit)) (Cx (@fst R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160)))) (Cx (@snd R R (@snd R (prod R R) (@snd (cart R (tybit0 unit)) (prod R (prod R R)) _3701160))))) x))))).
Proof. exact (REFL partcirclepath). Qed.
Definition circlepath : (prod (cart R (tybit0 unit)) R) -> (cart R unit) -> cart R (tybit0 unit) := fun _3702219 : prod (cart R (tybit0 unit)) R => partcirclepath (@pair (cart R (tybit0 unit)) (prod R (prod R R)) (@fst (cart R (tybit0 unit)) R _3702219) (@pair R (prod R R) (@snd (cart R (tybit0 unit)) R _3702219) (@pair R R (R_of_nat (NUMERAL O)) (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi)))).
Lemma circlepath_def : circlepath = (fun _3702219 : prod (cart R (tybit0 unit)) R => partcirclepath (@pair (cart R (tybit0 unit)) (prod R (prod R R)) (@fst (cart R (tybit0 unit)) R _3702219) (@pair R (prod R R) (@snd (cart R (tybit0 unit)) R _3702219) (@pair R R (R_of_nat (NUMERAL O)) (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) pi))))).
Proof. exact (REFL circlepath). Qed.
Definition moebius_function : R -> (cart R (tybit0 unit)) -> (cart R (tybit0 unit)) -> cart R (tybit0 unit) := fun _3778215 : R => fun _3778216 : cart R (tybit0 unit) => fun _3778217 : cart R (tybit0 unit) => complex_mul (cexp (complex_mul ii (Cx _3778215))) (complex_div (@vector_sub (tybit0 unit) _3778217 _3778216) (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul (cnj _3778216) _3778217))).
Lemma moebius_function_def : moebius_function = (fun _3778215 : R => fun _3778216 : cart R (tybit0 unit) => fun _3778217 : cart R (tybit0 unit) => complex_mul (cexp (complex_mul ii (Cx _3778215))) (complex_div (@vector_sub (tybit0 unit) _3778217 _3778216) (@vector_sub (tybit0 unit) (Cx (R_of_nat (NUMERAL (BIT1 O)))) (complex_mul (cnj _3778216) _3778217)))).
Proof. exact (REFL moebius_function). Qed.
