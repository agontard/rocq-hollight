Require Import Stdlib.Reals.Reals mathcomp.boot.ssrnat mathcomp.boot.div mathcomp.boot.seq mathcomp.algebra.ssralg mathcomp.algebra.ssrint mathcomp.algebra.intdiv mathcomp.classical.classical_sets mathcomp.classical.cardinality mathcomp.analysis_stdlib.Rstruct_topology HOLLight.Logic.mappings.
Require Import HOLLight.Logic.make_terms.
Axiom thm_T_DEF : True = ((fun p : Prop => p) = (fun p : Prop => p)).
Axiom thm_AND_DEF : and = (fun p : Prop => fun q : Prop => (fun f : Prop -> Prop -> Prop => f p q) = (fun f : Prop -> Prop -> Prop => f True True)).
Axiom thm_IMP_DEF : imp = (fun p : Prop => fun q : Prop => (p /\ q) = p).
Axiom thm_FORALL_DEF : forall {A : Type'}, (@Logic.all A) = (fun P : A -> Prop => P = (fun x : A => True)).
Axiom thm_EXISTS_DEF : forall {A : Type'}, (@ex A) = (fun P : A -> Prop => forall q : Prop, (forall x : A, (P x) -> q) -> q).
Axiom thm_OR_DEF : or = (fun p : Prop => fun q : Prop => forall r : Prop, (p -> r) -> (q -> r) -> r).
Axiom thm_F_DEF : False = (forall p : Prop, p).
Axiom thm_NOT_DEF : not = (fun p : Prop => p -> False).
Axiom thm_EXISTS_UNIQUE_DEF : forall {A : Type'}, (@ex1 A) = (fun P : A -> Prop => (ex P) /\ (forall x : A, forall y : A, ((P x) /\ (P y)) -> x = y)).
Axiom thm__FALSITY_ : False = False.
Axiom thm_EQ_REFL : forall {A : Type'}, forall x : A, x = x.
Axiom thm_REFL_CLAUSE : forall {A : Type'}, forall x : A, (x = x) = True.
Axiom thm_EQ_SYM : forall {A : Type'}, forall x : A, forall y : A, (x = y) -> y = x.
Axiom thm_EQ_SYM_EQ : forall {A : Type'}, forall x : A, forall y : A, (x = y) = (y = x).
Axiom thm_EQ_TRANS : forall {A : Type'}, forall x : A, forall y : A, forall z : A, ((x = y) /\ (y = z)) -> x = z.
Axiom thm_BETA_THM : forall {A B : Type'}, forall f : A -> B, forall y : A, ((fun x : A => f x) y) = (f y).
Axiom thm_ABS_SIMP : forall {A B : Type'}, forall t1 : A, forall t2 : B, ((fun x : B => t1) t2) = t1.
Axiom thm_CONJ_ASSOC : forall t1 : Prop, forall t2 : Prop, forall t3 : Prop, (t1 /\ (t2 /\ t3)) = ((t1 /\ t2) /\ t3).
Axiom thm_CONJ_SYM : forall t1 : Prop, forall t2 : Prop, (t1 /\ t2) = (t2 /\ t1).
Axiom thm_CONJ_ACI : forall (r : Prop) (p : Prop) (q : Prop), ((p /\ q) = (q /\ p)) /\ ((((p /\ q) /\ r) = (p /\ (q /\ r))) /\ (((p /\ (q /\ r)) = (q /\ (p /\ r))) /\ (((p /\ p) = p) /\ ((p /\ (p /\ q)) = (p /\ q))))).
Axiom thm_DISJ_ASSOC : forall t1 : Prop, forall t2 : Prop, forall t3 : Prop, (t1 \/ (t2 \/ t3)) = ((t1 \/ t2) \/ t3).
Axiom thm_DISJ_SYM : forall t1 : Prop, forall t2 : Prop, (t1 \/ t2) = (t2 \/ t1).
Axiom thm_DISJ_ACI : forall (r : Prop) (p : Prop) (q : Prop), ((p \/ q) = (q \/ p)) /\ ((((p \/ q) \/ r) = (p \/ (q \/ r))) /\ (((p \/ (q \/ r)) = (q \/ (p \/ r))) /\ (((p \/ p) = p) /\ ((p \/ (p \/ q)) = (p \/ q))))).
Axiom thm_IMP_CONJ : forall (p : Prop) (q : Prop) (r : Prop), ((p /\ q) -> r) = (p -> q -> r).
Axiom thm_IMP_CONJ_ALT : forall (q : Prop) (p : Prop) (r : Prop), ((p /\ q) -> r) = (q -> p -> r).
Axiom thm_LEFT_OR_DISTRIB : forall p : Prop, forall q : Prop, forall r : Prop, (p /\ (q \/ r)) = ((p /\ q) \/ (p /\ r)).
Axiom thm_RIGHT_OR_DISTRIB : forall p : Prop, forall q : Prop, forall r : Prop, ((p \/ q) /\ r) = ((p /\ r) \/ (q /\ r)).
Axiom thm_FORALL_SIMP : forall {A : Type'}, forall t : Prop, (forall x : A, t) = t.
Axiom thm_EXISTS_SIMP : forall {A : Type'}, forall t : Prop, (exists x : A, t) = t.
Axiom thm_EQ_CLAUSES : forall t : Prop, ((True = t) = t) /\ (((t = True) = t) /\ (((False = t) = (~ t)) /\ ((t = False) = (~ t)))).
Axiom thm_NOT_CLAUSES_WEAK : ((~ True) = False) /\ ((~ False) = True).
Axiom thm_AND_CLAUSES : forall t : Prop, ((True /\ t) = t) /\ (((t /\ True) = t) /\ (((False /\ t) = False) /\ (((t /\ False) = False) /\ ((t /\ t) = t)))).
Axiom thm_OR_CLAUSES : forall t : Prop, ((True \/ t) = True) /\ (((t \/ True) = True) /\ (((False \/ t) = t) /\ (((t \/ False) = t) /\ ((t \/ t) = t)))).
Axiom thm_IMP_CLAUSES : forall t : Prop, ((True -> t) = t) /\ (((t -> True) = True) /\ (((False -> t) = True) /\ (((t -> t) = True) /\ ((t -> False) = (~ t))))).
Axiom thm_EXISTS_UNIQUE_THM : forall {A : Type'}, forall P : A -> Prop, (@ex1 A (fun x : A => P x)) = ((exists x : A, P x) /\ (forall x : A, forall x' : A, ((P x) /\ (P x')) -> x = x')).
Axiom thm_EXISTS_REFL : forall {A : Type'}, forall a : A, exists x : A, x = a.
Axiom thm_EXISTS_UNIQUE_REFL : forall {A : Type'}, forall a : A, @ex1 A (fun x : A => x = a).
Axiom thm_UNWIND_THM1 : forall {A : Type'}, forall P : A -> Prop, forall a : A, (exists x : A, (a = x) /\ (P x)) = (P a).
Axiom thm_UNWIND_THM2 : forall {A : Type'}, forall P : A -> Prop, forall a : A, (exists x : A, (x = a) /\ (P x)) = (P a).
Axiom thm_FORALL_UNWIND_THM2 : forall {A : Type'}, forall P : A -> Prop, forall a : A, (forall x : A, (x = a) -> P x) = (P a).
Axiom thm_FORALL_UNWIND_THM1 : forall {A : Type'}, forall P : A -> Prop, forall a : A, (forall x : A, (a = x) -> P x) = (P a).
Axiom thm_SWAP_FORALL_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (forall x : A, forall y : B, P x y) = (forall y : B, forall x : A, P x y).
Axiom thm_SWAP_EXISTS_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (exists x : A, exists y : B, P x y) = (exists y : B, exists x : A, P x y).
Axiom thm_FORALL_AND_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, (forall x : A, (P x) /\ (Q x)) = ((forall x : A, P x) /\ (forall x : A, Q x)).
Axiom thm_AND_FORALL_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, ((forall x : A, P x) /\ (forall x : A, Q x)) = (forall x : A, (P x) /\ (Q x)).
Axiom thm_LEFT_AND_FORALL_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((forall x : A, P x) /\ Q) = (forall x : A, (P x) /\ Q).
Axiom thm_RIGHT_AND_FORALL_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P /\ (forall x : A, Q x)) = (forall x : A, P /\ (Q x)).
Axiom thm_EXISTS_OR_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, (exists x : A, (P x) \/ (Q x)) = ((exists x : A, P x) \/ (exists x : A, Q x)).
Axiom thm_OR_EXISTS_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, ((exists x : A, P x) \/ (exists x : A, Q x)) = (exists x : A, (P x) \/ (Q x)).
Axiom thm_LEFT_OR_EXISTS_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((exists x : A, P x) \/ Q) = (exists x : A, (P x) \/ Q).
Axiom thm_RIGHT_OR_EXISTS_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P \/ (exists x : A, Q x)) = (exists x : A, P \/ (Q x)).
Axiom thm_LEFT_EXISTS_AND_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, (exists x : A, (P x) /\ Q) = ((exists x : A, P x) /\ Q).
Axiom thm_RIGHT_EXISTS_AND_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (exists x : A, P /\ (Q x)) = (P /\ (exists x : A, Q x)).
Axiom thm_TRIV_EXISTS_AND_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, (exists x : A, P /\ Q) = ((exists x : A, P) /\ (exists x : A, Q)).
Axiom thm_LEFT_AND_EXISTS_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((exists x : A, P x) /\ Q) = (exists x : A, (P x) /\ Q).
Axiom thm_RIGHT_AND_EXISTS_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P /\ (exists x : A, Q x)) = (exists x : A, P /\ (Q x)).
Axiom thm_TRIV_AND_EXISTS_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, ((exists x : A, P) /\ (exists x : A, Q)) = (exists x : A, P /\ Q).
Axiom thm_TRIV_FORALL_OR_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, (forall x : A, P \/ Q) = ((forall x : A, P) \/ (forall x : A, Q)).
Axiom thm_TRIV_OR_FORALL_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, ((forall x : A, P) \/ (forall x : A, Q)) = (forall x : A, P \/ Q).
Axiom thm_RIGHT_IMP_FORALL_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P -> forall x : A, Q x) = (forall x : A, P -> Q x).
Axiom thm_RIGHT_FORALL_IMP_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (forall x : A, P -> Q x) = (P -> forall x : A, Q x).
Axiom thm_LEFT_IMP_EXISTS_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((exists x : A, P x) -> Q) = (forall x : A, (P x) -> Q).
Axiom thm_LEFT_FORALL_IMP_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, (forall x : A, (P x) -> Q) = ((exists x : A, P x) -> Q).
Axiom thm_TRIV_FORALL_IMP_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, (forall x : A, P -> Q) = ((exists x : A, P) -> forall x : A, Q).
Axiom thm_TRIV_EXISTS_IMP_THM : forall {A : Type'}, forall P : Prop, forall Q : Prop, (exists x : A, P -> Q) = ((forall x : A, P) -> exists x : A, Q).
Axiom thm_MONO_FORALL : forall {A : Type'} (P : A -> Prop) (Q : A -> Prop), (forall x : A, (P x) -> Q x) -> (forall x : A, P x) -> forall x : A, Q x.
Axiom thm_MONO_EXISTS : forall {A : Type'} (P : A -> Prop) (Q : A -> Prop), (forall x : A, (P x) -> Q x) -> (exists x : A, P x) -> exists x : A, Q x.
Axiom thm_WLOG_RELATION : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (P x y) -> P y x) /\ ((forall x : A, forall y : A, (R' x y) \/ (R' y x)) /\ (forall x : A, forall y : A, (R' x y) -> P x y))) -> forall x : A, forall y : A, P x y.
Axiom thm_EXISTS_UNIQUE_ALT : forall {A : Type'}, forall P : A -> Prop, (@ex1 A (fun x : A => P x)) = (exists x : A, forall y : A, (P y) = (x = y)).
Axiom thm_EXISTS_UNIQUE : forall {A : Type'}, forall P : A -> Prop, (@ex1 A (fun x : A => P x)) = (exists x : A, (P x) /\ (forall y : A, (P y) -> y = x)).
Axiom thm_ETA_AX : forall {A B : Type'}, forall t : A -> B, (fun x : A => t x) = t.
Axiom thm_EQ_EXT : forall {A B : Type'}, forall f : A -> B, forall g : A -> B, (forall x : A, (f x) = (g x)) -> f = g.
Axiom thm_FUN_EQ_THM : forall {A B : Type'}, forall f : A -> B, forall g : A -> B, (f = g) = (forall x : A, (f x) = (g x)).
Axiom thm_SELECT_AX : forall {A : Type'}, forall P : A -> Prop, forall x : A, (P x) -> P (@ε A P).
Axiom thm_EXISTS_THM : forall {A : Type'}, (@ex A) = (fun P : A -> Prop => P (@ε A P)).
Axiom thm_SELECT_REFL : forall {A : Type'}, forall x : A, (@ε A (fun y : A => y = x)) = x.
Axiom thm_SELECT_UNIQUE : forall {A : Type'}, forall P : A -> Prop, forall x : A, (forall y : A, (P y) = (y = x)) -> (@ε A P) = x.
Axiom thm_EXCLUDED_MIDDLE : forall t : Prop, t \/ (~ t).
Axiom thm_BOOL_CASES_AX : forall t : Prop, (t = True) \/ (t = False).
Axiom thm_DE_MORGAN_THM : forall t1 : Prop, forall t2 : Prop, ((~ (t1 /\ t2)) = ((~ t1) \/ (~ t2))) /\ ((~ (t1 \/ t2)) = ((~ t1) /\ (~ t2))).
Axiom thm_NOT_CLAUSES : (forall t : Prop, (~ (~ t)) = t) /\ (((~ True) = False) /\ ((~ False) = True)).
Axiom thm_NOT_IMP : forall t1 : Prop, forall t2 : Prop, (~ (t1 -> t2)) = (t1 /\ (~ t2)).
Axiom thm_CONTRAPOS_THM : forall t1 : Prop, forall t2 : Prop, ((~ t1) -> ~ t2) = (t2 -> t1).
Axiom thm_NOT_EXISTS_THM : forall {A : Type'}, forall P : A -> Prop, (~ (exists x : A, P x)) = (forall x : A, ~ (P x)).
Axiom thm_EXISTS_NOT_THM : forall {A : Type'}, forall P : A -> Prop, (exists x : A, ~ (P x)) = (~ (forall x : A, P x)).
Axiom thm_NOT_FORALL_THM : forall {A : Type'}, forall P : A -> Prop, (~ (forall x : A, P x)) = (exists x : A, ~ (P x)).
Axiom thm_FORALL_NOT_THM : forall {A : Type'}, forall P : A -> Prop, (forall x : A, ~ (P x)) = (~ (exists x : A, P x)).
Axiom thm_FORALL_BOOL_THM : forall (P : Prop -> Prop), (forall b : Prop, P b) = ((P True) /\ (P False)).
Axiom thm_EXISTS_BOOL_THM : forall (P : Prop -> Prop), (exists b : Prop, P b) = ((P True) \/ (P False)).
Axiom thm_LEFT_FORALL_OR_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, (forall x : A, (P x) \/ Q) = ((forall x : A, P x) \/ Q).
Axiom thm_RIGHT_FORALL_OR_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (forall x : A, P \/ (Q x)) = (P \/ (forall x : A, Q x)).
Axiom thm_LEFT_OR_FORALL_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((forall x : A, P x) \/ Q) = (forall x : A, (P x) \/ Q).
Axiom thm_RIGHT_OR_FORALL_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P \/ (forall x : A, Q x)) = (forall x : A, P \/ (Q x)).
Axiom thm_LEFT_IMP_FORALL_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, ((forall x : A, P x) -> Q) = (exists x : A, (P x) -> Q).
Axiom thm_LEFT_EXISTS_IMP_THM : forall {A : Type'}, forall P : A -> Prop, forall Q : Prop, (exists x : A, (P x) -> Q) = ((forall x : A, P x) -> Q).
Axiom thm_RIGHT_IMP_EXISTS_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (P -> exists x : A, Q x) = (exists x : A, P -> Q x).
Axiom thm_RIGHT_EXISTS_IMP_THM : forall {A : Type'}, forall P : Prop, forall Q : A -> Prop, (exists x : A, P -> Q x) = (P -> exists x : A, Q x).
Axiom thm_COND_DEF : forall {A : Type'}, (@COND A) = (fun t : Prop => fun t1 : A => fun t2 : A => @ε A (fun x : A => ((t = True) -> x = t1) /\ ((t = False) -> x = t2))).
Axiom thm_COND_CLAUSES : forall {A : Type'}, forall t1 : A, forall t2 : A, ((@COND A True t1 t2) = t1) /\ ((@COND A False t1 t2) = t2).
Axiom thm_COND_EXPAND : forall b : Prop, forall t1 : Prop, forall t2 : Prop, (@COND Prop b t1 t2) = (((~ b) \/ t1) /\ (b \/ t2)).
Axiom thm_COND_ID : forall {A : Type'}, forall b : Prop, forall t : A, (@COND A b t t) = t.
Axiom thm_COND_RAND : forall {A B : Type'}, forall b : Prop, forall f : A -> B, forall x : A, forall y : A, (f (@COND A b x y)) = (@COND B b (f x) (f y)).
Axiom thm_COND_RATOR : forall {A B : Type'}, forall b : Prop, forall f : A -> B, forall g : A -> B, forall x : A, (@COND (A -> B) b f g x) = (@COND B b (f x) (g x)).
Axiom thm_COND_ABS : forall {A B : Type'}, forall b : Prop, forall f : A -> B, forall g : A -> B, (fun x : A => @COND B b (f x) (g x)) = (@COND (A -> B) b f g).
Axiom thm_COND_SWAP : forall {A : Type'}, forall p : Prop, forall x : A, forall y : A, (@COND A (~ p) x y) = (@COND A p y x).
Axiom thm_MONO_COND : forall (A : Prop) (C : Prop) (b : Prop) (B : Prop) (D : Prop), ((A -> B) /\ (C -> D)) -> (@COND Prop b A C) -> @COND Prop b B D.
Axiom thm_COND_ELIM_THM : forall {A : Type'} (x : A) (c : Prop) (P : A -> Prop) (y : A), (P (@COND A c x y)) = ((c -> P x) /\ ((~ c) -> P y)).
Axiom thm_SKOLEM_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (forall x : A, exists y : B, P x y) = (exists y : A -> B, forall x : A, P x (y x)).
Axiom thm_SKOLEM_THM_GEN : forall {A B : Type'}, forall P : A -> Prop, forall R' : A -> B -> Prop, (forall x : A, (P x) -> exists y : B, R' x y) = (exists f : A -> B, forall x : A, (P x) -> R' x (f x)).
Axiom thm_UNIQUE_SKOLEM_ALT : forall {A B : Type'}, forall P : A -> B -> Prop, (forall x : A, @ex1 B (fun y : B => P x y)) = (exists f : A -> B, forall x : A, forall y : B, (P x y) = ((f x) = y)).
Axiom thm_UNIQUE_SKOLEM_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (forall x : A, @ex1 B (fun y : B => P x y)) = (@ex1 (A -> B) (fun f : A -> B => forall x : A, P x (f x))).
Axiom thm_bool_INDUCT : forall P : Prop -> Prop, ((P False) /\ (P True)) -> forall x : Prop, P x.
Axiom thm_bool_RECURSION : forall {A : Type'}, forall a : A, forall b : A, exists f : Prop -> A, ((f False) = a) /\ ((f True) = b).
Axiom thm_o_DEF : forall {A B C : Type'}, forall f : B -> C, forall g : A -> B, (@o A B C f g) = (fun x : A => f (g x)).
Axiom thm_I_DEF : forall {A : Type'}, (@I A) = (fun x : A => x).
Axiom thm_o_THM : forall {A B C : Type'}, forall f : B -> C, forall g : A -> B, forall x : A, (@o A B C f g x) = (f (g x)).
Axiom thm_o_ASSOC : forall {A B C D : Type'}, forall f : C -> D, forall g : B -> C, forall h : A -> B, (@o A C D f (@o A B C g h)) = (@o A B D (@o B C D f g) h).
Axiom thm_I_THM : forall {A : Type'}, forall x : A, (@I A x) = x.
Axiom thm_I_O_ID : forall {A B : Type'}, forall f : A -> B, ((@o A B B (@I B) f) = f) /\ ((@o A A B f (@I A)) = f).
Axiom thm_EXISTS_ONE_REP : exists b : Prop, b.
Axiom thm_one_DEF : tt = (@ε unit (fun x : unit => True)).
Axiom thm_one : forall v : unit, v = tt.
Axiom thm_one_axiom : forall {A : Type'}, forall f : A -> unit, forall g : A -> unit, f = g.
Axiom thm_one_INDUCT : forall P : unit -> Prop, (P tt) -> forall x : unit, P x.
Axiom thm_one_RECURSION : forall {A : Type'}, forall e : A, exists fn : unit -> A, (fn tt) = e.
Axiom thm_one_Axiom : forall {A : Type'}, forall e : A, @ex1 (unit -> A) (fun fn : unit -> A => (fn tt) = e).
Axiom thm_FORALL_ONE_THM : forall (P : unit -> Prop), (forall x : unit, P x) = (P tt).
Axiom thm_EXISTS_ONE_THM : forall (P : unit -> Prop), (exists x : unit, P x) = (P tt).
Axiom thm_ETA_ONE : forall {A : Type'}, forall f : unit -> A, (fun x : unit => f tt) = f.
Axiom thm_LET_DEF : forall {A B : Type'}, forall f : A -> B, forall x : A, (@LET A B f x) = (f x).
Axiom thm_LET_END_DEF : forall {A : Type'}, forall t : A, (@LET_END A t) = t.
Axiom thm_GABS_DEF : forall {A : Type'}, forall P : A -> Prop, (@ε A P) = (@ε A P).
Axiom thm_GEQ_DEF : forall {A : Type'}, forall a : A, forall b : A, (@eq A a b) = (a = b).
Axiom thm__SEQPATTERN : forall {A B : Type'}, (@_SEQPATTERN A B) = (fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x)).
Axiom thm__UNGUARDED_PATTERN : and = (fun p : Prop => fun r : Prop => p /\ r).
Axiom thm__GUARDED_PATTERN : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Axiom thm__MATCH : forall {A B : Type'}, (@_MATCH A B) = (fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False))).
Axiom thm__FUNCTION : forall {A B : Type'}, (@_FUNCTION A B) = (fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False))).
Axiom thm_mk_pair_def : forall {A B : Type'}, forall x : A, forall y : B, (@mk_pair A B x y) = (fun a : A => fun b : B => (a = x) /\ (b = y)).
Axiom thm_PAIR_EXISTS_THM : forall {A B : Type'}, exists x : A -> B -> Prop, exists a : A, exists b : B, x = (@mk_pair A B a b).
Axiom thm_REP_ABS_PAIR : forall {A B : Type'}, forall x : A, forall y : B, (@REP_prod A B (@ABS_prod A B (@mk_pair A B x y))) = (@mk_pair A B x y).
Axiom thm_COMMA_DEF : forall {A B : Type'}, forall x : A, forall y : B, (@pair A B x y) = (@ABS_prod A B (@mk_pair A B x y)).
Axiom thm_FST_DEF : forall {A B : Type'}, forall p : prod A B, (@fst A B p) = (@ε A (fun x : A => exists y : B, p = (@pair A B x y))).
Axiom thm_SND_DEF : forall {A B : Type'}, forall p : prod A B, (@snd A B p) = (@ε B (fun y : B => exists x : A, p = (@pair A B x y))).
Axiom thm_PAIR_EQ : forall {A B : Type'}, forall x : A, forall y : B, forall a : A, forall b : B, ((@pair A B x y) = (@pair A B a b)) = ((x = a) /\ (y = b)).
Axiom thm_PAIR_SURJECTIVE : forall {A B : Type'}, forall p : prod A B, exists x : A, exists y : B, p = (@pair A B x y).
Axiom thm_FST : forall {A B : Type'}, forall x : A, forall y : B, (@fst A B (@pair A B x y)) = x.
Axiom thm_SND : forall {A B : Type'}, forall x : A, forall y : B, (@snd A B (@pair A B x y)) = y.
Axiom thm_PAIR : forall {A B : Type'}, forall x : prod A B, (@pair A B (@fst A B x) (@snd A B x)) = x.
Axiom thm_pair_INDUCT : forall {A B : Type'}, forall P : (prod A B) -> Prop, (forall x : A, forall y : B, P (@pair A B x y)) -> forall p : prod A B, P p.
Axiom thm_pair_RECURSION : forall {A B C : Type'}, forall PAIR' : A -> B -> C, exists fn : (prod A B) -> C, forall a0 : A, forall a1 : B, (fn (@pair A B a0 a1)) = (PAIR' a0 a1).
Axiom thm_CURRY_DEF : forall {A B C : Type'}, forall f : (prod A B) -> C, forall x : A, forall y : B, (@CURRY A B C f x y) = (f (@pair A B x y)).
Axiom thm_UNCURRY_DEF : forall {A B C : Type'}, forall f : A -> B -> C, forall x : A, forall y : B, (@UNCURRY A B C f (@pair A B x y)) = (f x y).
Axiom thm_PASSOC_DEF : forall {A B C D : Type'}, forall f : (prod (prod A B) C) -> D, forall x : A, forall y : B, forall z : C, (@PASSOC A B C D f (@pair A (prod B C) x (@pair B C y z))) = (f (@pair (prod A B) C (@pair A B x y) z)).
Axiom thm_FORALL_PAIR_THM : forall {A B : Type'}, forall P : (prod A B) -> Prop, (forall p : prod A B, P p) = (forall p1 : A, forall p2 : B, P (@pair A B p1 p2)).
Axiom thm_EXISTS_PAIR_THM : forall {A B : Type'}, forall P : (prod A B) -> Prop, (exists p : prod A B, P p) = (exists p1 : A, exists p2 : B, P (@pair A B p1 p2)).
Axiom thm_LAMBDA_PAIR_THM : forall {A B C : Type'}, forall t : (prod A B) -> C, (fun p : prod A B => t p) = (@ε ((prod A B) -> C) (fun f : (prod A B) -> C => forall x : A, forall y : B, @eq C (f (@pair A B x y)) (t (@pair A B x y)))).
Axiom thm_LAMBDA_PAIR : forall {A B C : Type'}, forall f : A -> B -> C, (@ε ((prod A B) -> C) (fun f' : (prod A B) -> C => forall x : A, forall y : B, @eq C (f' (@pair A B x y)) (f x y))) = (fun p : prod A B => f (@fst A B p) (@snd A B p)).
Axiom thm_LAMBDA_TRIPLE_THM : forall {A B C D : Type'}, forall f : (prod A (prod B C)) -> D, (fun t : prod A (prod B C) => f t) = (@ε ((prod A (prod B C)) -> D) (fun f' : (prod A (prod B C)) -> D => forall x : A, forall y : B, forall z : C, @eq D (f' (@pair A (prod B C) x (@pair B C y z))) (f (@pair A (prod B C) x (@pair B C y z))))).
Axiom thm_LAMBDA_TRIPLE : forall {A B C D : Type'}, forall f : A -> B -> C -> D, (@ε ((prod A (prod B C)) -> D) (fun f' : (prod A (prod B C)) -> D => forall x : A, forall y : B, forall z : C, @eq D (f' (@pair A (prod B C) x (@pair B C y z))) (f x y z))) = (fun t : prod A (prod B C) => f (@fst A (prod B C) t) (@fst B C (@snd A (prod B C) t)) (@snd B C (@snd A (prod B C) t))).
Axiom thm_FORALL_UNCURRY : forall {A B C : Type'}, forall P : (A -> B -> C) -> Prop, (forall f : A -> B -> C, P f) = (forall f : (prod A B) -> C, P (fun a : A => fun b : B => f (@pair A B a b))).
Axiom thm_EXISTS_UNCURRY : forall {A B C : Type'}, forall P : (A -> B -> C) -> Prop, (exists f : A -> B -> C, P f) = (exists f : (prod A B) -> C, P (fun a : A => fun b : B => f (@pair A B a b))).
Axiom thm_EXISTS_CURRY : forall {A B C : Type'}, forall P : ((prod A B) -> C) -> Prop, (exists f : (prod A B) -> C, P f) = (exists f : A -> B -> C, P (@ε ((prod A B) -> C) (fun f' : (prod A B) -> C => forall a : A, forall b : B, @eq C (f' (@pair A B a b)) (f a b)))).
Axiom thm_FORALL_CURRY : forall {A B C : Type'}, forall P : ((prod A B) -> C) -> Prop, (forall f : (prod A B) -> C, P f) = (forall f : A -> B -> C, P (@ε ((prod A B) -> C) (fun f' : (prod A B) -> C => forall a : A, forall b : B, @eq C (f' (@pair A B a b)) (f a b)))).
Axiom thm_FORALL_UNPAIR_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (forall x : A, forall y : B, P x y) = (forall z : prod A B, P (@fst A B z) (@snd A B z)).
Axiom thm_EXISTS_UNPAIR_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (exists x : A, exists y : B, P x y) = (exists z : prod A B, P (@fst A B z) (@snd A B z)).
Axiom thm_FORALL_PAIR_FUN_THM : forall {A B C : Type'}, forall P : (A -> prod B C) -> Prop, (forall f : A -> prod B C, P f) = (forall g : A -> B, forall h : A -> C, P (fun a : A => @pair B C (g a) (h a))).
Axiom thm_EXISTS_PAIR_FUN_THM : forall {A B C : Type'}, forall P : (A -> prod B C) -> Prop, (exists f : A -> prod B C, P f) = (exists g : A -> B, exists h : A -> C, P (fun a : A => @pair B C (g a) (h a))).
Axiom thm_FORALL_UNPAIR_FUN_THM : forall {A B C : Type'}, forall P : (A -> B) -> (A -> C) -> Prop, (forall f : A -> B, forall g : A -> C, P f g) = (forall h : A -> prod B C, P (@o A (prod B C) B (@fst B C) h) (@o A (prod B C) C (@snd B C) h)).
Axiom thm_EXISTS_UNPAIR_FUN_THM : forall {A B C : Type'}, forall P : (A -> B) -> (A -> C) -> Prop, (exists f : A -> B, exists g : A -> C, P f g) = (exists h : A -> prod B C, P (@o A (prod B C) B (@fst B C) h) (@o A (prod B C) C (@snd B C) h)).
Axiom thm_EXISTS_SWAP_FUN_THM : forall {A B C : Type'}, forall P : (A -> B -> C) -> Prop, (exists f : A -> B -> C, P f) = (exists f : B -> A -> C, P (fun a : A => fun b : B => f b a)).
Axiom thm_FORALL_PAIRED_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (Logic.all (@ε ((prod A B) -> Prop) (fun f : (prod A B) -> Prop => forall x : A, forall y : B, @eq Prop (f (@pair A B x y)) (P x y)))) = (forall x : A, forall y : B, P x y).
Axiom thm_EXISTS_PAIRED_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (ex (@ε ((prod A B) -> Prop) (fun f : (prod A B) -> Prop => forall x : A, forall y : B, @eq Prop (f (@pair A B x y)) (P x y)))) = (exists x : A, exists y : B, P x y).
Axiom thm_FORALL_TRIPLED_THM : forall {A B C : Type'}, forall P : A -> B -> C -> Prop, (Logic.all (@ε ((prod A (prod B C)) -> Prop) (fun f : (prod A (prod B C)) -> Prop => forall x : A, forall y : B, forall z : C, @eq Prop (f (@pair A (prod B C) x (@pair B C y z))) (P x y z)))) = (forall x : A, forall y : B, forall z : C, P x y z).
Axiom thm_EXISTS_TRIPLED_THM : forall {A B C : Type'}, forall P : A -> B -> C -> Prop, (ex (@ε ((prod A (prod B C)) -> Prop) (fun f : (prod A (prod B C)) -> Prop => forall x : A, forall y : B, forall z : C, @eq Prop (f (@pair A (prod B C) x (@pair B C y z))) (P x y z)))) = (exists x : A, exists y : B, exists z : C, P x y z).
Axiom thm_CHOICE_UNPAIR_THM : forall {A B : Type'}, forall P : A -> B -> Prop, (@ε (prod A B) (@ε ((prod A B) -> Prop) (fun f : (prod A B) -> Prop => forall x : A, forall y : B, @eq Prop (f (@pair A B x y)) (P x y)))) = (@ε (prod A B) (fun p : prod A B => P (@fst A B p) (@snd A B p))).
Axiom thm_CHOICE_PAIRED_THM : forall {A B : Type'}, forall P : A -> B -> Prop, forall Q : (prod A B) -> Prop, ((exists x : A, exists y : B, P x y) /\ (forall x : A, forall y : B, (P x y) -> Q (@pair A B x y))) -> Q (@ε (prod A B) (@ε ((prod A B) -> Prop) (fun f : (prod A B) -> Prop => forall x : A, forall y : B, @eq Prop (f (@pair A B x y)) (P x y)))).
Axiom thm_ONE_ONE : forall {A B : Type'}, forall f : A -> B, (@ONE_ONE A B f) = (forall x1 : A, forall x2 : A, ((f x1) = (f x2)) -> x1 = x2).
Axiom thm_ONTO : forall {A B : Type'}, forall f : A -> B, (@ONTO A B f) = (forall y : B, exists x : A, y = (f x)).
Axiom thm_INFINITY_AX : exists f : ind -> ind, (@ONE_ONE ind ind f) /\ (~ (@ONTO ind ind f)).
Axiom thm_IND_SUC_0_EXISTS : exists f : ind -> ind, exists z : ind, (forall x1 : ind, forall x2 : ind, ((f x1) = (f x2)) = (x1 = x2)) /\ (forall x : ind, ~ ((f x) = z)).
Axiom thm_NUM_REP_RULES : (NUM_REP IND_0) /\ (forall i : ind, (NUM_REP i) -> NUM_REP (IND_SUC i)).
Axiom thm_NUM_REP_CASES : forall a : ind, (NUM_REP a) = ((a = IND_0) \/ (exists i : ind, (a = (IND_SUC i)) /\ (NUM_REP i))).
Axiom thm_NUM_REP_INDUCT : forall NUM_REP' : ind -> Prop, ((NUM_REP' IND_0) /\ (forall i : ind, (NUM_REP' i) -> NUM_REP' (IND_SUC i))) -> forall a : ind, (NUM_REP a) -> NUM_REP' a.
Axiom thm_ZERO_DEF : O = (mk_num IND_0).
Axiom thm_SUC_DEF : forall n : nat, (S n) = (mk_num (IND_SUC (dest_num n))).
Axiom thm_SUC_INJ : forall m : nat, forall n : nat, ((S m) = (S n)) = (m = n).
Axiom thm_NOT_SUC : forall n : nat, ~ ((S n) = (NUMERAL O)).
Axiom thm_num_INDUCTION : forall P : nat -> Prop, ((P (NUMERAL O)) /\ (forall n : nat, (P n) -> P (S n))) -> forall n : nat, P n.
Axiom thm_num_Axiom : forall {A : Type'}, forall e : A, forall f : A -> nat -> A, @ex1 (nat -> A) (fun fn : nat -> A => ((fn (NUMERAL O)) = e) /\ (forall n : nat, (fn (S n)) = (f (fn n) n))).
Axiom thm_num_CASES : forall m : nat, (m = (NUMERAL O)) \/ (exists n : nat, m = (S n)).
Axiom thm_PRE : ((predn (NUMERAL O)) = (NUMERAL O)) /\ (forall n : nat, (predn (S n)) = n).
Axiom thm_ADD : (forall n : nat, (addn (NUMERAL O) n) = n) /\ (forall m : nat, forall n : nat, (addn (S m) n) = (S (addn m n))).
Axiom thm_ADD_0 : forall m : nat, (addn m (NUMERAL O)) = m.
Axiom thm_ADD_SUC : forall m : nat, forall n : nat, (addn m (S n)) = (S (addn m n)).
Axiom thm_ADD_CLAUSES : (forall n : nat, (addn (NUMERAL O) n) = n) /\ ((forall m : nat, (addn m (NUMERAL O)) = m) /\ ((forall m : nat, forall n : nat, (addn (S m) n) = (S (addn m n))) /\ (forall m : nat, forall n : nat, (addn m (S n)) = (S (addn m n))))).
Axiom thm_ADD_SYM : forall m : nat, forall n : nat, (addn m n) = (addn n m).
Axiom thm_ADD_ASSOC : forall m : nat, forall n : nat, forall p : nat, (addn m (addn n p)) = (addn (addn m n) p).
Axiom thm_ADD_AC : forall (n : nat) (m : nat) (p : nat), ((addn m n) = (addn n m)) /\ (((addn (addn m n) p) = (addn m (addn n p))) /\ ((addn m (addn n p)) = (addn n (addn m p)))).
Axiom thm_ADD_EQ_0 : forall m : nat, forall n : nat, ((addn m n) = (NUMERAL O)) = ((m = (NUMERAL O)) /\ (n = (NUMERAL O))).
Axiom thm_EQ_ADD_LCANCEL : forall m : nat, forall n : nat, forall p : nat, ((addn m n) = (addn m p)) = (n = p).
Axiom thm_EQ_ADD_RCANCEL : forall m : nat, forall n : nat, forall p : nat, ((addn m p) = (addn n p)) = (m = n).
Axiom thm_EQ_ADD_LCANCEL_0 : forall m : nat, forall n : nat, ((addn m n) = m) = (n = (NUMERAL O)).
Axiom thm_EQ_ADD_RCANCEL_0 : forall m : nat, forall n : nat, ((addn m n) = n) = (m = (NUMERAL O)).
Axiom thm_BIT0 : forall n : nat, (BIT0 n) = (addn n n).
Axiom thm_BIT1 : forall n : nat, (BIT1 n) = (S (addn n n)).
Axiom thm_BIT0_THM : forall n : nat, (NUMERAL (BIT0 n)) = (addn (NUMERAL n) (NUMERAL n)).
Axiom thm_BIT1_THM : forall n : nat, (NUMERAL (BIT1 n)) = (S (addn (NUMERAL n) (NUMERAL n))).
Axiom thm_ONE : (NUMERAL (BIT1 O)) = (S (NUMERAL O)).
Axiom thm_TWO : (NUMERAL (BIT0 (BIT1 O))) = (S (NUMERAL (BIT1 O))).
Axiom thm_ADD1 : forall m : nat, (S m) = (addn m (NUMERAL (BIT1 O))).
Axiom thm_MULT : (forall n : nat, (muln (NUMERAL O) n) = (NUMERAL O)) /\ (forall m : nat, forall n : nat, (muln (S m) n) = (addn (muln m n) n)).
Axiom thm_MULT_0 : forall m : nat, (muln m (NUMERAL O)) = (NUMERAL O).
Axiom thm_MULT_SUC : forall m : nat, forall n : nat, (muln m (S n)) = (addn m (muln m n)).
Axiom thm_MULT_CLAUSES : (forall n : nat, (muln (NUMERAL O) n) = (NUMERAL O)) /\ ((forall m : nat, (muln m (NUMERAL O)) = (NUMERAL O)) /\ ((forall n : nat, (muln (NUMERAL (BIT1 O)) n) = n) /\ ((forall m : nat, (muln m (NUMERAL (BIT1 O))) = m) /\ ((forall m : nat, forall n : nat, (muln (S m) n) = (addn (muln m n) n)) /\ (forall m : nat, forall n : nat, (muln m (S n)) = (addn m (muln m n))))))).
Axiom thm_MULT_SYM : forall m : nat, forall n : nat, (muln m n) = (muln n m).
Axiom thm_LEFT_ADD_DISTRIB : forall m : nat, forall n : nat, forall p : nat, (muln m (addn n p)) = (addn (muln m n) (muln m p)).
Axiom thm_RIGHT_ADD_DISTRIB : forall m : nat, forall n : nat, forall p : nat, (muln (addn m n) p) = (addn (muln m p) (muln n p)).
Axiom thm_MULT_ASSOC : forall m : nat, forall n : nat, forall p : nat, (muln m (muln n p)) = (muln (muln m n) p).
Axiom thm_MULT_AC : forall (n : nat) (m : nat) (p : nat), ((muln m n) = (muln n m)) /\ (((muln (muln m n) p) = (muln m (muln n p))) /\ ((muln m (muln n p)) = (muln n (muln m p)))).
Axiom thm_MULT_EQ_0 : forall m : nat, forall n : nat, ((muln m n) = (NUMERAL O)) = ((m = (NUMERAL O)) \/ (n = (NUMERAL O))).
Axiom thm_EQ_MULT_LCANCEL : forall m : nat, forall n : nat, forall p : nat, ((muln m n) = (muln m p)) = ((m = (NUMERAL O)) \/ (n = p)).
Axiom thm_EQ_MULT_RCANCEL : forall m : nat, forall n : nat, forall p : nat, ((muln m p) = (muln n p)) = ((m = n) \/ (p = (NUMERAL O))).
Axiom thm_MULT_2 : forall n : nat, (muln (NUMERAL (BIT0 (BIT1 O))) n) = (addn n n).
Axiom thm_MULT_EQ_1 : forall m : nat, forall n : nat, ((muln m n) = (NUMERAL (BIT1 O))) = ((m = (NUMERAL (BIT1 O))) /\ (n = (NUMERAL (BIT1 O)))).
Axiom thm_EXP : (forall m : nat, (expn m (NUMERAL O)) = (NUMERAL (BIT1 O))) /\ (forall m : nat, forall n : nat, (expn m (S n)) = (muln m (expn m n))).
Axiom thm_EXP_EQ_0 : forall m : nat, forall n : nat, ((expn m n) = (NUMERAL O)) = ((m = (NUMERAL O)) /\ (~ (n = (NUMERAL O)))).
Axiom thm_EXP_EQ_1 : forall x : nat, forall n : nat, ((expn x n) = (NUMERAL (BIT1 O))) = ((x = (NUMERAL (BIT1 O))) \/ (n = (NUMERAL O))).
Axiom thm_EXP_ZERO : forall n : nat, (expn (NUMERAL O) n) = (@COND nat (n = (NUMERAL O)) (NUMERAL (BIT1 O)) (NUMERAL O)).
Axiom thm_EXP_ADD : forall m : nat, forall n : nat, forall p : nat, (expn m (addn n p)) = (muln (expn m n) (expn m p)).
Axiom thm_EXP_ONE : forall n : nat, (expn (NUMERAL (BIT1 O)) n) = (NUMERAL (BIT1 O)).
Axiom thm_EXP_1 : forall n : nat, (expn n (NUMERAL (BIT1 O))) = n.
Axiom thm_EXP_2 : forall n : nat, (expn n (NUMERAL (BIT0 (BIT1 O)))) = (muln n n).
Axiom thm_MULT_EXP : forall p : nat, forall m : nat, forall n : nat, (expn (muln m n) p) = (muln (expn m p) (expn n p)).
Axiom thm_EXP_MULT : forall m : nat, forall n : nat, forall p : nat, (expn m (muln n p)) = (expn (expn m n) p).
Axiom thm_EXP_EXP : forall x : nat, forall m : nat, forall n : nat, (expn (expn x m) n) = (expn x (muln m n)).
Axiom thm_LE : (forall m : nat, (leqn m (NUMERAL O)) = (m = (NUMERAL O))) /\ (forall m : nat, forall n : nat, (leqn m (S n)) = ((m = (S n)) \/ (leqn m n))).
Axiom thm_LT : (forall m : nat, (ltn m (NUMERAL O)) = False) /\ (forall m : nat, forall n : nat, (ltn m (S n)) = ((m = n) \/ (ltn m n))).
Axiom thm_GE : forall n : nat, forall m : nat, (geqn m n) = (leqn n m).
Axiom thm_GT : forall n : nat, forall m : nat, (gtn m n) = (ltn n m).
Axiom thm_MAX : forall m : nat, forall n : nat, (maxn m n) = (@COND nat (leqn m n) n m).
Axiom thm_MIN : forall m : nat, forall n : nat, (minn m n) = (@COND nat (leqn m n) m n).
Axiom thm_LE_SUC_LT : forall m : nat, forall n : nat, (leqn (S m) n) = (ltn m n).
Axiom thm_LT_SUC_LE : forall m : nat, forall n : nat, (ltn m (S n)) = (leqn m n).
Axiom thm_LE_SUC : forall m : nat, forall n : nat, (leqn (S m) (S n)) = (leqn m n).
Axiom thm_LT_SUC : forall m : nat, forall n : nat, (ltn (S m) (S n)) = (ltn m n).
Axiom thm_LE_0 : forall n : nat, leqn (NUMERAL O) n.
Axiom thm_LT_0 : forall n : nat, ltn (NUMERAL O) (S n).
Axiom thm_LE_REFL : forall n : nat, leqn n n.
Axiom thm_LT_REFL : forall n : nat, ~ (ltn n n).
Axiom thm_LT_IMP_NE : forall m : nat, forall n : nat, (ltn m n) -> ~ (m = n).
Axiom thm_LE_ANTISYM : forall m : nat, forall n : nat, ((leqn m n) /\ (leqn n m)) = (m = n).
Axiom thm_LT_ANTISYM : forall m : nat, forall n : nat, ~ ((ltn m n) /\ (ltn n m)).
Axiom thm_LET_ANTISYM : forall m : nat, forall n : nat, ~ ((leqn m n) /\ (ltn n m)).
Axiom thm_LTE_ANTISYM : forall m : nat, forall n : nat, ~ ((ltn m n) /\ (leqn n m)).
Axiom thm_LE_TRANS : forall m : nat, forall n : nat, forall p : nat, ((leqn m n) /\ (leqn n p)) -> leqn m p.
Axiom thm_LT_TRANS : forall m : nat, forall n : nat, forall p : nat, ((ltn m n) /\ (ltn n p)) -> ltn m p.
Axiom thm_LET_TRANS : forall m : nat, forall n : nat, forall p : nat, ((leqn m n) /\ (ltn n p)) -> ltn m p.
Axiom thm_LTE_TRANS : forall m : nat, forall n : nat, forall p : nat, ((ltn m n) /\ (leqn n p)) -> ltn m p.
Axiom thm_LE_CASES : forall m : nat, forall n : nat, (leqn m n) \/ (leqn n m).
Axiom thm_LT_CASES : forall m : nat, forall n : nat, (ltn m n) \/ ((ltn n m) \/ (m = n)).
Axiom thm_LET_CASES : forall m : nat, forall n : nat, (leqn m n) \/ (ltn n m).
Axiom thm_LTE_CASES : forall m : nat, forall n : nat, (ltn m n) \/ (leqn n m).
Axiom thm_LE_LT : forall m : nat, forall n : nat, (leqn m n) = ((ltn m n) \/ (m = n)).
Axiom thm_LT_LE : forall m : nat, forall n : nat, (ltn m n) = ((leqn m n) /\ (~ (m = n))).
Axiom thm_NOT_LE : forall m : nat, forall n : nat, (~ (leqn m n)) = (ltn n m).
Axiom thm_NOT_LT : forall m : nat, forall n : nat, (~ (ltn m n)) = (leqn n m).
Axiom thm_LT_IMP_LE : forall m : nat, forall n : nat, (ltn m n) -> leqn m n.
Axiom thm_EQ_IMP_LE : forall m : nat, forall n : nat, (m = n) -> leqn m n.
Axiom thm_LT_NZ : forall n : nat, (ltn (NUMERAL O) n) = (~ (n = (NUMERAL O))).
Axiom thm_LE_1 : (forall n : nat, (~ (n = (NUMERAL O))) -> ltn (NUMERAL O) n) /\ ((forall n : nat, (~ (n = (NUMERAL O))) -> leqn (NUMERAL (BIT1 O)) n) /\ ((forall n : nat, (ltn (NUMERAL O) n) -> ~ (n = (NUMERAL O))) /\ ((forall n : nat, (ltn (NUMERAL O) n) -> leqn (NUMERAL (BIT1 O)) n) /\ ((forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> ltn (NUMERAL O) n) /\ (forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> ~ (n = (NUMERAL O))))))).
Axiom thm_LE_EXISTS : forall m : nat, forall n : nat, (leqn m n) = (exists d : nat, n = (addn m d)).
Axiom thm_LT_EXISTS : forall m : nat, forall n : nat, (ltn m n) = (exists d : nat, n = (addn m (S d))).
Axiom thm_LE_ADD : forall m : nat, forall n : nat, leqn m (addn m n).
Axiom thm_LE_ADDR : forall m : nat, forall n : nat, leqn n (addn m n).
Axiom thm_LT_ADD : forall m : nat, forall n : nat, (ltn m (addn m n)) = (ltn (NUMERAL O) n).
Axiom thm_LT_ADDR : forall m : nat, forall n : nat, (ltn n (addn m n)) = (ltn (NUMERAL O) m).
Axiom thm_LE_ADD_LCANCEL : forall m : nat, forall n : nat, forall p : nat, (leqn (addn m n) (addn m p)) = (leqn n p).
Axiom thm_LE_ADD_RCANCEL : forall m : nat, forall n : nat, forall p : nat, (leqn (addn m p) (addn n p)) = (leqn m n).
Axiom thm_LT_ADD_LCANCEL : forall m : nat, forall n : nat, forall p : nat, (ltn (addn m n) (addn m p)) = (ltn n p).
Axiom thm_LT_ADD_RCANCEL : forall m : nat, forall n : nat, forall p : nat, (ltn (addn m p) (addn n p)) = (ltn m n).
Axiom thm_LE_ADD2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((leqn m p) /\ (leqn n q)) -> leqn (addn m n) (addn p q).
Axiom thm_LET_ADD2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((leqn m p) /\ (ltn n q)) -> ltn (addn m n) (addn p q).
Axiom thm_LTE_ADD2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((ltn m p) /\ (leqn n q)) -> ltn (addn m n) (addn p q).
Axiom thm_LT_ADD2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((ltn m p) /\ (ltn n q)) -> ltn (addn m n) (addn p q).
Axiom thm_LT_MULT : forall m : nat, forall n : nat, (ltn (NUMERAL O) (muln m n)) = ((ltn (NUMERAL O) m) /\ (ltn (NUMERAL O) n)).
Axiom thm_LE_MULT2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((leqn m n) /\ (leqn p q)) -> leqn (muln m p) (muln n q).
Axiom thm_LT_LMULT : forall m : nat, forall n : nat, forall p : nat, ((~ (m = (NUMERAL O))) /\ (ltn n p)) -> ltn (muln m n) (muln m p).
Axiom thm_LE_MULT_LCANCEL : forall m : nat, forall n : nat, forall p : nat, (leqn (muln m n) (muln m p)) = ((m = (NUMERAL O)) \/ (leqn n p)).
Axiom thm_LE_MULT_RCANCEL : forall m : nat, forall n : nat, forall p : nat, (leqn (muln m p) (muln n p)) = ((leqn m n) \/ (p = (NUMERAL O))).
Axiom thm_LT_MULT_LCANCEL : forall m : nat, forall n : nat, forall p : nat, (ltn (muln m n) (muln m p)) = ((~ (m = (NUMERAL O))) /\ (ltn n p)).
Axiom thm_LT_MULT_RCANCEL : forall m : nat, forall n : nat, forall p : nat, (ltn (muln m p) (muln n p)) = ((ltn m n) /\ (~ (p = (NUMERAL O)))).
Axiom thm_LT_MULT2 : forall m : nat, forall n : nat, forall p : nat, forall q : nat, ((ltn m n) /\ (ltn p q)) -> ltn (muln m p) (muln n q).
Axiom thm_LE_SQUARE_REFL : forall n : nat, leqn n (muln n n).
Axiom thm_LT_POW2_REFL : forall n : nat, ltn n (expn (NUMERAL (BIT0 (BIT1 O))) n).
Axiom thm_WLOG_LE : forall (P : nat -> nat -> Prop), ((forall m : nat, forall n : nat, (P m n) = (P n m)) /\ (forall m : nat, forall n : nat, (leqn m n) -> P m n)) -> forall m : nat, forall n : nat, P m n.
Axiom thm_WLOG_LT : forall (P : nat -> nat -> Prop), ((forall m : nat, P m m) /\ ((forall m : nat, forall n : nat, (P m n) = (P n m)) /\ (forall m : nat, forall n : nat, (ltn m n) -> P m n))) -> forall m : nat, forall y : nat, P m y.
Axiom thm_WLOG_LE_3 : forall P : nat -> nat -> nat -> Prop, ((forall x : nat, forall y : nat, forall z : nat, (P x y z) -> (P y x z) /\ (P x z y)) /\ (forall x : nat, forall y : nat, forall z : nat, ((leqn x y) /\ (leqn y z)) -> P x y z)) -> forall x : nat, forall y : nat, forall z : nat, P x y z.
Axiom thm_num_WF : forall P : nat -> Prop, (forall n : nat, (forall m : nat, (ltn m n) -> P m) -> P n) -> forall n : nat, P n.
Axiom thm_num_WOP : forall P : nat -> Prop, (exists n : nat, P n) = (exists n : nat, (P n) /\ (forall m : nat, (ltn m n) -> ~ (P m))).
Axiom thm_num_MAX : forall P : nat -> Prop, ((exists x : nat, P x) /\ (exists M : nat, forall x : nat, (P x) -> leqn x M)) = (exists m : nat, (P m) /\ (forall x : nat, (P x) -> leqn x m)).
Axiom thm_LE_INDUCT : forall P : nat -> nat -> Prop, ((forall m : nat, P m m) /\ (forall m : nat, forall n : nat, ((leqn m n) /\ (P m n)) -> P m (S n))) -> forall m : nat, forall n : nat, (leqn m n) -> P m n.
Axiom thm_num_INDUCTION_DOWN : forall P : nat -> Prop, forall m : nat, ((forall n : nat, (leqn m n) -> P n) /\ (forall n : nat, ((ltn n m) /\ (P (addn n (NUMERAL (BIT1 O))))) -> P n)) -> forall n : nat, P n.
Axiom thm_EVEN : ((even (NUMERAL O)) = True) /\ (forall n : nat, (even (S n)) = (~ (even n))).
Axiom thm_ODD : ((oddn (NUMERAL O)) = False) /\ (forall n : nat, (oddn (S n)) = (~ (oddn n))).
Axiom thm_NOT_EVEN : forall n : nat, (~ (even n)) = (oddn n).
Axiom thm_NOT_ODD : forall n : nat, (~ (oddn n)) = (even n).
Axiom thm_EVEN_OR_ODD : forall n : nat, (even n) \/ (oddn n).
Axiom thm_EVEN_AND_ODD : forall n : nat, ~ ((even n) /\ (oddn n)).
Axiom thm_EVEN_ADD : forall m : nat, forall n : nat, (even (addn m n)) = ((even m) = (even n)).
Axiom thm_EVEN_MULT : forall m : nat, forall n : nat, (even (muln m n)) = ((even m) \/ (even n)).
Axiom thm_EVEN_EXP : forall m : nat, forall n : nat, (even (expn m n)) = ((even m) /\ (~ (n = (NUMERAL O)))).
Axiom thm_ODD_ADD : forall m : nat, forall n : nat, (oddn (addn m n)) = (~ ((oddn m) = (oddn n))).
Axiom thm_ODD_MULT : forall m : nat, forall n : nat, (oddn (muln m n)) = ((oddn m) /\ (oddn n)).
Axiom thm_ODD_EXP : forall m : nat, forall n : nat, (oddn (expn m n)) = ((oddn m) \/ (n = (NUMERAL O))).
Axiom thm_EVEN_DOUBLE : forall n : nat, even (muln (NUMERAL (BIT0 (BIT1 O))) n).
Axiom thm_ODD_DOUBLE : forall n : nat, oddn (S (muln (NUMERAL (BIT0 (BIT1 O))) n)).
Axiom thm_EVEN_EXISTS_LEMMA : forall n : nat, ((even n) -> exists m : nat, n = (muln (NUMERAL (BIT0 (BIT1 O))) m)) /\ ((~ (even n)) -> exists m : nat, n = (S (muln (NUMERAL (BIT0 (BIT1 O))) m))).
Axiom thm_EVEN_EXISTS : forall n : nat, (even n) = (exists m : nat, n = (muln (NUMERAL (BIT0 (BIT1 O))) m)).
Axiom thm_ODD_EXISTS : forall n : nat, (oddn n) = (exists m : nat, n = (S (muln (NUMERAL (BIT0 (BIT1 O))) m))).
Axiom thm_EVEN_ODD_DECOMPOSITION : forall n : nat, (exists k : nat, exists m : nat, (oddn m) /\ (n = (muln (expn (NUMERAL (BIT0 (BIT1 O))) k) m))) = (~ (n = (NUMERAL O))).
Axiom thm_SUB : (forall m : nat, (subn m (NUMERAL O)) = m) /\ (forall m : nat, forall n : nat, (subn m (S n)) = (predn (subn m n))).
Axiom thm_SUB_0 : forall m : nat, ((subn (NUMERAL O) m) = (NUMERAL O)) /\ ((subn m (NUMERAL O)) = m).
Axiom thm_SUB_PRESUC : forall m : nat, forall n : nat, (predn (subn (S m) n)) = (subn m n).
Axiom thm_SUB_SUC : forall m : nat, forall n : nat, (subn (S m) (S n)) = (subn m n).
Axiom thm_SUB_REFL : forall n : nat, (subn n n) = (NUMERAL O).
Axiom thm_ADD_SUB : forall m : nat, forall n : nat, (subn (addn m n) n) = m.
Axiom thm_ADD_SUB2 : forall m : nat, forall n : nat, (subn (addn m n) m) = n.
Axiom thm_SUB_EQ_0 : forall m : nat, forall n : nat, ((subn m n) = (NUMERAL O)) = (leqn m n).
Axiom thm_ADD_SUBR2 : forall m : nat, forall n : nat, (subn m (addn m n)) = (NUMERAL O).
Axiom thm_ADD_SUBR : forall m : nat, forall n : nat, (subn n (addn m n)) = (NUMERAL O).
Axiom thm_SUB_ADD : forall m : nat, forall n : nat, (leqn n m) -> (addn (subn m n) n) = m.
Axiom thm_SUB_ADD_LCANCEL : forall m : nat, forall n : nat, forall p : nat, (subn (addn m n) (addn m p)) = (subn n p).
Axiom thm_SUB_ADD_RCANCEL : forall m : nat, forall n : nat, forall p : nat, (subn (addn m p) (addn n p)) = (subn m n).
Axiom thm_LEFT_SUB_DISTRIB : forall m : nat, forall n : nat, forall p : nat, (muln m (subn n p)) = (subn (muln m n) (muln m p)).
Axiom thm_RIGHT_SUB_DISTRIB : forall m : nat, forall n : nat, forall p : nat, (muln (subn m n) p) = (subn (muln m p) (muln n p)).
Axiom thm_EVEN_SUB : forall m : nat, forall n : nat, (even (subn m n)) = ((leqn m n) \/ ((even m) = (even n))).
Axiom thm_ODD_SUB : forall m : nat, forall n : nat, (oddn (subn m n)) = ((ltn n m) /\ (~ ((oddn m) = (oddn n)))).
Axiom thm_FACT : ((factorial (NUMERAL O)) = (NUMERAL (BIT1 O))) /\ (forall n : nat, (factorial (S n)) = (muln (S n) (factorial n))).
Axiom thm_FACT_LT : forall n : nat, ltn (NUMERAL O) (factorial n).
Axiom thm_FACT_LE : forall n : nat, leqn (NUMERAL (BIT1 O)) (factorial n).
Axiom thm_FACT_NZ : forall n : nat, ~ ((factorial n) = (NUMERAL O)).
Axiom thm_FACT_MONO : forall m : nat, forall n : nat, (leqn m n) -> leqn (factorial m) (factorial n).
Axiom thm_EXP_LT_0 : forall n : nat, forall x : nat, (ltn (NUMERAL O) (expn x n)) = ((~ (x = (NUMERAL O))) \/ (n = (NUMERAL O))).
Axiom thm_LT_EXP : forall x : nat, forall m : nat, forall n : nat, (ltn (expn x m) (expn x n)) = (((leqn (NUMERAL (BIT0 (BIT1 O))) x) /\ (ltn m n)) \/ ((x = (NUMERAL O)) /\ ((~ (m = (NUMERAL O))) /\ (n = (NUMERAL O))))).
Axiom thm_LE_EXP : forall x : nat, forall m : nat, forall n : nat, (leqn (expn x m) (expn x n)) = (@COND Prop (x = (NUMERAL O)) ((m = (NUMERAL O)) -> n = (NUMERAL O)) ((x = (NUMERAL (BIT1 O))) \/ (leqn m n))).
Axiom thm_EQ_EXP : forall x : nat, forall m : nat, forall n : nat, ((expn x m) = (expn x n)) = (@COND Prop (x = (NUMERAL O)) ((m = (NUMERAL O)) = (n = (NUMERAL O))) ((x = (NUMERAL (BIT1 O))) \/ (m = n))).
Axiom thm_EXP_MONO_LE_IMP : forall x : nat, forall y : nat, forall n : nat, (leqn x y) -> leqn (expn x n) (expn y n).
Axiom thm_EXP_MONO_LT_IMP : forall x : nat, forall y : nat, forall n : nat, ((ltn x y) /\ (~ (n = (NUMERAL O)))) -> ltn (expn x n) (expn y n).
Axiom thm_EXP_MONO_LE : forall x : nat, forall y : nat, forall n : nat, (leqn (expn x n) (expn y n)) = ((leqn x y) \/ (n = (NUMERAL O))).
Axiom thm_EXP_MONO_LT : forall x : nat, forall y : nat, forall n : nat, (ltn (expn x n) (expn y n)) = ((ltn x y) /\ (~ (n = (NUMERAL O)))).
Axiom thm_EXP_MONO_EQ : forall x : nat, forall y : nat, forall n : nat, ((expn x n) = (expn y n)) = ((x = y) \/ (n = (NUMERAL O))).
Axiom thm_DIVMOD_EXIST : forall m : nat, forall n : nat, (~ (n = (NUMERAL O))) -> exists q : nat, exists r : nat, (m = (addn (muln q n) r)) /\ (ltn r n).
Axiom thm_DIVMOD_EXIST_0 : forall m : nat, forall n : nat, exists q : nat, exists r : nat, @COND Prop (n = (NUMERAL O)) ((q = (NUMERAL O)) /\ (r = m)) ((m = (addn (muln q n) r)) /\ (ltn r n)).
Axiom thm_DIVISION : forall m : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (m = (addn (muln (divn m n) n) (modn m n))) /\ (ltn (modn m n) n).
Axiom thm_DIV_ZERO : forall n : nat, (divn n (NUMERAL O)) = (NUMERAL O).
Axiom thm_MOD_ZERO : forall n : nat, (modn n (NUMERAL O)) = n.
Axiom thm_DIVISION_SIMP : (forall m : nat, forall n : nat, (addn (muln (divn m n) n) (modn m n)) = m) /\ (forall m : nat, forall n : nat, (addn (muln n (divn m n)) (modn m n)) = m).
Axiom thm_EQ_DIVMOD : forall p : nat, forall m : nat, forall n : nat, (((divn m p) = (divn n p)) /\ ((modn m p) = (modn n p))) = (m = n).
Axiom thm_MOD_LT_EQ : forall m : nat, forall n : nat, (ltn (modn m n) n) = (~ (n = (NUMERAL O))).
Axiom thm_MOD_LT_EQ_LT : forall m : nat, forall n : nat, (ltn (modn m n) n) = (ltn (NUMERAL O) n).
Axiom thm_DIVMOD_UNIQ_LEMMA : forall m : nat, forall n : nat, forall q1 : nat, forall r1 : nat, forall q2 : nat, forall r2 : nat, (((m = (addn (muln q1 n) r1)) /\ (ltn r1 n)) /\ ((m = (addn (muln q2 n) r2)) /\ (ltn r2 n))) -> (q1 = q2) /\ (r1 = r2).
Axiom thm_DIVMOD_UNIQ : forall m : nat, forall n : nat, forall q : nat, forall r : nat, ((m = (addn (muln q n) r)) /\ (ltn r n)) -> ((divn m n) = q) /\ ((modn m n) = r).
Axiom thm_MOD_UNIQ : forall m : nat, forall n : nat, forall q : nat, forall r : nat, ((m = (addn (muln q n) r)) /\ (ltn r n)) -> (modn m n) = r.
Axiom thm_DIV_UNIQ : forall m : nat, forall n : nat, forall q : nat, forall r : nat, ((m = (addn (muln q n) r)) /\ (ltn r n)) -> (divn m n) = q.
Axiom thm_MOD_0 : forall n : nat, (modn (NUMERAL O) n) = (NUMERAL O).
Axiom thm_DIV_0 : forall n : nat, (divn (NUMERAL O) n) = (NUMERAL O).
Axiom thm_MOD_MULT : forall m : nat, forall n : nat, (modn (muln m n) m) = (NUMERAL O).
Axiom thm_DIV_MULT : forall m : nat, forall n : nat, (~ (m = (NUMERAL O))) -> (divn (muln m n) m) = n.
Axiom thm_MOD_LT : forall m : nat, forall n : nat, (ltn m n) -> (modn m n) = m.
Axiom thm_MOD_EQ_SELF : forall m : nat, forall n : nat, ((modn m n) = m) = ((n = (NUMERAL O)) \/ (ltn m n)).
Axiom thm_MOD_CASES : forall n : nat, forall p : nat, (ltn n (muln (NUMERAL (BIT0 (BIT1 O))) p)) -> (modn n p) = (@COND nat (ltn n p) n (subn n p)).
Axiom thm_MOD_ADD_CASES : forall m : nat, forall n : nat, forall p : nat, ((ltn m p) /\ (ltn n p)) -> (modn (addn m n) p) = (@COND nat (ltn (addn m n) p) (addn m n) (subn (addn m n) p)).
Axiom thm_MOD_EQ : forall m : nat, forall n : nat, forall p : nat, forall q : nat, (m = (addn n (muln q p))) -> (modn m p) = (modn n p).
Axiom thm_DIV_LE : forall m : nat, forall n : nat, leqn (divn m n) m.
Axiom thm_DIV_MUL_LE : forall m : nat, forall n : nat, leqn (muln n (divn m n)) m.
Axiom thm_MOD_LE_TWICE : forall m : nat, forall n : nat, ((ltn (NUMERAL O) m) /\ (leqn m n)) -> leqn (muln (NUMERAL (BIT0 (BIT1 O))) (modn n m)) n.
Axiom thm_MOD_1 : forall n : nat, (modn n (NUMERAL (BIT1 O))) = (NUMERAL O).
Axiom thm_DIV_1 : forall n : nat, (divn n (NUMERAL (BIT1 O))) = n.
Axiom thm_DIV_LT : forall m : nat, forall n : nat, (ltn m n) -> (divn m n) = (NUMERAL O).
Axiom thm_MOD_MOD : forall m : nat, forall n : nat, forall p : nat, (modn (modn m (muln n p)) n) = (modn m n).
Axiom thm_MOD_MOD_REFL : forall m : nat, forall n : nat, (modn (modn m n) n) = (modn m n).
Axiom thm_MOD_MOD_LE : forall m : nat, forall n : nat, forall p : nat, ((~ (n = (NUMERAL O))) /\ (leqn n p)) -> (modn (modn m n) p) = (modn m n).
Axiom thm_MOD_EVEN_2 : forall m : nat, forall n : nat, (even n) -> (modn (modn m n) (NUMERAL (BIT0 (BIT1 O)))) = (modn m (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_DIV_MULT2 : forall m : nat, forall n : nat, forall p : nat, (~ (m = (NUMERAL O))) -> (divn (muln m n) (muln m p)) = (divn n p).
Axiom thm_MOD_MULT2 : forall m : nat, forall n : nat, forall p : nat, (modn (muln m n) (muln m p)) = (muln m (modn n p)).
Axiom thm_MOD_EXISTS : forall m : nat, forall n : nat, (exists q : nat, m = (muln n q)) = (@COND Prop (n = (NUMERAL O)) (m = (NUMERAL O)) ((modn m n) = (NUMERAL O))).
Axiom thm_LE_RDIV_EQ : forall a : nat, forall b : nat, forall n : nat, (~ (a = (NUMERAL O))) -> (leqn n (divn b a)) = (leqn (muln a n) b).
Axiom thm_RDIV_LT_EQ : forall a : nat, forall b : nat, forall n : nat, (~ (a = (NUMERAL O))) -> (ltn (divn b a) n) = (ltn b (muln a n)).
Axiom thm_LE_LDIV_EQ : forall a : nat, forall b : nat, forall n : nat, (~ (a = (NUMERAL O))) -> (leqn (divn b a) n) = (ltn b (muln a (addn n (NUMERAL (BIT1 O))))).
Axiom thm_LDIV_LT_EQ : forall a : nat, forall b : nat, forall n : nat, (~ (a = (NUMERAL O))) -> (ltn n (divn b a)) = (leqn (muln a (addn n (NUMERAL (BIT1 O)))) b).
Axiom thm_LE_LDIV : forall a : nat, forall b : nat, forall n : nat, ((~ (a = (NUMERAL O))) /\ (leqn b (muln a n))) -> leqn (divn b a) n.
Axiom thm_DIV_MONO : forall m : nat, forall n : nat, forall p : nat, (leqn m n) -> leqn (divn m p) (divn n p).
Axiom thm_DIV_MONO_LT : forall m : nat, forall n : nat, forall p : nat, ((~ (p = (NUMERAL O))) /\ (leqn (addn m p) n)) -> ltn (divn m p) (divn n p).
Axiom thm_DIV_EQ_0 : forall m : nat, forall n : nat, (~ (n = (NUMERAL O))) -> ((divn m n) = (NUMERAL O)) = (ltn m n).
Axiom thm_MOD_DIV_EQ_0 : forall m : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (divn (modn m n) n) = (NUMERAL O).
Axiom thm_MOD_EQ_0 : forall m : nat, forall n : nat, ((modn m n) = (NUMERAL O)) = (exists q : nat, m = (muln q n)).
Axiom thm_DIV_EQ_SELF : forall m : nat, forall n : nat, ((divn m n) = m) = ((m = (NUMERAL O)) \/ (n = (NUMERAL (BIT1 O)))).
Axiom thm_MOD_REFL : forall n : nat, (modn n n) = (NUMERAL O).
Axiom thm_EVEN_MOD : forall n : nat, (even n) = ((modn n (NUMERAL (BIT0 (BIT1 O)))) = (NUMERAL O)).
Axiom thm_ODD_MOD : forall n : nat, (oddn n) = ((modn n (NUMERAL (BIT0 (BIT1 O)))) = (NUMERAL (BIT1 O))).
Axiom thm_MOD_2_CASES : forall n : nat, (modn n (NUMERAL (BIT0 (BIT1 O)))) = (@COND nat (even n) (NUMERAL O) (NUMERAL (BIT1 O))).
Axiom thm_EVEN_MOD_EVEN : forall m : nat, forall n : nat, (even n) -> (even (modn m n)) = (even m).
Axiom thm_ODD_MOD_EVEN : forall m : nat, forall n : nat, (even n) -> (oddn (modn m n)) = (oddn m).
Axiom thm_HALF_DOUBLE : (forall n : nat, (divn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT0 (BIT1 O)))) = n) /\ (forall n : nat, (divn (muln n (NUMERAL (BIT0 (BIT1 O)))) (NUMERAL (BIT0 (BIT1 O)))) = n).
Axiom thm_DOUBLE_HALF : (forall n : nat, (even n) -> (muln (NUMERAL (BIT0 (BIT1 O))) (divn n (NUMERAL (BIT0 (BIT1 O))))) = n) /\ (forall n : nat, (even n) -> (muln (divn n (NUMERAL (BIT0 (BIT1 O)))) (NUMERAL (BIT0 (BIT1 O)))) = n).
Axiom thm_MOD_MULT_RMOD : forall m : nat, forall n : nat, forall p : nat, (modn (muln m (modn p n)) n) = (modn (muln m p) n).
Axiom thm_MOD_MULT_LMOD : forall m : nat, forall n : nat, forall p : nat, (modn (muln (modn m n) p) n) = (modn (muln m p) n).
Axiom thm_MOD_MULT_MOD2 : forall m : nat, forall n : nat, forall p : nat, (modn (muln (modn m n) (modn p n)) n) = (modn (muln m p) n).
Axiom thm_MOD_EXP_MOD : forall m : nat, forall n : nat, forall p : nat, (modn (expn (modn m n) p) n) = (modn (expn m p) n).
Axiom thm_MOD_MULT_ADD : (forall m : nat, forall n : nat, forall p : nat, (modn (addn (muln m n) p) n) = (modn p n)) /\ ((forall m : nat, forall n : nat, forall p : nat, (modn (addn (muln n m) p) n) = (modn p n)) /\ ((forall m : nat, forall n : nat, forall p : nat, (modn (addn p (muln m n)) n) = (modn p n)) /\ (forall m : nat, forall n : nat, forall p : nat, (modn (addn p (muln n m)) n) = (modn p n)))).
Axiom thm_DIV_MULT_ADD : (forall a : nat, forall b : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (divn (addn (muln a n) b) n) = (addn a (divn b n))) /\ ((forall a : nat, forall b : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (divn (addn (muln n a) b) n) = (addn a (divn b n))) /\ ((forall a : nat, forall b : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (divn (addn b (muln a n)) n) = (addn (divn b n) a)) /\ (forall a : nat, forall b : nat, forall n : nat, (~ (n = (NUMERAL O))) -> (divn (addn b (muln n a)) n) = (addn (divn b n) a)))).
Axiom thm_MOD_ADD_MOD : forall a : nat, forall b : nat, forall n : nat, (modn (addn (modn a n) (modn b n)) n) = (modn (addn a b) n).
Axiom thm_DIV_ADD_MOD : forall a : nat, forall b : nat, forall n : nat, (~ (n = (NUMERAL O))) -> ((modn (addn a b) n) = (addn (modn a n) (modn b n))) = ((divn (addn a b) n) = (addn (divn a n) (divn b n))).
Axiom thm_MOD_ADD_EQ_EQ : forall n : nat, forall x : nat, forall y : nat, ((modn (addn x y) n) = (addn (modn x n) (modn y n))) = ((n = (NUMERAL O)) \/ (ltn (addn (modn x n) (modn y n)) n)).
Axiom thm_DIV_ADD_EQ_EQ : forall n : nat, forall x : nat, forall y : nat, ((divn (addn x y) n) = (addn (divn x n) (divn y n))) = ((n = (NUMERAL O)) \/ (ltn (addn (modn x n) (modn y n)) n)).
Axiom thm_DIV_ADD_EQ : forall n : nat, forall x : nat, forall y : nat, (ltn (addn (modn x n) (modn y n)) n) -> (divn (addn x y) n) = (addn (divn x n) (divn y n)).
Axiom thm_MOD_ADD_EQ : forall n : nat, forall x : nat, forall y : nat, (ltn (addn (modn x n) (modn y n)) n) -> (modn (addn x y) n) = (addn (modn x n) (modn y n)).
Axiom thm_DIV_REFL : forall n : nat, (~ (n = (NUMERAL O))) -> (divn n n) = (NUMERAL (BIT1 O)).
Axiom thm_MOD_LE : forall m : nat, forall n : nat, leqn (modn m n) m.
Axiom thm_DIV_MONO2 : forall m : nat, forall n : nat, forall p : nat, ((~ (p = (NUMERAL O))) /\ (leqn p m)) -> leqn (divn n m) (divn n p).
Axiom thm_DIV_LE_EXCLUSION : forall a : nat, forall b : nat, forall c : nat, forall d : nat, ((~ (b = (NUMERAL O))) /\ (ltn (muln b c) (muln (addn a (NUMERAL (BIT1 O))) d))) -> leqn (divn c d) (divn a b).
Axiom thm_DIV_EQ_EXCLUSION : forall a : nat, forall b : nat, forall c : nat, forall d : nat, ((ltn (muln b c) (muln (addn a (NUMERAL (BIT1 O))) d)) /\ (ltn (muln a d) (muln (addn c (NUMERAL (BIT1 O))) b))) -> (divn a b) = (divn c d).
Axiom thm_MULT_DIV_LE : forall m : nat, forall n : nat, forall p : nat, leqn (muln m (divn n p)) (divn (muln m n) p).
Axiom thm_DIV_DIV : forall m : nat, forall n : nat, forall p : nat, (divn (divn m n) p) = (divn m (muln n p)).
Axiom thm_DIV_MOD : forall m : nat, forall n : nat, forall p : nat, (modn (divn m n) p) = (divn (modn m (muln n p)) n).
Axiom thm_MOD_MULT_MOD : forall m : nat, forall n : nat, forall p : nat, (modn m (muln n p)) = (addn (muln n (modn (divn m n) p)) (modn m n)).
Axiom thm_MOD_MOD_EXP_MIN : forall x : nat, forall p : nat, forall m : nat, forall n : nat, (modn (modn x (expn p m)) (expn p n)) = (modn x (expn p (minn m n))).
Axiom thm_MOD_EXP : forall m : nat, forall n : nat, forall p : nat, (~ (m = (NUMERAL O))) -> (modn (expn m n) (expn m p)) = (@COND nat ((leqn p n) \/ (m = (NUMERAL (BIT1 O)))) (NUMERAL O) (expn m n)).
Axiom thm_DIV_EXP : forall m : nat, forall n : nat, forall p : nat, (~ (m = (NUMERAL O))) -> (divn (expn m n) (expn m p)) = (@COND nat (leqn p n) (expn m (subn n p)) (@COND nat (m = (NUMERAL (BIT1 O))) (NUMERAL (BIT1 O)) (NUMERAL O))).
Axiom thm_FORALL_LT_MOD_THM : forall P : nat -> Prop, forall n : nat, (forall a : nat, (ltn a n) -> P a) = ((n = (NUMERAL O)) \/ (forall a : nat, P (modn a n))).
Axiom thm_FORALL_MOD_THM : forall P : nat -> Prop, forall n : nat, (~ (n = (NUMERAL O))) -> (forall a : nat, P (modn a n)) = (forall a : nat, (ltn a n) -> P a).
Axiom thm_EXISTS_LT_MOD_THM : forall P : nat -> Prop, forall n : nat, (exists a : nat, (ltn a n) /\ (P a)) = ((~ (n = (NUMERAL O))) /\ (exists a : nat, P (modn a n))).
Axiom thm_EXISTS_MOD_THM : forall P : nat -> Prop, forall n : nat, (~ (n = (NUMERAL O))) -> (exists a : nat, P (modn a n)) = (exists a : nat, (ltn a n) /\ (P a)).
Axiom thm_PRE_ELIM_THM : forall (n : nat) (P : nat -> Prop), (P (predn n)) = (forall m : nat, ((n = (S m)) \/ ((m = (NUMERAL O)) /\ (n = (NUMERAL O)))) -> P m).
Axiom thm_SUB_ELIM_THM : forall (a : nat) (b : nat) (P : nat -> Prop), (P (subn a b)) = (forall d : nat, ((a = (addn b d)) \/ ((ltn a b) /\ (d = (NUMERAL O)))) -> P d).
Axiom thm_DIVMOD_ELIM_THM : forall (m : nat) (n : nat) (P : nat -> nat -> Prop), (P (divn m n) (modn m n)) = (forall q : nat, forall r : nat, (((n = (NUMERAL O)) /\ ((q = (NUMERAL O)) /\ (r = m))) \/ ((m = (addn (muln q n) r)) /\ (ltn r n))) -> P q r).
Axiom thm_minimal : forall P : nat -> Prop, (minimal P) = (@ε nat (fun n : nat => (P n) /\ (forall m : nat, (ltn m n) -> ~ (P m)))).
Axiom thm_MINIMAL : forall P : nat -> Prop, (exists n : nat, P n) = ((P (minimal P)) /\ (forall m : nat, (ltn m (minimal P)) -> ~ (P m))).
Axiom thm_MINIMAL_UNIQUE : forall P : nat -> Prop, forall n : nat, ((P n) /\ (forall m : nat, (ltn m n) -> ~ (P m))) -> (minimal P) = n.
Axiom thm_LE_MINIMAL : forall P : nat -> Prop, forall n : nat, (exists r : nat, P r) -> (leqn n (minimal P)) = (forall i : nat, (P i) -> leqn n i).
Axiom thm_MINIMAL_LE : forall P : nat -> Prop, forall n : nat, (exists r : nat, P r) -> (leqn (minimal P) n) = (exists i : nat, (leqn i n) /\ (P i)).
Axiom thm_MINIMAL_UBOUND : forall P : nat -> Prop, forall n : nat, (P n) -> leqn (minimal P) n.
Axiom thm_MINIMAL_LBOUND : forall P : nat -> Prop, forall n : nat, ((exists r : nat, P r) /\ (forall m : nat, (ltn m n) -> ~ (P m))) -> leqn n (minimal P).
Axiom thm_MINIMAL_MONO : forall P : nat -> Prop, forall Q : nat -> Prop, ((exists n : nat, P n) /\ (forall n : nat, (P n) -> Q n)) -> leqn (minimal Q) (minimal P).
Axiom thm_TRANSITIVE_STEPWISE_LT_EQ : forall R' : nat -> nat -> Prop, (forall x : nat, forall y : nat, forall z : nat, ((R' x y) /\ (R' y z)) -> R' x z) -> (forall m : nat, forall n : nat, (ltn m n) -> R' m n) = (forall n : nat, R' n (S n)).
Axiom thm_TRANSITIVE_STEPWISE_LT : forall R' : nat -> nat -> Prop, ((forall x : nat, forall y : nat, forall z : nat, ((R' x y) /\ (R' y z)) -> R' x z) /\ (forall n : nat, R' n (S n))) -> forall m : nat, forall n : nat, (ltn m n) -> R' m n.
Axiom thm_TRANSITIVE_STEPWISE_LE_EQ : forall R' : nat -> nat -> Prop, ((forall x : nat, R' x x) /\ (forall x : nat, forall y : nat, forall z : nat, ((R' x y) /\ (R' y z)) -> R' x z)) -> (forall m : nat, forall n : nat, (leqn m n) -> R' m n) = (forall n : nat, R' n (S n)).
Axiom thm_TRANSITIVE_STEPWISE_LE : forall R' : nat -> nat -> Prop, ((forall x : nat, R' x x) /\ ((forall x : nat, forall y : nat, forall z : nat, ((R' x y) /\ (R' y z)) -> R' x z) /\ (forall n : nat, R' n (S n)))) -> forall m : nat, forall n : nat, (leqn m n) -> R' m n.
Axiom thm_DEPENDENT_CHOICE_FIXED : forall {A : Type'}, forall P : nat -> A -> Prop, forall R' : nat -> A -> A -> Prop, forall a : A, ((P (NUMERAL O) a) /\ (forall n : nat, forall x : A, (P n x) -> exists y : A, (P (S n) y) /\ (R' n x y))) -> exists f : nat -> A, ((f (NUMERAL O)) = a) /\ ((forall n : nat, P n (f n)) /\ (forall n : nat, R' n (f n) (f (S n)))).
Axiom thm_DEPENDENT_CHOICE : forall {A : Type'}, forall P : nat -> A -> Prop, forall R' : nat -> A -> A -> Prop, ((exists a : A, P (NUMERAL O) a) /\ (forall n : nat, forall x : A, (P n x) -> exists y : A, (P (S n) y) /\ (R' n x y))) -> exists f : nat -> A, (forall n : nat, P n (f n)) /\ (forall n : nat, R' n (f n) (f (S n))).
Axiom thm_WF : forall {A : Type'}, forall lt2' : A -> A -> Prop, (@well_founded A lt2') = (forall P : A -> Prop, (exists x : A, P x) -> exists x : A, (P x) /\ (forall y : A, (lt2' y x) -> ~ (P y))).
Axiom thm_WF_EQ : forall {A : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') = (forall P : A -> Prop, (exists x : A, P x) = (exists x : A, (P x) /\ (forall y : A, (lt2' y x) -> ~ (P y)))).
Axiom thm_WF_IND : forall {A : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') = (forall P : A -> Prop, (forall x : A, (forall y : A, (lt2' y x) -> P y) -> P x) -> forall x : A, P x).
Axiom thm_WF_DCHAIN : forall {A : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') = (~ (exists s : nat -> A, forall n : nat, lt2' (s (S n)) (s n))).
Axiom thm_WF_DHAIN_TRANSITIVE : forall {A : Type'}, forall lt2' : A -> A -> Prop, (forall x : A, forall y : A, forall z : A, ((lt2' x y) /\ (lt2' y z)) -> lt2' x z) -> (@well_founded A lt2') = (~ (exists s : nat -> A, forall i : nat, forall j : nat, (ltn i j) -> lt2' (s j) (s i))).
Axiom thm_WF_UREC : forall {A B : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') -> forall H : (A -> B) -> A -> B, (forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) -> forall f : A -> B, forall g : A -> B, ((forall x : A, (f x) = (H f x)) /\ (forall x : A, (g x) = (H g x))) -> f = g.
Axiom thm_WF_UREC_WF : forall {A : Type'} (lt2' : A -> A -> Prop), (forall H : (A -> Prop) -> A -> Prop, (forall f : A -> Prop, forall g : A -> Prop, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) -> forall f : A -> Prop, forall g : A -> Prop, ((forall x : A, (f x) = (H f x)) /\ (forall x : A, (g x) = (H g x))) -> f = g) -> @well_founded A lt2'.
Axiom thm_WF_REC_INVARIANT : forall {A B : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') -> forall H : (A -> B) -> A -> B, forall S' : A -> B -> Prop, (forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> ((f z) = (g z)) /\ (S' z (f z))) -> ((H f x) = (H g x)) /\ (S' x (H f x))) -> exists f : A -> B, forall x : A, (f x) = (H f x).
Axiom thm_WF_REC : forall {A B : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') -> forall H : (A -> B) -> A -> B, (forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) -> exists f : A -> B, forall x : A, (f x) = (H f x).
Axiom thm_WF_REC_WF : forall {A : Type'} (lt2' : A -> A -> Prop), (forall H : (A -> nat) -> A -> nat, (forall f : A -> nat, forall g : A -> nat, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) -> exists f : A -> nat, forall x : A, (f x) = (H f x)) -> @well_founded A lt2'.
Axiom thm_WF_EREC : forall {A B : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') -> forall H : (A -> B) -> A -> B, (forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) -> @ex1 (A -> B) (fun f : A -> B => forall x : A, (f x) = (H f x)).
Axiom thm_WF_REC_EXISTS : forall {A B : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') -> forall P : (A -> B) -> A -> B -> Prop, ((forall f : A -> B, forall g : A -> B, forall x : A, forall y : B, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (P f x y) = (P g x y)) /\ (forall f : A -> B, forall x : A, (forall z : A, (lt2' z x) -> P f z (f z)) -> exists y : B, P f x y)) -> exists f : A -> B, forall x : A, P f x (f x).
Axiom thm_WF_SUBSET : forall {A : Type'}, forall lt2' : A -> A -> Prop, forall lt3 : A -> A -> Prop, ((forall x : A, forall y : A, (lt2' x y) -> lt3 x y) /\ (@well_founded A lt3)) -> @well_founded A lt2'.
Axiom thm_WF_RESTRICT : forall {A : Type'}, forall lt2' : A -> A -> Prop, forall P : A -> Prop, (@well_founded A lt2') -> @well_founded A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (lt2' x y))).
Axiom thm_WF_MEASURE_GEN : forall {A B : Type'}, forall lt2' : B -> B -> Prop, forall m : A -> B, (@well_founded B lt2') -> @well_founded A (fun x : A => fun x' : A => lt2' (m x) (m x')).
Axiom thm_WF_LEX_DEPENDENT : forall {A B : Type'}, forall R' : A -> A -> Prop, forall S' : A -> B -> B -> Prop, ((@well_founded A R') /\ (forall a : A, @well_founded B (S' a))) -> @well_founded (prod A B) (@ε ((prod A B) -> (prod A B) -> Prop) (fun f : (prod A B) -> (prod A B) -> Prop => forall r1 : A, forall s1 : B, @eq ((prod A B) -> Prop) (f (@pair A B r1 s1)) (@ε ((prod A B) -> Prop) (fun f' : (prod A B) -> Prop => forall r2 : A, forall s2 : B, @eq Prop (f' (@pair A B r2 s2)) ((R' r1 r2) \/ ((r1 = r2) /\ (S' r1 s1 s2))))))).
Axiom thm_WF_LEX : forall {A B : Type'}, forall R' : A -> A -> Prop, forall S' : B -> B -> Prop, ((@well_founded A R') /\ (@well_founded B S')) -> @well_founded (prod A B) (@ε ((prod A B) -> (prod A B) -> Prop) (fun f : (prod A B) -> (prod A B) -> Prop => forall r1 : A, forall s1 : B, @eq ((prod A B) -> Prop) (f (@pair A B r1 s1)) (@ε ((prod A B) -> Prop) (fun f' : (prod A B) -> Prop => forall r2 : A, forall s2 : B, @eq Prop (f' (@pair A B r2 s2)) ((R' r1 r2) \/ ((r1 = r2) /\ (S' s1 s2))))))).
Axiom thm_WF_POINTWISE : forall {A B : Type'} (lt2' : A -> A -> Prop) (lt3 : B -> B -> Prop), ((@well_founded A lt2') /\ (@well_founded B lt3)) -> @well_founded (prod A B) (@ε ((prod A B) -> (prod A B) -> Prop) (fun f : (prod A B) -> (prod A B) -> Prop => forall x1 : A, forall y1 : B, @eq ((prod A B) -> Prop) (f (@pair A B x1 y1)) (@ε ((prod A B) -> Prop) (fun f' : (prod A B) -> Prop => forall x2 : A, forall y2 : B, @eq Prop (f' (@pair A B x2 y2)) ((lt2' x1 x2) /\ (lt3 y1 y2)))))).
Axiom thm_WF_num : @well_founded nat ltn.
Axiom thm_WF_REC_num : forall {A : Type'}, forall H : (nat -> A) -> nat -> A, (forall f : nat -> A, forall g : nat -> A, forall n : nat, (forall m : nat, (ltn m n) -> (f m) = (g m)) -> (H f n) = (H g n)) -> exists f : nat -> A, forall n : nat, (f n) = (H f n).
Axiom thm_MEASURE : forall {A : Type'}, forall m : A -> nat, (@MEASURE A m) = (fun x : A => fun y : A => ltn (m x) (m y)).
Axiom thm_WF_MEASURE : forall {A : Type'}, forall m : A -> nat, @well_founded A (@MEASURE A m).
Axiom thm_MEASURE_LE : forall {A : Type'} (a : A) (b : A), forall m : A -> nat, (forall y : A, (@MEASURE A m y a) -> @MEASURE A m y b) = (leqn (m a) (m b)).
Axiom thm_WF_ANTISYM : forall {A : Type'}, forall lt2' : A -> A -> Prop, forall x : A, forall y : A, (@well_founded A lt2') -> ~ ((lt2' x y) /\ (lt2' y x)).
Axiom thm_WF_REFL : forall {A : Type'} (lt2' : A -> A -> Prop), forall x : A, (@well_founded A lt2') -> ~ (lt2' x x).
Axiom thm_WF_FALSE : forall {A : Type'}, @well_founded A (fun x : A => fun y : A => False).
Axiom thm_MINIMAL_BAD_SEQUENCE : forall {A : Type'}, forall lt2' : A -> A -> Prop, forall bad : (nat -> A) -> Prop, ((@well_founded A lt2') /\ ((forall x : nat -> A, (~ (bad x)) -> exists n : nat, forall y : nat -> A, (forall k : nat, (ltn k n) -> (y k) = (x k)) -> ~ (bad y)) /\ (exists x : nat -> A, bad x))) -> exists y : nat -> A, (bad y) /\ (forall z : nat -> A, forall n : nat, ((bad z) /\ (forall k : nat, (ltn k n) -> (z k) = (y k))) -> ~ (lt2' (z n) (y n))).
Axiom thm_WF_REC_TAIL : forall {A B : Type'}, forall P : A -> Prop, forall g : A -> A, forall h : A -> B, exists f : A -> B, forall x : A, (f x) = (@COND B (P x) (f (g x)) (h x)).
Axiom thm_WF_REC_TAIL_GENERAL : forall {A B : Type'} (lt2' : A -> A -> Prop), forall P : (A -> B) -> A -> Prop, forall G : (A -> B) -> A -> A, forall H : (A -> B) -> A -> B, ((@well_founded A lt2') /\ ((forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> ((P f x) = (P g x)) /\ (((G f x) = (G g x)) /\ ((H f x) = (H g x)))) /\ ((forall f : A -> B, forall g : A -> B, forall x : A, (forall z : A, (lt2' z x) -> (f z) = (g z)) -> (H f x) = (H g x)) /\ (forall f : A -> B, forall x : A, forall y : A, ((P f x) /\ (lt2' y (G f x))) -> lt2' y x)))) -> exists f : A -> B, forall x : A, (f x) = (@COND B (P f x) (f (G f x)) (H f x)).
Axiom thm_ARITH_ZERO : ((NUMERAL (NUMERAL O)) = (NUMERAL O)) /\ ((BIT0 O) = O).
Axiom thm_BIT0_0 : (BIT0 (NUMERAL O)) = (NUMERAL O).
Axiom thm_BIT1_0 : (BIT1 (NUMERAL O)) = (NUMERAL (BIT1 O)).
Axiom thm_ARITH_SUC : (forall n : nat, (S (NUMERAL n)) = (NUMERAL (S n))) /\ (((S O) = (BIT1 O)) /\ ((forall n : nat, (S (BIT0 n)) = (BIT1 n)) /\ (forall n : nat, (S (BIT1 n)) = (BIT0 (S n))))).
Axiom thm_ARITH_PRE : (forall n : nat, (predn (NUMERAL n)) = (NUMERAL (predn n))) /\ (((predn O) = O) /\ ((forall n : nat, (predn (BIT0 n)) = (@COND nat (n = O) O (BIT1 (predn n)))) /\ (forall n : nat, (predn (BIT1 n)) = (BIT0 n)))).
Axiom thm_ARITH_ADD : (forall m : nat, forall n : nat, (addn (NUMERAL m) (NUMERAL n)) = (NUMERAL (addn m n))) /\ (((addn O O) = O) /\ ((forall n : nat, (addn O (BIT0 n)) = (BIT0 n)) /\ ((forall n : nat, (addn O (BIT1 n)) = (BIT1 n)) /\ ((forall n : nat, (addn (BIT0 n) O) = (BIT0 n)) /\ ((forall n : nat, (addn (BIT1 n) O) = (BIT1 n)) /\ ((forall m : nat, forall n : nat, (addn (BIT0 m) (BIT0 n)) = (BIT0 (addn m n))) /\ ((forall m : nat, forall n : nat, (addn (BIT0 m) (BIT1 n)) = (BIT1 (addn m n))) /\ ((forall m : nat, forall n : nat, (addn (BIT1 m) (BIT0 n)) = (BIT1 (addn m n))) /\ (forall m : nat, forall n : nat, (addn (BIT1 m) (BIT1 n)) = (BIT0 (S (addn m n)))))))))))).
Axiom thm_ARITH_MULT : (forall m : nat, forall n : nat, (muln (NUMERAL m) (NUMERAL n)) = (NUMERAL (muln m n))) /\ (((muln O O) = O) /\ ((forall n : nat, (muln O (BIT0 n)) = O) /\ ((forall n : nat, (muln O (BIT1 n)) = O) /\ ((forall n : nat, (muln (BIT0 n) O) = O) /\ ((forall n : nat, (muln (BIT1 n) O) = O) /\ ((forall m : nat, forall n : nat, (muln (BIT0 m) (BIT0 n)) = (BIT0 (BIT0 (muln m n)))) /\ ((forall m : nat, forall n : nat, (muln (BIT0 m) (BIT1 n)) = (addn (BIT0 m) (BIT0 (BIT0 (muln m n))))) /\ ((forall m : nat, forall n : nat, (muln (BIT1 m) (BIT0 n)) = (addn (BIT0 n) (BIT0 (BIT0 (muln m n))))) /\ (forall m : nat, forall n : nat, (muln (BIT1 m) (BIT1 n)) = (addn (BIT1 m) (addn (BIT0 n) (BIT0 (BIT0 (muln m n)))))))))))))).
Axiom thm_ARITH_EXP : (forall m : nat, forall n : nat, (expn (NUMERAL m) (NUMERAL n)) = (NUMERAL (expn m n))) /\ (((expn O O) = (BIT1 O)) /\ ((forall m : nat, (expn (BIT0 m) O) = (BIT1 O)) /\ ((forall m : nat, (expn (BIT1 m) O) = (BIT1 O)) /\ ((forall n : nat, (expn O (BIT0 n)) = (muln (expn O n) (expn O n))) /\ ((forall m : nat, forall n : nat, (expn (BIT0 m) (BIT0 n)) = (muln (expn (BIT0 m) n) (expn (BIT0 m) n))) /\ ((forall m : nat, forall n : nat, (expn (BIT1 m) (BIT0 n)) = (muln (expn (BIT1 m) n) (expn (BIT1 m) n))) /\ ((forall n : nat, (expn O (BIT1 n)) = O) /\ ((forall m : nat, forall n : nat, (expn (BIT0 m) (BIT1 n)) = (muln (BIT0 m) (muln (expn (BIT0 m) n) (expn (BIT0 m) n)))) /\ (forall m : nat, forall n : nat, (expn (BIT1 m) (BIT1 n)) = (muln (BIT1 m) (muln (expn (BIT1 m) n) (expn (BIT1 m) n)))))))))))).
Axiom thm_ARITH_EVEN : (forall n : nat, (even (NUMERAL n)) = (even n)) /\ (((even O) = True) /\ ((forall n : nat, (even (BIT0 n)) = True) /\ (forall n : nat, (even (BIT1 n)) = False))).
Axiom thm_ARITH_ODD : (forall n : nat, (oddn (NUMERAL n)) = (oddn n)) /\ (((oddn O) = False) /\ ((forall n : nat, (oddn (BIT0 n)) = False) /\ (forall n : nat, (oddn (BIT1 n)) = True))).
Axiom thm_ARITH_LE : (forall m : nat, forall n : nat, (leqn (NUMERAL m) (NUMERAL n)) = (leqn m n)) /\ (((leqn O O) = True) /\ ((forall n : nat, (leqn (BIT0 n) O) = (leqn n O)) /\ ((forall n : nat, (leqn (BIT1 n) O) = False) /\ ((forall n : nat, (leqn O (BIT0 n)) = True) /\ ((forall n : nat, (leqn O (BIT1 n)) = True) /\ ((forall m : nat, forall n : nat, (leqn (BIT0 m) (BIT0 n)) = (leqn m n)) /\ ((forall m : nat, forall n : nat, (leqn (BIT0 m) (BIT1 n)) = (leqn m n)) /\ ((forall m : nat, forall n : nat, (leqn (BIT1 m) (BIT0 n)) = (ltn m n)) /\ (forall m : nat, forall n : nat, (leqn (BIT1 m) (BIT1 n)) = (leqn m n)))))))))).
Axiom thm_ARITH_LT : (forall m : nat, forall n : nat, (ltn (NUMERAL m) (NUMERAL n)) = (ltn m n)) /\ (((ltn O O) = False) /\ ((forall n : nat, (ltn (BIT0 n) O) = False) /\ ((forall n : nat, (ltn (BIT1 n) O) = False) /\ ((forall n : nat, (ltn O (BIT0 n)) = (ltn O n)) /\ ((forall n : nat, (ltn O (BIT1 n)) = True) /\ ((forall m : nat, forall n : nat, (ltn (BIT0 m) (BIT0 n)) = (ltn m n)) /\ ((forall m : nat, forall n : nat, (ltn (BIT0 m) (BIT1 n)) = (leqn m n)) /\ ((forall m : nat, forall n : nat, (ltn (BIT1 m) (BIT0 n)) = (ltn m n)) /\ (forall m : nat, forall n : nat, (ltn (BIT1 m) (BIT1 n)) = (ltn m n)))))))))).
Axiom thm_ARITH_EQ : (forall m : nat, forall n : nat, ((NUMERAL m) = (NUMERAL n)) = (m = n)) /\ (((O = O) = True) /\ ((forall n : nat, ((BIT0 n) = O) = (n = O)) /\ ((forall n : nat, ((BIT1 n) = O) = False) /\ ((forall n : nat, (O = (BIT0 n)) = (O = n)) /\ ((forall n : nat, (O = (BIT1 n)) = False) /\ ((forall m : nat, forall n : nat, ((BIT0 m) = (BIT0 n)) = (m = n)) /\ ((forall m : nat, forall n : nat, ((BIT0 m) = (BIT1 n)) = False) /\ ((forall m : nat, forall n : nat, ((BIT1 m) = (BIT0 n)) = False) /\ (forall m : nat, forall n : nat, ((BIT1 m) = (BIT1 n)) = (m = n)))))))))).
Axiom thm_ARITH_SUB : (forall m : nat, forall n : nat, (subn (NUMERAL m) (NUMERAL n)) = (NUMERAL (subn m n))) /\ (((subn O O) = O) /\ ((forall n : nat, (subn O (BIT0 n)) = O) /\ ((forall n : nat, (subn O (BIT1 n)) = O) /\ ((forall n : nat, (subn (BIT0 n) O) = (BIT0 n)) /\ ((forall n : nat, (subn (BIT1 n) O) = (BIT1 n)) /\ ((forall m : nat, forall n : nat, (subn (BIT0 m) (BIT0 n)) = (BIT0 (subn m n))) /\ ((forall m : nat, forall n : nat, (subn (BIT0 m) (BIT1 n)) = (predn (BIT0 (subn m n)))) /\ ((forall m : nat, forall n : nat, (subn (BIT1 m) (BIT0 n)) = (@COND nat (leqn n m) (BIT1 (subn m n)) O)) /\ (forall m : nat, forall n : nat, (subn (BIT1 m) (BIT1 n)) = (BIT0 (subn m n))))))))))).
Axiom thm_EXP_2_NE_0 : forall n : nat, ~ ((expn (NUMERAL (BIT0 (BIT1 O))) n) = (NUMERAL O)).
Axiom thm_INJ_INVERSE2 : forall {A B C : Type'}, forall P : A -> B -> C, (forall x1 : A, forall y1 : B, forall x2 : A, forall y2 : B, ((P x1 y1) = (P x2 y2)) = ((x1 = x2) /\ (y1 = y2))) -> exists X : C -> A, exists Y : C -> B, forall x : A, forall y : B, ((X (P x y)) = x) /\ ((Y (P x y)) = y).
Axiom thm_NUMPAIR : forall x : nat, forall y : nat, (NUMPAIR x y) = (muln (expn (NUMERAL (BIT0 (BIT1 O))) x) (addn (muln (NUMERAL (BIT0 (BIT1 O))) y) (NUMERAL (BIT1 O)))).
Axiom thm_NUMPAIR_INJ_LEMMA : forall x1 : nat, forall y1 : nat, forall x2 : nat, forall y2 : nat, ((NUMPAIR x1 y1) = (NUMPAIR x2 y2)) -> x1 = x2.
Axiom thm_NUMPAIR_INJ : forall x1 : nat, forall y1 : nat, forall x2 : nat, forall y2 : nat, ((NUMPAIR x1 y1) = (NUMPAIR x2 y2)) = ((x1 = x2) /\ (y1 = y2)).
Axiom thm_NUMSUM : forall b : Prop, forall x : nat, (NUMSUM b x) = (@COND nat b (S (muln (NUMERAL (BIT0 (BIT1 O))) x)) (muln (NUMERAL (BIT0 (BIT1 O))) x)).
Axiom thm_NUMSUM_INJ : forall b1 : Prop, forall x1 : nat, forall b2 : Prop, forall x2 : nat, ((NUMSUM b1 x1) = (NUMSUM b2 x2)) = ((b1 = b2) /\ (x1 = x2)).
Axiom thm_INJN : forall {A : Type'}, forall m : nat, (@INJN A m) = (fun n : nat => fun a : A => n = m).
Axiom thm_INJN_INJ : forall {A : Type'}, forall n1 : nat, forall n2 : nat, ((@INJN A n1) = (@INJN A n2)) = (n1 = n2).
Axiom thm_INJA : forall {A : Type'}, forall a : A, (@INJA A a) = (fun n : nat => fun b : A => b = a).
Axiom thm_INJA_INJ : forall {A : Type'}, forall a1 : A, forall a2 : A, ((@INJA A a1) = (@INJA A a2)) = (a1 = a2).
Axiom thm_INJF : forall {A : Type'}, forall f : nat -> nat -> A -> Prop, (@INJF A f) = (fun n : nat => f (NUMFST n) (NUMSND n)).
Axiom thm_INJF_INJ : forall {A : Type'}, forall f1 : nat -> nat -> A -> Prop, forall f2 : nat -> nat -> A -> Prop, ((@INJF A f1) = (@INJF A f2)) = (f1 = f2).
Axiom thm_INJP : forall {A : Type'}, forall f1 : nat -> A -> Prop, forall f2 : nat -> A -> Prop, (@INJP A f1 f2) = (fun n : nat => fun a : A => @COND Prop (NUMLEFT n) (f1 (NUMRIGHT n) a) (f2 (NUMRIGHT n) a)).
Axiom thm_INJP_INJ : forall {A : Type'}, forall f1 : nat -> A -> Prop, forall f1' : nat -> A -> Prop, forall f2 : nat -> A -> Prop, forall f2' : nat -> A -> Prop, ((@INJP A f1 f2) = (@INJP A f1' f2')) = ((f1 = f1') /\ (f2 = f2')).
Axiom thm_ZCONSTR : forall {A : Type'}, forall c : nat, forall i : A, forall r : nat -> nat -> A -> Prop, (@ZCONSTR A c i r) = (@INJP A (@INJN A (S c)) (@INJP A (@INJA A i) (@INJF A r))).
Axiom thm_ZBOT : forall {A : Type'}, (@ZBOT A) = (@INJP A (@INJN A (NUMERAL O)) (@ε (nat -> A -> Prop) (fun z : nat -> A -> Prop => True))).
Axiom thm_ZCONSTR_ZBOT : forall {A : Type'}, forall c : nat, forall i : A, forall r : nat -> nat -> A -> Prop, ~ ((@ZCONSTR A c i r) = (@ZBOT A)).
Axiom thm_ZRECSPACE_RULES : forall {A : Type'}, (@ZRECSPACE A (@ZBOT A)) /\ (forall c : nat, forall i : A, forall r : nat -> nat -> A -> Prop, (forall n : nat, @ZRECSPACE A (r n)) -> @ZRECSPACE A (@ZCONSTR A c i r)).
Axiom thm_ZRECSPACE_CASES : forall {A : Type'}, forall a : nat -> A -> Prop, (@ZRECSPACE A a) = ((a = (@ZBOT A)) \/ (exists c : nat, exists i : A, exists r : nat -> nat -> A -> Prop, (a = (@ZCONSTR A c i r)) /\ (forall n : nat, @ZRECSPACE A (r n)))).
Axiom thm_ZRECSPACE_INDUCT : forall {A : Type'}, forall ZRECSPACE' : (nat -> A -> Prop) -> Prop, ((ZRECSPACE' (@ZBOT A)) /\ (forall c : nat, forall i : A, forall r : nat -> nat -> A -> Prop, (forall n : nat, ZRECSPACE' (r n)) -> ZRECSPACE' (@ZCONSTR A c i r))) -> forall a : nat -> A -> Prop, (@ZRECSPACE A a) -> ZRECSPACE' a.
Axiom thm_BOTTOM : forall {A : Type'}, (@BOTTOM A) = (@_mk_rec A (@ZBOT A)).
Axiom thm_CONSTR : forall {A : Type'}, forall c : nat, forall i : A, forall r : nat -> recspace A, (@CONSTR A c i r) = (@_mk_rec A (@ZCONSTR A c i (fun n : nat => @_dest_rec A (r n)))).
Axiom thm_MK_REC_INJ : forall {A : Type'}, forall x : nat -> A -> Prop, forall y : nat -> A -> Prop, ((@_mk_rec A x) = (@_mk_rec A y)) -> ((@ZRECSPACE A x) /\ (@ZRECSPACE A y)) -> x = y.
Axiom thm_DEST_REC_INJ : forall {A : Type'}, forall x : recspace A, forall y : recspace A, ((@_dest_rec A x) = (@_dest_rec A y)) = (x = y).
Axiom thm_CONSTR_BOT : forall {A : Type'}, forall c : nat, forall i : A, forall r : nat -> recspace A, ~ ((@CONSTR A c i r) = (@BOTTOM A)).
Axiom thm_CONSTR_INJ : forall {A : Type'}, forall c1 : nat, forall i1 : A, forall r1 : nat -> recspace A, forall c2 : nat, forall i2 : A, forall r2 : nat -> recspace A, ((@CONSTR A c1 i1 r1) = (@CONSTR A c2 i2 r2)) = ((c1 = c2) /\ ((i1 = i2) /\ (r1 = r2))).
Axiom thm_CONSTR_IND : forall {A : Type'}, forall P : (recspace A) -> Prop, ((P (@BOTTOM A)) /\ (forall c : nat, forall i : A, forall r : nat -> recspace A, (forall n : nat, P (r n)) -> P (@CONSTR A c i r))) -> forall x : recspace A, P x.
Axiom thm_CONSTR_REC : forall {A B : Type'}, forall Fn' : nat -> A -> (nat -> recspace A) -> (nat -> B) -> B, exists f : (recspace A) -> B, forall c : nat, forall i : A, forall r : nat -> recspace A, (f (@CONSTR A c i r)) = (Fn' c i r (fun n : nat => f (r n))).
Axiom thm_FCONS : forall {A : Type'}, (forall a : A, forall f : nat -> A, (@FCONS A a f (NUMERAL O)) = a) /\ (forall a : A, forall f : nat -> A, forall n : nat, (@FCONS A a f (S n)) = (f n)).
Axiom thm_FCONS_UNDO : forall {A : Type'}, forall f : nat -> A, f = (@FCONS A (f (NUMERAL O)) (@o nat nat A f S)).
Axiom thm_FNIL : forall {A : Type'}, forall n : nat, (@FNIL A n) = (@ε A (fun x : A => True)).
Axiom thm_sum_INDUCT : forall {A B : Type'}, forall P : (Datatypes.sum A B) -> Prop, ((forall a : A, P (@inl A B a)) /\ (forall a : B, P (@inr A B a))) -> forall x : Datatypes.sum A B, P x.
Axiom thm_sum_RECURSION : forall {A B Z' : Type'}, forall INL' : A -> Z', forall INR' : B -> Z', exists fn : (Datatypes.sum A B) -> Z', (forall a : A, (fn (@inl A B a)) = (INL' a)) /\ (forall a : B, (fn (@inr A B a)) = (INR' a)).
Axiom thm_OUTL : forall {A B : Type'} (x : A), (@OUTL A B (@inl A B x)) = x.
Axiom thm_OUTR : forall {A B : Type'} (y : B), (@OUTR A B (@inr A B y)) = y.
Axiom thm_option_INDUCT : forall {A : Type'}, forall P : (option A) -> Prop, ((P (@None A)) /\ (forall a : A, P (@Some A a))) -> forall x : option A, P x.
Axiom thm_option_RECURSION : forall {A Z' : Type'}, forall NONE' : Z', forall SOME' : A -> Z', exists fn : (option A) -> Z', ((fn (@None A)) = NONE') /\ (forall a : A, (fn (@Some A a)) = (SOME' a)).
Axiom thm_list_INDUCT : forall {A : Type'}, forall P : (seq A) -> Prop, ((P (@nil A)) /\ (forall a0 : A, forall a1 : seq A, (P a1) -> P (@cons A a0 a1))) -> forall x : seq A, P x.
Axiom thm_list_RECURSION : forall {A Z' : Type'}, forall NIL' : Z', forall CONS' : A -> (seq A) -> Z' -> Z', exists fn : (seq A) -> Z', ((fn (@nil A)) = NIL') /\ (forall a0 : A, forall a1 : seq A, (fn (@cons A a0 a1)) = (CONS' a0 a1 (fn a1))).
Axiom thm_FORALL_OPTION_THM : forall {A : Type'}, forall P : (option A) -> Prop, (forall x : option A, P x) = ((P (@None A)) /\ (forall a : A, P (@Some A a))).
Axiom thm_EXISTS_OPTION_THM : forall {A : Type'}, forall P : (option A) -> Prop, (exists x : option A, P x) = ((P (@None A)) \/ (exists a : A, P (@Some A a))).
Axiom thm_option_DISTINCT : forall {A : Type'}, forall a : A, ~ ((@Some A a) = (@None A)).
Axiom thm_option_INJ : forall {A : Type'}, forall a : A, forall b : A, ((@Some A a) = (@Some A b)) = (a = b).
Axiom thm_ISO : forall {A B : Type'}, forall g : B -> A, forall f : A -> B, (@cancel2 A B f g) = ((forall x : B, (f (g x)) = x) /\ (forall y : A, (g (f y)) = y)).
Axiom thm_ISO_REFL : forall {A : Type'}, @cancel2 A A (fun x : A => x) (fun x : A => x).
Axiom thm_ISO_FUN : forall {A A' B B' : Type'} (g : B -> B') (f' : A' -> A) (g' : B' -> B) (f : A -> A'), ((@cancel2 A A' f f') /\ (@cancel2 B B' g g')) -> @cancel2 (A -> B) (A' -> B') (fun h : A -> B => fun a' : A' => g (h (f' a'))) (fun h : A' -> B' => fun a : A => g' (h (f a))).
Axiom thm_ISO_USAGE : forall {A B : Type'} (g : B -> A) (f : A -> B), (@cancel2 A B f g) -> (forall P : A -> Prop, (forall x : A, P x) = (forall x : B, P (g x))) /\ ((forall P : A -> Prop, (exists x : A, P x) = (exists x : B, P (g x))) /\ (forall a : A, forall b : B, (a = (g b)) = ((f a) = b))).
Axiom thm_HD : forall {A : Type'} (t : seq A) (h : A), (@HD A (@cons A h t)) = h.
Axiom thm_TL : forall {A : Type'} (h : A) (t : seq A), (@TL A (@cons A h t)) = t.
Axiom thm_APPEND : forall {A : Type'}, (forall l : seq A, (@cat A (@nil A) l) = l) /\ (forall h : A, forall t : seq A, forall l : seq A, (@cat A (@cons A h t) l) = (@cons A h (@cat A t l))).
Axiom thm_REVERSE : forall {A : Type'} (l : seq A) (x : A), ((@rev A (@nil A)) = (@nil A)) /\ ((@rev A (@cons A x l)) = (@cat A (@rev A l) (@cons A x (@nil A)))).
Axiom thm_LENGTH : forall {A : Type'}, ((@size A (@nil A)) = (NUMERAL O)) /\ (forall h : A, forall t : seq A, (@size A (@cons A h t)) = (S (@size A t))).
Axiom thm_MAP : forall {A B : Type'}, (forall f : A -> B, (@map A B f (@nil A)) = (@nil B)) /\ (forall f : A -> B, forall h : A, forall t : seq A, (@map A B f (@cons A h t)) = (@cons B (f h) (@map A B f t))).
Axiom thm_LAST : forall {A : Type'} (h : A) (t : seq A), (@LAST A (@cons A h t)) = (@COND A (t = (@nil A)) h (@LAST A t)).
Axiom thm_BUTLAST : forall {A : Type'} (h : A) (t : seq A), ((@BUTLAST A (@nil A)) = (@nil A)) /\ ((@BUTLAST A (@cons A h t)) = (@COND (seq A) (t = (@nil A)) (@nil A) (@cons A h (@BUTLAST A t)))).
Axiom thm_REPLICATE : forall {A : Type'} (n : nat) (x : A), ((@nseq A (NUMERAL O) x) = (@nil A)) /\ ((@nseq A (S n) x) = (@cons A x (@nseq A n x))).
Axiom thm_NULL : forall {A : Type'} (h : A) (t : seq A), ((@NULL A (@nil A)) = True) /\ ((@NULL A (@cons A h t)) = False).
Axiom thm_ALL : forall {A : Type'} (h : A) (P : A -> Prop) (t : seq A), ((@ALL A P (@nil A)) = True) /\ ((@ALL A P (@cons A h t)) = ((P h) /\ (@ALL A P t))).
Axiom thm_EX : forall {A : Type'} (h : A) (P : A -> Prop) (t : seq A), ((@EX A P (@nil A)) = False) /\ ((@EX A P (@cons A h t)) = ((P h) \/ (@EX A P t))).
Axiom thm_ITLIST : forall {A B : Type'} (h : A) (f : A -> B -> B) (t : seq A) (b : B), ((@ITLIST A B f (@nil A) b) = b) /\ ((@ITLIST A B f (@cons A h t) b) = (f h (@ITLIST A B f t b))).
Axiom thm_MEM : forall {A : Type'} (h : A) (x : A) (t : seq A), ((@MEM A x (@nil A)) = False) /\ ((@MEM A x (@cons A h t)) = ((x = h) \/ (@MEM A x t))).
Axiom thm_ALL2_DEF : forall {A B : Type'} (h1' : A) (P : A -> B -> Prop) (t1 : seq A) (l2 : seq B), ((@ALL2 A B P (@nil A) l2) = (l2 = (@nil B))) /\ ((@ALL2 A B P (@cons A h1' t1) l2) = (@COND Prop (l2 = (@nil B)) False ((P h1' (@HD B l2)) /\ (@ALL2 A B P t1 (@TL B l2))))).
Axiom thm_ALL2 : forall {A B : Type'} (h1' : A) (h2' : B) (P : A -> B -> Prop) (t1 : seq A) (t2 : seq B), ((@ALL2 A B P (@nil A) (@nil B)) = True) /\ (((@ALL2 A B P (@cons A h1' t1) (@nil B)) = False) /\ (((@ALL2 A B P (@nil A) (@cons B h2' t2)) = False) /\ ((@ALL2 A B P (@cons A h1' t1) (@cons B h2' t2)) = ((P h1' h2') /\ (@ALL2 A B P t1 t2))))).
Axiom thm_MAP2_DEF : forall {A B C : Type'} (h1' : A) (f : A -> B -> C) (t1 : seq A) (l : seq B), ((@MAP2 A B C f (@nil A) l) = (@nil C)) /\ ((@MAP2 A B C f (@cons A h1' t1) l) = (@cons C (f h1' (@HD B l)) (@MAP2 A B C f t1 (@TL B l)))).
Axiom thm_MAP2 : forall {A B C : Type'} (h1' : A) (h2' : B) (f : A -> B -> C) (t1 : seq A) (t2 : seq B), ((@MAP2 A B C f (@nil A) (@nil B)) = (@nil C)) /\ ((@MAP2 A B C f (@cons A h1' t1) (@cons B h2' t2)) = (@cons C (f h1' h2') (@MAP2 A B C f t1 t2))).
Axiom thm_EL : forall {A : Type'} (n : nat) (l : seq A), ((@EL A (NUMERAL O) l) = (@HD A l)) /\ ((@EL A (S n) l) = (@EL A n (@TL A l))).
Axiom thm_FILTER : forall {A : Type'} (h : A) (P : A -> Prop) (t : seq A), ((@FILTER A P (@nil A)) = (@nil A)) /\ ((@FILTER A P (@cons A h t)) = (@COND (seq A) (P h) (@cons A h (@FILTER A P t)) (@FILTER A P t))).
Axiom thm_ASSOC : forall {A B : Type'} (h : prod A B) (a : A) (t : seq (prod A B)), (@ASSOC A B a (@cons (prod A B) h t)) = (@COND B ((@fst A B h) = a) (@snd A B h) (@ASSOC A B a t)).
Axiom thm_ITLIST2_DEF : forall {A B C : Type'} (h1' : A) (f : A -> B -> C -> C) (t1 : seq A) (l2 : seq B) (b : C), ((@ITLIST2 A B C f (@nil A) l2 b) = b) /\ ((@ITLIST2 A B C f (@cons A h1' t1) l2 b) = (f h1' (@HD B l2) (@ITLIST2 A B C f t1 (@TL B l2) b))).
Axiom thm_ITLIST2 : forall {A B C : Type'} (h1' : A) (h2' : B) (f : A -> B -> C -> C) (t1 : seq A) (t2 : seq B) (b : C), ((@ITLIST2 A B C f (@nil A) (@nil B) b) = b) /\ ((@ITLIST2 A B C f (@cons A h1' t1) (@cons B h2' t2) b) = (f h1' h2' (@ITLIST2 A B C f t1 t2 b))).
Axiom thm_ZIP_DEF : forall {A B : Type'} (h1' : A) (t1 : seq A) (l2 : seq B), ((@ZIP A B (@nil A) l2) = (@nil (prod A B))) /\ ((@ZIP A B (@cons A h1' t1) l2) = (@cons (prod A B) (@pair A B h1' (@HD B l2)) (@ZIP A B t1 (@TL B l2)))).
Axiom thm_ZIP : forall {A B : Type'} (h1' : A) (h2' : B) (t1 : seq A) (t2 : seq B), ((@ZIP A B (@nil A) (@nil B)) = (@nil (prod A B))) /\ ((@ZIP A B (@cons A h1' t1) (@cons B h2' t2)) = (@cons (prod A B) (@pair A B h1' h2') (@ZIP A B t1 t2))).
Axiom thm_ALLPAIRS : forall {A B : Type'} (h : A) (f : A -> B -> Prop) (t : seq A) (l : seq B), ((@ALLPAIRS A B f (@nil A) l) = True) /\ ((@ALLPAIRS A B f (@cons A h t) l) = ((@ALL B (f h) l) /\ (@ALLPAIRS A B f t l))).
Axiom thm_PAIRWISE : forall {A : Type'} (h : A) (r : A -> A -> Prop) (t : seq A), ((@PAIRWISE A r (@nil A)) = True) /\ ((@PAIRWISE A r (@cons A h t)) = ((@ALL A (r h) t) /\ (@PAIRWISE A r t))).
Axiom thm_list_of_seq : forall {A : Type'} (s : nat -> A) (n : nat), ((@mkseq A s (NUMERAL O)) = (@nil A)) /\ ((@mkseq A s (S n)) = (@cat A (@mkseq A s n) (@cons A (s n) (@nil A)))).
Axiom thm_NOT_CONS_NIL : forall {A : Type'}, forall h : A, forall t : seq A, ~ ((@cons A h t) = (@nil A)).
Axiom thm_LAST_CLAUSES : forall {A : Type'} (h : A) (k : A) (t : seq A), ((@LAST A (@cons A h (@nil A))) = h) /\ ((@LAST A (@cons A h (@cons A k t))) = (@LAST A (@cons A k t))).
Axiom thm_APPEND_NIL : forall {A : Type'}, forall l : seq A, (@cat A l (@nil A)) = l.
Axiom thm_APPEND_ASSOC : forall {A : Type'}, forall l : seq A, forall m : seq A, forall n : seq A, (@cat A l (@cat A m n)) = (@cat A (@cat A l m) n).
Axiom thm_REVERSE_APPEND : forall {A : Type'}, forall l : seq A, forall m : seq A, (@rev A (@cat A l m)) = (@cat A (@rev A m) (@rev A l)).
Axiom thm_REVERSE_REVERSE : forall {A : Type'}, forall l : seq A, (@rev A (@rev A l)) = l.
Axiom thm_REVERSE_EQ_EMPTY : forall {A : Type'}, forall l : seq A, ((@rev A l) = (@nil A)) = (l = (@nil A)).
Axiom thm_CONS_11 : forall {A : Type'}, forall h1' : A, forall h2' : A, forall t1 : seq A, forall t2 : seq A, ((@cons A h1' t1) = (@cons A h2' t2)) = ((h1' = h2') /\ (t1 = t2)).
Axiom thm_list_CASES : forall {A : Type'}, forall l : seq A, (l = (@nil A)) \/ (exists h : A, exists t : seq A, l = (@cons A h t)).
Axiom thm_LIST_EQ : forall {A : Type'}, forall l1 : seq A, forall l2 : seq A, (l1 = l2) = (((@size A l1) = (@size A l2)) /\ (forall n : nat, (ltn n (@size A l2)) -> (@EL A n l1) = (@EL A n l2))).
Axiom thm_LENGTH_APPEND : forall {A : Type'}, forall l : seq A, forall m : seq A, (@size A (@cat A l m)) = (addn (@size A l) (@size A m)).
Axiom thm_MAP_APPEND : forall {A B : Type'}, forall f : A -> B, forall l1 : seq A, forall l2 : seq A, (@map A B f (@cat A l1 l2)) = (@cat B (@map A B f l1) (@map A B f l2)).
Axiom thm_LENGTH_MAP : forall {A B : Type'}, forall l : seq A, forall f : A -> B, (@size B (@map A B f l)) = (@size A l).
Axiom thm_LENGTH_EQ_NIL : forall {A : Type'}, forall l : seq A, ((@size A l) = (NUMERAL O)) = (l = (@nil A)).
Axiom thm_LENGTH_EQ_CONS : forall {A : Type'}, forall l : seq A, forall n : nat, ((@size A l) = (S n)) = (exists h : A, exists t : seq A, (l = (@cons A h t)) /\ ((@size A t) = n)).
Axiom thm_LENGTH_REVERSE : forall {A : Type'}, forall l : seq A, (@size A (@rev A l)) = (@size A l).
Axiom thm_MAP_o : forall {A B C : Type'}, forall f : A -> B, forall g : B -> C, forall l : seq A, (@map A C (@o A B C g f) l) = (@map B C g (@map A B f l)).
Axiom thm_MAP_EQ : forall {A B : Type'}, forall f : A -> B, forall g : A -> B, forall l : seq A, (@ALL A (fun x : A => (f x) = (g x)) l) -> (@map A B f l) = (@map A B g l).
Axiom thm_ALL_IMP : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, forall l : seq A, ((forall x : A, ((@MEM A x l) /\ (P x)) -> Q x) /\ (@ALL A P l)) -> @ALL A Q l.
Axiom thm_NOT_EX : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, (~ (@EX A P l)) = (@ALL A (fun x : A => ~ (P x)) l).
Axiom thm_NOT_ALL : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, (~ (@ALL A P l)) = (@EX A (fun x : A => ~ (P x)) l).
Axiom thm_ALL_MAP : forall {A B : Type'}, forall P : B -> Prop, forall f : A -> B, forall l : seq A, (@ALL B P (@map A B f l)) = (@ALL A (@o A B Prop P f) l).
Axiom thm_ALL_EQ : forall {A : Type'} (R' : A -> Prop) (P : A -> Prop) (Q : A -> Prop), forall l : seq A, ((@ALL A R' l) /\ (forall x : A, (R' x) -> (P x) = (Q x))) -> (@ALL A P l) = (@ALL A Q l).
Axiom thm_ALL_T : forall {A : Type'}, forall l : seq A, @ALL A (fun x : A => True) l.
Axiom thm_ALL2_MAP : forall {A B : Type'}, forall P : B -> A -> Prop, forall f : A -> B, forall l : seq A, (@ALL2 B A P (@map A B f l) l) = (@ALL A (fun a : A => P (f a) a) l).
Axiom thm_MAP_EQ_DEGEN : forall {A : Type'}, forall l : seq A, forall f : A -> A, (@ALL A (fun x : A => (f x) = x) l) -> (@map A A f l) = l.
Axiom thm_ALL2_AND_RIGHT : forall {A B : Type'}, forall l : seq A, forall m : seq B, forall P : A -> Prop, forall Q : A -> B -> Prop, (@ALL2 A B (fun x : A => fun y : B => (P x) /\ (Q x y)) l m) = ((@ALL A P l) /\ (@ALL2 A B Q l m)).
Axiom thm_ITLIST_APPEND : forall {A B : Type'}, forall f : A -> B -> B, forall a : B, forall l1 : seq A, forall l2 : seq A, (@ITLIST A B f (@cat A l1 l2) a) = (@ITLIST A B f l1 (@ITLIST A B f l2 a)).
Axiom thm_ITLIST_EXTRA : forall {A B : Type'} (a : A) (b : B), forall f : A -> B -> B, forall l : seq A, (@ITLIST A B f (@cat A l (@cons A a (@nil A))) b) = (@ITLIST A B f l (f a b)).
Axiom thm_ALL_MP : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, forall l : seq A, ((@ALL A (fun x : A => (P x) -> Q x) l) /\ (@ALL A P l)) -> @ALL A Q l.
Axiom thm_AND_ALL : forall {A : Type'} (P : A -> Prop) (Q : A -> Prop), forall l : seq A, ((@ALL A P l) /\ (@ALL A Q l)) = (@ALL A (fun x : A => (P x) /\ (Q x)) l).
Axiom thm_EX_IMP : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, forall l : seq A, ((forall x : A, ((@MEM A x l) /\ (P x)) -> Q x) /\ (@EX A P l)) -> @EX A Q l.
Axiom thm_ALL_MEM : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, (forall x : A, (@MEM A x l) -> P x) = (@ALL A P l).
Axiom thm_LENGTH_REPLICATE : forall {A : Type'}, forall n : nat, forall x : A, (@size A (@nseq A n x)) = n.
Axiom thm_MEM_REPLICATE : forall {A : Type'}, forall n : nat, forall x : A, forall y : A, (@MEM A x (@nseq A n y)) = ((x = y) /\ (~ (n = (NUMERAL O)))).
Axiom thm_EX_MAP : forall {A B : Type'}, forall P : B -> Prop, forall f : A -> B, forall l : seq A, (@EX B P (@map A B f l)) = (@EX A (@o A B Prop P f) l).
Axiom thm_EXISTS_EX : forall {A B : Type'}, forall P : A -> B -> Prop, forall l : seq B, (exists x : A, @EX B (P x) l) = (@EX B (fun s : B => exists x : A, P x s) l).
Axiom thm_FORALL_ALL : forall {A B : Type'}, forall P : A -> B -> Prop, forall l : seq B, (forall x : A, @ALL B (P x) l) = (@ALL B (fun s : B => forall x : A, P x s) l).
Axiom thm_MEM_APPEND : forall {A : Type'}, forall x : A, forall l1 : seq A, forall l2 : seq A, (@MEM A x (@cat A l1 l2)) = ((@MEM A x l1) \/ (@MEM A x l2)).
Axiom thm_MEM_MAP : forall {A B : Type'}, forall f : A -> B, forall y : B, forall l : seq A, (@MEM B y (@map A B f l)) = (exists x : A, (@MEM A x l) /\ (y = (f x))).
Axiom thm_FILTER_APPEND : forall {A : Type'}, forall P : A -> Prop, forall l1 : seq A, forall l2 : seq A, (@FILTER A P (@cat A l1 l2)) = (@cat A (@FILTER A P l1) (@FILTER A P l2)).
Axiom thm_FILTER_MAP : forall {A B : Type'}, forall P : B -> Prop, forall f : A -> B, forall l : seq A, (@FILTER B P (@map A B f l)) = (@map A B f (@FILTER A (@o A B Prop P f) l)).
Axiom thm_MEM_FILTER : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, forall x : A, (@MEM A x (@FILTER A P l)) = ((P x) /\ (@MEM A x l)).
Axiom thm_LENGTH_FILTER : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, leqn (@size A (@FILTER A P l)) (@size A l).
Axiom thm_EX_MEM : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, (exists x : A, (P x) /\ (@MEM A x l)) = (@EX A P l).
Axiom thm_MAP_FST_ZIP : forall {A B : Type'}, forall l1 : seq A, forall l2 : seq B, ((@size A l1) = (@size B l2)) -> (@map (prod A B) A (@fst A B) (@ZIP A B l1 l2)) = l1.
Axiom thm_MAP_SND_ZIP : forall {A B : Type'}, forall l1 : seq A, forall l2 : seq B, ((@size A l1) = (@size B l2)) -> (@map (prod A B) B (@snd A B) (@ZIP A B l1 l2)) = l2.
Axiom thm_LENGTH_ZIP : forall {A B : Type'}, forall l1 : seq A, forall l2 : seq B, ((@size A l1) = (@size B l2)) -> (@size (prod A B) (@ZIP A B l1 l2)) = (@size B l2).
Axiom thm_MEM_ASSOC : forall {A B : Type'}, forall l : seq (prod A B), forall x : A, (@MEM (prod A B) (@pair A B x (@ASSOC A B x l)) l) = (@MEM A x (@map (prod A B) A (@fst A B) l)).
Axiom thm_ALL_APPEND : forall {A : Type'}, forall P : A -> Prop, forall l1 : seq A, forall l2 : seq A, (@ALL A P (@cat A l1 l2)) = ((@ALL A P l1) /\ (@ALL A P l2)).
Axiom thm_MEM_EL : forall {A : Type'}, forall l : seq A, forall n : nat, (ltn n (@size A l)) -> @MEM A (@EL A n l) l.
Axiom thm_MEM_EXISTS_EL : forall {A : Type'}, forall l : seq A, forall x : A, (@MEM A x l) = (exists i : nat, (ltn i (@size A l)) /\ (x = (@EL A i l))).
Axiom thm_ALL_EL : forall {A : Type'}, forall P : A -> Prop, forall l : seq A, (forall i : nat, (ltn i (@size A l)) -> P (@EL A i l)) = (@ALL A P l).
Axiom thm_ALL2_MAP2 : forall {A B C D : Type'} (P : B -> D -> Prop), forall f : A -> B, forall g : C -> D, forall l : seq A, forall m : seq C, (@ALL2 B D P (@map A B f l) (@map C D g m)) = (@ALL2 A C (fun x : A => fun y : C => P (f x) (g y)) l m).
Axiom thm_AND_ALL2 : forall {A B : Type'}, forall P : A -> B -> Prop, forall Q : A -> B -> Prop, forall l : seq A, forall m : seq B, ((@ALL2 A B P l m) /\ (@ALL2 A B Q l m)) = (@ALL2 A B (fun x : A => fun y : B => (P x y) /\ (Q x y)) l m).
Axiom thm_ALLPAIRS_SYM : forall {A B : Type'}, forall P : A -> B -> Prop, forall l : seq A, forall m : seq B, (@ALLPAIRS A B P l m) = (@ALLPAIRS B A (fun x : B => fun y : A => P y x) m l).
Axiom thm_ALLPAIRS_MEM : forall {A B : Type'}, forall P : A -> B -> Prop, forall l : seq A, forall m : seq B, (forall x : A, forall y : B, ((@MEM A x l) /\ (@MEM B y m)) -> P x y) = (@ALLPAIRS A B P l m).
Axiom thm_ALLPAIRS_MAP : forall {A B C D : Type'}, forall P : B -> D -> Prop, forall f : A -> B, forall g : C -> D, forall l : seq A, forall m : seq C, (@ALLPAIRS B D P (@map A B f l) (@map C D g m)) = (@ALLPAIRS A C (fun x : A => fun y : C => P (f x) (g y)) l m).
Axiom thm_ALLPAIRS_EQ : forall {A B : Type'} (R' : A -> B -> Prop) (R'' : A -> B -> Prop), forall l : seq A, forall m : seq B, forall P : A -> Prop, forall Q : B -> Prop, ((@ALL A P l) /\ ((@ALL B Q m) /\ (forall p : A, forall q : B, ((P p) /\ (Q q)) -> (R' p q) = (R'' p q)))) -> (@ALLPAIRS A B R' l m) = (@ALLPAIRS A B R'' l m).
Axiom thm_ALL2_ALL : forall {A : Type'}, forall P : A -> A -> Prop, forall l : seq A, (@ALL2 A A P l l) = (@ALL A (fun x : A => P x x) l).
Axiom thm_APPEND_EQ_NIL : forall {A : Type'}, forall l : seq A, forall m : seq A, ((@cat A l m) = (@nil A)) = ((l = (@nil A)) /\ (m = (@nil A))).
Axiom thm_APPEND_LCANCEL : forall {A : Type'}, forall l1 : seq A, forall l2 : seq A, forall l3 : seq A, ((@cat A l1 l2) = (@cat A l1 l3)) = (l2 = l3).
Axiom thm_APPEND_RCANCEL : forall {A : Type'}, forall l1 : seq A, forall l2 : seq A, forall l3 : seq A, ((@cat A l1 l3) = (@cat A l2 l3)) = (l1 = l2).
Axiom thm_LENGTH_MAP2 : forall {A B C : Type'}, forall f : A -> B -> C, forall l : seq A, forall m : seq B, ((@size A l) = (@size B m)) -> (@size C (@MAP2 A B C f l m)) = (@size B m).
Axiom thm_EL_MAP2 : forall {A B C : Type'}, forall f : A -> B -> C, forall l : seq A, forall m : seq B, forall k : nat, ((ltn k (@size A l)) /\ (ltn k (@size B m))) -> (@EL C k (@MAP2 A B C f l m)) = (f (@EL A k l) (@EL B k m)).
Axiom thm_MAP_EQ_NIL : forall {A B : Type'}, forall f : A -> B, forall l : seq A, ((@map A B f l) = (@nil B)) = (l = (@nil A)).
Axiom thm_INJECTIVE_MAP : forall {A B : Type'}, forall f : A -> B, (forall l : seq A, forall m : seq A, ((@map A B f l) = (@map A B f m)) -> l = m) = (forall x : A, forall y : A, ((f x) = (f y)) -> x = y).
Axiom thm_SURJECTIVE_MAP : forall {A B : Type'}, forall f : A -> B, (forall m : seq B, exists l : seq A, (@map A B f l) = m) = (forall y : B, exists x : A, (f x) = y).
Axiom thm_MAP_ID : forall {A : Type'}, forall l : seq A, (@map A A (fun x : A => x) l) = l.
Axiom thm_MAP_I : forall {A : Type'}, (@map A A (@I A)) = (@I (seq A)).
Axiom thm_BUTLAST_CLAUSES : forall {A : Type'}, ((@BUTLAST A (@nil A)) = (@nil A)) /\ ((forall a : A, (@BUTLAST A (@cons A a (@nil A))) = (@nil A)) /\ (forall a : A, forall h : A, forall t : seq A, (@BUTLAST A (@cons A a (@cons A h t))) = (@cons A a (@BUTLAST A (@cons A h t))))).
Axiom thm_BUTLAST_APPEND : forall {A : Type'}, forall l : seq A, forall m : seq A, (@BUTLAST A (@cat A l m)) = (@COND (seq A) (m = (@nil A)) (@BUTLAST A l) (@cat A l (@BUTLAST A m))).
Axiom thm_APPEND_BUTLAST_LAST : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> (@cat A (@BUTLAST A l) (@cons A (@LAST A l) (@nil A))) = l.
Axiom thm_LAST_APPEND : forall {A : Type'}, forall p : seq A, forall q : seq A, (@LAST A (@cat A p q)) = (@COND A (q = (@nil A)) (@LAST A p) (@LAST A q)).
Axiom thm_LENGTH_TL : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> (@size A (@TL A l)) = (subn (@size A l) (NUMERAL (BIT1 O))).
Axiom thm_LAST_REVERSE : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> (@LAST A (@rev A l)) = (@HD A l).
Axiom thm_HD_REVERSE : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> (@HD A (@rev A l)) = (@LAST A l).
Axiom thm_EL_APPEND : forall {A : Type'}, forall k : nat, forall l : seq A, forall m : seq A, (@EL A k (@cat A l m)) = (@COND A (ltn k (@size A l)) (@EL A k l) (@EL A (subn k (@size A l)) m)).
Axiom thm_EL_TL : forall {A : Type'} (l : seq A), forall n : nat, (@EL A n (@TL A l)) = (@EL A (addn n (NUMERAL (BIT1 O))) l).
Axiom thm_EL_CONS : forall {A : Type'}, forall n : nat, forall h : A, forall t : seq A, (@EL A n (@cons A h t)) = (@COND A (n = (NUMERAL O)) h (@EL A (subn n (NUMERAL (BIT1 O))) t)).
Axiom thm_LAST_EL : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> (@LAST A l) = (@EL A (subn (@size A l) (NUMERAL (BIT1 O))) l).
Axiom thm_HD_APPEND : forall {A : Type'}, forall l : seq A, forall m : seq A, (@HD A (@cat A l m)) = (@COND A (l = (@nil A)) (@HD A m) (@HD A l)).
Axiom thm_CONS_HD_TL : forall {A : Type'}, forall l : seq A, (~ (l = (@nil A))) -> l = (@cons A (@HD A l) (@TL A l)).
Axiom thm_EL_MAP : forall {A B : Type'}, forall f : A -> B, forall n : nat, forall l : seq A, (ltn n (@size A l)) -> (@EL B n (@map A B f l)) = (f (@EL A n l)).
Axiom thm_MAP_REVERSE : forall {A B : Type'}, forall f : A -> B, forall l : seq A, (@rev B (@map A B f l)) = (@map A B f (@rev A l)).
Axiom thm_ALL_FILTER : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, forall l : seq A, (@ALL A P (@FILTER A Q l)) = (@ALL A (fun x : A => (Q x) -> P x) l).
Axiom thm_APPEND_SING : forall {A : Type'}, forall h : A, forall t : seq A, (@cat A (@cons A h (@nil A)) t) = (@cons A h t).
Axiom thm_MEM_APPEND_DECOMPOSE_LEFT : forall {A : Type'}, forall x : A, forall l : seq A, (@MEM A x l) = (exists l1 : seq A, exists l2 : seq A, (~ (@MEM A x l1)) /\ (l = (@cat A l1 (@cons A x l2)))).
Axiom thm_MEM_APPEND_DECOMPOSE : forall {A : Type'}, forall x : A, forall l : seq A, (@MEM A x l) = (exists l1 : seq A, exists l2 : seq A, l = (@cat A l1 (@cons A x l2))).
Axiom thm_PAIRWISE_APPEND : forall {A : Type'}, forall R' : A -> A -> Prop, forall l : seq A, forall m : seq A, (@PAIRWISE A R' (@cat A l m)) = ((@PAIRWISE A R' l) /\ ((@PAIRWISE A R' m) /\ (forall x : A, forall y : A, ((@MEM A x l) /\ (@MEM A y m)) -> R' x y))).
Axiom thm_PAIRWISE_MAP : forall {A B : Type'}, forall R' : B -> B -> Prop, forall f : A -> B, forall l : seq A, (@PAIRWISE B R' (@map A B f l)) = (@PAIRWISE A (fun x : A => fun y : A => R' (f x) (f y)) l).
Axiom thm_PAIRWISE_IMPLIES : forall {A : Type'}, forall R' : A -> A -> Prop, forall R'' : A -> A -> Prop, forall l : seq A, ((@PAIRWISE A R' l) /\ (forall x : A, forall y : A, ((@MEM A x l) /\ ((@MEM A y l) /\ (R' x y))) -> R'' x y)) -> @PAIRWISE A R'' l.
Axiom thm_PAIRWISE_TRANSITIVE : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall l : seq A, (forall x' : A, forall y' : A, forall z : A, ((R' x' y') /\ (R' y' z)) -> R' x' z) -> (@PAIRWISE A R' (@cons A x (@cons A y l))) = ((R' x y) /\ (@PAIRWISE A R' (@cons A y l))).
Axiom thm_LENGTH_LIST_OF_SEQ : forall {A : Type'}, forall s : nat -> A, forall n : nat, (@size A (@mkseq A s n)) = n.
Axiom thm_EL_LIST_OF_SEQ : forall {A : Type'}, forall s : nat -> A, forall m : nat, forall n : nat, (ltn m n) -> (@EL A m (@mkseq A s n)) = (s m).
Axiom thm_LIST_OF_SEQ_EQ_NIL : forall {A : Type'}, forall s : nat -> A, forall n : nat, ((@mkseq A s n) = (@nil A)) = (n = (NUMERAL O)).
Axiom thm_LIST_OF_SEQ_EQ_SELF : forall {A : Type'}, forall l : seq A, (@mkseq A (fun i : nat => @EL A i l) (@size A l)) = l.
Axiom thm_LENGTH_EQ_LIST_OF_SEQ : forall {A : Type'}, forall l : seq A, forall n : nat, ((@size A l) = n) = (l = (@mkseq A (fun i : nat => @EL A i l) n)).
Axiom thm_MAP_LIST_OF_SEQ : forall {A B : Type'}, forall f : nat -> A, forall g : A -> B, forall n : nat, (@map A B g (@mkseq A f n)) = (@mkseq B (@o nat A B g f) n).
Axiom thm_LIST_OF_SEQ : forall {A : Type'}, (forall f : nat -> A, (@mkseq A f (NUMERAL O)) = (@nil A)) /\ (forall f : nat -> A, forall n : nat, (@mkseq A f (S n)) = (@cons A (f (NUMERAL O)) (@mkseq A (@o nat nat A f S) n))).
Axiom thm_MONO_ALL : forall {A : Type'} (P : A -> Prop) (Q : A -> Prop) (l : seq A), (forall x : A, (P x) -> Q x) -> (@ALL A P l) -> @ALL A Q l.
Axiom thm_MONO_ALL2 : forall {A B : Type'} (P : A -> B -> Prop) (Q : A -> B -> Prop) (l : seq A) (l' : seq B), (forall x : A, forall y : B, (P x y) -> Q x y) -> (@ALL2 A B P l l') -> @ALL2 A B Q l l'.
Axiom thm_char_INDUCT : forall P : Ascii.ascii -> Prop, (forall a0 : Prop, forall a1 : Prop, forall a2 : Prop, forall a3 : Prop, forall a4 : Prop, forall a5 : Prop, forall a6 : Prop, forall a7 : Prop, P (ASCII a0 a1 a2 a3 a4 a5 a6 a7)) -> forall x : Ascii.ascii, P x.
Axiom thm_char_RECURSION : forall {Z' : Type'}, forall f : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Z', exists fn : Ascii.ascii -> Z', forall a0 : Prop, forall a1 : Prop, forall a2 : Prop, forall a3 : Prop, forall a4 : Prop, forall a5 : Prop, forall a6 : Prop, forall a7 : Prop, (fn (ASCII a0 a1 a2 a3 a4 a5 a6 a7)) = (f a0 a1 a2 a3 a4 a5 a6 a7).
Axiom thm_dist : forall n : nat, forall m : nat, (dist (@pair nat nat m n)) = (addn (subn m n) (subn n m)).
Axiom thm_DIST_REFL : forall n : nat, (dist (@pair nat nat n n)) = (NUMERAL O).
Axiom thm_DIST_LZERO : forall n : nat, (dist (@pair nat nat (NUMERAL O) n)) = n.
Axiom thm_DIST_RZERO : forall n : nat, (dist (@pair nat nat n (NUMERAL O))) = n.
Axiom thm_DIST_SYM : forall m : nat, forall n : nat, (dist (@pair nat nat m n)) = (dist (@pair nat nat n m)).
Axiom thm_DIST_LADD : forall m : nat, forall p : nat, forall n : nat, (dist (@pair nat nat (addn m n) (addn m p))) = (dist (@pair nat nat n p)).
Axiom thm_DIST_RADD : forall m : nat, forall p : nat, forall n : nat, (dist (@pair nat nat (addn m p) (addn n p))) = (dist (@pair nat nat m n)).
Axiom thm_DIST_LADD_0 : forall m : nat, forall n : nat, (dist (@pair nat nat (addn m n) m)) = n.
Axiom thm_DIST_RADD_0 : forall m : nat, forall n : nat, (dist (@pair nat nat m (addn m n))) = n.
Axiom thm_DIST_LMUL : forall m : nat, forall n : nat, forall p : nat, (muln m (dist (@pair nat nat n p))) = (dist (@pair nat nat (muln m n) (muln m p))).
Axiom thm_DIST_RMUL : forall m : nat, forall n : nat, forall p : nat, (muln (dist (@pair nat nat m n)) p) = (dist (@pair nat nat (muln m p) (muln n p))).
Axiom thm_DIST_EQ_0 : forall m : nat, forall n : nat, ((dist (@pair nat nat m n)) = (NUMERAL O)) = (m = n).
Axiom thm_DIST_ELIM_THM : forall (y : nat) (x : nat) (P : nat -> Prop), (P (dist (@pair nat nat x y))) = (forall d : nat, ((x = (addn y d)) -> P d) /\ ((y = (addn x d)) -> P d)).
Axiom thm_DIST_TRIANGLE_LE : forall m : nat, forall n : nat, forall p : nat, forall q : nat, (leqn (addn (dist (@pair nat nat m n)) (dist (@pair nat nat n p))) q) -> leqn (dist (@pair nat nat m p)) q.
Axiom thm_DIST_TRIANGLES_LE : forall m : nat, forall n : nat, forall p : nat, forall q : nat, forall r : nat, forall s : nat, ((leqn (dist (@pair nat nat m n)) r) /\ (leqn (dist (@pair nat nat p q)) s)) -> leqn (dist (@pair nat nat m p)) (addn (dist (@pair nat nat n q)) (addn r s)).
Axiom thm_BOUNDS_LINEAR : forall A : nat, forall B : nat, forall C : nat, (forall n : nat, leqn (muln A n) (addn (muln B n) C)) = (leqn A B).
Axiom thm_BOUNDS_LINEAR_0 : forall A : nat, forall B : nat, (forall n : nat, leqn (muln A n) B) = (A = (NUMERAL O)).
Axiom thm_BOUNDS_DIVIDED : forall P : nat -> nat, (exists B : nat, forall n : nat, leqn (P n) B) = (exists A : nat, exists B : nat, forall n : nat, leqn (muln n (P n)) (addn (muln A n) B)).
Axiom thm_BOUNDS_NOTZERO : forall P : nat -> nat -> nat, forall A : nat, forall B : nat, (((P (NUMERAL O) (NUMERAL O)) = (NUMERAL O)) /\ (forall m : nat, forall n : nat, leqn (P m n) (addn (muln A (addn m n)) B))) -> exists B' : nat, forall m : nat, forall n : nat, leqn (P m n) (muln B' (addn m n)).
Axiom thm_BOUNDS_IGNORE : forall P : nat -> nat, forall Q : nat -> nat, (exists B : nat, forall i : nat, leqn (P i) (addn (Q i) B)) = (exists B : nat, exists N' : nat, forall i : nat, (leqn N' i) -> leqn (P i) (addn (Q i) B)).
Axiom thm_is_nadd : forall x : nat -> nat, (is_nadd x) = (exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (muln m (x n)) (muln n (x m)))) (muln B (addn m n))).
Axiom thm_is_nadd_0 : is_nadd (fun n : nat => NUMERAL O).
Axiom thm_NADD_CAUCHY : forall x : nadd, exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (muln m (dest_nadd x n)) (muln n (dest_nadd x m)))) (muln B (addn m n)).
Axiom thm_NADD_BOUND : forall x : nadd, exists A : nat, exists B : nat, forall n : nat, leqn (dest_nadd x n) (addn (muln A n) B).
Axiom thm_NADD_MULTIPLICATIVE : forall x : nadd, exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x (muln m n)) (muln m (dest_nadd x n)))) (addn (muln B m) B).
Axiom thm_NADD_ADDITIVE : forall x : nadd, exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x (addn m n)) (addn (dest_nadd x m) (dest_nadd x n)))) B.
Axiom thm_NADD_SUC : forall x : nadd, exists B : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x (S n)) (dest_nadd x n))) B.
Axiom thm_NADD_DIST_LEMMA : forall x : nadd, exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x (addn m n)) (dest_nadd x m))) (muln B n).
Axiom thm_NADD_DIST : forall x : nadd, exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x m) (dest_nadd x n))) (muln B (dist (@pair nat nat m n))).
Axiom thm_NADD_ALTMUL : forall x : nadd, forall y : nadd, exists A : nat, exists B : nat, forall n : nat, leqn (dist (@pair nat nat (muln n (dest_nadd x (dest_nadd y n))) (muln (dest_nadd x n) (dest_nadd y n)))) (addn (muln A n) B).
Axiom thm_nadd_eq : forall x : nadd, forall y : nadd, (nadd_eq x y) = (exists B : nat, forall n : nat, leqn (dist (@pair nat nat (dest_nadd x n) (dest_nadd y n))) B).
Axiom thm_NADD_EQ_REFL : forall x : nadd, nadd_eq x x.
Axiom thm_NADD_EQ_SYM : forall x : nadd, forall y : nadd, (nadd_eq x y) = (nadd_eq y x).
Axiom thm_NADD_EQ_TRANS : forall x : nadd, forall y : nadd, forall z : nadd, ((nadd_eq x y) /\ (nadd_eq y z)) -> nadd_eq x z.
Axiom thm_nadd_of_num : forall k : nat, (nadd_of_num k) = (mk_nadd (fun n : nat => muln k n)).
Axiom thm_NADD_OF_NUM : forall k : nat, (dest_nadd (nadd_of_num k)) = (fun n : nat => muln k n).
Axiom thm_NADD_OF_NUM_WELLDEF : forall m : nat, forall n : nat, (m = n) -> nadd_eq (nadd_of_num m) (nadd_of_num n).
Axiom thm_NADD_OF_NUM_EQ : forall m : nat, forall n : nat, (nadd_eq (nadd_of_num m) (nadd_of_num n)) = (m = n).
Axiom thm_nadd_le : forall x : nadd, forall y : nadd, (nadd_le x y) = (exists B : nat, forall n : nat, leqn (dest_nadd x n) (addn (dest_nadd y n) B)).
Axiom thm_NADD_LE_WELLDEF_LEMMA : forall x : nadd, forall x' : nadd, forall y : nadd, forall y' : nadd, ((nadd_eq x x') /\ ((nadd_eq y y') /\ (nadd_le x y))) -> nadd_le x' y'.
Axiom thm_NADD_LE_WELLDEF : forall x : nadd, forall x' : nadd, forall y : nadd, forall y' : nadd, ((nadd_eq x x') /\ (nadd_eq y y')) -> (nadd_le x y) = (nadd_le x' y').
Axiom thm_NADD_LE_REFL : forall x : nadd, nadd_le x x.
Axiom thm_NADD_LE_TRANS : forall x : nadd, forall y : nadd, forall z : nadd, ((nadd_le x y) /\ (nadd_le y z)) -> nadd_le x z.
Axiom thm_NADD_LE_ANTISYM : forall x : nadd, forall y : nadd, ((nadd_le x y) /\ (nadd_le y x)) = (nadd_eq x y).
Axiom thm_NADD_LE_TOTAL_LEMMA : forall x : nadd, forall y : nadd, (~ (nadd_le x y)) -> forall B : nat, exists n : nat, (~ (n = (NUMERAL O))) /\ (ltn (addn (dest_nadd y n) B) (dest_nadd x n)).
Axiom thm_NADD_LE_TOTAL : forall x : nadd, forall y : nadd, (nadd_le x y) \/ (nadd_le y x).
Axiom thm_NADD_ARCH : forall x : nadd, exists n : nat, nadd_le x (nadd_of_num n).
Axiom thm_NADD_OF_NUM_LE : forall m : nat, forall n : nat, (nadd_le (nadd_of_num m) (nadd_of_num n)) = (leqn m n).
Axiom thm_nadd_add : forall x : nadd, forall y : nadd, (nadd_add x y) = (mk_nadd (fun n : nat => addn (dest_nadd x n) (dest_nadd y n))).
Axiom thm_NADD_ADD : forall x : nadd, forall y : nadd, (dest_nadd (nadd_add x y)) = (fun n : nat => addn (dest_nadd x n) (dest_nadd y n)).
Axiom thm_NADD_ADD_WELLDEF : forall x : nadd, forall x' : nadd, forall y : nadd, forall y' : nadd, ((nadd_eq x x') /\ (nadd_eq y y')) -> nadd_eq (nadd_add x y) (nadd_add x' y').
Axiom thm_NADD_ADD_SYM : forall x : nadd, forall y : nadd, nadd_eq (nadd_add x y) (nadd_add y x).
Axiom thm_NADD_ADD_ASSOC : forall x : nadd, forall y : nadd, forall z : nadd, nadd_eq (nadd_add x (nadd_add y z)) (nadd_add (nadd_add x y) z).
Axiom thm_NADD_ADD_LID : forall x : nadd, nadd_eq (nadd_add (nadd_of_num (NUMERAL O)) x) x.
Axiom thm_NADD_ADD_LCANCEL : forall x : nadd, forall y : nadd, forall z : nadd, (nadd_eq (nadd_add x y) (nadd_add x z)) -> nadd_eq y z.
Axiom thm_NADD_LE_ADD : forall x : nadd, forall y : nadd, nadd_le x (nadd_add x y).
Axiom thm_NADD_LE_EXISTS : forall x : nadd, forall y : nadd, (nadd_le x y) -> exists d : nadd, nadd_eq y (nadd_add x d).
Axiom thm_NADD_OF_NUM_ADD : forall m : nat, forall n : nat, nadd_eq (nadd_add (nadd_of_num m) (nadd_of_num n)) (nadd_of_num (addn m n)).
Axiom thm_nadd_mul : forall x : nadd, forall y : nadd, (nadd_mul x y) = (mk_nadd (fun n : nat => dest_nadd x (dest_nadd y n))).
Axiom thm_NADD_MUL : forall x : nadd, forall y : nadd, (dest_nadd (nadd_mul x y)) = (fun n : nat => dest_nadd x (dest_nadd y n)).
Axiom thm_NADD_MUL_SYM : forall x : nadd, forall y : nadd, nadd_eq (nadd_mul x y) (nadd_mul y x).
Axiom thm_NADD_MUL_ASSOC : forall x : nadd, forall y : nadd, forall z : nadd, nadd_eq (nadd_mul x (nadd_mul y z)) (nadd_mul (nadd_mul x y) z).
Axiom thm_NADD_MUL_LID : forall x : nadd, nadd_eq (nadd_mul (nadd_of_num (NUMERAL (BIT1 O))) x) x.
Axiom thm_NADD_LDISTRIB : forall x : nadd, forall y : nadd, forall z : nadd, nadd_eq (nadd_mul x (nadd_add y z)) (nadd_add (nadd_mul x y) (nadd_mul x z)).
Axiom thm_NADD_MUL_WELLDEF_LEMMA : forall x : nadd, forall y : nadd, forall y' : nadd, (nadd_eq y y') -> nadd_eq (nadd_mul x y) (nadd_mul x y').
Axiom thm_NADD_MUL_WELLDEF : forall x : nadd, forall x' : nadd, forall y : nadd, forall y' : nadd, ((nadd_eq x x') /\ (nadd_eq y y')) -> nadd_eq (nadd_mul x y) (nadd_mul x' y').
Axiom thm_NADD_OF_NUM_MUL : forall m : nat, forall n : nat, nadd_eq (nadd_mul (nadd_of_num m) (nadd_of_num n)) (nadd_of_num (muln m n)).
Axiom thm_NADD_LE_0 : forall x : nadd, nadd_le (nadd_of_num (NUMERAL O)) x.
Axiom thm_NADD_EQ_IMP_LE : forall x : nadd, forall y : nadd, (nadd_eq x y) -> nadd_le x y.
Axiom thm_NADD_LE_LMUL : forall x : nadd, forall y : nadd, forall z : nadd, (nadd_le y z) -> nadd_le (nadd_mul x y) (nadd_mul x z).
Axiom thm_NADD_LE_RMUL : forall x : nadd, forall y : nadd, forall z : nadd, (nadd_le x y) -> nadd_le (nadd_mul x z) (nadd_mul y z).
Axiom thm_NADD_LE_RADD : forall x : nadd, forall y : nadd, forall z : nadd, (nadd_le (nadd_add x z) (nadd_add y z)) = (nadd_le x y).
Axiom thm_NADD_LE_LADD : forall x : nadd, forall y : nadd, forall z : nadd, (nadd_le (nadd_add x y) (nadd_add x z)) = (nadd_le y z).
Axiom thm_NADD_RDISTRIB : forall x : nadd, forall y : nadd, forall z : nadd, nadd_eq (nadd_mul (nadd_add x y) z) (nadd_add (nadd_mul x z) (nadd_mul y z)).
Axiom thm_NADD_ARCH_MULT : forall x : nadd, forall k : nat, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists N' : nat, nadd_le (nadd_of_num k) (nadd_mul (nadd_of_num N') x).
Axiom thm_NADD_ARCH_ZERO : forall x : nadd, forall k : nadd, (forall n : nat, nadd_le (nadd_mul (nadd_of_num n) x) k) -> nadd_eq x (nadd_of_num (NUMERAL O)).
Axiom thm_NADD_ARCH_LEMMA : forall x : nadd, forall y : nadd, forall z : nadd, (forall n : nat, nadd_le (nadd_mul (nadd_of_num n) x) (nadd_add (nadd_mul (nadd_of_num n) y) z)) -> nadd_le x y.
Axiom thm_NADD_COMPLETE : forall P : nadd -> Prop, ((exists x : nadd, P x) /\ (exists M : nadd, forall x : nadd, (P x) -> nadd_le x M)) -> exists M : nadd, (forall x : nadd, (P x) -> nadd_le x M) /\ (forall M' : nadd, (forall x : nadd, (P x) -> nadd_le x M') -> nadd_le M M').
Axiom thm_NADD_UBOUND : forall x : nadd, exists B : nat, exists N' : nat, forall n : nat, (leqn N' n) -> leqn (dest_nadd x n) (muln B n).
Axiom thm_NADD_NONZERO : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists N' : nat, forall n : nat, (leqn N' n) -> ~ ((dest_nadd x n) = (NUMERAL O)).
Axiom thm_NADD_LBOUND : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists A : nat, exists N' : nat, forall n : nat, (leqn N' n) -> leqn n (muln A (dest_nadd x n)).
Axiom thm_nadd_rinv : forall x : nadd, (nadd_rinv x) = (fun n : nat => divn (muln n n) (dest_nadd x n)).
Axiom thm_NADD_MUL_LINV_LEMMA0 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists A : nat, exists B : nat, forall n : nat, leqn (nadd_rinv x n) (addn (muln A n) B).
Axiom thm_NADD_MUL_LINV_LEMMA1 : forall x : nadd, forall n : nat, (~ ((dest_nadd x n) = (NUMERAL O))) -> leqn (dist (@pair nat nat (muln (dest_nadd x n) (nadd_rinv x n)) (muln n n))) (dest_nadd x n).
Axiom thm_NADD_MUL_LINV_LEMMA2 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists N' : nat, forall n : nat, (leqn N' n) -> leqn (dist (@pair nat nat (muln (dest_nadd x n) (nadd_rinv x n)) (muln n n))) (dest_nadd x n).
Axiom thm_NADD_MUL_LINV_LEMMA3 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists N' : nat, forall m : nat, forall n : nat, (leqn N' n) -> leqn (dist (@pair nat nat (muln m (muln (dest_nadd x m) (muln (dest_nadd x n) (nadd_rinv x n)))) (muln m (muln (dest_nadd x m) (muln n n))))) (muln m (muln (dest_nadd x m) (dest_nadd x n))).
Axiom thm_NADD_MUL_LINV_LEMMA4 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists N' : nat, forall m : nat, forall n : nat, ((leqn N' m) /\ (leqn N' n)) -> leqn (muln (muln (dest_nadd x m) (dest_nadd x n)) (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m))))) (addn (muln (muln m n) (dist (@pair nat nat (muln m (dest_nadd x n)) (muln n (dest_nadd x m))))) (muln (muln (dest_nadd x m) (dest_nadd x n)) (addn m n))).
Axiom thm_NADD_MUL_LINV_LEMMA5 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists B : nat, exists N' : nat, forall m : nat, forall n : nat, ((leqn N' m) /\ (leqn N' n)) -> leqn (muln (muln (dest_nadd x m) (dest_nadd x n)) (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m))))) (muln B (muln (muln m n) (addn m n))).
Axiom thm_NADD_MUL_LINV_LEMMA6 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists B : nat, exists N' : nat, forall m : nat, forall n : nat, ((leqn N' m) /\ (leqn N' n)) -> leqn (muln (muln m n) (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m))))) (muln B (muln (muln m n) (addn m n))).
Axiom thm_NADD_MUL_LINV_LEMMA7 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists B : nat, exists N' : nat, forall m : nat, forall n : nat, ((leqn N' m) /\ (leqn N' n)) -> leqn (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m)))) (muln B (addn m n)).
Axiom thm_NADD_MUL_LINV_LEMMA7a : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> forall N' : nat, exists A : nat, exists B : nat, forall m : nat, forall n : nat, (leqn m N') -> leqn (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m)))) (addn (muln A n) B).
Axiom thm_NADD_MUL_LINV_LEMMA8 : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> exists B : nat, forall m : nat, forall n : nat, leqn (dist (@pair nat nat (muln m (nadd_rinv x n)) (muln n (nadd_rinv x m)))) (muln B (addn m n)).
Axiom thm_nadd_inv : forall x : nadd, (nadd_inv x) = (@COND nadd (nadd_eq x (nadd_of_num (NUMERAL O))) (nadd_of_num (NUMERAL O)) (mk_nadd (nadd_rinv x))).
Axiom thm_NADD_INV : forall x : nadd, (dest_nadd (nadd_inv x)) = (@COND (nat -> nat) (nadd_eq x (nadd_of_num (NUMERAL O))) (fun n : nat => NUMERAL O) (nadd_rinv x)).
Axiom thm_NADD_MUL_LINV : forall x : nadd, (~ (nadd_eq x (nadd_of_num (NUMERAL O)))) -> nadd_eq (nadd_mul (nadd_inv x) x) (nadd_of_num (NUMERAL (BIT1 O))).
Axiom thm_NADD_INV_0 : nadd_eq (nadd_inv (nadd_of_num (NUMERAL O))) (nadd_of_num (NUMERAL O)).
Axiom thm_NADD_INV_WELLDEF : forall x : nadd, forall y : nadd, (nadd_eq x y) -> nadd_eq (nadd_inv x) (nadd_inv y).
Axiom thm_HREAL_OF_NUM_EQ : forall m : nat, forall n : nat, ((hreal_of_num m) = (hreal_of_num n)) = (m = n).
Axiom thm_HREAL_OF_NUM_LE : forall m : nat, forall n : nat, (hreal_le (hreal_of_num m) (hreal_of_num n)) = (leqn m n).
Axiom thm_HREAL_OF_NUM_ADD : forall m : nat, forall n : nat, (hreal_add (hreal_of_num m) (hreal_of_num n)) = (hreal_of_num (addn m n)).
Axiom thm_HREAL_OF_NUM_MUL : forall m : nat, forall n : nat, (hreal_mul (hreal_of_num m) (hreal_of_num n)) = (hreal_of_num (muln m n)).
Axiom thm_HREAL_LE_REFL : forall x : hreal, hreal_le x x.
Axiom thm_HREAL_LE_TRANS : forall x : hreal, forall y : hreal, forall z : hreal, ((hreal_le x y) /\ (hreal_le y z)) -> hreal_le x z.
Axiom thm_HREAL_LE_ANTISYM : forall x : hreal, forall y : hreal, ((hreal_le x y) /\ (hreal_le y x)) = (x = y).
Axiom thm_HREAL_LE_TOTAL : forall x : hreal, forall y : hreal, (hreal_le x y) \/ (hreal_le y x).
Axiom thm_HREAL_LE_ADD : forall x : hreal, forall y : hreal, hreal_le x (hreal_add x y).
Axiom thm_HREAL_LE_EXISTS : forall x : hreal, forall y : hreal, (hreal_le x y) -> exists d : hreal, y = (hreal_add x d).
Axiom thm_HREAL_ARCH : forall x : hreal, exists n : nat, hreal_le x (hreal_of_num n).
Axiom thm_HREAL_ADD_SYM : forall x : hreal, forall y : hreal, (hreal_add x y) = (hreal_add y x).
Axiom thm_HREAL_ADD_ASSOC : forall x : hreal, forall y : hreal, forall z : hreal, (hreal_add x (hreal_add y z)) = (hreal_add (hreal_add x y) z).
Axiom thm_HREAL_ADD_LID : forall x : hreal, (hreal_add (hreal_of_num (NUMERAL O)) x) = x.
Axiom thm_HREAL_ADD_LCANCEL : forall x : hreal, forall y : hreal, forall z : hreal, ((hreal_add x y) = (hreal_add x z)) -> y = z.
Axiom thm_HREAL_MUL_SYM : forall x : hreal, forall y : hreal, (hreal_mul x y) = (hreal_mul y x).
Axiom thm_HREAL_MUL_ASSOC : forall x : hreal, forall y : hreal, forall z : hreal, (hreal_mul x (hreal_mul y z)) = (hreal_mul (hreal_mul x y) z).
Axiom thm_HREAL_MUL_LID : forall x : hreal, (hreal_mul (hreal_of_num (NUMERAL (BIT1 O))) x) = x.
Axiom thm_HREAL_ADD_LDISTRIB : forall x : hreal, forall y : hreal, forall z : hreal, (hreal_mul x (hreal_add y z)) = (hreal_add (hreal_mul x y) (hreal_mul x z)).
Axiom thm_HREAL_MUL_LINV : forall x : hreal, (~ (x = (hreal_of_num (NUMERAL O)))) -> (hreal_mul (hreal_inv x) x) = (hreal_of_num (NUMERAL (BIT1 O))).
Axiom thm_HREAL_INV_0 : (hreal_inv (hreal_of_num (NUMERAL O))) = (hreal_of_num (NUMERAL O)).
Axiom thm_HREAL_LE_EXISTS_DEF : forall m : hreal, forall n : hreal, (hreal_le m n) = (exists d : hreal, n = (hreal_add m d)).
Axiom thm_HREAL_EQ_ADD_LCANCEL : forall m : hreal, forall n : hreal, forall p : hreal, ((hreal_add m n) = (hreal_add m p)) = (n = p).
Axiom thm_HREAL_EQ_ADD_RCANCEL : forall m : hreal, forall n : hreal, forall p : hreal, ((hreal_add m p) = (hreal_add n p)) = (m = n).
Axiom thm_HREAL_LE_ADD_LCANCEL : forall m : hreal, forall n : hreal, forall p : hreal, (hreal_le (hreal_add m n) (hreal_add m p)) = (hreal_le n p).
Axiom thm_HREAL_LE_ADD_RCANCEL : forall m : hreal, forall n : hreal, forall p : hreal, (hreal_le (hreal_add m p) (hreal_add n p)) = (hreal_le m n).
Axiom thm_HREAL_ADD_RID : forall n : hreal, (hreal_add n (hreal_of_num (NUMERAL O))) = n.
Axiom thm_HREAL_ADD_RDISTRIB : forall m : hreal, forall n : hreal, forall p : hreal, (hreal_mul (hreal_add m n) p) = (hreal_add (hreal_mul m p) (hreal_mul n p)).
Axiom thm_HREAL_MUL_LZERO : forall m : hreal, (hreal_mul (hreal_of_num (NUMERAL O)) m) = (hreal_of_num (NUMERAL O)).
Axiom thm_HREAL_MUL_RZERO : forall m : hreal, (hreal_mul m (hreal_of_num (NUMERAL O))) = (hreal_of_num (NUMERAL O)).
Axiom thm_HREAL_ADD_AC : forall (n : hreal) (m : hreal) (p : hreal), ((hreal_add m n) = (hreal_add n m)) /\ (((hreal_add (hreal_add m n) p) = (hreal_add m (hreal_add n p))) /\ ((hreal_add m (hreal_add n p)) = (hreal_add n (hreal_add m p)))).
Axiom thm_HREAL_LE_ADD2 : forall a : hreal, forall b : hreal, forall c : hreal, forall d : hreal, ((hreal_le a b) /\ (hreal_le c d)) -> hreal_le (hreal_add a c) (hreal_add b d).
Axiom thm_HREAL_LE_MUL_RCANCEL_IMP : forall a : hreal, forall b : hreal, forall c : hreal, (hreal_le a b) -> hreal_le (hreal_mul a c) (hreal_mul b c).
Axiom thm_treal_of_num : forall n : nat, (treal_of_num n) = (@pair hreal hreal (hreal_of_num n) (hreal_of_num (NUMERAL O))).
Axiom thm_treal_neg : forall y : hreal, forall x : hreal, (treal_neg (@pair hreal hreal x y)) = (@pair hreal hreal y x).
Axiom thm_treal_add : forall x1 : hreal, forall x2 : hreal, forall y1 : hreal, forall y2 : hreal, (treal_add (@pair hreal hreal x1 y1) (@pair hreal hreal x2 y2)) = (@pair hreal hreal (hreal_add x1 x2) (hreal_add y1 y2)).
Axiom thm_treal_mul : forall x1 : hreal, forall y2 : hreal, forall y1 : hreal, forall x2 : hreal, (treal_mul (@pair hreal hreal x1 y1) (@pair hreal hreal x2 y2)) = (@pair hreal hreal (hreal_add (hreal_mul x1 x2) (hreal_mul y1 y2)) (hreal_add (hreal_mul x1 y2) (hreal_mul y1 x2))).
Axiom thm_treal_le : forall x1 : hreal, forall y2 : hreal, forall x2 : hreal, forall y1 : hreal, (treal_le (@pair hreal hreal x1 y1) (@pair hreal hreal x2 y2)) = (hreal_le (hreal_add x1 y2) (hreal_add x2 y1)).
Axiom thm_treal_inv : forall y : hreal, forall x : hreal, (treal_inv (@pair hreal hreal x y)) = (@COND (prod hreal hreal) (x = y) (@pair hreal hreal (hreal_of_num (NUMERAL O)) (hreal_of_num (NUMERAL O))) (@COND (prod hreal hreal) (hreal_le y x) (@pair hreal hreal (hreal_inv (@ε hreal (fun d : hreal => x = (hreal_add y d)))) (hreal_of_num (NUMERAL O))) (@pair hreal hreal (hreal_of_num (NUMERAL O)) (hreal_inv (@ε hreal (fun d : hreal => y = (hreal_add x d))))))).
Axiom thm_treal_eq : forall x1 : hreal, forall y2 : hreal, forall x2 : hreal, forall y1 : hreal, (treal_eq (@pair hreal hreal x1 y1) (@pair hreal hreal x2 y2)) = ((hreal_add x1 y2) = (hreal_add x2 y1)).
Axiom thm_TREAL_EQ_REFL : forall x : prod hreal hreal, treal_eq x x.
Axiom thm_TREAL_EQ_SYM : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_eq x y) = (treal_eq y x).
Axiom thm_TREAL_EQ_TRANS : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, ((treal_eq x y) /\ (treal_eq y z)) -> treal_eq x z.
Axiom thm_TREAL_EQ_AP : forall x : prod hreal hreal, forall y : prod hreal hreal, (x = y) -> treal_eq x y.
Axiom thm_TREAL_OF_NUM_EQ : forall m : nat, forall n : nat, (treal_eq (treal_of_num m) (treal_of_num n)) = (m = n).
Axiom thm_TREAL_OF_NUM_LE : forall m : nat, forall n : nat, (treal_le (treal_of_num m) (treal_of_num n)) = (leqn m n).
Axiom thm_TREAL_OF_NUM_ADD : forall m : nat, forall n : nat, treal_eq (treal_add (treal_of_num m) (treal_of_num n)) (treal_of_num (addn m n)).
Axiom thm_TREAL_OF_NUM_MUL : forall m : nat, forall n : nat, treal_eq (treal_mul (treal_of_num m) (treal_of_num n)) (treal_of_num (muln m n)).
Axiom thm_TREAL_ADD_SYM_EQ : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_add x y) = (treal_add y x).
Axiom thm_TREAL_MUL_SYM_EQ : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_mul x y) = (treal_mul y x).
Axiom thm_TREAL_ADD_SYM : forall x : prod hreal hreal, forall y : prod hreal hreal, treal_eq (treal_add x y) (treal_add y x).
Axiom thm_TREAL_ADD_ASSOC : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, treal_eq (treal_add x (treal_add y z)) (treal_add (treal_add x y) z).
Axiom thm_TREAL_ADD_LID : forall x : prod hreal hreal, treal_eq (treal_add (treal_of_num (NUMERAL O)) x) x.
Axiom thm_TREAL_ADD_LINV : forall x : prod hreal hreal, treal_eq (treal_add (treal_neg x) x) (treal_of_num (NUMERAL O)).
Axiom thm_TREAL_MUL_SYM : forall x : prod hreal hreal, forall y : prod hreal hreal, treal_eq (treal_mul x y) (treal_mul y x).
Axiom thm_TREAL_MUL_ASSOC : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, treal_eq (treal_mul x (treal_mul y z)) (treal_mul (treal_mul x y) z).
Axiom thm_TREAL_MUL_LID : forall x : prod hreal hreal, treal_eq (treal_mul (treal_of_num (NUMERAL (BIT1 O))) x) x.
Axiom thm_TREAL_ADD_LDISTRIB : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, treal_eq (treal_mul x (treal_add y z)) (treal_add (treal_mul x y) (treal_mul x z)).
Axiom thm_TREAL_LE_REFL : forall x : prod hreal hreal, treal_le x x.
Axiom thm_TREAL_LE_ANTISYM : forall x : prod hreal hreal, forall y : prod hreal hreal, ((treal_le x y) /\ (treal_le y x)) = (treal_eq x y).
Axiom thm_TREAL_LE_TRANS : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, ((treal_le x y) /\ (treal_le y z)) -> treal_le x z.
Axiom thm_TREAL_LE_TOTAL : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_le x y) \/ (treal_le y x).
Axiom thm_TREAL_LE_LADD_IMP : forall x : prod hreal hreal, forall y : prod hreal hreal, forall z : prod hreal hreal, (treal_le y z) -> treal_le (treal_add x y) (treal_add x z).
Axiom thm_TREAL_LE_MUL : forall x : prod hreal hreal, forall y : prod hreal hreal, ((treal_le (treal_of_num (NUMERAL O)) x) /\ (treal_le (treal_of_num (NUMERAL O)) y)) -> treal_le (treal_of_num (NUMERAL O)) (treal_mul x y).
Axiom thm_TREAL_INV_0 : treal_eq (treal_inv (treal_of_num (NUMERAL O))) (treal_of_num (NUMERAL O)).
Axiom thm_TREAL_MUL_LINV : forall x : prod hreal hreal, (~ (treal_eq x (treal_of_num (NUMERAL O)))) -> treal_eq (treal_mul (treal_inv x) x) (treal_of_num (NUMERAL (BIT1 O))).
Axiom thm_TREAL_OF_NUM_WELLDEF : forall m : nat, forall n : nat, (m = n) -> treal_eq (treal_of_num m) (treal_of_num n).
Axiom thm_TREAL_NEG_WELLDEF : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, (treal_eq x1 x2) -> treal_eq (treal_neg x1) (treal_neg x2).
Axiom thm_TREAL_ADD_WELLDEFR : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, forall y : prod hreal hreal, (treal_eq x1 x2) -> treal_eq (treal_add x1 y) (treal_add x2 y).
Axiom thm_TREAL_ADD_WELLDEF : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, forall y1 : prod hreal hreal, forall y2 : prod hreal hreal, ((treal_eq x1 x2) /\ (treal_eq y1 y2)) -> treal_eq (treal_add x1 y1) (treal_add x2 y2).
Axiom thm_TREAL_MUL_WELLDEFR : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, forall y : prod hreal hreal, (treal_eq x1 x2) -> treal_eq (treal_mul x1 y) (treal_mul x2 y).
Axiom thm_TREAL_MUL_WELLDEF : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, forall y1 : prod hreal hreal, forall y2 : prod hreal hreal, ((treal_eq x1 x2) /\ (treal_eq y1 y2)) -> treal_eq (treal_mul x1 y1) (treal_mul x2 y2).
Axiom thm_TREAL_EQ_IMP_LE : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_eq x y) -> treal_le x y.
Axiom thm_TREAL_LE_WELLDEF : forall x1 : prod hreal hreal, forall x2 : prod hreal hreal, forall y1 : prod hreal hreal, forall y2 : prod hreal hreal, ((treal_eq x1 x2) /\ (treal_eq y1 y2)) -> (treal_le x1 y1) = (treal_le x2 y2).
Axiom thm_TREAL_INV_WELLDEF : forall x : prod hreal hreal, forall y : prod hreal hreal, (treal_eq x y) -> treal_eq (treal_inv x) (treal_inv y).
Axiom thm_REAL_ADD_SYM : forall x : R, forall y : R, (addr x y) = (addr y x).
Axiom thm_REAL_ADD_ASSOC : forall x : R, forall y : R, forall z : R, (addr x (addr y z)) = (addr (addr x y) z).
Axiom thm_REAL_ADD_LID : forall x : R, (addr (R_of_nat (NUMERAL O)) x) = x.
Axiom thm_REAL_ADD_LINV : forall x : R, (addr (oppr x) x) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_MUL_SYM : forall x : R, forall y : R, (mulr x y) = (mulr y x).
Axiom thm_REAL_MUL_ASSOC : forall x : R, forall y : R, forall z : R, (mulr x (mulr y z)) = (mulr (mulr x y) z).
Axiom thm_REAL_MUL_LID : forall x : R, (mulr (R_of_nat (NUMERAL (BIT1 O))) x) = x.
Axiom thm_REAL_ADD_LDISTRIB : forall x : R, forall y : R, forall z : R, (mulr x (addr y z)) = (addr (mulr x y) (mulr x z)).
Axiom thm_REAL_LE_ANTISYM : forall x : R, forall y : R, ((ler x y) /\ (ler y x)) = (x = y).
Axiom thm_REAL_LE_LADD_IMP : forall x : R, forall y : R, forall z : R, (ler y z) -> ler (addr x y) (addr x z).
Axiom thm_REAL_INV_0 : (invr (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_MUL_LINV : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (mulr (invr x) x) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_OF_NUM_EQ : forall m : nat, forall n : nat, ((R_of_nat m) = (R_of_nat n)) = (m = n).
Axiom thm_REAL_OF_NUM_LE : forall m : nat, forall n : nat, (ler (R_of_nat m) (R_of_nat n)) = (leqn m n).
Axiom thm_REAL_OF_NUM_ADD : forall m : nat, forall n : nat, (addr (R_of_nat m) (R_of_nat n)) = (R_of_nat (addn m n)).
Axiom thm_REAL_OF_NUM_MUL : forall m : nat, forall n : nat, (mulr (R_of_nat m) (R_of_nat n)) = (R_of_nat (muln m n)).
Axiom thm_real_sub : forall x : R, forall y : R, (subr x y) = (addr x (oppr y)).
Axiom thm_real_lt : forall y : R, forall x : R, (ltr x y) = (~ (ler y x)).
Axiom thm_real_ge : forall y : R, forall x : R, (ger x y) = (ler y x).
Axiom thm_real_gt : forall y : R, forall x : R, (gtr x y) = (ltr y x).
Axiom thm_real_abs : forall x : R, (normr x) = (@COND R (ler (R_of_nat (NUMERAL O)) x) x (oppr x)).
Axiom thm_real_pow : forall (x : R), ((expr x (NUMERAL O)) = (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall n : nat, (expr x (S n)) = (mulr x (expr x n))).
Axiom thm_real_div : forall x : R, forall y : R, (divr x y) = (mulr x (invr y)).
Axiom thm_real_max : forall n : R, forall m : R, (maxr m n) = (@COND R (ler m n) n m).
Axiom thm_real_min : forall m : R, forall n : R, (minr m n) = (@COND R (ler m n) m n).
Axiom thm_REAL_HREAL_LEMMA1 : exists r : hreal -> R, (forall x : R, (ler (R_of_nat (NUMERAL O)) x) = (exists y : hreal, x = (r y))) /\ (forall y : hreal, forall z : hreal, (hreal_le y z) = (ler (r y) (r z))).
Axiom thm_REAL_HREAL_LEMMA2 : exists h : R -> hreal, exists r : hreal -> R, (forall x : hreal, (h (r x)) = x) /\ ((forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> (r (h x)) = x) /\ ((forall x : hreal, ler (R_of_nat (NUMERAL O)) (r x)) /\ (forall x : hreal, forall y : hreal, (hreal_le x y) = (ler (r x) (r y))))).
Axiom thm_REAL_COMPLETE_SOMEPOS : forall P : R -> Prop, ((exists x : R, (P x) /\ (ler (R_of_nat (NUMERAL O)) x)) /\ (exists M : R, forall x : R, (P x) -> ler x M)) -> exists M : R, (forall x : R, (P x) -> ler x M) /\ (forall M' : R, (forall x : R, (P x) -> ler x M') -> ler M M').
Axiom thm_REAL_COMPLETE : forall P : R -> Prop, ((exists x : R, P x) /\ (exists M : R, forall x : R, (P x) -> ler x M)) -> exists M : R, (forall x : R, (P x) -> ler x M) /\ (forall M' : R, (forall x : R, (P x) -> ler x M') -> ler M M').
Axiom thm_REAL_ADD_AC : forall (n : R) (m : R) (p : R), ((addr m n) = (addr n m)) /\ (((addr (addr m n) p) = (addr m (addr n p))) /\ ((addr m (addr n p)) = (addr n (addr m p)))).
Axiom thm_REAL_ADD_RINV : forall x : R, (addr x (oppr x)) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_EQ_ADD_LCANCEL : forall x : R, forall y : R, forall z : R, ((addr x y) = (addr x z)) = (y = z).
Axiom thm_REAL_EQ_ADD_RCANCEL : forall x : R, forall y : R, forall z : R, ((addr x z) = (addr y z)) = (x = y).
Axiom thm_REAL_MUL_RNEG : forall x : R, forall y : R, (mulr x (oppr y)) = (oppr (mulr x y)).
Axiom thm_REAL_MUL_LNEG : forall x : R, forall y : R, (mulr (oppr x) y) = (oppr (mulr x y)).
Axiom thm_REAL_ADD_RID : forall x : R, (addr x (R_of_nat (NUMERAL O))) = x.
Axiom thm_REAL_LE_LNEG : forall x : R, forall y : R, (ler (oppr x) y) = (ler (R_of_nat (NUMERAL O)) (addr x y)).
Axiom thm_REAL_LE_RNEG : forall x : R, forall y : R, (ler x (oppr y)) = (ler (addr x y) (R_of_nat (NUMERAL O))).
Axiom thm_REAL_OF_NUM_POW : forall x : nat, forall n : nat, (expr (R_of_nat x) n) = (R_of_nat (expn x n)).
Axiom thm_REAL_POW_NEG : forall x : R, forall n : nat, (expr (oppr x) n) = (@COND R (even n) (expr x n) (oppr (expr x n))).
Axiom thm_REAL_ABS_NUM : forall n : nat, (normr (R_of_nat n)) = (R_of_nat n).
Axiom thm_REAL_ABS_NEG : forall x : R, (normr (oppr x)) = (normr x).
Axiom thm_REAL_LTE_TOTAL : forall x : R, forall y : R, (ltr x y) \/ (ler y x).
Axiom thm_REAL_LET_TOTAL : forall x : R, forall y : R, (ler x y) \/ (ltr y x).
Axiom thm_REAL_LET_TRANS : forall x : R, forall y : R, forall z : R, ((ler x y) /\ (ltr y z)) -> ltr x z.
Axiom thm_REAL_LT_TRANS : forall x : R, forall y : R, forall z : R, ((ltr x y) /\ (ltr y z)) -> ltr x z.
Axiom thm_REAL_LE_ADD : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler (R_of_nat (NUMERAL O)) y)) -> ler (R_of_nat (NUMERAL O)) (addr x y).
Axiom thm_REAL_LTE_ANTISYM : forall x : R, forall y : R, ~ ((ltr x y) /\ (ler y x)).
Axiom thm_REAL_LT_REFL : forall x : R, ~ (ltr x x).
Axiom thm_REAL_LET_ADD : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) -> ltr (R_of_nat (NUMERAL O)) (addr x y).
Axiom thm_REAL_ENTIRE : forall x : R, forall y : R, ((mulr x y) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) \/ (y = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_POW_2 : forall x : R, (expr x (NUMERAL (BIT0 (BIT1 O)))) = (mulr x x).
Axiom thm_REAL_POLY_CLAUSES : (forall x : R, forall y : R, forall z : R, (addr x (addr y z)) = (addr (addr x y) z)) /\ ((forall x : R, forall y : R, (addr x y) = (addr y x)) /\ ((forall x : R, (addr (R_of_nat (NUMERAL O)) x) = x) /\ ((forall x : R, forall y : R, forall z : R, (mulr x (mulr y z)) = (mulr (mulr x y) z)) /\ ((forall x : R, forall y : R, (mulr x y) = (mulr y x)) /\ ((forall x : R, (mulr (R_of_nat (NUMERAL (BIT1 O))) x) = x) /\ ((forall x : R, (mulr (R_of_nat (NUMERAL O)) x) = (R_of_nat (NUMERAL O))) /\ ((forall x : R, forall y : R, forall z : R, (mulr x (addr y z)) = (addr (mulr x y) (mulr x z))) /\ ((forall x : R, (expr x (NUMERAL O)) = (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall x : R, forall n : nat, (expr x (S n)) = (mulr x (expr x n))))))))))).
Axiom thm_REAL_POLY_NEG_CLAUSES : (forall x : R, (oppr x) = (mulr (oppr (R_of_nat (NUMERAL (BIT1 O)))) x)) /\ (forall x : R, forall y : R, (subr x y) = (addr x (mulr (oppr (R_of_nat (NUMERAL (BIT1 O)))) y))).
Axiom thm_REAL_POS_LT : forall n : nat, ltr (R_of_nat (NUMERAL O)) (R_of_nat (S n)).
Axiom thm_REAL_OF_NUM_LT : forall m : nat, forall n : nat, (ltr (R_of_nat m) (R_of_nat n)) = (ltn m n).
Axiom thm_REAL_OF_NUM_GE : forall m : nat, forall n : nat, (ger (R_of_nat m) (R_of_nat n)) = (geqn m n).
Axiom thm_REAL_OF_NUM_GT : forall m : nat, forall n : nat, (gtr (R_of_nat m) (R_of_nat n)) = (gtn m n).
Axiom thm_REAL_OF_NUM_MAX : forall m : nat, forall n : nat, (maxr (R_of_nat m) (R_of_nat n)) = (R_of_nat (maxn m n)).
Axiom thm_REAL_OF_NUM_MIN : forall m : nat, forall n : nat, (minr (R_of_nat m) (R_of_nat n)) = (R_of_nat (minn m n)).
Axiom thm_REAL_OF_NUM_SUC : forall n : nat, (addr (R_of_nat n) (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (S n)).
Axiom thm_REAL_OF_NUM_SUB : forall m : nat, forall n : nat, (leqn m n) -> (subr (R_of_nat n) (R_of_nat m)) = (R_of_nat (subn n m)).
Axiom thm_REAL_OF_NUM_SUB_CASES : forall m : nat, forall n : nat, (subr (R_of_nat m) (R_of_nat n)) = (@COND R (leqn n m) (R_of_nat (subn m n)) (oppr (R_of_nat (subn n m)))).
Axiom thm_REAL_OF_NUM_CLAUSES : (forall m : nat, forall n : nat, ((R_of_nat m) = (R_of_nat n)) = (m = n)) /\ ((forall m : nat, forall n : nat, (ger (R_of_nat m) (R_of_nat n)) = (geqn m n)) /\ ((forall m : nat, forall n : nat, (gtr (R_of_nat m) (R_of_nat n)) = (gtn m n)) /\ ((forall m : nat, forall n : nat, (ler (R_of_nat m) (R_of_nat n)) = (leqn m n)) /\ ((forall m : nat, forall n : nat, (ltr (R_of_nat m) (R_of_nat n)) = (ltn m n)) /\ ((forall m : nat, forall n : nat, (maxr (R_of_nat m) (R_of_nat n)) = (R_of_nat (maxn m n))) /\ ((forall m : nat, forall n : nat, (minr (R_of_nat m) (R_of_nat n)) = (R_of_nat (minn m n))) /\ ((forall m : nat, forall n : nat, (addr (R_of_nat m) (R_of_nat n)) = (R_of_nat (addn m n))) /\ ((forall m : nat, forall n : nat, (mulr (R_of_nat m) (R_of_nat n)) = (R_of_nat (muln m n))) /\ (forall x : nat, forall n : nat, (expr (R_of_nat x) n) = (R_of_nat (expn x n))))))))))).
Axiom thm_REAL_MUL_AC : forall (n : R) (m : R) (p : R), ((mulr m n) = (mulr n m)) /\ (((mulr (mulr m n) p) = (mulr m (mulr n p))) /\ ((mulr m (mulr n p)) = (mulr n (mulr m p)))).
Axiom thm_REAL_ADD_RDISTRIB : forall x : R, forall y : R, forall z : R, (mulr (addr x y) z) = (addr (mulr x z) (mulr y z)).
Axiom thm_REAL_LT_LADD_IMP : forall x : R, forall y : R, forall z : R, (ltr y z) -> ltr (addr x y) (addr x z).
Axiom thm_REAL_LT_MUL : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) -> ltr (R_of_nat (NUMERAL O)) (mulr x y).
Axiom thm_REAL_EQ_ADD_LCANCEL_0 : forall x : R, forall y : R, ((addr x y) = x) = (y = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_EQ_ADD_RCANCEL_0 : forall x : R, forall y : R, ((addr x y) = y) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_NOT_EQ : forall x : R, forall y : R, (~ (x = y)) = ((ltr x y) \/ (ltr y x)).
Axiom thm_REAL_LET_ANTISYM : forall x : R, forall y : R, ~ ((ler x y) /\ (ltr y x)).
Axiom thm_REAL_LT_TOTAL : forall x : R, forall y : R, (x = y) \/ ((ltr x y) \/ (ltr y x)).
Axiom thm_REAL_LE_01 : ler (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_LE_ADD2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ler w x) /\ (ler y z)) -> ler (addr w y) (addr x z).
Axiom thm_REAL_LT_LNEG : forall x : R, forall y : R, (ltr (oppr x) y) = (ltr (R_of_nat (NUMERAL O)) (addr x y)).
Axiom thm_REAL_LT_RNEG : forall x : R, forall y : R, (ltr x (oppr y)) = (ltr (addr x y) (R_of_nat (NUMERAL O))).
Axiom thm_REAL_NEG_EQ_0 : forall x : R, ((oppr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_ADD_SUB : forall x : R, forall y : R, (subr (addr x y) x) = y.
Axiom thm_REAL_LE_ADDR : forall x : R, forall y : R, (ler x (addr x y)) = (ler (R_of_nat (NUMERAL O)) y).
Axiom thm_REAL_LE_ADDL : forall x : R, forall y : R, (ler y (addr x y)) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_LT_ADDR : forall x : R, forall y : R, (ltr x (addr x y)) = (ltr (R_of_nat (NUMERAL O)) y).
Axiom thm_REAL_LT_ADDL : forall x : R, forall y : R, (ltr y (addr x y)) = (ltr (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_ADD2_SUB2 : forall a : R, forall b : R, forall c : R, forall d : R, (subr (addr a b) (addr c d)) = (addr (subr a c) (subr b d)).
Axiom thm_REAL_LET_ADD2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ler w x) /\ (ltr y z)) -> ltr (addr w y) (addr x z).
Axiom thm_REAL_EQ_SUB_LADD : forall x : R, forall y : R, forall z : R, (x = (subr y z)) = ((addr x z) = y).
Axiom thm_REAL_EQ_SUB_RADD : forall x : R, forall y : R, forall z : R, ((subr x y) = z) = (x = (addr z y)).
Axiom thm_REAL_ADD_SUB2 : forall x : R, forall y : R, (subr x (addr x y)) = (oppr y).
Axiom thm_REAL_EQ_IMP_LE : forall x : R, forall y : R, (x = y) -> ler x y.
Axiom thm_REAL_DIFFSQ : forall x : R, forall y : R, (mulr (addr x y) (subr x y)) = (subr (mulr x x) (mulr y y)).
Axiom thm_REAL_EQ_NEG2 : forall x : R, forall y : R, ((oppr x) = (oppr y)) = (x = y).
Axiom thm_REAL_ABS_ZERO : forall x : R, ((normr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_ABS_0 : (normr (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_ABS_1 : (normr (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_ABS_TRIANGLE : forall x : R, forall y : R, ler (normr (addr x y)) (addr (normr x) (normr y)).
Axiom thm_REAL_ABS_TRIANGLE_LE : forall x : R, forall y : R, forall z : R, (ler (addr (normr x) (normr (subr y x))) z) -> ler (normr y) z.
Axiom thm_REAL_ABS_TRIANGLE_LT : forall x : R, forall y : R, forall z : R, (ltr (addr (normr x) (normr (subr y x))) z) -> ltr (normr y) z.
Axiom thm_REAL_ABS_POS : forall x : R, ler (R_of_nat (NUMERAL O)) (normr x).
Axiom thm_REAL_ABS_SUB : forall x : R, forall y : R, (normr (subr x y)) = (normr (subr y x)).
Axiom thm_REAL_ABS_NZ : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) = (ltr (R_of_nat (NUMERAL O)) (normr x)).
Axiom thm_REAL_ABS_ABS : forall x : R, (normr (normr x)) = (normr x).
Axiom thm_REAL_ABS_LE : forall x : R, ler x (normr x).
Axiom thm_REAL_ABS_REFL : forall x : R, ((normr x) = x) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_ABS_BETWEEN : forall x : R, forall y : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((ltr (subr x d) y) /\ (ltr y (addr x d)))) = (ltr (normr (subr y x)) d).
Axiom thm_REAL_ABS_BOUND : forall x : R, forall y : R, forall d : R, (ltr (normr (subr x y)) d) -> ltr y (addr x d).
Axiom thm_REAL_ABS_STILLNZ : forall x : R, forall y : R, (ltr (normr (subr x y)) (normr y)) -> ~ (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_ABS_CASES : forall x : R, (x = (R_of_nat (NUMERAL O))) \/ (ltr (R_of_nat (NUMERAL O)) (normr x)).
Axiom thm_REAL_ABS_BETWEEN1 : forall x : R, forall y : R, forall z : R, ((ltr x z) /\ (ltr (normr (subr y x)) (subr z x))) -> ltr y z.
Axiom thm_REAL_ABS_SIGN : forall x : R, forall y : R, (ltr (normr (subr x y)) y) -> ltr (R_of_nat (NUMERAL O)) x.
Axiom thm_REAL_ABS_SIGN2 : forall x : R, forall y : R, (ltr (normr (subr x y)) (oppr y)) -> ltr x (R_of_nat (NUMERAL O)).
Axiom thm_REAL_ABS_CIRCLE : forall x : R, forall y : R, forall h : R, (ltr (normr h) (subr (normr y) (normr x))) -> ltr (normr (addr x h)) (normr y).
Axiom thm_REAL_ABS_SUB_ABS : forall x : R, forall y : R, ler (normr (subr (normr x) (normr y))) (normr (subr x y)).
Axiom thm_REAL_ABS_BETWEEN2 : forall x0 : R, forall x : R, forall y0 : R, forall y : R, ((ltr x0 y0) /\ ((ltr (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (normr (subr x x0))) (subr y0 x0)) /\ (ltr (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (normr (subr y y0))) (subr y0 x0)))) -> ltr x y.
Axiom thm_REAL_ABS_BOUNDS : forall x : R, forall k : R, (ler (normr x) k) = ((ler (oppr k) x) /\ (ler x k)).
Axiom thm_REAL_BOUNDS_LE : forall x : R, forall k : R, ((ler (oppr k) x) /\ (ler x k)) = (ler (normr x) k).
Axiom thm_REAL_BOUNDS_LT : forall x : R, forall k : R, ((ltr (oppr k) x) /\ (ltr x k)) = (ltr (normr x) k).
Axiom thm_REAL_MIN_MAX : forall x : R, forall y : R, (minr x y) = (oppr (maxr (oppr x) (oppr y))).
Axiom thm_REAL_MAX_MIN : forall x : R, forall y : R, (maxr x y) = (oppr (minr (oppr x) (oppr y))).
Axiom thm_REAL_MAX_MAX : forall x : R, forall y : R, (ler x (maxr x y)) /\ (ler y (maxr x y)).
Axiom thm_REAL_MIN_MIN : forall x : R, forall y : R, (ler (minr x y) x) /\ (ler (minr x y) y).
Axiom thm_REAL_MAX_SYM : forall x : R, forall y : R, (maxr x y) = (maxr y x).
Axiom thm_REAL_MIN_SYM : forall x : R, forall y : R, (minr x y) = (minr y x).
Axiom thm_REAL_LE_MAX : forall x : R, forall y : R, forall z : R, (ler z (maxr x y)) = ((ler z x) \/ (ler z y)).
Axiom thm_REAL_LE_MIN : forall x : R, forall y : R, forall z : R, (ler z (minr x y)) = ((ler z x) /\ (ler z y)).
Axiom thm_REAL_LT_MAX : forall x : R, forall y : R, forall z : R, (ltr z (maxr x y)) = ((ltr z x) \/ (ltr z y)).
Axiom thm_REAL_LT_MIN : forall x : R, forall y : R, forall z : R, (ltr z (minr x y)) = ((ltr z x) /\ (ltr z y)).
Axiom thm_REAL_MAX_LE : forall x : R, forall y : R, forall z : R, (ler (maxr x y) z) = ((ler x z) /\ (ler y z)).
Axiom thm_REAL_MIN_LE : forall x : R, forall y : R, forall z : R, (ler (minr x y) z) = ((ler x z) \/ (ler y z)).
Axiom thm_REAL_MAX_LT : forall x : R, forall y : R, forall z : R, (ltr (maxr x y) z) = ((ltr x z) /\ (ltr y z)).
Axiom thm_REAL_MIN_LT : forall x : R, forall y : R, forall z : R, (ltr (minr x y) z) = ((ltr x z) \/ (ltr y z)).
Axiom thm_REAL_MAX_ASSOC : forall x : R, forall y : R, forall z : R, (maxr x (maxr y z)) = (maxr (maxr x y) z).
Axiom thm_REAL_MIN_ASSOC : forall x : R, forall y : R, forall z : R, (minr x (minr y z)) = (minr (minr x y) z).
Axiom thm_REAL_MAX_ACI : forall (z : R) (x : R) (y : R), ((maxr x y) = (maxr y x)) /\ (((maxr (maxr x y) z) = (maxr x (maxr y z))) /\ (((maxr x (maxr y z)) = (maxr y (maxr x z))) /\ (((maxr x x) = x) /\ ((maxr x (maxr x y)) = (maxr x y))))).
Axiom thm_REAL_MIN_ACI : forall (z : R) (x : R) (y : R), ((minr x y) = (minr y x)) /\ (((minr (minr x y) z) = (minr x (minr y z))) /\ (((minr x (minr y z)) = (minr y (minr x z))) /\ (((minr x x) = x) /\ ((minr x (minr x y)) = (minr x y))))).
Axiom thm_REAL_ABS_MUL : forall x : R, forall y : R, (normr (mulr x y)) = (mulr (normr x) (normr y)).
Axiom thm_REAL_POW_LE : forall x : R, forall n : nat, (ler (R_of_nat (NUMERAL O)) x) -> ler (R_of_nat (NUMERAL O)) (expr x n).
Axiom thm_REAL_POW_LT : forall x : R, forall n : nat, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (expr x n).
Axiom thm_REAL_ABS_POW : forall x : R, forall n : nat, (normr (expr x n)) = (expr (normr x) n).
Axiom thm_REAL_LE_LMUL : forall x : R, forall y : R, forall z : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler y z)) -> ler (mulr x y) (mulr x z).
Axiom thm_REAL_LE_RMUL : forall x : R, forall y : R, forall z : R, ((ler x y) /\ (ler (R_of_nat (NUMERAL O)) z)) -> ler (mulr x z) (mulr y z).
Axiom thm_REAL_LT_LMUL : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr y z)) -> ltr (mulr x y) (mulr x z).
Axiom thm_REAL_LT_RMUL : forall x : R, forall y : R, forall z : R, ((ltr x y) /\ (ltr (R_of_nat (NUMERAL O)) z)) -> ltr (mulr x z) (mulr y z).
Axiom thm_REAL_EQ_MUL_LCANCEL : forall x : R, forall y : R, forall z : R, ((mulr x y) = (mulr x z)) = ((x = (R_of_nat (NUMERAL O))) \/ (y = z)).
Axiom thm_REAL_EQ_MUL_RCANCEL : forall x : R, forall y : R, forall z : R, ((mulr x z) = (mulr y z)) = ((x = y) \/ (z = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_MUL_LINV_UNIQ : forall x : R, forall y : R, ((mulr x y) = (R_of_nat (NUMERAL (BIT1 O)))) -> (invr y) = x.
Axiom thm_REAL_MUL_RINV_UNIQ : forall x : R, forall y : R, ((mulr x y) = (R_of_nat (NUMERAL (BIT1 O)))) -> (invr x) = y.
Axiom thm_REAL_INV_INV : forall x : R, (invr (invr x)) = x.
Axiom thm_REAL_EQ_INV2 : forall x : R, forall y : R, ((invr x) = (invr y)) = (x = y).
Axiom thm_REAL_INV_EQ_0 : forall x : R, ((invr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_LT_INV : forall x : R, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (invr x).
Axiom thm_REAL_LT_INV_EQ : forall x : R, (ltr (R_of_nat (NUMERAL O)) (invr x)) = (ltr (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_INV_NEG : forall x : R, (invr (oppr x)) = (oppr (invr x)).
Axiom thm_REAL_LE_INV_EQ : forall x : R, (ler (R_of_nat (NUMERAL O)) (invr x)) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_LE_INV : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> ler (R_of_nat (NUMERAL O)) (invr x).
Axiom thm_REAL_INV_1 : (invr (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_INV_EQ_1 : forall x : R, ((invr x) = (R_of_nat (NUMERAL (BIT1 O)))) = (x = (R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_REAL_DIV_1 : forall x : R, (divr x (R_of_nat (NUMERAL (BIT1 O)))) = x.
Axiom thm_REAL_DIV_REFL : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (divr x x) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_DIV_RMUL : forall x : R, forall y : R, (~ (y = (R_of_nat (NUMERAL O)))) -> (mulr (divr x y) y) = x.
Axiom thm_REAL_DIV_LMUL : forall x : R, forall y : R, (~ (y = (R_of_nat (NUMERAL O)))) -> (mulr y (divr x y)) = x.
Axiom thm_REAL_DIV_EQ_1 : forall x : R, forall y : R, ((divr x y) = (R_of_nat (NUMERAL (BIT1 O)))) = ((x = y) /\ ((~ (x = (R_of_nat (NUMERAL O)))) /\ (~ (y = (R_of_nat (NUMERAL O)))))).
Axiom thm_REAL_ABS_INV : forall x : R, (normr (invr x)) = (invr (normr x)).
Axiom thm_REAL_ABS_DIV : forall x : R, forall y : R, (normr (divr x y)) = (divr (normr x) (normr y)).
Axiom thm_REAL_INV_MUL : forall x : R, forall y : R, (invr (mulr x y)) = (mulr (invr x) (invr y)).
Axiom thm_REAL_INV_DIV : forall x : R, forall y : R, (invr (divr x y)) = (divr y x).
Axiom thm_REAL_POW_MUL : forall x : R, forall y : R, forall n : nat, (expr (mulr x y) n) = (mulr (expr x n) (expr y n)).
Axiom thm_REAL_POW_INV : forall x : R, forall n : nat, (expr (invr x) n) = (invr (expr x n)).
Axiom thm_REAL_INV_POW : forall x : R, forall n : nat, (invr (expr x n)) = (expr (invr x) n).
Axiom thm_REAL_POW_DIV : forall x : R, forall y : R, forall n : nat, (expr (divr x y) n) = (divr (expr x n) (expr y n)).
Axiom thm_REAL_DIV_EQ_0 : forall x : R, forall y : R, ((divr x y) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) \/ (y = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_POW_ADD : forall x : R, forall m : nat, forall n : nat, (expr x (addn m n)) = (mulr (expr x m) (expr x n)).
Axiom thm_REAL_POW_NZ : forall x : R, forall n : nat, (~ (x = (R_of_nat (NUMERAL O)))) -> ~ ((expr x n) = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_POW_SUB : forall x : R, forall m : nat, forall n : nat, ((~ (x = (R_of_nat (NUMERAL O)))) /\ (leqn m n)) -> (expr x (subn n m)) = (divr (expr x n) (expr x m)).
Axiom thm_REAL_LT_LCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (mulr x y) (mulr x z))) -> ltr y z.
Axiom thm_REAL_LT_RCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) z) /\ (ltr (mulr x z) (mulr y z))) -> ltr x y.
Axiom thm_REAL_LE_LCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler (mulr x y) (mulr x z))) -> ler y z.
Axiom thm_REAL_LE_RCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) z) /\ (ler (mulr x z) (mulr y z))) -> ler x y.
Axiom thm_REAL_LE_LMUL_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ler (mulr z x) (mulr z y)) = (ler x y).
Axiom thm_REAL_LE_MUL_EQ : (forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) x) -> (ler (R_of_nat (NUMERAL O)) (mulr x y)) = (ler (R_of_nat (NUMERAL O)) y)) /\ (forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) y) -> (ler (R_of_nat (NUMERAL O)) (mulr x y)) = (ler (R_of_nat (NUMERAL O)) x)).
Axiom thm_REAL_LT_MUL_EQ : (forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) x) -> (ltr (R_of_nat (NUMERAL O)) (mulr x y)) = (ltr (R_of_nat (NUMERAL O)) y)) /\ (forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) y) -> (ltr (R_of_nat (NUMERAL O)) (mulr x y)) = (ltr (R_of_nat (NUMERAL O)) x)).
Axiom thm_REAL_MUL_POS_LT : forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) (mulr x y)) = (((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) \/ ((ltr x (R_of_nat (NUMERAL O))) /\ (ltr y (R_of_nat (NUMERAL O))))).
Axiom thm_REAL_MUL_POS_LE : forall x : R, forall y : R, (ler (R_of_nat (NUMERAL O)) (mulr x y)) = ((x = (R_of_nat (NUMERAL O))) \/ ((y = (R_of_nat (NUMERAL O))) \/ (((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) \/ ((ltr x (R_of_nat (NUMERAL O))) /\ (ltr y (R_of_nat (NUMERAL O))))))).
Axiom thm_REAL_LE_RDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ler x (divr y z)) = (ler (mulr x z) y).
Axiom thm_REAL_LE_LDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ler (divr x z) y) = (ler x (mulr y z)).
Axiom thm_REAL_LT_RDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr x (divr y z)) = (ltr (mulr x z) y).
Axiom thm_REAL_LT_LDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr (divr x z) y) = (ltr x (mulr y z)).
Axiom thm_REAL_EQ_RDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (x = (divr y z)) = ((mulr x z) = y).
Axiom thm_REAL_EQ_LDIV_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> ((divr x z) = y) = (x = (mulr y z)).
Axiom thm_REAL_LT_DIV2_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr (divr x z) (divr y z)) = (ltr x y).
Axiom thm_REAL_LE_DIV2_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ler (divr x z) (divr y z)) = (ler x y).
Axiom thm_REAL_MUL_2 : forall x : R, (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x) = (addr x x).
Axiom thm_REAL_POW_EQ_0 : forall x : R, forall n : nat, ((expr x n) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) /\ (~ (n = (NUMERAL O)))).
Axiom thm_REAL_LE_MUL2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ler (R_of_nat (NUMERAL O)) w) /\ ((ler w x) /\ ((ler (R_of_nat (NUMERAL O)) y) /\ (ler y z)))) -> ler (mulr w y) (mulr x z).
Axiom thm_REAL_LT_MUL2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ler (R_of_nat (NUMERAL O)) w) /\ ((ltr w x) /\ ((ler (R_of_nat (NUMERAL O)) y) /\ (ltr y z)))) -> ltr (mulr w y) (mulr x z).
Axiom thm_REAL_LT_SQUARE : forall x : R, (ltr (R_of_nat (NUMERAL O)) (mulr x x)) = (~ (x = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_POW_1 : forall x : R, (expr x (NUMERAL (BIT1 O))) = x.
Axiom thm_REAL_POW_ONE : forall n : nat, (expr (R_of_nat (NUMERAL (BIT1 O))) n) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_LT_INV2 : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x y)) -> ltr (invr y) (invr x).
Axiom thm_REAL_LE_INV2 : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler x y)) -> ler (invr y) (invr x).
Axiom thm_REAL_LT_LINV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) y) /\ (ltr (invr y) x)) -> ltr (invr x) y.
Axiom thm_REAL_LT_RINV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x (invr y))) -> ltr y (invr x).
Axiom thm_REAL_LE_LINV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) y) /\ (ler (invr y) x)) -> ler (invr x) y.
Axiom thm_REAL_LE_RINV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler x (invr y))) -> ler y (invr x).
Axiom thm_REAL_INV_LE_1 : forall x : R, (ler (R_of_nat (NUMERAL (BIT1 O))) x) -> ler (invr x) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_INV_1_LE : forall x : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler x (R_of_nat (NUMERAL (BIT1 O))))) -> ler (R_of_nat (NUMERAL (BIT1 O))) (invr x).
Axiom thm_REAL_INV_LT_1 : forall x : R, (ltr (R_of_nat (NUMERAL (BIT1 O))) x) -> ltr (invr x) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_INV_1_LT : forall x : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x (R_of_nat (NUMERAL (BIT1 O))))) -> ltr (R_of_nat (NUMERAL (BIT1 O))) (invr x).
Axiom thm_REAL_SUB_INV : forall x : R, forall y : R, ((~ (x = (R_of_nat (NUMERAL O)))) /\ (~ (y = (R_of_nat (NUMERAL O))))) -> (subr (invr x) (invr y)) = (divr (subr y x) (mulr x y)).
Axiom thm_REAL_DOWN : forall d : R, (ltr (R_of_nat (NUMERAL O)) d) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (ltr e d).
Axiom thm_REAL_DOWN2 : forall d1 : R, forall d2 : R, ((ltr (R_of_nat (NUMERAL O)) d1) /\ (ltr (R_of_nat (NUMERAL O)) d2)) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ ((ltr e d1) /\ (ltr e d2)).
Axiom thm_REAL_POW_LE2 : forall n : nat, forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler x y)) -> ler (expr x n) (expr y n).
Axiom thm_REAL_POW_LE_1 : forall n : nat, forall x : R, (ler (R_of_nat (NUMERAL (BIT1 O))) x) -> ler (R_of_nat (NUMERAL (BIT1 O))) (expr x n).
Axiom thm_REAL_POW_1_LE : forall n : nat, forall x : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler x (R_of_nat (NUMERAL (BIT1 O))))) -> ler (expr x n) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_POW_MONO : forall m : nat, forall n : nat, forall x : R, ((ler (R_of_nat (NUMERAL (BIT1 O))) x) /\ (leqn m n)) -> ler (expr x m) (expr x n).
Axiom thm_REAL_POW_LT2 : forall n : nat, forall x : R, forall y : R, ((~ (n = (NUMERAL O))) /\ ((ler (R_of_nat (NUMERAL O)) x) /\ (ltr x y))) -> ltr (expr x n) (expr y n).
Axiom thm_REAL_POW_LT_1 : forall n : nat, forall x : R, ((~ (n = (NUMERAL O))) /\ (ltr (R_of_nat (NUMERAL (BIT1 O))) x)) -> ltr (R_of_nat (NUMERAL (BIT1 O))) (expr x n).
Axiom thm_REAL_POW_1_LT : forall n : nat, forall x : R, ((~ (n = (NUMERAL O))) /\ ((ler (R_of_nat (NUMERAL O)) x) /\ (ltr x (R_of_nat (NUMERAL (BIT1 O)))))) -> ltr (expr x n) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_POW_MONO_LT : forall m : nat, forall n : nat, forall x : R, ((ltr (R_of_nat (NUMERAL (BIT1 O))) x) /\ (ltn m n)) -> ltr (expr x m) (expr x n).
Axiom thm_REAL_POW_POW : forall x : R, forall m : nat, forall n : nat, (expr (expr x m) n) = (expr x (muln m n)).
Axiom thm_REAL_EQ_RCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((~ (z = (R_of_nat (NUMERAL O)))) /\ ((mulr x z) = (mulr y z))) -> x = y.
Axiom thm_REAL_EQ_LCANCEL_IMP : forall x : R, forall y : R, forall z : R, ((~ (z = (R_of_nat (NUMERAL O)))) /\ ((mulr z x) = (mulr z y))) -> x = y.
Axiom thm_REAL_LT_DIV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) -> ltr (R_of_nat (NUMERAL O)) (divr x y).
Axiom thm_REAL_LE_DIV : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler (R_of_nat (NUMERAL O)) y)) -> ler (R_of_nat (NUMERAL O)) (divr x y).
Axiom thm_REAL_DIV_POW2 : forall x : R, forall m : nat, forall n : nat, (~ (x = (R_of_nat (NUMERAL O)))) -> (divr (expr x m) (expr x n)) = (@COND R (leqn n m) (expr x (subn m n)) (invr (expr x (subn n m)))).
Axiom thm_REAL_DIV_POW2_ALT : forall x : R, forall m : nat, forall n : nat, (~ (x = (R_of_nat (NUMERAL O)))) -> (divr (expr x m) (expr x n)) = (@COND R (ltn n m) (expr x (subn m n)) (invr (expr x (subn n m)))).
Axiom thm_REAL_LT_POW2 : forall n : nat, ltr (R_of_nat (NUMERAL O)) (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_REAL_LE_POW2 : forall n : nat, ler (R_of_nat (NUMERAL (BIT1 O))) (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_REAL_POW2_ABS : forall x : R, (expr (normr x) (NUMERAL (BIT0 (BIT1 O)))) = (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_REAL_LE_SQUARE_ABS : forall x : R, forall y : R, (ler (normr x) (normr y)) = (ler (expr x (NUMERAL (BIT0 (BIT1 O)))) (expr y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_REAL_LT_SQUARE_ABS : forall x : R, forall y : R, (ltr (normr x) (normr y)) = (ltr (expr x (NUMERAL (BIT0 (BIT1 O)))) (expr y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_REAL_EQ_SQUARE_ABS : forall x : R, forall y : R, ((normr x) = (normr y)) = ((expr x (NUMERAL (BIT0 (BIT1 O)))) = (expr y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_REAL_LE_POW_2 : forall x : R, ler (R_of_nat (NUMERAL O)) (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_REAL_LT_POW_2 : forall x : R, (ltr (R_of_nat (NUMERAL O)) (expr x (NUMERAL (BIT0 (BIT1 O))))) = (~ (x = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_SOS_EQ_0 : forall x : R, forall y : R, ((addr (expr x (NUMERAL (BIT0 (BIT1 O)))) (expr y (NUMERAL (BIT0 (BIT1 O))))) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) /\ (y = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_POW_ZERO : forall n : nat, (expr (R_of_nat (NUMERAL O)) n) = (@COND R (n = (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))).
Axiom thm_REAL_POW_MONO_INV : forall m : nat, forall n : nat, forall x : R, ((ler (R_of_nat (NUMERAL O)) x) /\ ((ler x (R_of_nat (NUMERAL (BIT1 O)))) /\ (leqn n m))) -> ler (expr x m) (expr x n).
Axiom thm_REAL_POW_LE2_REV : forall n : nat, forall x : R, forall y : R, ((~ (n = (NUMERAL O))) /\ ((ler (R_of_nat (NUMERAL O)) y) /\ (ler (expr x n) (expr y n)))) -> ler x y.
Axiom thm_REAL_POW_LT2_REV : forall n : nat, forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) y) /\ (ltr (expr x n) (expr y n))) -> ltr x y.
Axiom thm_REAL_POW_EQ : forall n : nat, forall x : R, forall y : R, ((~ (n = (NUMERAL O))) /\ ((ler (R_of_nat (NUMERAL O)) x) /\ ((ler (R_of_nat (NUMERAL O)) y) /\ ((expr x n) = (expr y n))))) -> x = y.
Axiom thm_REAL_POW_EQ_ABS : forall n : nat, forall x : R, forall y : R, ((~ (n = (NUMERAL O))) /\ ((expr x n) = (expr y n))) -> (normr x) = (normr y).
Axiom thm_REAL_POW_EQ_1_IMP : forall x : R, forall n : nat, ((~ (n = (NUMERAL O))) /\ ((expr x n) = (R_of_nat (NUMERAL (BIT1 O))))) -> (normr x) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_POW_EQ_1 : forall x : R, forall n : nat, ((expr x n) = (R_of_nat (NUMERAL (BIT1 O)))) = ((((normr x) = (R_of_nat (NUMERAL (BIT1 O)))) /\ ((ltr x (R_of_nat (NUMERAL O))) -> even n)) \/ (n = (NUMERAL O))).
Axiom thm_REAL_POW_LT2_ODD : forall n : nat, forall x : R, forall y : R, ((ltr x y) /\ (oddn n)) -> ltr (expr x n) (expr y n).
Axiom thm_REAL_POW_LE2_ODD : forall n : nat, forall x : R, forall y : R, ((ler x y) /\ (oddn n)) -> ler (expr x n) (expr y n).
Axiom thm_REAL_POW_LT2_ODD_EQ : forall n : nat, forall x : R, forall y : R, (oddn n) -> (ltr (expr x n) (expr y n)) = (ltr x y).
Axiom thm_REAL_POW_LE2_ODD_EQ : forall n : nat, forall x : R, forall y : R, (oddn n) -> (ler (expr x n) (expr y n)) = (ler x y).
Axiom thm_REAL_POW_EQ_ODD_EQ : forall n : nat, forall x : R, forall y : R, (oddn n) -> ((expr x n) = (expr y n)) = (x = y).
Axiom thm_REAL_POW_EQ_ODD : forall n : nat, forall x : R, forall y : R, ((oddn n) /\ ((expr x n) = (expr y n))) -> x = y.
Axiom thm_REAL_POW_EQ_EQ : forall n : nat, forall x : R, forall y : R, ((expr x n) = (expr y n)) = (@COND Prop (even n) ((n = (NUMERAL O)) \/ ((normr x) = (normr y))) (x = y)).
Axiom thm_REAL_EVENPOW_ABS : forall x : R, forall n : nat, (even n) -> (expr (normr x) n) = (expr x n).
Axiom thm_REAL_OF_NUM_MOD : forall m : nat, forall n : nat, (R_of_nat (modn m n)) = (subr (R_of_nat m) (mulr (R_of_nat (divn m n)) (R_of_nat n))).
Axiom thm_REAL_OF_NUM_DIV : forall m : nat, forall n : nat, (R_of_nat (divn m n)) = (subr (divr (R_of_nat m) (R_of_nat n)) (divr (R_of_nat (modn m n)) (R_of_nat n))).
Axiom thm_REAL_CONVEX_BOUND2_LT : forall (b : R), forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ltr x a) /\ ((ltr y b) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ltr (addr (mulr u x) (mulr v y)) (addr (mulr u a) (mulr v b)).
Axiom thm_REAL_CONVEX_BOUND2_LE : forall (b : R), forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ler x a) /\ ((ler y b) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (addr (mulr u x) (mulr v y)) (addr (mulr u a) (mulr v b)).
Axiom thm_REAL_CONVEX_BOUND_LT : forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ltr x a) /\ ((ltr y a) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ltr (addr (mulr u x) (mulr v y)) a.
Axiom thm_REAL_CONVEX_BOUND_LE : forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ler x a) /\ ((ler y a) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler (addr (mulr u x) (mulr v y)) a.
Axiom thm_REAL_CONVEX_BOUND_GT : forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ltr a x) /\ ((ltr a y) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ltr a (addr (mulr u x) (mulr v y)).
Axiom thm_REAL_CONVEX_BOUND_GE : forall x : R, forall y : R, forall a : R, forall u : R, forall v : R, ((ler a x) /\ ((ler a y) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))) -> ler a (addr (mulr u x) (mulr v y)).
Axiom thm_REAL_CONVEX_BOUNDS_LE : forall x : R, forall y : R, forall a : R, forall b : R, forall u : R, forall v : R, ((ler a x) /\ ((ler x b) /\ ((ler a y) /\ ((ler y b) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))))) -> (ler a (addr (mulr u x) (mulr v y))) /\ (ler (addr (mulr u x) (mulr v y)) b).
Axiom thm_REAL_CONVEX_BOUNDS_LT : forall x : R, forall y : R, forall a : R, forall b : R, forall u : R, forall v : R, ((ltr a x) /\ ((ltr x b) /\ ((ltr a y) /\ ((ltr y b) /\ ((ler (R_of_nat (NUMERAL O)) u) /\ ((ler (R_of_nat (NUMERAL O)) v) /\ ((addr u v) = (R_of_nat (NUMERAL (BIT1 O)))))))))) -> (ltr a (addr (mulr u x) (mulr v y))) /\ (ltr (addr (mulr u x) (mulr v y)) b).
Axiom thm_REAL_ARCH_LT : forall x : R, exists n : nat, ltr x (R_of_nat n).
Axiom thm_REAL_ARCH_INV : forall e : R, (ltr (R_of_nat (NUMERAL O)) e) = (exists n : nat, (~ (n = (NUMERAL O))) /\ ((ltr (R_of_nat (NUMERAL O)) (invr (R_of_nat n))) /\ (ltr (invr (R_of_nat n)) e))).
Axiom thm_REAL_ARCH_POW_INV : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) y) /\ (ltr x (R_of_nat (NUMERAL (BIT1 O))))) -> exists n : nat, ltr (expr x n) y.
Axiom thm_real_sgn : forall x : R, (sgr x) = (@COND R (ltr (R_of_nat (NUMERAL O)) x) (R_of_nat (NUMERAL (BIT1 O))) (@COND R (ltr x (R_of_nat (NUMERAL O))) (oppr (R_of_nat (NUMERAL (BIT1 O)))) (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_SGN_0 : (sgr (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_SGN_NEG : forall x : R, (sgr (oppr x)) = (oppr (sgr x)).
Axiom thm_REAL_SGN_ABS : forall x : R, (mulr (sgr x) (normr x)) = x.
Axiom thm_REAL_SGN_ABS_ALT : forall x : R, (mulr (sgr x) x) = (normr x).
Axiom thm_REAL_EQ_SGN_ABS : forall x : R, forall y : R, (x = y) = (((sgr x) = (sgr y)) /\ ((normr x) = (normr y))).
Axiom thm_REAL_ABS_SGN : forall x : R, (normr (sgr x)) = (sgr (normr x)).
Axiom thm_REAL_SGN : forall x : R, (sgr x) = (divr x (normr x)).
Axiom thm_REAL_SGN_MUL : forall x : R, forall y : R, (sgr (mulr x y)) = (mulr (sgr x) (sgr y)).
Axiom thm_REAL_SGN_INV : forall x : R, (sgr (invr x)) = (sgr x).
Axiom thm_REAL_SGN_DIV : forall x : R, forall y : R, (sgr (divr x y)) = (divr (sgr x) (sgr y)).
Axiom thm_REAL_SGN_EQ : (forall x : R, ((sgr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O)))) /\ ((forall x : R, ((sgr x) = (R_of_nat (NUMERAL (BIT1 O)))) = (gtr x (R_of_nat (NUMERAL O)))) /\ (forall x : R, ((sgr x) = (oppr (R_of_nat (NUMERAL (BIT1 O))))) = (ltr x (R_of_nat (NUMERAL O))))).
Axiom thm_REAL_SGN_CASES : forall x : R, ((sgr x) = (R_of_nat (NUMERAL O))) \/ (((sgr x) = (R_of_nat (NUMERAL (BIT1 O)))) \/ ((sgr x) = (oppr (R_of_nat (NUMERAL (BIT1 O)))))).
Axiom thm_REAL_SGN_INEQS : (forall x : R, (ler (R_of_nat (NUMERAL O)) (sgr x)) = (ler (R_of_nat (NUMERAL O)) x)) /\ ((forall x : R, (ltr (R_of_nat (NUMERAL O)) (sgr x)) = (ltr (R_of_nat (NUMERAL O)) x)) /\ ((forall x : R, (ger (R_of_nat (NUMERAL O)) (sgr x)) = (ger (R_of_nat (NUMERAL O)) x)) /\ ((forall x : R, (gtr (R_of_nat (NUMERAL O)) (sgr x)) = (gtr (R_of_nat (NUMERAL O)) x)) /\ ((forall x : R, ((R_of_nat (NUMERAL O)) = (sgr x)) = ((R_of_nat (NUMERAL O)) = x)) /\ ((forall x : R, (ler (sgr x) (R_of_nat (NUMERAL O))) = (ler x (R_of_nat (NUMERAL O)))) /\ ((forall x : R, (ltr (sgr x) (R_of_nat (NUMERAL O))) = (ltr x (R_of_nat (NUMERAL O)))) /\ ((forall x : R, (ger (sgr x) (R_of_nat (NUMERAL O))) = (ger x (R_of_nat (NUMERAL O)))) /\ ((forall x : R, (gtr (sgr x) (R_of_nat (NUMERAL O))) = (gtr x (R_of_nat (NUMERAL O)))) /\ (forall x : R, ((sgr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O)))))))))))).
Axiom thm_REAL_SGN_POW : forall x : R, forall n : nat, (sgr (expr x n)) = (expr (sgr x) n).
Axiom thm_REAL_SGN_POW_2 : forall x : R, (sgr (expr x (NUMERAL (BIT0 (BIT1 O))))) = (sgr (normr x)).
Axiom thm_REAL_SGN_REAL_SGN : forall x : R, (sgr (sgr x)) = (sgr x).
Axiom thm_REAL_INV_SGN : forall x : R, (invr (sgr x)) = (sgr x).
Axiom thm_REAL_SGN_EQ_INEQ : forall x : R, forall y : R, ((sgr x) = (sgr y)) = ((x = y) \/ (ltr (normr (subr x y)) (maxr (normr x) (normr y)))).
Axiom thm_REAL_SGNS_EQ : forall x : R, forall y : R, ((sgr x) = (sgr y)) = (((x = (R_of_nat (NUMERAL O))) = (y = (R_of_nat (NUMERAL O)))) /\ (((gtr x (R_of_nat (NUMERAL O))) = (gtr y (R_of_nat (NUMERAL O)))) /\ ((ltr x (R_of_nat (NUMERAL O))) = (ltr y (R_of_nat (NUMERAL O)))))).
Axiom thm_REAL_SGNS_EQ_ALT : forall x : R, forall y : R, ((sgr x) = (sgr y)) = (((x = (R_of_nat (NUMERAL O))) -> y = (R_of_nat (NUMERAL O))) /\ (((gtr x (R_of_nat (NUMERAL O))) -> gtr y (R_of_nat (NUMERAL O))) /\ ((ltr x (R_of_nat (NUMERAL O))) -> ltr y (R_of_nat (NUMERAL O))))).
Axiom thm_REAL_WLOG_LE : forall (P : R -> R -> Prop), ((forall x : R, forall y : R, (P x y) = (P y x)) /\ (forall x : R, forall y : R, (ler x y) -> P x y)) -> forall x : R, forall y : R, P x y.
Axiom thm_REAL_WLOG_LT : forall (P : R -> R -> Prop), ((forall x : R, P x x) /\ ((forall x : R, forall y : R, (P x y) = (P y x)) /\ (forall x : R, forall y : R, (ltr x y) -> P x y))) -> forall x : R, forall y : R, P x y.
Axiom thm_REAL_WLOG_LE_3 : forall P : R -> R -> R -> Prop, ((forall x : R, forall y : R, forall z : R, (P x y z) -> (P y x z) /\ (P x z y)) /\ (forall x : R, forall y : R, forall z : R, ((ler x y) /\ (ler y z)) -> P x y z)) -> forall x : R, forall y : R, forall z : R, P x y z.
Axiom thm_sqrt : forall x : R, (hol_sqrt x) = (@ε R (fun y : R => ((sgr y) = (sgr x)) /\ ((expr y (NUMERAL (BIT0 (BIT1 O)))) = (normr x)))).
Axiom thm_SQRT_UNIQUE : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) y) /\ ((expr y (NUMERAL (BIT0 (BIT1 O)))) = x)) -> (hol_sqrt x) = y.
Axiom thm_POW_2_SQRT : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> (hol_sqrt (expr x (NUMERAL (BIT0 (BIT1 O))))) = x.
Axiom thm_SQRT_0 : (hol_sqrt (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_SQRT_1 : (hol_sqrt (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_POW_2_SQRT_ABS : forall x : R, (hol_sqrt (expr x (NUMERAL (BIT0 (BIT1 O))))) = (normr x).
Axiom thm_SQRT_WORKS_GEN : forall x : R, ((sgr (hol_sqrt x)) = (sgr x)) /\ ((expr (hol_sqrt x) (NUMERAL (BIT0 (BIT1 O)))) = (normr x)).
Axiom thm_SQRT_UNIQUE_GEN : forall x : R, forall y : R, (((sgr y) = (sgr x)) /\ ((expr y (NUMERAL (BIT0 (BIT1 O)))) = (normr x))) -> (hol_sqrt x) = y.
Axiom thm_SQRT_NEG : forall x : R, (hol_sqrt (oppr x)) = (oppr (hol_sqrt x)).
Axiom thm_REAL_SGN_SQRT : forall x : R, (sgr (hol_sqrt x)) = (sgr x).
Axiom thm_SQRT_WORKS : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> (ler (R_of_nat (NUMERAL O)) (hol_sqrt x)) /\ ((expr (hol_sqrt x) (NUMERAL (BIT0 (BIT1 O)))) = x).
Axiom thm_REAL_POS_EQ_SQUARE : forall x : R, (ler (R_of_nat (NUMERAL O)) x) = (exists y : R, (expr y (NUMERAL (BIT0 (BIT1 O)))) = x).
Axiom thm_SQRT_POS_LE : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> ler (R_of_nat (NUMERAL O)) (hol_sqrt x).
Axiom thm_SQRT_POW_2 : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> (expr (hol_sqrt x) (NUMERAL (BIT0 (BIT1 O)))) = x.
Axiom thm_SQRT_POW2 : forall x : R, ((expr (hol_sqrt x) (NUMERAL (BIT0 (BIT1 O)))) = x) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_SQRT_MUL : forall x : R, forall y : R, (hol_sqrt (mulr x y)) = (mulr (hol_sqrt x) (hol_sqrt y)).
Axiom thm_SQRT_INV : forall x : R, (hol_sqrt (invr x)) = (invr (hol_sqrt x)).
Axiom thm_SQRT_DIV : forall x : R, forall y : R, (hol_sqrt (divr x y)) = (divr (hol_sqrt x) (hol_sqrt y)).
Axiom thm_SQRT_LT_0 : forall x : R, (ltr (R_of_nat (NUMERAL O)) (hol_sqrt x)) = (ltr (R_of_nat (NUMERAL O)) x).
Axiom thm_SQRT_EQ_0 : forall x : R, ((hol_sqrt x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_SQRT_LE_0 : forall x : R, (ler (R_of_nat (NUMERAL O)) (hol_sqrt x)) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_ABS_SQRT : forall x : R, (normr (hol_sqrt x)) = (hol_sqrt (normr x)).
Axiom thm_SQRT_MONO_LT : forall x : R, forall y : R, (ltr x y) -> ltr (hol_sqrt x) (hol_sqrt y).
Axiom thm_SQRT_MONO_LE : forall x : R, forall y : R, (ler x y) -> ler (hol_sqrt x) (hol_sqrt y).
Axiom thm_SQRT_MONO_LT_EQ : forall x : R, forall y : R, (ltr (hol_sqrt x) (hol_sqrt y)) = (ltr x y).
Axiom thm_SQRT_MONO_LE_EQ : forall x : R, forall y : R, (ler (hol_sqrt x) (hol_sqrt y)) = (ler x y).
Axiom thm_SQRT_INJ : forall x : R, forall y : R, ((hol_sqrt x) = (hol_sqrt y)) = (x = y).
Axiom thm_SQRT_EQ_1 : forall x : R, ((hol_sqrt x) = (R_of_nat (NUMERAL (BIT1 O)))) = (x = (R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_SQRT_POS_LT : forall x : R, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (hol_sqrt x).
Axiom thm_REAL_LE_LSQRT : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) y) /\ (ler x (expr y (NUMERAL (BIT0 (BIT1 O)))))) -> ler (hol_sqrt x) y.
Axiom thm_REAL_LE_RSQRT : forall x : R, forall y : R, (ler (expr x (NUMERAL (BIT0 (BIT1 O)))) y) -> ler x (hol_sqrt y).
Axiom thm_REAL_LT_LSQRT : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) y) /\ (ltr x (expr y (NUMERAL (BIT0 (BIT1 O)))))) -> ltr (hol_sqrt x) y.
Axiom thm_REAL_LT_RSQRT : forall x : R, forall y : R, (ltr (expr x (NUMERAL (BIT0 (BIT1 O)))) y) -> ltr x (hol_sqrt y).
Axiom thm_SQRT_EVEN_POW2 : forall n : nat, (even n) -> (hol_sqrt (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n)) = (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (divn n (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_REAL_DIV_SQRT : forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> (divr x (hol_sqrt x)) = (hol_sqrt x).
Axiom thm_REAL_RSQRT_LE : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ ((ler (R_of_nat (NUMERAL O)) y) /\ (ler x (hol_sqrt y)))) -> ler (expr x (NUMERAL (BIT0 (BIT1 O)))) y.
Axiom thm_REAL_LSQRT_LE : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler (hol_sqrt x) y)) -> ler x (expr y (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_REAL_SQRT_POW_2 : forall x : R, (expr (hol_sqrt x) (NUMERAL (BIT0 (BIT1 O)))) = (normr x).
Axiom thm_REAL_ABS_LE_SQRT_POS : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler (R_of_nat (NUMERAL O)) y)) -> ler (normr (subr (hol_sqrt x) (hol_sqrt y))) (hol_sqrt (normr (subr x y))).
Axiom thm_REAL_ABS_LE_SQRT : forall x : R, forall y : R, ler (normr (subr (hol_sqrt x) (hol_sqrt y))) (hol_sqrt (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) (normr (subr x y)))).
Axiom thm_DECIMAL : forall x : nat, forall y : nat, (DECIMAL x y) = (divr (R_of_nat x) (R_of_nat y)).
Axiom thm_RAT_LEMMA1 : forall (x1 : R) (x2 : R) (y1 : R) (y2 : R), ((~ (y1 = (R_of_nat (NUMERAL O)))) /\ (~ (y2 = (R_of_nat (NUMERAL O))))) -> (addr (divr x1 y1) (divr x2 y2)) = (mulr (addr (mulr x1 y2) (mulr x2 y1)) (mulr (invr y1) (invr y2))).
Axiom thm_RAT_LEMMA2 : forall (x1 : R) (x2 : R) (y1 : R) (y2 : R), ((ltr (R_of_nat (NUMERAL O)) y1) /\ (ltr (R_of_nat (NUMERAL O)) y2)) -> (addr (divr x1 y1) (divr x2 y2)) = (mulr (addr (mulr x1 y2) (mulr x2 y1)) (mulr (invr y1) (invr y2))).
Axiom thm_RAT_LEMMA3 : forall (x1 : R) (x2 : R) (y1 : R) (y2 : R), ((ltr (R_of_nat (NUMERAL O)) y1) /\ (ltr (R_of_nat (NUMERAL O)) y2)) -> (subr (divr x1 y1) (divr x2 y2)) = (mulr (subr (mulr x1 y2) (mulr x2 y1)) (mulr (invr y1) (invr y2))).
Axiom thm_RAT_LEMMA4 : forall (x1 : R) (y2 : R) (x2 : R) (y1 : R), ((ltr (R_of_nat (NUMERAL O)) y1) /\ (ltr (R_of_nat (NUMERAL O)) y2)) -> (ler (divr x1 y1) (divr x2 y2)) = (ler (mulr x1 y2) (mulr x2 y1)).
Axiom thm_RAT_LEMMA5 : forall (x1 : R) (y2 : R) (x2 : R) (y1 : R), ((ltr (R_of_nat (NUMERAL O)) y1) /\ (ltr (R_of_nat (NUMERAL O)) y2)) -> ((divr x1 y1) = (divr x2 y2)) = ((mulr x1 y2) = (mulr x2 y1)).
Axiom thm_REAL_LE_TRANS_LE : forall x : R, forall y : R, (ler x y) = (forall z : R, (ler y z) -> ler x z).
Axiom thm_REAL_LE_TRANS_LTE : forall x : R, forall y : R, (ler x y) = (forall z : R, (ltr y z) -> ler x z).
Axiom thm_REAL_LE_TRANS_LT : forall x : R, forall y : R, (ler x y) = (forall z : R, (ltr y z) -> ltr x z).
Axiom thm_REAL_SHRINK_RANGE : forall x : R, ltr (normr (divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x)))) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_SHRINK_LT : forall x : R, forall y : R, (ltr (divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) (divr y (addr (R_of_nat (NUMERAL (BIT1 O))) (normr y)))) = (ltr x y).
Axiom thm_REAL_SHRINK_LE : forall x : R, forall y : R, (ler (divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) (divr y (addr (R_of_nat (NUMERAL (BIT1 O))) (normr y)))) = (ler x y).
Axiom thm_REAL_SHRINK_EQ : forall x : R, forall y : R, ((divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) = (divr y (addr (R_of_nat (NUMERAL (BIT1 O))) (normr y)))) = (x = y).
Axiom thm_REAL_SHRINK_GALOIS : forall x : R, forall y : R, ((divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) = y) = ((ltr (normr y) (R_of_nat (NUMERAL (BIT1 O)))) /\ ((divr y (subr (R_of_nat (NUMERAL (BIT1 O))) (normr y))) = x)).
Axiom thm_REAL_GROW_SHRINK : forall x : R, (divr (divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) (subr (R_of_nat (NUMERAL (BIT1 O))) (normr (divr x (addr (R_of_nat (NUMERAL (BIT1 O))) (normr x)))))) = x.
Axiom thm_REAL_SHRINK_GROW_EQ : forall x : R, ((divr (divr x (subr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) (addr (R_of_nat (NUMERAL (BIT1 O))) (normr (divr x (subr (R_of_nat (NUMERAL (BIT1 O))) (normr x)))))) = x) = (ltr (normr x) (R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_REAL_SHRINK_GROW : forall x : R, (ltr (normr x) (R_of_nat (NUMERAL (BIT1 O)))) -> (divr (divr x (subr (R_of_nat (NUMERAL (BIT1 O))) (normr x))) (addr (R_of_nat (NUMERAL (BIT1 O))) (normr (divr x (subr (R_of_nat (NUMERAL (BIT1 O))) (normr x)))))) = x.
Axiom thm_integer : forall x : R, (Rint x) = (exists n : nat, (normr x) = (R_of_nat n)).
Axiom thm_is_int : forall (x : R), (Rint x) = (exists n : nat, (x = (R_of_nat n)) \/ (x = (oppr (R_of_nat n)))).
Axiom thm_dest_int_rep : forall i : int, exists n : nat, ((real_of_int i) = (R_of_nat n)) \/ ((real_of_int i) = (oppr (R_of_nat n))).
Axiom thm_INTEGER_REAL_OF_INT : forall x : int, Rint (real_of_int x).
Axiom thm_int_eq : forall x : int, forall y : int, (x = y) = ((real_of_int x) = (real_of_int y)).
Axiom thm_int_le : forall x : int, forall y : int, (lez x y) = (ler (real_of_int x) (real_of_int y)).
Axiom thm_int_lt : forall x : int, forall y : int, (ltz x y) = (ltr (real_of_int x) (real_of_int y)).
Axiom thm_int_ge : forall x : int, forall y : int, (gez x y) = (ger (real_of_int x) (real_of_int y)).
Axiom thm_int_gt : forall x : int, forall y : int, (gtz x y) = (gtr (real_of_int x) (real_of_int y)).
Axiom thm_int_of_num : forall n : nat, (int_of_nat n) = (int_of_real (R_of_nat n)).
Axiom thm_int_of_num_th : forall n : nat, (real_of_int (int_of_nat n)) = (R_of_nat n).
Axiom thm_int_neg : forall i : int, (oppz i) = (int_of_real (oppr (real_of_int i))).
Axiom thm_int_neg_th : forall x : int, (real_of_int (oppz x)) = (oppr (real_of_int x)).
Axiom thm_int_add : forall x : int, forall y : int, (addz x y) = (int_of_real (addr (real_of_int x) (real_of_int y))).
Axiom thm_int_add_th : forall x : int, forall y : int, (real_of_int (addz x y)) = (addr (real_of_int x) (real_of_int y)).
Axiom thm_int_sub : forall x : int, forall y : int, (subz x y) = (int_of_real (subr (real_of_int x) (real_of_int y))).
Axiom thm_int_sub_th : forall x : int, forall y : int, (real_of_int (subz x y)) = (subr (real_of_int x) (real_of_int y)).
Axiom thm_int_mul : forall x : int, forall y : int, (mulz x y) = (int_of_real (mulr (real_of_int x) (real_of_int y))).
Axiom thm_int_mul_th : forall x : int, forall y : int, (real_of_int (mulz x y)) = (mulr (real_of_int x) (real_of_int y)).
Axiom thm_int_abs : forall x : int, (normz x) = (int_of_real (normr (real_of_int x))).
Axiom thm_int_abs_th : forall x : int, (real_of_int (normz x)) = (normr (real_of_int x)).
Axiom thm_int_sgn : forall x : int, (sgz x) = (int_of_real (sgr (real_of_int x))).
Axiom thm_int_sgn_th : forall x : int, (real_of_int (sgz x)) = (sgr (real_of_int x)).
Axiom thm_int_max : forall x : int, forall y : int, (maxz x y) = (int_of_real (maxr (real_of_int x) (real_of_int y))).
Axiom thm_int_max_th : forall x : int, forall y : int, (real_of_int (maxz x y)) = (maxr (real_of_int x) (real_of_int y)).
Axiom thm_int_min : forall x : int, forall y : int, (minz x y) = (int_of_real (minr (real_of_int x) (real_of_int y))).
Axiom thm_int_min_th : forall x : int, forall y : int, (real_of_int (minz x y)) = (minr (real_of_int x) (real_of_int y)).
Axiom thm_int_pow : forall x : int, forall n : nat, (expz x n) = (int_of_real (expr (real_of_int x) n)).
Axiom thm_int_pow_th : forall x : int, forall n : nat, (real_of_int (expz x n)) = (expr (real_of_int x) n).
Axiom thm_REAL_OF_INT_CLAUSES : (forall x : int, forall y : int, ((real_of_int x) = (real_of_int y)) = (x = y)) /\ ((forall x : int, forall y : int, (ger (real_of_int x) (real_of_int y)) = (gez x y)) /\ ((forall x : int, forall y : int, (gtr (real_of_int x) (real_of_int y)) = (gtz x y)) /\ ((forall x : int, forall y : int, (ler (real_of_int x) (real_of_int y)) = (lez x y)) /\ ((forall x : int, forall y : int, (ltr (real_of_int x) (real_of_int y)) = (ltz x y)) /\ ((forall x : int, forall y : int, (maxr (real_of_int x) (real_of_int y)) = (real_of_int (maxz x y))) /\ ((forall x : int, forall y : int, (minr (real_of_int x) (real_of_int y)) = (real_of_int (minz x y))) /\ ((forall n : nat, (R_of_nat n) = (real_of_int (int_of_nat n))) /\ ((forall x : int, (oppr (real_of_int x)) = (real_of_int (oppz x))) /\ ((forall x : int, (normr (real_of_int x)) = (real_of_int (normz x))) /\ ((forall x : int, forall y : int, (maxr (real_of_int x) (real_of_int y)) = (real_of_int (maxz x y))) /\ ((forall x : int, forall y : int, (minr (real_of_int x) (real_of_int y)) = (real_of_int (minz x y))) /\ ((forall x : int, (sgr (real_of_int x)) = (real_of_int (sgz x))) /\ ((forall x : int, forall y : int, (addr (real_of_int x) (real_of_int y)) = (real_of_int (addz x y))) /\ ((forall x : int, forall y : int, (subr (real_of_int x) (real_of_int y)) = (real_of_int (subz x y))) /\ ((forall x : int, forall y : int, (mulr (real_of_int x) (real_of_int y)) = (real_of_int (mulz x y))) /\ (forall x : int, forall n : nat, (expr (real_of_int x) n) = (real_of_int (expz x n)))))))))))))))))).
Axiom thm_INT_IMAGE : forall x : int, (exists n : nat, x = (int_of_nat n)) \/ (exists n : nat, x = (oppz (int_of_nat n))).
Axiom thm_FORALL_INT_CASES : forall P : int -> Prop, (forall x : int, P x) = ((forall n : nat, P (int_of_nat n)) /\ (forall n : nat, P (oppz (int_of_nat n)))).
Axiom thm_EXISTS_INT_CASES : forall P : int -> Prop, (exists x : int, P x) = ((exists n : nat, P (int_of_nat n)) \/ (exists n : nat, P (oppz (int_of_nat n)))).
Axiom thm_INT_LT_DISCRETE : forall x : int, forall y : int, (ltz x y) = (lez (addz x (int_of_nat (NUMERAL (BIT1 O)))) y).
Axiom thm_INT_GT_DISCRETE : forall x : int, forall y : int, (gtz x y) = (gez x (addz y (int_of_nat (NUMERAL (BIT1 O))))).
Axiom thm_INT_ABS_0 : (normz (int_of_nat (NUMERAL O))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_ABS_1 : (normz (int_of_nat (NUMERAL (BIT1 O)))) = (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_ABS_ABS : forall x : int, (normz (normz x)) = (normz x).
Axiom thm_INT_ABS_BETWEEN : forall x : int, forall y : int, forall d : int, ((ltz (int_of_nat (NUMERAL O)) d) /\ ((ltz (subz x d) y) /\ (ltz y (addz x d)))) = (ltz (normz (subz y x)) d).
Axiom thm_INT_ABS_BETWEEN1 : forall x : int, forall y : int, forall z : int, ((ltz x z) /\ (ltz (normz (subz y x)) (subz z x))) -> ltz y z.
Axiom thm_INT_ABS_BETWEEN2 : forall x0 : int, forall x : int, forall y0 : int, forall y : int, ((ltz x0 y0) /\ ((ltz (mulz (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (normz (subz x x0))) (subz y0 x0)) /\ (ltz (mulz (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (normz (subz y y0))) (subz y0 x0)))) -> ltz x y.
Axiom thm_INT_ABS_BOUND : forall x : int, forall y : int, forall d : int, (ltz (normz (subz x y)) d) -> ltz y (addz x d).
Axiom thm_INT_ABS_BOUNDS : forall x : int, forall k : int, (lez (normz x) k) = ((lez (oppz k) x) /\ (lez x k)).
Axiom thm_INT_ABS_CASES : forall x : int, (x = (int_of_nat (NUMERAL O))) \/ (ltz (int_of_nat (NUMERAL O)) (normz x)).
Axiom thm_INT_ABS_CIRCLE : forall x : int, forall y : int, forall h : int, (ltz (normz h) (subz (normz y) (normz x))) -> ltz (normz (addz x h)) (normz y).
Axiom thm_INT_ABS_LE : forall x : int, lez x (normz x).
Axiom thm_INT_ABS_MUL : forall x : int, forall y : int, (normz (mulz x y)) = (mulz (normz x) (normz y)).
Axiom thm_INT_ABS_NEG : forall x : int, (normz (oppz x)) = (normz x).
Axiom thm_INT_ABS_NUM : forall n : nat, (normz (int_of_nat n)) = (int_of_nat n).
Axiom thm_INT_ABS_NZ : forall x : int, (~ (x = (int_of_nat (NUMERAL O)))) = (ltz (int_of_nat (NUMERAL O)) (normz x)).
Axiom thm_INT_ABS_POS : forall x : int, lez (int_of_nat (NUMERAL O)) (normz x).
Axiom thm_INT_ABS_POW : forall x : int, forall n : nat, (normz (expz x n)) = (expz (normz x) n).
Axiom thm_INT_ABS_REFL : forall x : int, ((normz x) = x) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_ABS_SGN : forall x : int, (normz (sgz x)) = (sgz (normz x)).
Axiom thm_INT_ABS_SIGN : forall x : int, forall y : int, (ltz (normz (subz x y)) y) -> ltz (int_of_nat (NUMERAL O)) x.
Axiom thm_INT_ABS_SIGN2 : forall x : int, forall y : int, (ltz (normz (subz x y)) (oppz y)) -> ltz x (int_of_nat (NUMERAL O)).
Axiom thm_INT_ABS_STILLNZ : forall x : int, forall y : int, (ltz (normz (subz x y)) (normz y)) -> ~ (x = (int_of_nat (NUMERAL O))).
Axiom thm_INT_ABS_SUB : forall x : int, forall y : int, (normz (subz x y)) = (normz (subz y x)).
Axiom thm_INT_ABS_SUB_ABS : forall x : int, forall y : int, lez (normz (subz (normz x) (normz y))) (normz (subz x y)).
Axiom thm_INT_ABS_TRIANGLE : forall x : int, forall y : int, lez (normz (addz x y)) (addz (normz x) (normz y)).
Axiom thm_INT_ABS_ZERO : forall x : int, ((normz x) = (int_of_nat (NUMERAL O))) = (x = (int_of_nat (NUMERAL O))).
Axiom thm_INT_ADD2_SUB2 : forall a : int, forall b : int, forall c : int, forall d : int, (subz (addz a b) (addz c d)) = (addz (subz a c) (subz b d)).
Axiom thm_INT_ADD_AC : forall (n : int) (m : int) (p : int), ((addz m n) = (addz n m)) /\ (((addz (addz m n) p) = (addz m (addz n p))) /\ ((addz m (addz n p)) = (addz n (addz m p)))).
Axiom thm_INT_ADD_ASSOC : forall x : int, forall y : int, forall z : int, (addz x (addz y z)) = (addz (addz x y) z).
Axiom thm_INT_ADD_LDISTRIB : forall x : int, forall y : int, forall z : int, (mulz x (addz y z)) = (addz (mulz x y) (mulz x z)).
Axiom thm_INT_ADD_LID : forall x : int, (addz (int_of_nat (NUMERAL O)) x) = x.
Axiom thm_INT_ADD_LINV : forall x : int, (addz (oppz x) x) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_ADD_RDISTRIB : forall x : int, forall y : int, forall z : int, (mulz (addz x y) z) = (addz (mulz x z) (mulz y z)).
Axiom thm_INT_ADD_RID : forall x : int, (addz x (int_of_nat (NUMERAL O))) = x.
Axiom thm_INT_ADD_RINV : forall x : int, (addz x (oppz x)) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_ADD_SUB : forall x : int, forall y : int, (subz (addz x y) x) = y.
Axiom thm_INT_ADD_SUB2 : forall x : int, forall y : int, (subz x (addz x y)) = (oppz y).
Axiom thm_INT_ADD_SYM : forall x : int, forall y : int, (addz x y) = (addz y x).
Axiom thm_INT_BOUNDS_LE : forall x : int, forall k : int, ((lez (oppz k) x) /\ (lez x k)) = (lez (normz x) k).
Axiom thm_INT_BOUNDS_LT : forall x : int, forall k : int, ((ltz (oppz k) x) /\ (ltz x k)) = (ltz (normz x) k).
Axiom thm_INT_DIFFSQ : forall x : int, forall y : int, (mulz (addz x y) (subz x y)) = (subz (mulz x x) (mulz y y)).
Axiom thm_INT_ENTIRE : forall x : int, forall y : int, ((mulz x y) = (int_of_nat (NUMERAL O))) = ((x = (int_of_nat (NUMERAL O))) \/ (y = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_EQ_ADD_LCANCEL : forall x : int, forall y : int, forall z : int, ((addz x y) = (addz x z)) = (y = z).
Axiom thm_INT_EQ_ADD_LCANCEL_0 : forall x : int, forall y : int, ((addz x y) = x) = (y = (int_of_nat (NUMERAL O))).
Axiom thm_INT_EQ_ADD_RCANCEL : forall x : int, forall y : int, forall z : int, ((addz x z) = (addz y z)) = (x = y).
Axiom thm_INT_EQ_ADD_RCANCEL_0 : forall x : int, forall y : int, ((addz x y) = y) = (x = (int_of_nat (NUMERAL O))).
Axiom thm_INT_EQ_IMP_LE : forall x : int, forall y : int, (x = y) -> lez x y.
Axiom thm_INT_EQ_LCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((~ (z = (int_of_nat (NUMERAL O)))) /\ ((mulz z x) = (mulz z y))) -> x = y.
Axiom thm_INT_EQ_MUL_LCANCEL : forall x : int, forall y : int, forall z : int, ((mulz x y) = (mulz x z)) = ((x = (int_of_nat (NUMERAL O))) \/ (y = z)).
Axiom thm_INT_EQ_MUL_RCANCEL : forall x : int, forall y : int, forall z : int, ((mulz x z) = (mulz y z)) = ((x = y) \/ (z = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_EQ_NEG2 : forall x : int, forall y : int, ((oppz x) = (oppz y)) = (x = y).
Axiom thm_INT_EQ_RCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((~ (z = (int_of_nat (NUMERAL O)))) /\ ((mulz x z) = (mulz y z))) -> x = y.
Axiom thm_INT_EQ_SGN_ABS : forall x : int, forall y : int, (x = y) = (((sgz x) = (sgz y)) /\ ((normz x) = (normz y))).
Axiom thm_INT_EQ_SQUARE_ABS : forall x : int, forall y : int, ((normz x) = (normz y)) = ((expz x (NUMERAL (BIT0 (BIT1 O)))) = (expz y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_INT_EQ_SUB_LADD : forall x : int, forall y : int, forall z : int, (x = (subz y z)) = ((addz x z) = y).
Axiom thm_INT_EQ_SUB_RADD : forall x : int, forall y : int, forall z : int, ((subz x y) = z) = (x = (addz z y)).
Axiom thm_INT_EVENPOW_ABS : forall x : int, forall n : nat, (even n) -> (expz (normz x) n) = (expz x n).
Axiom thm_INT_LET_ADD : forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (ltz (int_of_nat (NUMERAL O)) y)) -> ltz (int_of_nat (NUMERAL O)) (addz x y).
Axiom thm_INT_LET_ADD2 : forall w : int, forall x : int, forall y : int, forall z : int, ((lez w x) /\ (ltz y z)) -> ltz (addz w y) (addz x z).
Axiom thm_INT_LET_ANTISYM : forall x : int, forall y : int, ~ ((lez x y) /\ (ltz y x)).
Axiom thm_INT_LET_TOTAL : forall x : int, forall y : int, (lez x y) \/ (ltz y x).
Axiom thm_INT_LET_TRANS : forall x : int, forall y : int, forall z : int, ((lez x y) /\ (ltz y z)) -> ltz x z.
Axiom thm_INT_LE_01 : lez (int_of_nat (NUMERAL O)) (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_LE_ADD : forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez (int_of_nat (NUMERAL O)) y)) -> lez (int_of_nat (NUMERAL O)) (addz x y).
Axiom thm_INT_LE_ADD2 : forall w : int, forall x : int, forall y : int, forall z : int, ((lez w x) /\ (lez y z)) -> lez (addz w y) (addz x z).
Axiom thm_INT_LE_ADDL : forall x : int, forall y : int, (lez y (addz x y)) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_LE_ADDR : forall x : int, forall y : int, (lez x (addz x y)) = (lez (int_of_nat (NUMERAL O)) y).
Axiom thm_INT_LE_ANTISYM : forall x : int, forall y : int, ((lez x y) /\ (lez y x)) = (x = y).
Axiom thm_INT_LE_DOUBLE : forall x : int, (lez (int_of_nat (NUMERAL O)) (addz x x)) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_LE_LADD : forall x : int, forall y : int, forall z : int, (lez (addz x y) (addz x z)) = (lez y z).
Axiom thm_INT_LE_LADD_IMP : forall x : int, forall y : int, forall z : int, (lez y z) -> lez (addz x y) (addz x z).
Axiom thm_INT_LE_LCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (lez (mulz x y) (mulz x z))) -> lez y z.
Axiom thm_INT_LE_LMUL : forall x : int, forall y : int, forall z : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez y z)) -> lez (mulz x y) (mulz x z).
Axiom thm_INT_LE_LMUL_EQ : forall x : int, forall y : int, forall z : int, (ltz (int_of_nat (NUMERAL O)) z) -> (lez (mulz z x) (mulz z y)) = (lez x y).
Axiom thm_INT_LE_LNEG : forall x : int, forall y : int, (lez (oppz x) y) = (lez (int_of_nat (NUMERAL O)) (addz x y)).
Axiom thm_INT_LE_LT : forall x : int, forall y : int, (lez x y) = ((ltz x y) \/ (x = y)).
Axiom thm_INT_LE_MAX : forall x : int, forall y : int, forall z : int, (lez z (maxz x y)) = ((lez z x) \/ (lez z y)).
Axiom thm_INT_LE_MIN : forall x : int, forall y : int, forall z : int, (lez z (minz x y)) = ((lez z x) /\ (lez z y)).
Axiom thm_INT_LE_MUL : forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez (int_of_nat (NUMERAL O)) y)) -> lez (int_of_nat (NUMERAL O)) (mulz x y).
Axiom thm_INT_LE_MUL2 : forall w : int, forall x : int, forall y : int, forall z : int, ((lez (int_of_nat (NUMERAL O)) w) /\ ((lez w x) /\ ((lez (int_of_nat (NUMERAL O)) y) /\ (lez y z)))) -> lez (mulz w y) (mulz x z).
Axiom thm_INT_LE_MUL_EQ : (forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) x) -> (lez (int_of_nat (NUMERAL O)) (mulz x y)) = (lez (int_of_nat (NUMERAL O)) y)) /\ (forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) y) -> (lez (int_of_nat (NUMERAL O)) (mulz x y)) = (lez (int_of_nat (NUMERAL O)) x)).
Axiom thm_INT_LE_NEG2 : forall x : int, forall y : int, (lez (oppz x) (oppz y)) = (lez y x).
Axiom thm_INT_LE_NEGL : forall x : int, (lez (oppz x) x) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_LE_NEGR : forall x : int, (lez x (oppz x)) = (lez x (int_of_nat (NUMERAL O))).
Axiom thm_INT_LE_NEGTOTAL : forall x : int, (lez (int_of_nat (NUMERAL O)) x) \/ (lez (int_of_nat (NUMERAL O)) (oppz x)).
Axiom thm_INT_LE_POW2 : forall n : nat, lez (int_of_nat (NUMERAL (BIT1 O))) (expz (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_INT_LE_POW_2 : forall x : int, lez (int_of_nat (NUMERAL O)) (expz x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_INT_LE_RADD : forall x : int, forall y : int, forall z : int, (lez (addz x z) (addz y z)) = (lez x y).
Axiom thm_INT_LE_RCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((ltz (int_of_nat (NUMERAL O)) z) /\ (lez (mulz x z) (mulz y z))) -> lez x y.
Axiom thm_INT_LE_REFL : forall x : int, lez x x.
Axiom thm_INT_LE_RMUL : forall x : int, forall y : int, forall z : int, ((lez x y) /\ (lez (int_of_nat (NUMERAL O)) z)) -> lez (mulz x z) (mulz y z).
Axiom thm_INT_LE_RMUL_EQ : forall x : int, forall y : int, forall z : int, (ltz (int_of_nat (NUMERAL O)) z) -> (lez (mulz x z) (mulz y z)) = (lez x y).
Axiom thm_INT_LE_RNEG : forall x : int, forall y : int, (lez x (oppz y)) = (lez (addz x y) (int_of_nat (NUMERAL O))).
Axiom thm_INT_LE_SQUARE : forall x : int, lez (int_of_nat (NUMERAL O)) (mulz x x).
Axiom thm_INT_LE_SQUARE_ABS : forall x : int, forall y : int, (lez (normz x) (normz y)) = (lez (expz x (NUMERAL (BIT0 (BIT1 O)))) (expz y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_INT_LE_SUB_LADD : forall x : int, forall y : int, forall z : int, (lez x (subz y z)) = (lez (addz x z) y).
Axiom thm_INT_LE_SUB_RADD : forall x : int, forall y : int, forall z : int, (lez (subz x y) z) = (lez x (addz z y)).
Axiom thm_INT_LE_TOTAL : forall x : int, forall y : int, (lez x y) \/ (lez y x).
Axiom thm_INT_LE_TRANS : forall x : int, forall y : int, forall z : int, ((lez x y) /\ (lez y z)) -> lez x z.
Axiom thm_INT_LNEG_UNIQ : forall x : int, forall y : int, ((addz x y) = (int_of_nat (NUMERAL O))) = (x = (oppz y)).
Axiom thm_INT_LTE_ADD : forall x : int, forall y : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (lez (int_of_nat (NUMERAL O)) y)) -> ltz (int_of_nat (NUMERAL O)) (addz x y).
Axiom thm_INT_LTE_ADD2 : forall w : int, forall x : int, forall y : int, forall z : int, ((ltz w x) /\ (lez y z)) -> ltz (addz w y) (addz x z).
Axiom thm_INT_LTE_ANTISYM : forall x : int, forall y : int, ~ ((ltz x y) /\ (lez y x)).
Axiom thm_INT_LTE_TOTAL : forall x : int, forall y : int, (ltz x y) \/ (lez y x).
Axiom thm_INT_LTE_TRANS : forall x : int, forall y : int, forall z : int, ((ltz x y) /\ (lez y z)) -> ltz x z.
Axiom thm_INT_LT_01 : ltz (int_of_nat (NUMERAL O)) (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_LT_ADD : forall x : int, forall y : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz (int_of_nat (NUMERAL O)) y)) -> ltz (int_of_nat (NUMERAL O)) (addz x y).
Axiom thm_INT_LT_ADD1 : forall x : int, forall y : int, (lez x y) -> ltz x (addz y (int_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_INT_LT_ADD2 : forall w : int, forall x : int, forall y : int, forall z : int, ((ltz w x) /\ (ltz y z)) -> ltz (addz w y) (addz x z).
Axiom thm_INT_LT_ADDL : forall x : int, forall y : int, (ltz y (addz x y)) = (ltz (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_LT_ADDNEG : forall x : int, forall y : int, forall z : int, (ltz y (addz x (oppz z))) = (ltz (addz y z) x).
Axiom thm_INT_LT_ADDNEG2 : forall x : int, forall y : int, forall z : int, (ltz (addz x (oppz y)) z) = (ltz x (addz z y)).
Axiom thm_INT_LT_ADDR : forall x : int, forall y : int, (ltz x (addz x y)) = (ltz (int_of_nat (NUMERAL O)) y).
Axiom thm_INT_LT_ADD_SUB : forall x : int, forall y : int, forall z : int, (ltz (addz x y) z) = (ltz x (subz z y)).
Axiom thm_INT_LT_ANTISYM : forall x : int, forall y : int, ~ ((ltz x y) /\ (ltz y x)).
Axiom thm_INT_LT_GT : forall x : int, forall y : int, (ltz x y) -> ~ (ltz y x).
Axiom thm_INT_LT_IMP_LE : forall x : int, forall y : int, (ltz x y) -> lez x y.
Axiom thm_INT_LT_IMP_NE : forall x : int, forall y : int, (ltz x y) -> ~ (x = y).
Axiom thm_INT_LT_LADD : forall x : int, forall y : int, forall z : int, (ltz (addz x y) (addz x z)) = (ltz y z).
Axiom thm_INT_LT_LADD_IMP : forall x : int, forall y : int, forall z : int, (ltz y z) -> ltz (addz x y) (addz x z).
Axiom thm_INT_LT_LCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz (mulz x y) (mulz x z))) -> ltz y z.
Axiom thm_INT_LT_LE : forall x : int, forall y : int, (ltz x y) = ((lez x y) /\ (~ (x = y))).
Axiom thm_INT_LT_LMUL : forall x : int, forall y : int, forall z : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz y z)) -> ltz (mulz x y) (mulz x z).
Axiom thm_INT_LT_LMUL_EQ : forall x : int, forall y : int, forall z : int, (ltz (int_of_nat (NUMERAL O)) z) -> (ltz (mulz z x) (mulz z y)) = (ltz x y).
Axiom thm_INT_LT_LNEG : forall x : int, forall y : int, (ltz (oppz x) y) = (ltz (int_of_nat (NUMERAL O)) (addz x y)).
Axiom thm_INT_LT_MAX : forall x : int, forall y : int, forall z : int, (ltz z (maxz x y)) = ((ltz z x) \/ (ltz z y)).
Axiom thm_INT_LT_MIN : forall x : int, forall y : int, forall z : int, (ltz z (minz x y)) = ((ltz z x) /\ (ltz z y)).
Axiom thm_INT_LT_MUL : forall x : int, forall y : int, ((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz (int_of_nat (NUMERAL O)) y)) -> ltz (int_of_nat (NUMERAL O)) (mulz x y).
Axiom thm_INT_LT_MUL2 : forall w : int, forall x : int, forall y : int, forall z : int, ((lez (int_of_nat (NUMERAL O)) w) /\ ((ltz w x) /\ ((lez (int_of_nat (NUMERAL O)) y) /\ (ltz y z)))) -> ltz (mulz w y) (mulz x z).
Axiom thm_INT_LT_MUL_EQ : (forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) x) -> (ltz (int_of_nat (NUMERAL O)) (mulz x y)) = (ltz (int_of_nat (NUMERAL O)) y)) /\ (forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) y) -> (ltz (int_of_nat (NUMERAL O)) (mulz x y)) = (ltz (int_of_nat (NUMERAL O)) x)).
Axiom thm_INT_LT_NEG2 : forall x : int, forall y : int, (ltz (oppz x) (oppz y)) = (ltz y x).
Axiom thm_INT_LT_NEGTOTAL : forall x : int, (x = (int_of_nat (NUMERAL O))) \/ ((ltz (int_of_nat (NUMERAL O)) x) \/ (ltz (int_of_nat (NUMERAL O)) (oppz x))).
Axiom thm_INT_LT_POW2 : forall n : nat, ltz (int_of_nat (NUMERAL O)) (expz (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_INT_LT_POW_2 : forall x : int, (ltz (int_of_nat (NUMERAL O)) (expz x (NUMERAL (BIT0 (BIT1 O))))) = (~ (x = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_LT_RADD : forall x : int, forall y : int, forall z : int, (ltz (addz x z) (addz y z)) = (ltz x y).
Axiom thm_INT_LT_RCANCEL_IMP : forall x : int, forall y : int, forall z : int, ((ltz (int_of_nat (NUMERAL O)) z) /\ (ltz (mulz x z) (mulz y z))) -> ltz x y.
Axiom thm_INT_LT_REFL : forall x : int, ~ (ltz x x).
Axiom thm_INT_LT_RMUL : forall x : int, forall y : int, forall z : int, ((ltz x y) /\ (ltz (int_of_nat (NUMERAL O)) z)) -> ltz (mulz x z) (mulz y z).
Axiom thm_INT_LT_RMUL_EQ : forall x : int, forall y : int, forall z : int, (ltz (int_of_nat (NUMERAL O)) z) -> (ltz (mulz x z) (mulz y z)) = (ltz x y).
Axiom thm_INT_LT_RNEG : forall x : int, forall y : int, (ltz x (oppz y)) = (ltz (addz x y) (int_of_nat (NUMERAL O))).
Axiom thm_INT_LT_SQUARE : forall x : int, (ltz (int_of_nat (NUMERAL O)) (mulz x x)) = (~ (x = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_LT_SQUARE_ABS : forall x : int, forall y : int, (ltz (normz x) (normz y)) = (ltz (expz x (NUMERAL (BIT0 (BIT1 O)))) (expz y (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_INT_LT_SUB_LADD : forall x : int, forall y : int, forall z : int, (ltz x (subz y z)) = (ltz (addz x z) y).
Axiom thm_INT_LT_SUB_RADD : forall x : int, forall y : int, forall z : int, (ltz (subz x y) z) = (ltz x (addz z y)).
Axiom thm_INT_LT_TOTAL : forall x : int, forall y : int, (x = y) \/ ((ltz x y) \/ (ltz y x)).
Axiom thm_INT_LT_TRANS : forall x : int, forall y : int, forall z : int, ((ltz x y) /\ (ltz y z)) -> ltz x z.
Axiom thm_INT_MAX_ACI : forall (z : int) (x : int) (y : int), ((maxz x y) = (maxz y x)) /\ (((maxz (maxz x y) z) = (maxz x (maxz y z))) /\ (((maxz x (maxz y z)) = (maxz y (maxz x z))) /\ (((maxz x x) = x) /\ ((maxz x (maxz x y)) = (maxz x y))))).
Axiom thm_INT_MAX_ASSOC : forall x : int, forall y : int, forall z : int, (maxz x (maxz y z)) = (maxz (maxz x y) z).
Axiom thm_INT_MAX_LE : forall x : int, forall y : int, forall z : int, (lez (maxz x y) z) = ((lez x z) /\ (lez y z)).
Axiom thm_INT_MAX_LT : forall x : int, forall y : int, forall z : int, (ltz (maxz x y) z) = ((ltz x z) /\ (ltz y z)).
Axiom thm_INT_MAX_MAX : forall x : int, forall y : int, (lez x (maxz x y)) /\ (lez y (maxz x y)).
Axiom thm_INT_MAX_MIN : forall x : int, forall y : int, (maxz x y) = (oppz (minz (oppz x) (oppz y))).
Axiom thm_INT_MAX_SYM : forall x : int, forall y : int, (maxz x y) = (maxz y x).
Axiom thm_INT_MIN_ACI : forall (z : int) (x : int) (y : int), ((minz x y) = (minz y x)) /\ (((minz (minz x y) z) = (minz x (minz y z))) /\ (((minz x (minz y z)) = (minz y (minz x z))) /\ (((minz x x) = x) /\ ((minz x (minz x y)) = (minz x y))))).
Axiom thm_INT_MIN_ASSOC : forall x : int, forall y : int, forall z : int, (minz x (minz y z)) = (minz (minz x y) z).
Axiom thm_INT_MIN_LE : forall x : int, forall y : int, forall z : int, (lez (minz x y) z) = ((lez x z) \/ (lez y z)).
Axiom thm_INT_MIN_LT : forall x : int, forall y : int, forall z : int, (ltz (minz x y) z) = ((ltz x z) \/ (ltz y z)).
Axiom thm_INT_MIN_MAX : forall x : int, forall y : int, (minz x y) = (oppz (maxz (oppz x) (oppz y))).
Axiom thm_INT_MIN_MIN : forall x : int, forall y : int, (lez (minz x y) x) /\ (lez (minz x y) y).
Axiom thm_INT_MIN_SYM : forall x : int, forall y : int, (minz x y) = (minz y x).
Axiom thm_INT_MUL_2 : forall x : int, (mulz (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) x) = (addz x x).
Axiom thm_INT_MUL_AC : forall (n : int) (m : int) (p : int), ((mulz m n) = (mulz n m)) /\ (((mulz (mulz m n) p) = (mulz m (mulz n p))) /\ ((mulz m (mulz n p)) = (mulz n (mulz m p)))).
Axiom thm_INT_MUL_ASSOC : forall x : int, forall y : int, forall z : int, (mulz x (mulz y z)) = (mulz (mulz x y) z).
Axiom thm_INT_MUL_LID : forall x : int, (mulz (int_of_nat (NUMERAL (BIT1 O))) x) = x.
Axiom thm_INT_MUL_LNEG : forall x : int, forall y : int, (mulz (oppz x) y) = (oppz (mulz x y)).
Axiom thm_INT_MUL_LZERO : forall x : int, (mulz (int_of_nat (NUMERAL O)) x) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_MUL_POS_LE : forall x : int, forall y : int, (lez (int_of_nat (NUMERAL O)) (mulz x y)) = ((x = (int_of_nat (NUMERAL O))) \/ ((y = (int_of_nat (NUMERAL O))) \/ (((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz (int_of_nat (NUMERAL O)) y)) \/ ((ltz x (int_of_nat (NUMERAL O))) /\ (ltz y (int_of_nat (NUMERAL O))))))).
Axiom thm_INT_MUL_POS_LT : forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) (mulz x y)) = (((ltz (int_of_nat (NUMERAL O)) x) /\ (ltz (int_of_nat (NUMERAL O)) y)) \/ ((ltz x (int_of_nat (NUMERAL O))) /\ (ltz y (int_of_nat (NUMERAL O))))).
Axiom thm_INT_MUL_RID : forall x : int, (mulz x (int_of_nat (NUMERAL (BIT1 O)))) = x.
Axiom thm_INT_MUL_RNEG : forall x : int, forall y : int, (mulz x (oppz y)) = (oppz (mulz x y)).
Axiom thm_INT_MUL_RZERO : forall x : int, (mulz x (int_of_nat (NUMERAL O))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_MUL_SYM : forall x : int, forall y : int, (mulz x y) = (mulz y x).
Axiom thm_INT_NEG_0 : (oppz (int_of_nat (NUMERAL O))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_NEG_ADD : forall x : int, forall y : int, (oppz (addz x y)) = (addz (oppz x) (oppz y)).
Axiom thm_INT_NEG_EQ : forall x : int, forall y : int, ((oppz x) = y) = (x = (oppz y)).
Axiom thm_INT_NEG_EQ_0 : forall x : int, ((oppz x) = (int_of_nat (NUMERAL O))) = (x = (int_of_nat (NUMERAL O))).
Axiom thm_INT_NEG_GE0 : forall x : int, (lez (int_of_nat (NUMERAL O)) (oppz x)) = (lez x (int_of_nat (NUMERAL O))).
Axiom thm_INT_NEG_GT0 : forall x : int, (ltz (int_of_nat (NUMERAL O)) (oppz x)) = (ltz x (int_of_nat (NUMERAL O))).
Axiom thm_INT_NEG_LE0 : forall x : int, (lez (oppz x) (int_of_nat (NUMERAL O))) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_NEG_LMUL : forall x : int, forall y : int, (oppz (mulz x y)) = (mulz (oppz x) y).
Axiom thm_INT_NEG_LT0 : forall x : int, (ltz (oppz x) (int_of_nat (NUMERAL O))) = (ltz (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_NEG_MINUS1 : forall x : int, (oppz x) = (mulz (oppz (int_of_nat (NUMERAL (BIT1 O)))) x).
Axiom thm_INT_NEG_MUL2 : forall x : int, forall y : int, (mulz (oppz x) (oppz y)) = (mulz x y).
Axiom thm_INT_NEG_NEG : forall x : int, (oppz (oppz x)) = x.
Axiom thm_INT_NEG_RMUL : forall x : int, forall y : int, (oppz (mulz x y)) = (mulz x (oppz y)).
Axiom thm_INT_NEG_SUB : forall x : int, forall y : int, (oppz (subz x y)) = (subz y x).
Axiom thm_INT_NOT_EQ : forall x : int, forall y : int, (~ (x = y)) = ((ltz x y) \/ (ltz y x)).
Axiom thm_INT_NOT_LE : forall x : int, forall y : int, (~ (lez x y)) = (ltz y x).
Axiom thm_INT_NOT_LT : forall x : int, forall y : int, (~ (ltz x y)) = (lez y x).
Axiom thm_INT_OF_NUM_ADD : forall m : nat, forall n : nat, (addz (int_of_nat m) (int_of_nat n)) = (int_of_nat (addn m n)).
Axiom thm_INT_OF_NUM_CLAUSES : (forall m : nat, forall n : nat, ((int_of_nat m) = (int_of_nat n)) = (m = n)) /\ ((forall m : nat, forall n : nat, (gez (int_of_nat m) (int_of_nat n)) = (geqn m n)) /\ ((forall m : nat, forall n : nat, (gtz (int_of_nat m) (int_of_nat n)) = (gtn m n)) /\ ((forall m : nat, forall n : nat, (lez (int_of_nat m) (int_of_nat n)) = (leqn m n)) /\ ((forall m : nat, forall n : nat, (ltz (int_of_nat m) (int_of_nat n)) = (ltn m n)) /\ ((forall m : nat, forall n : nat, (maxz (int_of_nat m) (int_of_nat n)) = (int_of_nat (maxn m n))) /\ ((forall m : nat, forall n : nat, (minz (int_of_nat m) (int_of_nat n)) = (int_of_nat (minn m n))) /\ ((forall m : nat, forall n : nat, (addz (int_of_nat m) (int_of_nat n)) = (int_of_nat (addn m n))) /\ ((forall m : nat, forall n : nat, (mulz (int_of_nat m) (int_of_nat n)) = (int_of_nat (muln m n))) /\ (forall x : nat, forall n : nat, (expz (int_of_nat x) n) = (int_of_nat (expn x n))))))))))).
Axiom thm_INT_OF_NUM_EQ : forall m : nat, forall n : nat, ((int_of_nat m) = (int_of_nat n)) = (m = n).
Axiom thm_INT_OF_NUM_GE : forall m : nat, forall n : nat, (gez (int_of_nat m) (int_of_nat n)) = (geqn m n).
Axiom thm_INT_OF_NUM_GT : forall m : nat, forall n : nat, (gtz (int_of_nat m) (int_of_nat n)) = (gtn m n).
Axiom thm_INT_OF_NUM_LE : forall m : nat, forall n : nat, (lez (int_of_nat m) (int_of_nat n)) = (leqn m n).
Axiom thm_INT_OF_NUM_LT : forall m : nat, forall n : nat, (ltz (int_of_nat m) (int_of_nat n)) = (ltn m n).
Axiom thm_INT_OF_NUM_MAX : forall m : nat, forall n : nat, (maxz (int_of_nat m) (int_of_nat n)) = (int_of_nat (maxn m n)).
Axiom thm_INT_OF_NUM_MIN : forall m : nat, forall n : nat, (minz (int_of_nat m) (int_of_nat n)) = (int_of_nat (minn m n)).
Axiom thm_INT_OF_NUM_MOD : forall m : nat, forall n : nat, (int_of_nat (modn m n)) = (subz (int_of_nat m) (mulz (int_of_nat (divn m n)) (int_of_nat n))).
Axiom thm_INT_OF_NUM_MUL : forall m : nat, forall n : nat, (mulz (int_of_nat m) (int_of_nat n)) = (int_of_nat (muln m n)).
Axiom thm_INT_OF_NUM_POW : forall x : nat, forall n : nat, (expz (int_of_nat x) n) = (int_of_nat (expn x n)).
Axiom thm_INT_OF_NUM_SUB : forall m : nat, forall n : nat, (leqn m n) -> (subz (int_of_nat n) (int_of_nat m)) = (int_of_nat (subn n m)).
Axiom thm_INT_OF_NUM_SUB_CASES : forall m : nat, forall n : nat, (subz (int_of_nat m) (int_of_nat n)) = (@COND int (leqn n m) (int_of_nat (subn m n)) (oppz (int_of_nat (subn n m)))).
Axiom thm_INT_OF_NUM_SUC : forall n : nat, (addz (int_of_nat n) (int_of_nat (NUMERAL (BIT1 O)))) = (int_of_nat (S n)).
Axiom thm_INT_POS : forall n : nat, lez (int_of_nat (NUMERAL O)) (int_of_nat n).
Axiom thm_INT_POS_EQ_SQUARE : forall x : int, (lez (int_of_nat (NUMERAL O)) x) = (exists y : R, (expr y (NUMERAL (BIT0 (BIT1 O)))) = (real_of_int x)).
Axiom thm_INT_POS_NZ : forall x : int, (ltz (int_of_nat (NUMERAL O)) x) -> ~ (x = (int_of_nat (NUMERAL O))).
Axiom thm_INT_POW2_ABS : forall x : int, (expz (normz x) (NUMERAL (BIT0 (BIT1 O)))) = (expz x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_INT_POW_1 : forall x : int, (expz x (NUMERAL (BIT1 O))) = x.
Axiom thm_INT_POW_1_LE : forall n : nat, forall x : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez x (int_of_nat (NUMERAL (BIT1 O))))) -> lez (expz x n) (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_POW_1_LT : forall n : nat, forall x : int, ((~ (n = (NUMERAL O))) /\ ((lez (int_of_nat (NUMERAL O)) x) /\ (ltz x (int_of_nat (NUMERAL (BIT1 O)))))) -> ltz (expz x n) (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_POW_2 : forall x : int, (expz x (NUMERAL (BIT0 (BIT1 O)))) = (mulz x x).
Axiom thm_INT_POW_ADD : forall x : int, forall m : nat, forall n : nat, (expz x (addn m n)) = (mulz (expz x m) (expz x n)).
Axiom thm_INT_POW_EQ : forall n : nat, forall x : int, forall y : int, ((~ (n = (NUMERAL O))) /\ ((lez (int_of_nat (NUMERAL O)) x) /\ ((lez (int_of_nat (NUMERAL O)) y) /\ ((expz x n) = (expz y n))))) -> x = y.
Axiom thm_INT_POW_EQ_0 : forall x : int, forall n : nat, ((expz x n) = (int_of_nat (NUMERAL O))) = ((x = (int_of_nat (NUMERAL O))) /\ (~ (n = (NUMERAL O)))).
Axiom thm_INT_POW_EQ_1 : forall x : int, forall n : nat, ((expz x n) = (int_of_nat (NUMERAL (BIT1 O)))) = ((((normz x) = (int_of_nat (NUMERAL (BIT1 O)))) /\ ((ltz x (int_of_nat (NUMERAL O))) -> even n)) \/ (n = (NUMERAL O))).
Axiom thm_INT_POW_EQ_1_IMP : forall x : int, forall n : nat, ((~ (n = (NUMERAL O))) /\ ((expz x n) = (int_of_nat (NUMERAL (BIT1 O))))) -> (normz x) = (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_POW_EQ_ABS : forall n : nat, forall x : int, forall y : int, ((~ (n = (NUMERAL O))) /\ ((expz x n) = (expz y n))) -> (normz x) = (normz y).
Axiom thm_INT_POW_EQ_EQ : forall n : nat, forall x : int, forall y : int, ((expz x n) = (expz y n)) = (@COND Prop (even n) ((n = (NUMERAL O)) \/ ((normz x) = (normz y))) (x = y)).
Axiom thm_INT_POW_EQ_ODD : forall n : nat, forall x : int, forall y : int, ((oddn n) /\ ((expz x n) = (expz y n))) -> x = y.
Axiom thm_INT_POW_EQ_ODD_EQ : forall n : nat, forall x : int, forall y : int, (oddn n) -> ((expz x n) = (expz y n)) = (x = y).
Axiom thm_INT_POW_LBOUND : forall x : int, forall n : nat, (lez (int_of_nat (NUMERAL O)) x) -> lez (addz (int_of_nat (NUMERAL (BIT1 O))) (mulz (int_of_nat n) x)) (expz (addz (int_of_nat (NUMERAL (BIT1 O))) x) n).
Axiom thm_INT_POW_LE : forall x : int, forall n : nat, (lez (int_of_nat (NUMERAL O)) x) -> lez (int_of_nat (NUMERAL O)) (expz x n).
Axiom thm_INT_POW_LE2 : forall n : nat, forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez x y)) -> lez (expz x n) (expz y n).
Axiom thm_INT_POW_LE2_ODD : forall n : nat, forall x : int, forall y : int, ((lez x y) /\ (oddn n)) -> lez (expz x n) (expz y n).
Axiom thm_INT_POW_LE2_ODD_EQ : forall n : nat, forall x : int, forall y : int, (oddn n) -> (lez (expz x n) (expz y n)) = (lez x y).
Axiom thm_INT_POW_LE2_REV : forall n : nat, forall x : int, forall y : int, ((~ (n = (NUMERAL O))) /\ ((lez (int_of_nat (NUMERAL O)) y) /\ (lez (expz x n) (expz y n)))) -> lez x y.
Axiom thm_INT_POW_LE_1 : forall n : nat, forall x : int, (lez (int_of_nat (NUMERAL (BIT1 O))) x) -> lez (int_of_nat (NUMERAL (BIT1 O))) (expz x n).
Axiom thm_INT_POW_LT : forall x : int, forall n : nat, (ltz (int_of_nat (NUMERAL O)) x) -> ltz (int_of_nat (NUMERAL O)) (expz x n).
Axiom thm_INT_POW_LT2 : forall n : nat, forall x : int, forall y : int, ((~ (n = (NUMERAL O))) /\ ((lez (int_of_nat (NUMERAL O)) x) /\ (ltz x y))) -> ltz (expz x n) (expz y n).
Axiom thm_INT_POW_LT2_ODD : forall n : nat, forall x : int, forall y : int, ((ltz x y) /\ (oddn n)) -> ltz (expz x n) (expz y n).
Axiom thm_INT_POW_LT2_ODD_EQ : forall n : nat, forall x : int, forall y : int, (oddn n) -> (ltz (expz x n) (expz y n)) = (ltz x y).
Axiom thm_INT_POW_LT2_REV : forall n : nat, forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) y) /\ (ltz (expz x n) (expz y n))) -> ltz x y.
Axiom thm_INT_POW_LT_1 : forall n : nat, forall x : int, ((~ (n = (NUMERAL O))) /\ (ltz (int_of_nat (NUMERAL (BIT1 O))) x)) -> ltz (int_of_nat (NUMERAL (BIT1 O))) (expz x n).
Axiom thm_INT_POW_MONO : forall m : nat, forall n : nat, forall x : int, ((lez (int_of_nat (NUMERAL (BIT1 O))) x) /\ (leqn m n)) -> lez (expz x m) (expz x n).
Axiom thm_INT_POW_MONO_LT : forall m : nat, forall n : nat, forall x : int, ((ltz (int_of_nat (NUMERAL (BIT1 O))) x) /\ (ltn m n)) -> ltz (expz x m) (expz x n).
Axiom thm_INT_POW_MUL : forall x : int, forall y : int, forall n : nat, (expz (mulz x y) n) = (mulz (expz x n) (expz y n)).
Axiom thm_INT_POW_NEG : forall x : int, forall n : nat, (expz (oppz x) n) = (@COND int (even n) (expz x n) (oppz (expz x n))).
Axiom thm_INT_POW_NZ : forall x : int, forall n : nat, (~ (x = (int_of_nat (NUMERAL O)))) -> ~ ((expz x n) = (int_of_nat (NUMERAL O))).
Axiom thm_INT_POW_ONE : forall n : nat, (expz (int_of_nat (NUMERAL (BIT1 O))) n) = (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_INT_POW_POW : forall x : int, forall m : nat, forall n : nat, (expz (expz x m) n) = (expz x (muln m n)).
Axiom thm_INT_POW_ZERO : forall n : nat, (expz (int_of_nat (NUMERAL O)) n) = (@COND int (n = (NUMERAL O)) (int_of_nat (NUMERAL (BIT1 O))) (int_of_nat (NUMERAL O))).
Axiom thm_INT_RNEG_UNIQ : forall x : int, forall y : int, ((addz x y) = (int_of_nat (NUMERAL O))) = (y = (oppz x)).
Axiom thm_INT_SGN : forall x : int, (sgz x) = (@COND int (ltz (int_of_nat (NUMERAL O)) x) (int_of_nat (NUMERAL (BIT1 O))) (@COND int (ltz x (int_of_nat (NUMERAL O))) (oppz (int_of_nat (NUMERAL (BIT1 O)))) (int_of_nat (NUMERAL O)))).
Axiom thm_INT_SGNS_EQ : forall x : int, forall y : int, ((sgz x) = (sgz y)) = (((x = (int_of_nat (NUMERAL O))) = (y = (int_of_nat (NUMERAL O)))) /\ (((gtz x (int_of_nat (NUMERAL O))) = (gtz y (int_of_nat (NUMERAL O)))) /\ ((ltz x (int_of_nat (NUMERAL O))) = (ltz y (int_of_nat (NUMERAL O)))))).
Axiom thm_INT_SGNS_EQ_ALT : forall x : int, forall y : int, ((sgz x) = (sgz y)) = (((x = (int_of_nat (NUMERAL O))) -> y = (int_of_nat (NUMERAL O))) /\ (((gtz x (int_of_nat (NUMERAL O))) -> gtz y (int_of_nat (NUMERAL O))) /\ ((ltz x (int_of_nat (NUMERAL O))) -> ltz y (int_of_nat (NUMERAL O))))).
Axiom thm_INT_SGN_0 : (sgz (int_of_nat (NUMERAL O))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_SGN_ABS : forall x : int, (mulz (sgz x) (normz x)) = x.
Axiom thm_INT_SGN_ABS_ALT : forall x : int, (mulz (sgz x) x) = (normz x).
Axiom thm_INT_SGN_CASES : forall x : int, ((sgz x) = (int_of_nat (NUMERAL O))) \/ (((sgz x) = (int_of_nat (NUMERAL (BIT1 O)))) \/ ((sgz x) = (oppz (int_of_nat (NUMERAL (BIT1 O)))))).
Axiom thm_INT_SGN_EQ : (forall x : int, ((sgz x) = (int_of_nat (NUMERAL O))) = (x = (int_of_nat (NUMERAL O)))) /\ ((forall x : int, ((sgz x) = (int_of_nat (NUMERAL (BIT1 O)))) = (gtz x (int_of_nat (NUMERAL O)))) /\ (forall x : int, ((sgz x) = (oppz (int_of_nat (NUMERAL (BIT1 O))))) = (ltz x (int_of_nat (NUMERAL O))))).
Axiom thm_INT_SGN_EQ_INEQ : forall x : int, forall y : int, ((sgz x) = (sgz y)) = ((x = y) \/ (ltz (normz (subz x y)) (maxz (normz x) (normz y)))).
Axiom thm_INT_SGN_INEQS : (forall x : int, (lez (int_of_nat (NUMERAL O)) (sgz x)) = (lez (int_of_nat (NUMERAL O)) x)) /\ ((forall x : int, (ltz (int_of_nat (NUMERAL O)) (sgz x)) = (ltz (int_of_nat (NUMERAL O)) x)) /\ ((forall x : int, (gez (int_of_nat (NUMERAL O)) (sgz x)) = (gez (int_of_nat (NUMERAL O)) x)) /\ ((forall x : int, (gtz (int_of_nat (NUMERAL O)) (sgz x)) = (gtz (int_of_nat (NUMERAL O)) x)) /\ ((forall x : int, ((int_of_nat (NUMERAL O)) = (sgz x)) = ((int_of_nat (NUMERAL O)) = x)) /\ ((forall x : int, (lez (sgz x) (int_of_nat (NUMERAL O))) = (lez x (int_of_nat (NUMERAL O)))) /\ ((forall x : int, (ltz (sgz x) (int_of_nat (NUMERAL O))) = (ltz x (int_of_nat (NUMERAL O)))) /\ ((forall x : int, (gez (sgz x) (int_of_nat (NUMERAL O))) = (gez x (int_of_nat (NUMERAL O)))) /\ ((forall x : int, (gtz (sgz x) (int_of_nat (NUMERAL O))) = (gtz x (int_of_nat (NUMERAL O)))) /\ (forall x : int, ((sgz x) = (int_of_nat (NUMERAL O))) = (x = (int_of_nat (NUMERAL O)))))))))))).
Axiom thm_INT_SGN_INT_SGN : forall x : int, (sgz (sgz x)) = (sgz x).
Axiom thm_INT_SGN_MUL : forall x : int, forall y : int, (sgz (mulz x y)) = (mulz (sgz x) (sgz y)).
Axiom thm_INT_SGN_NEG : forall x : int, (sgz (oppz x)) = (oppz (sgz x)).
Axiom thm_INT_SGN_POW : forall x : int, forall n : nat, (sgz (expz x n)) = (expz (sgz x) n).
Axiom thm_INT_SGN_POW_2 : forall x : int, (sgz (expz x (NUMERAL (BIT0 (BIT1 O))))) = (sgz (normz x)).
Axiom thm_INT_SOS_EQ_0 : forall x : int, forall y : int, ((addz (expz x (NUMERAL (BIT0 (BIT1 O)))) (expz y (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL O))) = ((x = (int_of_nat (NUMERAL O))) /\ (y = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_SUB_0 : forall x : int, forall y : int, ((subz x y) = (int_of_nat (NUMERAL O))) = (x = y).
Axiom thm_INT_SUB_ABS : forall x : int, forall y : int, lez (subz (normz x) (normz y)) (normz (subz x y)).
Axiom thm_INT_SUB_ADD : forall x : int, forall y : int, (addz (subz x y) y) = x.
Axiom thm_INT_SUB_ADD2 : forall x : int, forall y : int, (addz y (subz x y)) = x.
Axiom thm_INT_SUB_LDISTRIB : forall x : int, forall y : int, forall z : int, (mulz x (subz y z)) = (subz (mulz x y) (mulz x z)).
Axiom thm_INT_SUB_LE : forall x : int, forall y : int, (lez (int_of_nat (NUMERAL O)) (subz x y)) = (lez y x).
Axiom thm_INT_SUB_LNEG : forall x : int, forall y : int, (subz (oppz x) y) = (oppz (addz x y)).
Axiom thm_INT_SUB_LT : forall x : int, forall y : int, (ltz (int_of_nat (NUMERAL O)) (subz x y)) = (ltz y x).
Axiom thm_INT_SUB_LZERO : forall x : int, (subz (int_of_nat (NUMERAL O)) x) = (oppz x).
Axiom thm_INT_SUB_NEG2 : forall x : int, forall y : int, (subz (oppz x) (oppz y)) = (subz y x).
Axiom thm_INT_SUB_RDISTRIB : forall x : int, forall y : int, forall z : int, (mulz (subz x y) z) = (subz (mulz x z) (mulz y z)).
Axiom thm_INT_SUB_REFL : forall x : int, (subz x x) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_SUB_RNEG : forall x : int, forall y : int, (subz x (oppz y)) = (addz x y).
Axiom thm_INT_SUB_RZERO : forall x : int, (subz x (int_of_nat (NUMERAL O))) = x.
Axiom thm_INT_SUB_SUB : forall x : int, forall y : int, (subz (subz x y) x) = (oppz y).
Axiom thm_INT_SUB_SUB2 : forall x : int, forall y : int, (subz x (subz x y)) = y.
Axiom thm_INT_SUB_TRIANGLE : forall a : int, forall b : int, forall c : int, (addz (subz a b) (subz b c)) = (subz a c).
Axiom thm_INT_WLOG_LE : forall (P : int -> int -> Prop), ((forall x : int, forall y : int, (P x y) = (P y x)) /\ (forall x : int, forall y : int, (lez x y) -> P x y)) -> forall x : int, forall y : int, P x y.
Axiom thm_INT_WLOG_LT : forall (P : int -> int -> Prop), ((forall x : int, P x x) /\ ((forall x : int, forall y : int, (P x y) = (P y x)) /\ (forall x : int, forall y : int, (ltz x y) -> P x y))) -> forall x : int, forall y : int, P x y.
Axiom thm_INT_WLOG_LE_3 : forall P : int -> int -> int -> Prop, ((forall x : int, forall y : int, forall z : int, (P x y z) -> (P y x z) /\ (P x z y)) /\ (forall x : int, forall y : int, forall z : int, ((lez x y) /\ (lez y z)) -> P x y z)) -> forall x : int, forall y : int, forall z : int, P x y z.
Axiom thm_INT_FORALL_POS : forall P : int -> Prop, (forall n : nat, P (int_of_nat n)) = (forall i : int, (lez (int_of_nat (NUMERAL O)) i) -> P i).
Axiom thm_INT_EXISTS_POS : forall P : int -> Prop, (exists n : nat, P (int_of_nat n)) = (exists i : int, (lez (int_of_nat (NUMERAL O)) i) /\ (P i)).
Axiom thm_INT_FORALL_ABS : forall P : int -> Prop, (forall n : nat, P (int_of_nat n)) = (forall x : int, P (normz x)).
Axiom thm_INT_EXISTS_ABS : forall P : int -> Prop, (exists n : nat, P (int_of_nat n)) = (exists x : int, P (normz x)).
Axiom thm_INT_POW : forall (x : int), ((expz x (NUMERAL O)) = (int_of_nat (NUMERAL (BIT1 O)))) /\ (forall n : nat, (expz x (S n)) = (mulz x (expz x n))).
Axiom thm_INT_ABS : forall x : int, (normz x) = (@COND int (lez (int_of_nat (NUMERAL O)) x) x (oppz x)).
Axiom thm_INT_GE : forall x : int, forall y : int, (gez x y) = (lez y x).
Axiom thm_INT_GT : forall x : int, forall y : int, (gtz x y) = (ltz y x).
Axiom thm_INT_LT : forall x : int, forall y : int, (ltz x y) = (~ (lez y x)).
Axiom thm_INT_SUB : forall x : int, forall y : int, (subz x y) = (addz x (oppz y)).
Axiom thm_INT_MAX : forall x : int, forall y : int, (maxz x y) = (@COND int (lez x y) y x).
Axiom thm_INT_MIN : forall x : int, forall y : int, (minz x y) = (@COND int (lez x y) x y).
Axiom thm_INT_OF_NUM_EXISTS : forall x : int, (exists n : nat, x = (int_of_nat n)) = (lez (int_of_nat (NUMERAL O)) x).
Axiom thm_INT_LE_DISCRETE : forall x : int, forall y : int, (lez x y) = (ltz x (addz y (int_of_nat (NUMERAL (BIT1 O))))).
Axiom thm_INT_LE_TRANS_LE : forall x : int, forall y : int, (lez x y) = (forall z : int, (lez y z) -> lez x z).
Axiom thm_INT_LE_TRANS_LT : forall x : int, forall y : int, (lez x y) = (forall z : int, (ltz y z) -> ltz x z).
Axiom thm_INT_MUL_EQ_1 : forall x : int, forall y : int, ((mulz x y) = (int_of_nat (NUMERAL (BIT1 O)))) = (((x = (int_of_nat (NUMERAL (BIT1 O)))) /\ (y = (int_of_nat (NUMERAL (BIT1 O))))) \/ ((x = (oppz (int_of_nat (NUMERAL (BIT1 O))))) /\ (y = (oppz (int_of_nat (NUMERAL (BIT1 O))))))).
Axiom thm_INT_ABS_MUL_1 : forall x : int, forall y : int, ((normz (mulz x y)) = (int_of_nat (NUMERAL (BIT1 O)))) = (((normz x) = (int_of_nat (NUMERAL (BIT1 O)))) /\ ((normz y) = (int_of_nat (NUMERAL (BIT1 O))))).
Axiom thm_INT_WOP : forall (P : int -> Prop), (exists x : int, (lez (int_of_nat (NUMERAL O)) x) /\ (P x)) = (exists x : int, (lez (int_of_nat (NUMERAL O)) x) /\ ((P x) /\ (forall y : int, ((lez (int_of_nat (NUMERAL O)) y) /\ (P y)) -> lez x y))).
Axiom thm_INT_ARCH : forall x : int, forall d : int, (~ (d = (int_of_nat (NUMERAL O)))) -> exists c : int, ltz x (mulz c d).
Axiom thm_INT_DIVMOD_EXIST_0 : forall m : int, forall n : int, exists q : int, exists r : int, @COND Prop (n = (int_of_nat (NUMERAL O))) ((q = (int_of_nat (NUMERAL O))) /\ (r = m)) ((lez (int_of_nat (NUMERAL O)) r) /\ ((ltz r (normz n)) /\ (m = (addz (mulz q n) r)))).
Axiom thm_INT_DIVISION : forall m : int, forall n : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (m = (addz (mulz (divz m n) n) (modz m n))) /\ ((lez (int_of_nat (NUMERAL O)) (modz m n)) /\ (ltz (modz m n) (normz n))).
Axiom thm_INT_DIVISION_SIMP : forall m : int, forall n : int, (addz (mulz (divz m n) n) (modz m n)) = m.
Axiom thm_INT_REM_POS : forall a : int, forall b : int, (~ (b = (int_of_nat (NUMERAL O)))) -> lez (int_of_nat (NUMERAL O)) (modz a b).
Axiom thm_INT_DIV_0 : forall m : int, (divz m (int_of_nat (NUMERAL O))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_REM_0 : forall m : int, (modz m (int_of_nat (NUMERAL O))) = m.
Axiom thm_INT_REM_POS_EQ : forall m : int, forall n : int, (lez (int_of_nat (NUMERAL O)) (modz m n)) = ((n = (int_of_nat (NUMERAL O))) -> lez (int_of_nat (NUMERAL O)) m).
Axiom thm_INT_REM_DIV : forall m : int, forall n : int, (modz m n) = (subz m (mulz (divz m n) n)).
Axiom thm_INT_LT_REM : forall x : int, forall n : int, (ltz (int_of_nat (NUMERAL O)) n) -> ltz (modz x n) n.
Axiom thm_INT_LT_REM_EQ : forall m : int, forall n : int, (ltz (modz m n) n) = ((ltz (int_of_nat (NUMERAL O)) n) \/ ((n = (int_of_nat (NUMERAL O))) /\ (ltz m (int_of_nat (NUMERAL O))))).
Axiom thm_cong : forall {A : Type'}, forall rel : A -> A -> Prop, forall x : A, forall y : A, (@eq2 A x y rel) = (rel x y).
Axiom thm_real_mod : forall x : R, forall y : R, forall n : R, (congruent_modzr n x y) = (exists q : R, (Rint q) /\ ((subr x y) = (mulr q n))).
Axiom thm_int_divides : forall b : int, forall a : int, (dividez a b) = (exists x : int, b = (mulz a x)).
Axiom thm_INT_DIVIDES_LE : forall x : int, forall y : int, (dividez x y) -> (lez (normz x) (normz y)) \/ (y = (int_of_nat (NUMERAL O))).
Axiom thm_int_mod : forall n : int, forall x : int, forall y : int, (int_mod n x y) = (dividez n (subz x y)).
Axiom thm_int_congruent : forall x : int, forall y : int, forall n : int, (@eq2 int x y (int_mod n)) = (exists d : int, (subz x y) = (mulz n d)).
Axiom thm_INT_CONG_IMP_EQ : forall x : int, forall y : int, forall n : int, ((ltz (normz (subz x y)) n) /\ (@eq2 int x y (int_mod n))) -> x = y.
Axiom thm_int_coprime : forall a : int, forall b : int, (pair_coprimez (@pair int int a b)) = (exists x : int, exists y : int, (addz (mulz a x) (mulz b y)) = (int_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_INT_DIVMOD_UNIQ : forall m : int, forall n : int, forall q : int, forall r : int, ((m = (addz (mulz q n) r)) /\ ((lez (int_of_nat (NUMERAL O)) r) /\ (ltz r (normz n)))) -> ((divz m n) = q) /\ ((modz m n) = r).
Axiom thm_INT_DIV_UNIQ : forall m : int, forall n : int, forall q : int, forall r : int, ((m = (addz (mulz q n) r)) /\ ((lez (int_of_nat (NUMERAL O)) r) /\ (ltz r (normz n)))) -> (divz m n) = q.
Axiom thm_INT_REM_UNIQ : forall m : int, forall n : int, forall q : int, forall r : int, ((m = (addz (mulz q n) r)) /\ ((lez (int_of_nat (NUMERAL O)) r) /\ (ltz r (normz n)))) -> (modz m n) = r.
Axiom thm_INT_REM_LT : forall m : int, forall n : int, (((~ (n = (int_of_nat (NUMERAL O)))) -> lez (int_of_nat (NUMERAL O)) m) /\ (ltz m n)) -> (modz m n) = m.
Axiom thm_INT_DIV_LT : forall m : int, forall n : int, (((~ (n = (int_of_nat (NUMERAL O)))) -> lez (int_of_nat (NUMERAL O)) m) /\ (ltz m n)) -> (divz m n) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_REM_RNEG : forall m : int, forall n : int, (modz m (oppz n)) = (modz m n).
Axiom thm_INT_DIV_RNEG : forall m : int, forall n : int, (divz m (oppz n)) = (oppz (divz m n)).
Axiom thm_INT_REM_RABS : forall x : int, forall y : int, (modz x (normz y)) = (modz x y).
Axiom thm_INT_REM_REM : forall m : int, forall n : int, (modz (modz m n) n) = (modz m n).
Axiom thm_INT_REM_EQ : forall m : int, forall n : int, forall p : int, ((modz m p) = (modz n p)) = (@eq2 int m n (int_mod p)).
Axiom thm_INT_REM_ZERO : forall n : int, (modz (int_of_nat (NUMERAL O)) n) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_DIV_ZERO : forall n : int, (divz (int_of_nat (NUMERAL O)) n) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_REM_EQ_0 : forall m : int, forall n : int, ((modz m n) = (int_of_nat (NUMERAL O))) = (dividez n m).
Axiom thm_INT_MUL_DIV_EQ : (forall m : int, forall n : int, ((mulz n (divz m n)) = m) = (dividez n m)) /\ (forall m : int, forall n : int, ((mulz (divz m n) n) = m) = (dividez n m)).
Axiom thm_INT_CONG_LREM : forall x : int, forall y : int, forall n : int, (@eq2 int (modz x n) y (int_mod n)) = (@eq2 int x y (int_mod n)).
Axiom thm_INT_CONG_RREM : forall x : int, forall y : int, forall n : int, (@eq2 int x (modz y n) (int_mod n)) = (@eq2 int x y (int_mod n)).
Axiom thm_INT_REM_MOD_SELF : forall m : int, forall n : int, @eq2 int (modz m n) m (int_mod n).
Axiom thm_INT_REM_REM_MUL : (forall m : int, forall n : int, forall p : int, (modz (modz m (mulz n p)) n) = (modz m n)) /\ (forall m : int, forall n : int, forall p : int, (modz (modz m (mulz n p)) p) = (modz m p)).
Axiom thm_INT_CONG_SOLVE_BOUNDS : forall a : int, forall n : int, (~ (n = (int_of_nat (NUMERAL O)))) -> exists x : int, (lez (int_of_nat (NUMERAL O)) x) /\ ((ltz x (normz n)) /\ (@eq2 int x a (int_mod n))).
Axiom thm_INT_NEG_REM : forall n : int, forall p : int, (modz (oppz (modz n p)) p) = (modz (oppz n) p).
Axiom thm_INT_ADD_REM : forall m : int, forall n : int, forall p : int, (modz (addz (modz m p) (modz n p)) p) = (modz (addz m n) p).
Axiom thm_INT_SUB_REM : forall m : int, forall n : int, forall p : int, (modz (subz (modz m p) (modz n p)) p) = (modz (subz m n) p).
Axiom thm_INT_MUL_REM : forall m : int, forall n : int, forall p : int, (modz (mulz (modz m p) (modz n p)) p) = (modz (mulz m n) p).
Axiom thm_INT_POW_REM : forall m : int, forall n : nat, forall p : int, (modz (expz (modz m p) n) p) = (modz (expz m n) p).
Axiom thm_INT_OF_NUM_REM : forall m : nat, forall n : nat, (modz (int_of_nat m) (int_of_nat n)) = (int_of_nat (modn m n)).
Axiom thm_INT_OF_NUM_DIV : forall m : nat, forall n : nat, (divz (int_of_nat m) (int_of_nat n)) = (int_of_nat (divn m n)).
Axiom thm_INT_REM_REFL : forall n : int, (modz n n) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_DIV_REFL : forall n : int, (divz n n) = (@COND int (n = (int_of_nat (NUMERAL O))) (int_of_nat (NUMERAL O)) (int_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_INT_REM_LNEG : forall m : int, forall n : int, (modz (oppz m) n) = (@COND int ((modz m n) = (int_of_nat (NUMERAL O))) (int_of_nat (NUMERAL O)) (subz (normz n) (modz m n))).
Axiom thm_INT_DIV_LNEG : forall m : int, forall n : int, (divz (oppz m) n) = (@COND int ((modz m n) = (int_of_nat (NUMERAL O))) (oppz (divz m n)) (subz (oppz (divz m n)) (sgz n))).
Axiom thm_INT_DIV_NEG2 : forall m : int, forall n : int, (divz (oppz m) (oppz n)) = (@COND int ((modz m n) = (int_of_nat (NUMERAL O))) (divz m n) (addz (divz m n) (sgz n))).
Axiom thm_INT_REM_NEG2 : forall m : int, forall n : int, (modz (oppz m) (oppz n)) = (@COND int ((modz m n) = (int_of_nat (NUMERAL O))) (int_of_nat (NUMERAL O)) (subz (normz n) (modz m n))).
Axiom thm_INT_REM_1 : forall n : int, (modz n (int_of_nat (NUMERAL (BIT1 O)))) = (int_of_nat (NUMERAL O)).
Axiom thm_INT_DIV_1 : forall n : int, (divz n (int_of_nat (NUMERAL (BIT1 O)))) = n.
Axiom thm_INT_REM_MUL : (forall m : int, forall n : int, (modz (mulz m n) n) = (int_of_nat (NUMERAL O))) /\ (forall m : int, forall n : int, (modz (mulz m n) m) = (int_of_nat (NUMERAL O))).
Axiom thm_INT_DIV_MUL : (forall m : int, forall n : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (divz (mulz m n) n) = m) /\ (forall m : int, forall n : int, (~ (m = (int_of_nat (NUMERAL O)))) -> (divz (mulz m n) m) = n).
Axiom thm_INT_DIV_LT_EQ : forall a : int, forall b : int, forall c : int, (ltz (int_of_nat (NUMERAL O)) a) -> (ltz (divz b a) c) = (ltz b (mulz a c)).
Axiom thm_INT_LE_DIV_EQ : forall a : int, forall b : int, forall c : int, (ltz (int_of_nat (NUMERAL O)) a) -> (lez c (divz b a)) = (lez (mulz a c) b).
Axiom thm_INT_DIV_LE_EQ : forall a : int, forall b : int, forall c : int, (ltz (int_of_nat (NUMERAL O)) a) -> (lez (divz b a) c) = (ltz b (mulz a (addz c (int_of_nat (NUMERAL (BIT1 O)))))).
Axiom thm_INT_LT_DIV_EQ : forall a : int, forall b : int, forall c : int, (ltz (int_of_nat (NUMERAL O)) a) -> (ltz c (divz b a)) = (lez (mulz a (addz c (int_of_nat (NUMERAL (BIT1 O))))) b).
Axiom thm_INT_DIV_LE : forall m : int, forall n : int, lez (normz (divz m n)) (normz m).
Axiom thm_INT_REM_MUL_REM : forall m : int, forall n : int, forall p : int, (lez (int_of_nat (NUMERAL O)) n) -> (modz m (mulz n p)) = (addz (mulz n (modz (divz m n) p)) (modz m n)).
Axiom thm_INT_DIV_DIV : forall m : int, forall n : int, forall p : int, (lez (int_of_nat (NUMERAL O)) n) -> (divz (divz m n) p) = (divz m (mulz n p)).
Axiom thm_INT_DIV_EQ_0 : forall m : int, forall n : int, ((divz m n) = (int_of_nat (NUMERAL O))) = ((n = (int_of_nat (NUMERAL O))) \/ ((lez (int_of_nat (NUMERAL O)) m) /\ (ltz m (normz n)))).
Axiom thm_INT_REM_EQ_SELF : forall m : int, forall n : int, ((modz m n) = m) = ((n = (int_of_nat (NUMERAL O))) \/ ((lez (int_of_nat (NUMERAL O)) m) /\ (ltz m (normz n)))).
Axiom thm_INT_REM_UNIQUE : forall m : int, forall n : int, forall p : int, ((modz m n) = p) = ((((n = (int_of_nat (NUMERAL O))) /\ (m = p)) \/ ((lez (int_of_nat (NUMERAL O)) p) /\ (ltz p (normz n)))) /\ (@eq2 int m p (int_mod n))).
Axiom thm_INT_DIV_REM : forall m : int, forall n : int, forall p : int, (lez (int_of_nat (NUMERAL O)) n) -> (modz (divz m n) p) = (divz (modz m (mulz n p)) n).
Axiom thm_INT_REM_REM_LE : forall m : int, forall n : int, forall p : int, ((~ (n = (int_of_nat (NUMERAL O)))) /\ (lez (normz n) (normz p))) -> (modz (modz m n) p) = (modz m n).
Axiom thm_INT_LE_DIV : forall m : int, forall n : int, ((lez (int_of_nat (NUMERAL O)) m) /\ (lez (int_of_nat (NUMERAL O)) n)) -> lez (int_of_nat (NUMERAL O)) (divz m n).
Axiom thm_INT_LT_DIV : forall m : int, forall n : int, ((ltz (int_of_nat (NUMERAL O)) n) /\ (lez n m)) -> ltz (int_of_nat (NUMERAL O)) (divz m n).
Axiom thm_INT_REM_LE_EQ : forall m : int, forall n : int, (lez (modz m n) m) = ((n = (int_of_nat (NUMERAL O))) \/ (lez (int_of_nat (NUMERAL O)) m)).
Axiom thm_INT_REM_LE : forall m : int, forall n : int, forall p : int, (((n = (int_of_nat (NUMERAL O))) \/ (lez (int_of_nat (NUMERAL O)) m)) /\ (lez m p)) -> lez (modz m n) p.
Axiom thm_INT_REM_MUL_ADD : (forall m : int, forall n : int, forall p : int, (modz (addz (mulz m n) p) n) = (modz p n)) /\ ((forall m : int, forall n : int, forall p : int, (modz (addz (mulz n m) p) n) = (modz p n)) /\ ((forall m : int, forall n : int, forall p : int, (modz (addz p (mulz m n)) n) = (modz p n)) /\ (forall m : int, forall n : int, forall p : int, (modz (addz p (mulz n m)) n) = (modz p n)))).
Axiom thm_INT_DIV_MUL_ADD : (forall m : int, forall n : int, forall p : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (divz (addz (mulz m n) p) n) = (addz m (divz p n))) /\ ((forall m : int, forall n : int, forall p : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (divz (addz (mulz n m) p) n) = (addz m (divz p n))) /\ ((forall m : int, forall n : int, forall p : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (divz (addz p (mulz m n)) n) = (addz (divz p n) m)) /\ (forall m : int, forall n : int, forall p : int, (~ (n = (int_of_nat (NUMERAL O)))) -> (divz (addz p (mulz n m)) n) = (addz (divz p n) m)))).
Axiom thm_INT_CONG_DIV2 : forall a : int, forall b : int, forall m : int, forall n : int, (@eq2 int a b (int_mod (mulz m n))) -> @eq2 int (divz a m) (divz b m) (int_mod n).
Axiom thm_INT_REM_2_CASES : forall n : int, ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL O))) \/ ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_NOT_INT_REM_2 : (forall n : int, (~ ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL O)))) = ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL (BIT1 O))))) /\ (forall n : int, (~ ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL (BIT1 O))))) = ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL O)))).
Axiom thm_INT_REM_2_DIVIDES : (forall n : int, ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL O))) = (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n)) /\ (forall n : int, ((modz n (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (int_of_nat (NUMERAL (BIT1 O)))) = (~ (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n))).
Axiom thm_INT_REM_2_EXPAND : forall x : int, (modz x (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (@COND int (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) x) (int_of_nat (NUMERAL O)) (int_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_INT_REM_2_NEG : forall x : int, (modz (oppz x) (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (modz x (int_of_nat (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_INT_DIVIDES_DIV_SELF : forall n : int, forall d : int, (dividez d n) -> dividez (divz n d) n.
Axiom thm_INT_DIV_BY_DIV : forall m : int, forall n : int, ((~ (n = (int_of_nat (NUMERAL O)))) /\ (dividez m n)) -> (divz n (divz n m)) = m.
Axiom thm_INT_DIVIDES_DIV_DIVIDES : forall n : int, forall d : int, forall e : int, ((dividez d n) /\ ((n = (int_of_nat (NUMERAL O))) -> e = (int_of_nat (NUMERAL O)))) -> (dividez (divz n d) e) = (dividez n (mulz d e)).
Axiom thm_INT_DIVIDES_DIVIDES_DIV : forall n : int, forall d : int, forall e : int, (dividez d n) -> (dividez e (divz n d)) = (dividez (mulz d e) n).
Axiom thm_INT_DIVIDES_DIVIDES_DIV_EQ : forall n : int, forall d : int, forall e : int, ((dividez d n) /\ (dividez e (divz n d))) = (dividez (mulz d e) n).
Axiom thm_INT_2_DIVIDES_ADD : forall m : int, forall n : int, (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (addz m n)) = ((dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) m) = (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n)).
Axiom thm_INT_2_DIVIDES_SUB : forall m : int, forall n : int, (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (subz m n)) = ((dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) m) = (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n)).
Axiom thm_INT_2_DIVIDES_MUL : forall m : int, forall n : int, (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (mulz m n)) = ((dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) m) \/ (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n)).
Axiom thm_INT_2_DIVIDES_POW : forall n : int, forall k : nat, (dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) (expz n k)) = ((dividez (int_of_nat (NUMERAL (BIT0 (BIT1 O)))) n) /\ (~ (k = (NUMERAL O)))).
Axiom thm_WF_INT_MEASURE : forall {A : Type'}, forall P : A -> Prop, forall m : A -> int, ((forall x : A, lez (int_of_nat (NUMERAL O)) (m x)) /\ (forall x : A, (forall y : A, (ltz (m y) (m x)) -> P y) -> P x)) -> forall x : A, P x.
Axiom thm_WF_INT_MEASURE_2 : forall {A B : Type'}, forall P : A -> B -> Prop, forall m : A -> B -> int, ((forall x : A, forall y : B, lez (int_of_nat (NUMERAL O)) (m x y)) /\ (forall x : A, forall y : B, (forall x' : A, forall y' : B, (ltz (m x' y') (m x y)) -> P x' y') -> P x y)) -> forall x : A, forall y : B, P x y.
Axiom thm_INT_GCD_EXISTS : forall a : int, forall b : int, exists d : int, (dividez d a) /\ ((dividez d b) /\ (exists x : int, exists y : int, d = (addz (mulz a x) (mulz b y)))).
Axiom thm_INT_GCD_EXISTS_POS : forall a : int, forall b : int, exists d : int, (lez (int_of_nat (NUMERAL O)) d) /\ ((dividez d a) /\ ((dividez d b) /\ (exists x : int, exists y : int, d = (addz (mulz a x) (mulz b y))))).
Axiom thm_int_lcm : forall m : int, forall n : int, (pair_lcmz (@pair int int m n)) = (@COND int ((mulz m n) = (int_of_nat (NUMERAL O))) (int_of_nat (NUMERAL O)) (divz (normz (mulz m n)) (pair_gcdz (@pair int int m n)))).
Axiom thm_INT_DIVIDES_LABS : forall d : int, forall n : int, (dividez (normz d) n) = (dividez d n).
Axiom thm_INT_DIVIDES_RABS : forall d : int, forall n : int, (dividez d (normz n)) = (dividez d n).
Axiom thm_INT_DIVIDES_ABS : (forall d : int, forall n : int, (dividez (normz d) n) = (dividez d n)) /\ (forall d : int, forall n : int, (dividez d (normz n)) = (dividez d n)).
Axiom thm_INT_LCM_POS : forall m : int, forall n : int, lez (int_of_nat (NUMERAL O)) (pair_lcmz (@pair int int m n)).
Axiom thm_INT_MUL_GCD_LCM : forall m : int, forall n : int, (mulz (pair_gcdz (@pair int int m n)) (pair_lcmz (@pair int int m n))) = (normz (mulz m n)).
Axiom thm_INT_MUL_LCM_GCD : forall m : int, forall n : int, (mulz (pair_lcmz (@pair int int m n)) (pair_gcdz (@pair int int m n))) = (normz (mulz m n)).
Axiom thm_INT_DIVIDES_LCM_GCD : forall m : int, forall n : int, forall d : int, (dividez d (pair_lcmz (@pair int int m n))) = (dividez (mulz d (pair_gcdz (@pair int int m n))) (mulz m n)).
Axiom thm_INT_LCM_DIVIDES : forall m : int, forall n : int, forall d : int, (dividez (pair_lcmz (@pair int int m n)) d) = ((dividez m d) /\ (dividez n d)).
Axiom thm_INT_LCM : forall m : int, forall n : int, (dividez m (pair_lcmz (@pair int int m n))) /\ ((dividez n (pair_lcmz (@pair int int m n))) /\ (forall d : int, ((dividez m d) /\ (dividez n d)) -> dividez (pair_lcmz (@pair int int m n)) d)).
Axiom thm_num_of_int : forall x : int, (num_of_int x) = (@ε nat (fun n : nat => (int_of_nat n) = x)).
Axiom thm_NUM_OF_INT_OF_NUM : forall n : nat, (num_of_int (int_of_nat n)) = n.
Axiom thm_INT_OF_NUM_OF_INT : forall x : int, (lez (int_of_nat (NUMERAL O)) x) -> (int_of_nat (num_of_int x)) = x.
Axiom thm_NUM_OF_INT : forall x : int, (lez (int_of_nat (NUMERAL O)) x) = ((int_of_nat (num_of_int x)) = x).
Axiom thm_NUM_OF_INT_ADD : forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez (int_of_nat (NUMERAL O)) y)) -> (num_of_int (addz x y)) = (addn (num_of_int x) (num_of_int y)).
Axiom thm_NUM_OF_INT_MUL : forall x : int, forall y : int, ((lez (int_of_nat (NUMERAL O)) x) /\ (lez (int_of_nat (NUMERAL O)) y)) -> (num_of_int (mulz x y)) = (muln (num_of_int x) (num_of_int y)).
Axiom thm_NUM_OF_INT_POW : forall x : int, forall n : nat, (lez (int_of_nat (NUMERAL O)) x) -> (num_of_int (expz x n)) = (expn (num_of_int x) n).
Axiom thm_num_divides : forall a : nat, forall b : nat, (num_divides a b) = (dividez (int_of_nat a) (int_of_nat b)).
Axiom thm_num_mod : forall n : nat, forall x : nat, forall y : nat, (num_mod n x y) = (int_mod (int_of_nat n) (int_of_nat x) (int_of_nat y)).
Axiom thm_num_congruent : forall x : nat, forall y : nat, forall n : nat, (@eq2 nat x y (num_mod n)) = (@eq2 int (int_of_nat x) (int_of_nat y) (int_mod (int_of_nat n))).
Axiom thm_num_coprime : forall a : nat, forall b : nat, (num_coprime (@pair nat nat a b)) = (pair_coprimez (@pair int int (int_of_nat a) (int_of_nat b))).
Axiom thm_num_gcd : forall a : nat, forall b : nat, (num_gcd (@pair nat nat a b)) = (num_of_int (pair_gcdz (@pair int int (int_of_nat a) (int_of_nat b)))).
Axiom thm_num_lcm : forall a : nat, forall b : nat, (num_lcm (@pair nat nat a b)) = (num_of_int (pair_lcmz (@pair int int (int_of_nat a) (int_of_nat b)))).
Axiom thm_BINARY_INDUCT : forall P : nat -> Prop, ((P (NUMERAL O)) /\ (forall n : nat, (P n) -> (P (muln (NUMERAL (BIT0 (BIT1 O))) n)) /\ (P (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O)))))) -> forall n : nat, P n.
Axiom thm_NUM_CASES_BINARY : forall P : nat -> Prop, (forall n : nat, P n) = ((forall n : nat, P (muln (NUMERAL (BIT0 (BIT1 O))) n)) /\ (forall n : nat, P (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O))))).
Axiom thm_num_WF_DOWN : forall P : nat -> Prop, forall m : nat, ((forall n : nat, (leqn m n) -> P n) /\ (forall n : nat, ((ltn n m) /\ (forall p : nat, (ltn n p) -> P p)) -> P n)) -> forall n : nat, P n.
Axiom thm_INT_REM_REM_POW_MIN : forall x : int, forall p : int, forall m : nat, forall n : nat, (modz (modz x (expz p m)) (expz p n)) = (modz x (expz p (minn m n))).
Axiom thm_NUM_GCD : forall a : nat, forall b : nat, (int_of_nat (num_gcd (@pair nat nat a b))) = (pair_gcdz (@pair int int (int_of_nat a) (int_of_nat b))).
Axiom thm_NUM_LCM : forall a : nat, forall b : nat, (int_of_nat (num_lcm (@pair nat nat a b))) = (pair_lcmz (@pair int int (int_of_nat a) (int_of_nat b))).
Axiom thm_CONG : forall x : nat, forall y : nat, forall n : nat, (@eq2 nat x y (num_mod n)) = ((modn x n) = (modn y n)).
Axiom thm_CONG_LMOD : forall x : nat, forall y : nat, forall n : nat, (@eq2 nat (modn x n) y (num_mod n)) = (@eq2 nat x y (num_mod n)).
Axiom thm_CONG_RMOD : forall x : nat, forall y : nat, forall n : nat, (@eq2 nat x (modn y n) (num_mod n)) = (@eq2 nat x y (num_mod n)).
Axiom thm_CONG_DIV2 : forall a : nat, forall b : nat, forall m : nat, forall n : nat, (@eq2 nat a b (num_mod (muln m n))) -> @eq2 nat (divn a m) (divn b m) (num_mod n).
Axiom thm_divides : forall (b : nat) (a : nat), (num_divides a b) = (exists x : nat, b = (muln a x)).
Axiom thm_DIVIDES_LE : forall m : nat, forall n : nat, (num_divides m n) -> (leqn m n) \/ (n = (NUMERAL O)).
Axiom thm_DIVIDES_LE_STRONG : forall m : nat, forall n : nat, (num_divides m n) -> ((leqn (NUMERAL (BIT1 O)) m) /\ (leqn m n)) \/ (n = (NUMERAL O)).
Axiom thm_DIVIDES_LE_IMP : forall m : nat, forall n : nat, ((num_divides m n) /\ ((n = (NUMERAL O)) -> m = (NUMERAL O))) -> leqn m n.
Axiom thm_PROPERLY_DIVIDES_LE_IMP : forall m : nat, forall n : nat, ((num_divides m n) /\ ((~ (n = (NUMERAL O))) /\ (~ (m = n)))) -> leqn (muln (NUMERAL (BIT0 (BIT1 O))) m) n.
Axiom thm_DIVIDES_ANTISYM : forall m : nat, forall n : nat, ((num_divides m n) /\ (num_divides n m)) = (m = n).
Axiom thm_DIVIDES_ONE : forall n : nat, (num_divides n (NUMERAL (BIT1 O))) = (n = (NUMERAL (BIT1 O))).
Axiom thm_DIV_ADD : forall d : nat, forall a : nat, forall b : nat, ((num_divides d a) \/ (num_divides d b)) -> (divn (addn a b) d) = (addn (divn a d) (divn b d)).
Axiom thm_DIVIDES_MOD : forall m : nat, forall n : nat, (num_divides m n) = ((modn n m) = (NUMERAL O)).
Axiom thm_DIVIDES_DIV_MULT : forall m : nat, forall n : nat, (num_divides m n) = ((muln (divn n m) m) = n).
Axiom thm_DIV_BY_DIV : forall m : nat, forall n : nat, ((~ (n = (NUMERAL O))) /\ (num_divides m n)) -> (divn n (divn n m)) = m.
Axiom thm_DIVIDES_DIV_DIVIDES : forall n : nat, forall d : nat, forall e : nat, ((num_divides d n) /\ ((n = (NUMERAL O)) -> e = (NUMERAL O))) -> (num_divides (divn n d) e) = (num_divides n (muln d e)).
Axiom thm_DIVIDES_DIV_SELF : forall n : nat, forall d : nat, (num_divides d n) -> num_divides (divn n d) n.
Axiom thm_DIVIDES_DIVIDES_DIV : forall n : nat, forall d : nat, forall e : nat, (num_divides d n) -> (num_divides e (divn n d)) = (num_divides (muln d e) n).
Axiom thm_DIVIDES_DIVIDES_DIV_EQ : forall n : nat, forall d : nat, forall e : nat, ((num_divides d n) /\ (num_divides e (divn n d))) = (num_divides (muln d e) n).
Axiom thm_DIVIDES_DIVIDES_DIV_IMP : forall n : nat, forall d : nat, forall e : nat, (num_divides (muln d e) n) -> num_divides e (divn n d).
Axiom thm_MULT_DIV : (forall m : nat, forall n : nat, forall p : nat, (num_divides p m) -> (divn (muln m n) p) = (muln (divn m p) n)) /\ (forall m : nat, forall n : nat, forall p : nat, (num_divides p n) -> (divn (muln m n) p) = (muln m (divn n p))).
Axiom thm_COPRIME_LMOD : forall a : nat, forall n : nat, (num_coprime (@pair nat nat (modn a n) n)) = (num_coprime (@pair nat nat a n)).
Axiom thm_COPRIME_RMOD : forall a : nat, forall n : nat, (num_coprime (@pair nat nat n (modn a n))) = (num_coprime (@pair nat nat n a)).
Axiom thm_INT_CONG_NUM_EXISTS : forall x : int, forall y : int, ((y = (int_of_nat (NUMERAL O))) -> lez (int_of_nat (NUMERAL O)) x) -> exists n : nat, @eq2 int (int_of_nat n) x (int_mod y).
Axiom thm_GCD : forall a : nat, forall b : nat, ((num_divides (num_gcd (@pair nat nat a b)) a) /\ (num_divides (num_gcd (@pair nat nat a b)) b)) /\ (forall e : nat, ((num_divides e a) /\ (num_divides e b)) -> num_divides e (num_gcd (@pair nat nat a b))).
Axiom thm_coprime : forall (a : nat) (b : nat), (num_coprime (@pair nat nat a b)) = (forall d : nat, ((num_divides d a) /\ (num_divides d b)) -> d = (NUMERAL (BIT1 O))).
Axiom thm_prime : forall p : nat, (prime p) = ((~ (p = (NUMERAL (BIT1 O)))) /\ (forall x : nat, (num_divides x p) -> (x = (NUMERAL (BIT1 O))) \/ (x = p))).
Axiom thm_ONE_OR_PRIME : forall p : nat, ((p = (NUMERAL (BIT1 O))) \/ (prime p)) = (forall n : nat, (num_divides n p) -> (n = (NUMERAL (BIT1 O))) \/ (n = p)).
Axiom thm_ONE_OR_PRIME_DIVIDES_OR_COPRIME : forall p : nat, ((p = (NUMERAL (BIT1 O))) \/ (prime p)) = (forall n : nat, (num_divides p n) \/ (num_coprime (@pair nat nat p n))).
Axiom thm_PRIME_COPRIME_EQ_NONDIVISIBLE : forall p : nat, (prime p) = (forall n : nat, (num_coprime (@pair nat nat p n)) = (~ (num_divides p n))).
Axiom thm_ZERO_ONE_OR_PRIME_DIVPROD : forall p : nat, forall a : nat, forall b : nat, ((p = (NUMERAL O)) \/ ((p = (NUMERAL (BIT1 O))) \/ (prime p))) -> (num_divides p (muln a b)) = ((num_divides p a) \/ (num_divides p b)).
Axiom thm_ZERO_ONE_OR_PRIME : forall p : nat, ((p = (NUMERAL O)) \/ ((p = (NUMERAL (BIT1 O))) \/ (prime p))) = (forall a : nat, forall b : nat, (num_divides p (muln a b)) -> (num_divides p a) \/ (num_divides p b)).
Axiom thm_real_zpow : forall z : R, forall i : int, (real_zpow z i) = (@COND R (lez (int_of_nat (NUMERAL O)) i) (expr z (num_of_int i)) (invr (expr z (num_of_int (oppz i))))).
Axiom thm_REAL_POW_ZPOW : forall x : R, forall n : nat, (expr x n) = (real_zpow x (int_of_nat n)).
Axiom thm_REAL_ZPOW_NUM : forall x : R, forall n : nat, (real_zpow x (int_of_nat n)) = (expr x n).
Axiom thm_REAL_ZPOW_0 : forall x : R, (real_zpow x (int_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_ZPOW_1 : forall x : R, (real_zpow x (int_of_nat (NUMERAL (BIT1 O)))) = x.
Axiom thm_REAL_ZPOW_2 : forall x : R, (real_zpow x (int_of_nat (NUMERAL (BIT0 (BIT1 O))))) = (mulr x x).
Axiom thm_REAL_ZPOW_ONE : forall n : int, (real_zpow (R_of_nat (NUMERAL (BIT1 O))) n) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_ZPOW_NEG : forall x : R, forall n : int, (real_zpow x (oppz n)) = (invr (real_zpow x n)).
Axiom thm_REAL_ZPOW_MINUS1 : forall x : R, (real_zpow x (oppz (int_of_nat (NUMERAL (BIT1 O))))) = (invr x).
Axiom thm_REAL_ZPOW_ZERO : forall n : int, (real_zpow (R_of_nat (NUMERAL O)) n) = (@COND R (n = (int_of_nat (NUMERAL O))) (R_of_nat (NUMERAL (BIT1 O))) (R_of_nat (NUMERAL O))).
Axiom thm_REAL_ZPOW_POW : (forall x : R, forall n : nat, (real_zpow x (int_of_nat n)) = (expr x n)) /\ (forall x : R, forall n : nat, (real_zpow x (oppz (int_of_nat n))) = (invr (expr x n))).
Axiom thm_REAL_INV_ZPOW : forall x : R, forall n : int, (invr (real_zpow x n)) = (real_zpow (invr x) n).
Axiom thm_REAL_ZPOW_INV : forall x : R, forall n : int, (real_zpow (invr x) n) = (invr (real_zpow x n)).
Axiom thm_REAL_ZPOW_ZPOW : forall x : R, forall m : int, forall n : int, (real_zpow (real_zpow x m) n) = (real_zpow x (mulz m n)).
Axiom thm_REAL_ZPOW_MUL : forall x : R, forall y : R, forall n : int, (real_zpow (mulr x y) n) = (mulr (real_zpow x n) (real_zpow y n)).
Axiom thm_REAL_ZPOW_DIV : forall x : R, forall y : R, forall n : int, (real_zpow (divr x y) n) = (divr (real_zpow x n) (real_zpow y n)).
Axiom thm_REAL_ZPOW_ADD : forall x : R, forall m : int, forall n : int, (~ (x = (R_of_nat (NUMERAL O)))) -> (real_zpow x (addz m n)) = (mulr (real_zpow x m) (real_zpow x n)).
Axiom thm_REAL_ZPOW_SUB : forall x : R, forall m : int, forall n : int, (~ (x = (R_of_nat (NUMERAL O)))) -> (real_zpow x (subz m n)) = (divr (real_zpow x m) (real_zpow x n)).
Axiom thm_REAL_ZPOW_LE : forall x : R, forall n : int, (ler (R_of_nat (NUMERAL O)) x) -> ler (R_of_nat (NUMERAL O)) (real_zpow x n).
Axiom thm_REAL_ZPOW_LT : forall x : R, forall n : int, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (real_zpow x n).
Axiom thm_REAL_ZPOW_EQ_0 : forall x : R, forall n : int, ((real_zpow x n) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) /\ (~ (n = (int_of_nat (NUMERAL O))))).
Axiom thm_REAL_ABS_ZPOW : forall x : R, forall n : int, (normr (real_zpow x n)) = (real_zpow (normr x) n).
Axiom thm_REAL_SGN_ZPOW : forall x : R, forall n : int, (sgr (real_zpow x n)) = (real_zpow (sgr x) n).
Axiom thm_IN : forall {A : Type'}, forall P : A -> Prop, forall x : A, (@IN A x P) = (P x).
Axiom thm_EXTENSION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (s = t) = (forall x : A, (@IN A x s) = (@IN A x t)).
Axiom thm_GSPEC : forall {A : Type'}, forall p : A -> Prop, (@GSPEC A p) = p.
Axiom thm_SETSPEC : forall {A : Type'}, forall P : Prop, forall v : A, forall t : A, (@SETSPEC A v P t) = (P /\ (v = t)).
Axiom thm_IN_ELIM_THM : forall {A : Type'}, (forall P : (Prop -> A -> Prop) -> Prop, forall x : A, (@IN A x (@GSPEC A (fun v : A => P (@SETSPEC A v)))) = (P (fun p : Prop => fun t : A => p /\ (x = t)))) /\ ((forall p : A -> Prop, forall x : A, (@IN A x (@GSPEC A (fun v : A => exists y : A, @SETSPEC A v (p y) y))) = (p x)) /\ ((forall P : (Prop -> A -> Prop) -> Prop, forall x : A, (@GSPEC A (fun v : A => P (@SETSPEC A v)) x) = (P (fun p : Prop => fun t : A => p /\ (x = t)))) /\ ((forall p : A -> Prop, forall x : A, (@GSPEC A (fun v : A => exists y : A, @SETSPEC A v (p y) y) x) = (p x)) /\ (forall p : A -> Prop, forall x : A, (@IN A x (fun y : A => p y)) = (p x))))).
Axiom thm_EMPTY : forall {A : Type'}, (@set0 A) = (fun x : A => False).
Axiom thm_INSERT_DEF : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@INSERT A x s) = (fun y : A => (@IN A y s) \/ (y = x)).
Axiom thm_UNIV : forall {A : Type'}, (@setT A) = (fun x : A => True).
Axiom thm_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setU A s t) = (@GSPEC A (fun GEN_PVAR_0 : A => exists x : A, @SETSPEC A GEN_PVAR_0 ((@IN A x s) \/ (@IN A x t)) x)).
Axiom thm_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@UNIONS A s) = (@GSPEC A (fun GEN_PVAR_1 : A => exists x : A, @SETSPEC A GEN_PVAR_1 (exists u : A -> Prop, (@IN (A -> Prop) u s) /\ (@IN A x u)) x)).
Axiom thm_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setI A s t) = (@GSPEC A (fun GEN_PVAR_2 : A => exists x : A, @SETSPEC A GEN_PVAR_2 ((@IN A x s) /\ (@IN A x t)) x)).
Axiom thm_INTERS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@INTERS A s) = (@GSPEC A (fun GEN_PVAR_3 : A => exists x : A, @SETSPEC A GEN_PVAR_3 (forall u : A -> Prop, (@IN (A -> Prop) u s) -> @IN A x u) x)).
Axiom thm_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setD A s t) = (@GSPEC A (fun GEN_PVAR_4 : A => exists x : A, @SETSPEC A GEN_PVAR_4 ((@IN A x s) /\ (~ (@IN A x t))) x)).
Axiom thm_INSERT : forall {A : Type'} (s : A -> Prop) (x : A), (@INSERT A x s) = (@GSPEC A (fun GEN_PVAR_5 : A => exists y : A, @SETSPEC A GEN_PVAR_5 ((@IN A y s) \/ (y = x)) y)).
Axiom thm_DELETE : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@DELETE A s x) = (@GSPEC A (fun GEN_PVAR_6 : A => exists y : A, @SETSPEC A GEN_PVAR_6 ((@IN A y s) /\ (~ (y = x))) y)).
Axiom thm_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@subset A s t) = (forall x : A, (@IN A x s) -> @IN A x t).
Axiom thm_PSUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@proper A s t) = ((@subset A s t) /\ (~ (s = t))).
Axiom thm_DISJOINT : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@DISJOINT A s t) = ((@setI A s t) = (@set0 A)).
Axiom thm_SING : forall {A : Type'}, forall s : A -> Prop, (@is_set1 A s) = (exists x : A, s = (@INSERT A x (@set0 A))).
Axiom thm_FINITE_RULES : forall {A : Type'}, (@finite_set A (@set0 A)) /\ (forall x : A, forall s : A -> Prop, (@finite_set A s) -> @finite_set A (@INSERT A x s)).
Axiom thm_FINITE_CASES : forall {A : Type'}, forall a : A -> Prop, (@finite_set A a) = ((a = (@set0 A)) \/ (exists x : A, exists s : A -> Prop, (a = (@INSERT A x s)) /\ (@finite_set A s))).
Axiom thm_FINITE_INDUCT : forall {A : Type'}, forall FINITE' : (A -> Prop) -> Prop, ((FINITE' (@set0 A)) /\ (forall x : A, forall s : A -> Prop, (FINITE' s) -> FINITE' (@INSERT A x s))) -> forall a : A -> Prop, (@finite_set A a) -> FINITE' a.
Axiom thm_INFINITE : forall {A : Type'}, forall s : A -> Prop, (@INFINITE A s) = (~ (@finite_set A s)).
Axiom thm_IMAGE : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, (@IMAGE A B f s) = (@GSPEC B (fun GEN_PVAR_7 : B => exists y : B, @SETSPEC B GEN_PVAR_7 (exists x : A, (@IN A x s) /\ (y = (f x))) y)).
Axiom thm_INJ : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, forall f : A -> B, (@INJ A B f s t) = ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y)).
Axiom thm_SURJ : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, forall f : A -> B, (@SURJ A B f s t) = ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : B, (@IN B x t) -> exists y : A, (@IN A y s) /\ ((f y) = x))).
Axiom thm_BIJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, (@BIJ A B f s t) = ((@INJ A B f s t) /\ (@SURJ A B f s t)).
Axiom thm_CHOICE : forall {A : Type'}, forall s : A -> Prop, (@CHOICE A s) = (@ε A (fun x : A => @IN A x s)).
Axiom thm_REST : forall {A : Type'}, forall s : A -> Prop, (@REST A s) = (@DELETE A s (@CHOICE A s)).
Axiom thm_NOT_IN_EMPTY : forall {A : Type'}, forall x : A, ~ (@IN A x (@set0 A)).
Axiom thm_IN_UNIV : forall {A : Type'}, forall x : A, @IN A x (@setT A).
Axiom thm_IN_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@IN A x (@setU A s t)) = ((@IN A x s) \/ (@IN A x t)).
Axiom thm_IN_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall x : A, (@IN A x (@UNIONS A s)) = (exists t : A -> Prop, (@IN (A -> Prop) t s) /\ (@IN A x t)).
Axiom thm_IN_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@IN A x (@setI A s t)) = ((@IN A x s) /\ (@IN A x t)).
Axiom thm_IN_INTERS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall x : A, (@IN A x (@INTERS A s)) = (forall t : A -> Prop, (@IN (A -> Prop) t s) -> @IN A x t).
Axiom thm_IN_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@IN A x (@setD A s t)) = ((@IN A x s) /\ (~ (@IN A x t))).
Axiom thm_IN_INSERT : forall {A : Type'}, forall x : A, forall y : A, forall s : A -> Prop, (@IN A x (@INSERT A y s)) = ((x = y) \/ (@IN A x s)).
Axiom thm_IN_DELETE : forall {A : Type'}, forall s : A -> Prop, forall x : A, forall y : A, (@IN A x (@DELETE A s y)) = ((@IN A x s) /\ (~ (x = y))).
Axiom thm_IN_SING : forall {A : Type'}, forall x : A, forall y : A, (@IN A x (@INSERT A y (@set0 A))) = (x = y).
Axiom thm_IN_IMAGE : forall {A B : Type'}, forall y : B, forall s : A -> Prop, forall f : A -> B, (@IN B y (@IMAGE A B f s)) = (exists x : A, (y = (f x)) /\ (@IN A x s)).
Axiom thm_IN_REST : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@IN A x (@REST A s)) = ((@IN A x s) /\ (~ (x = (@CHOICE A s)))).
Axiom thm_FORALL_IN_INSERT : forall {A : Type'}, forall P : A -> Prop, forall a : A, forall s : A -> Prop, (forall x : A, (@IN A x (@INSERT A a s)) -> P x) = ((P a) /\ (forall x : A, (@IN A x s) -> P x)).
Axiom thm_EXISTS_IN_INSERT : forall {A : Type'}, forall P : A -> Prop, forall a : A, forall s : A -> Prop, (exists x : A, (@IN A x (@INSERT A a s)) /\ (P x)) = ((P a) \/ (exists x : A, (@IN A x s) /\ (P x))).
Axiom thm_FORALL_IN_UNION : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (forall x : A, (@IN A x (@setU A s t)) -> P x) = ((forall x : A, (@IN A x s) -> P x) /\ (forall x : A, (@IN A x t) -> P x)).
Axiom thm_EXISTS_IN_UNION : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (exists x : A, (@IN A x (@setU A s t)) /\ (P x)) = ((exists x : A, (@IN A x s) /\ (P x)) \/ (exists x : A, (@IN A x t) /\ (P x))).
Axiom thm_FORALL_IN_IMAGE : forall {A B : Type'} (P : B -> Prop), forall f : A -> B, forall s : A -> Prop, (forall y : B, (@IN B y (@IMAGE A B f s)) -> P y) = (forall x : A, (@IN A x s) -> P (f x)).
Axiom thm_EXISTS_IN_IMAGE : forall {A B : Type'} (P : B -> Prop), forall f : A -> B, forall s : A -> Prop, (exists y : B, (@IN B y (@IMAGE A B f s)) /\ (P y)) = (exists x : A, (@IN A x s) /\ (P (f x))).
Axiom thm_FORALL_IN_GSPEC : forall {A B C D E : Type'}, (forall P : A -> Prop, forall Q : B -> Prop, forall f : A -> B, (forall z : B, (@IN B z (@GSPEC B (fun GEN_PVAR_8 : B => exists x : A, @SETSPEC B GEN_PVAR_8 (P x) (f x)))) -> Q z) = (forall x : A, (P x) -> Q (f x))) /\ ((forall P : A -> B -> Prop, forall Q : C -> Prop, forall f : A -> B -> C, (forall z : C, (@IN C z (@GSPEC C (fun GEN_PVAR_9 : C => exists x : A, exists y : B, @SETSPEC C GEN_PVAR_9 (P x y) (f x y)))) -> Q z) = (forall x : A, forall y : B, (P x y) -> Q (f x y))) /\ ((forall P : A -> B -> C -> Prop, forall Q : D -> Prop, forall f : A -> B -> C -> D, (forall z : D, (@IN D z (@GSPEC D (fun GEN_PVAR_10 : D => exists w : A, exists x : B, exists y : C, @SETSPEC D GEN_PVAR_10 (P w x y) (f w x y)))) -> Q z) = (forall w : A, forall x : B, forall y : C, (P w x y) -> Q (f w x y))) /\ (forall P : A -> B -> C -> D -> Prop, forall Q : E -> Prop, forall f : A -> B -> C -> D -> E, (forall z : E, (@IN E z (@GSPEC E (fun GEN_PVAR_11 : E => exists v : A, exists w : B, exists x : C, exists y : D, @SETSPEC E GEN_PVAR_11 (P v w x y) (f v w x y)))) -> Q z) = (forall v : A, forall w : B, forall x : C, forall y : D, (P v w x y) -> Q (f v w x y))))).
Axiom thm_EXISTS_IN_GSPEC : forall {A B C D E : Type'}, (forall P : A -> Prop, forall Q : B -> Prop, forall f : A -> B, (exists z : B, (@IN B z (@GSPEC B (fun GEN_PVAR_12 : B => exists x : A, @SETSPEC B GEN_PVAR_12 (P x) (f x)))) /\ (Q z)) = (exists x : A, (P x) /\ (Q (f x)))) /\ ((forall P : A -> B -> Prop, forall Q : C -> Prop, forall f : A -> B -> C, (exists z : C, (@IN C z (@GSPEC C (fun GEN_PVAR_13 : C => exists x : A, exists y : B, @SETSPEC C GEN_PVAR_13 (P x y) (f x y)))) /\ (Q z)) = (exists x : A, exists y : B, (P x y) /\ (Q (f x y)))) /\ ((forall P : A -> B -> C -> Prop, forall Q : D -> Prop, forall f : A -> B -> C -> D, (exists z : D, (@IN D z (@GSPEC D (fun GEN_PVAR_14 : D => exists w : A, exists x : B, exists y : C, @SETSPEC D GEN_PVAR_14 (P w x y) (f w x y)))) /\ (Q z)) = (exists w : A, exists x : B, exists y : C, (P w x y) /\ (Q (f w x y)))) /\ (forall P : A -> B -> C -> D -> Prop, forall Q : E -> Prop, forall f : A -> B -> C -> D -> E, (exists z : E, (@IN E z (@GSPEC E (fun GEN_PVAR_15 : E => exists v : A, exists w : B, exists x : C, exists y : D, @SETSPEC E GEN_PVAR_15 (P v w x y) (f v w x y)))) /\ (Q z)) = (exists v : A, exists w : B, exists x : C, exists y : D, (P v w x y) /\ (Q (f v w x y)))))).
Axiom thm_UNIONS_IMAGE : forall {A B : Type'}, forall f : A -> B -> Prop, forall s : A -> Prop, (@UNIONS B (@IMAGE A (B -> Prop) f s)) = (@GSPEC B (fun GEN_PVAR_16 : B => exists y : B, @SETSPEC B GEN_PVAR_16 (exists x : A, (@IN A x s) /\ (@IN B y (f x))) y)).
Axiom thm_INTERS_IMAGE : forall {A B : Type'}, forall f : A -> B -> Prop, forall s : A -> Prop, (@INTERS B (@IMAGE A (B -> Prop) f s)) = (@GSPEC B (fun GEN_PVAR_17 : B => exists y : B, @SETSPEC B GEN_PVAR_17 (forall x : A, (@IN A x s) -> @IN B y (f x)) y)).
Axiom thm_UNIONS_GSPEC : forall {A B C D : Type'}, (forall P : A -> Prop, forall f : A -> B -> Prop, (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_18 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_18 (P x) (f x)))) = (@GSPEC B (fun GEN_PVAR_19 : B => exists a : B, @SETSPEC B GEN_PVAR_19 (exists x : A, (P x) /\ (@IN B a (f x))) a))) /\ ((forall P : A -> B -> Prop, forall f : A -> B -> C -> Prop, (@UNIONS C (@GSPEC (C -> Prop) (fun GEN_PVAR_20 : C -> Prop => exists x : A, exists y : B, @SETSPEC (C -> Prop) GEN_PVAR_20 (P x y) (f x y)))) = (@GSPEC C (fun GEN_PVAR_21 : C => exists a : C, @SETSPEC C GEN_PVAR_21 (exists x : A, exists y : B, (P x y) /\ (@IN C a (f x y))) a))) /\ (forall P : A -> B -> C -> Prop, forall f : A -> B -> C -> D -> Prop, (@UNIONS D (@GSPEC (D -> Prop) (fun GEN_PVAR_22 : D -> Prop => exists x : A, exists y : B, exists z : C, @SETSPEC (D -> Prop) GEN_PVAR_22 (P x y z) (f x y z)))) = (@GSPEC D (fun GEN_PVAR_23 : D => exists a : D, @SETSPEC D GEN_PVAR_23 (exists x : A, exists y : B, exists z : C, (P x y z) /\ (@IN D a (f x y z))) a)))).
Axiom thm_INTERS_GSPEC : forall {A B C D : Type'}, (forall P : A -> Prop, forall f : A -> B -> Prop, (@INTERS B (@GSPEC (B -> Prop) (fun GEN_PVAR_24 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_24 (P x) (f x)))) = (@GSPEC B (fun GEN_PVAR_25 : B => exists a : B, @SETSPEC B GEN_PVAR_25 (forall x : A, (P x) -> @IN B a (f x)) a))) /\ ((forall P : A -> B -> Prop, forall f : A -> B -> C -> Prop, (@INTERS C (@GSPEC (C -> Prop) (fun GEN_PVAR_26 : C -> Prop => exists x : A, exists y : B, @SETSPEC (C -> Prop) GEN_PVAR_26 (P x y) (f x y)))) = (@GSPEC C (fun GEN_PVAR_27 : C => exists a : C, @SETSPEC C GEN_PVAR_27 (forall x : A, forall y : B, (P x y) -> @IN C a (f x y)) a))) /\ (forall P : A -> B -> C -> Prop, forall f : A -> B -> C -> D -> Prop, (@INTERS D (@GSPEC (D -> Prop) (fun GEN_PVAR_28 : D -> Prop => exists x : A, exists y : B, exists z : C, @SETSPEC (D -> Prop) GEN_PVAR_28 (P x y z) (f x y z)))) = (@GSPEC D (fun GEN_PVAR_29 : D => exists a : D, @SETSPEC D GEN_PVAR_29 (forall x : A, forall y : B, forall z : C, (P x y z) -> @IN D a (f x y z)) a)))).
Axiom thm_CHOICE_DEF : forall {A : Type'}, forall s : A -> Prop, (~ (s = (@set0 A))) -> @IN A (@CHOICE A s) s.
Axiom thm_NOT_EQUAL_SETS : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (~ (s = t)) = (exists x : A, (@IN A x t) = (~ (@IN A x s))).
Axiom thm_INSERT_RESTRICT : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall a : A, (@GSPEC A (fun GEN_PVAR_30 : A => exists x : A, @SETSPEC A GEN_PVAR_30 ((@IN A x (@INSERT A a s)) /\ (P x)) x)) = (@COND (A -> Prop) (P a) (@INSERT A a (@GSPEC A (fun GEN_PVAR_31 : A => exists x : A, @SETSPEC A GEN_PVAR_31 ((@IN A x s) /\ (P x)) x))) (@GSPEC A (fun GEN_PVAR_32 : A => exists x : A, @SETSPEC A GEN_PVAR_32 ((@IN A x s) /\ (P x)) x))).
Axiom thm_UNIV_1 : (@setT unit) = (@INSERT unit tt (@set0 unit)).
Axiom thm_MEMBER_NOT_EMPTY : forall {A : Type'}, forall s : A -> Prop, (exists x : A, @IN A x s) = (~ (s = (@set0 A))).
Axiom thm_UNIV_NOT_EMPTY : forall {A : Type'}, ~ ((@setT A) = (@set0 A)).
Axiom thm_EMPTY_NOT_UNIV : forall {A : Type'}, ~ ((@set0 A) = (@setT A)).
Axiom thm_EQ_UNIV : forall {A : Type'} (s : A -> Prop), (forall x : A, @IN A x s) = (s = (@setT A)).
Axiom thm_SUBSET_TRANS : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@subset A s t) /\ (@subset A t u)) -> @subset A s u.
Axiom thm_SUBSET_REFL : forall {A : Type'}, forall s : A -> Prop, @subset A s s.
Axiom thm_SUBSET_ANTISYM : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@subset A s t) /\ (@subset A t s)) -> s = t.
Axiom thm_SUBSET_ANTISYM_EQ : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@subset A s t) /\ (@subset A t s)) = (s = t).
Axiom thm_EMPTY_SUBSET : forall {A : Type'}, forall s : A -> Prop, @subset A (@set0 A) s.
Axiom thm_SUBSET_EMPTY : forall {A : Type'}, forall s : A -> Prop, (@subset A s (@set0 A)) = (s = (@set0 A)).
Axiom thm_SUBSET_UNIV : forall {A : Type'}, forall s : A -> Prop, @subset A s (@setT A).
Axiom thm_UNIV_SUBSET : forall {A : Type'}, forall s : A -> Prop, (@subset A (@setT A) s) = (s = (@setT A)).
Axiom thm_SING_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@subset A (@INSERT A x (@set0 A)) s) = (@IN A x s).
Axiom thm_SUBSET_RESTRICT : forall {A : Type'}, forall s : A -> Prop, forall P : A -> Prop, @subset A (@GSPEC A (fun GEN_PVAR_33 : A => exists x : A, @SETSPEC A GEN_PVAR_33 ((@IN A x s) /\ (P x)) x)) s.
Axiom thm_PSUBSET_TRANS : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@proper A s t) /\ (@proper A t u)) -> @proper A s u.
Axiom thm_PSUBSET_SUBSET_TRANS : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@proper A s t) /\ (@subset A t u)) -> @proper A s u.
Axiom thm_SUBSET_PSUBSET_TRANS : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@subset A s t) /\ (@proper A t u)) -> @proper A s u.
Axiom thm_PSUBSET_IRREFL : forall {A : Type'}, forall s : A -> Prop, ~ (@proper A s s).
Axiom thm_NOT_PSUBSET_EMPTY : forall {A : Type'}, forall s : A -> Prop, ~ (@proper A s (@set0 A)).
Axiom thm_NOT_UNIV_PSUBSET : forall {A : Type'}, forall s : A -> Prop, ~ (@proper A (@setT A) s).
Axiom thm_PSUBSET_UNIV : forall {A : Type'}, forall s : A -> Prop, (@proper A s (@setT A)) = (exists x : A, ~ (@IN A x s)).
Axiom thm_PSUBSET_ALT : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@proper A s t) = ((@subset A s t) /\ (exists a : A, (@IN A a t) /\ (~ (@IN A a s)))).
Axiom thm_UNION_ASSOC : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@setU A (@setU A s t) u) = (@setU A s (@setU A t u)).
Axiom thm_UNION_IDEMPOT : forall {A : Type'}, forall s : A -> Prop, (@setU A s s) = s.
Axiom thm_UNION_COMM : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setU A s t) = (@setU A t s).
Axiom thm_SUBSET_UNION : forall {A : Type'}, (forall s : A -> Prop, forall t : A -> Prop, @subset A s (@setU A s t)) /\ (forall s : A -> Prop, forall t : A -> Prop, @subset A s (@setU A t s)).
Axiom thm_SUBSET_UNION_ABSORPTION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@subset A s t) = ((@setU A s t) = t).
Axiom thm_UNION_EMPTY : forall {A : Type'}, (forall s : A -> Prop, (@setU A (@set0 A) s) = s) /\ (forall s : A -> Prop, (@setU A s (@set0 A)) = s).
Axiom thm_UNION_UNIV : forall {A : Type'}, (forall s : A -> Prop, (@setU A (@setT A) s) = (@setT A)) /\ (forall s : A -> Prop, (@setU A s (@setT A)) = (@setT A)).
Axiom thm_EMPTY_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@setU A s t) = (@set0 A)) = ((s = (@set0 A)) /\ (t = (@set0 A))).
Axiom thm_UNION_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@subset A (@setU A s t) u) = ((@subset A s u) /\ (@subset A t u)).
Axiom thm_UNION_RESTRICT : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (@GSPEC A (fun GEN_PVAR_34 : A => exists x : A, @SETSPEC A GEN_PVAR_34 ((@IN A x (@setU A s t)) /\ (P x)) x)) = (@setU A (@GSPEC A (fun GEN_PVAR_35 : A => exists x : A, @SETSPEC A GEN_PVAR_35 ((@IN A x s) /\ (P x)) x)) (@GSPEC A (fun GEN_PVAR_36 : A => exists x : A, @SETSPEC A GEN_PVAR_36 ((@IN A x t) /\ (P x)) x))).
Axiom thm_FORALL_SUBSET_UNION : forall {A : Type'} (P : (A -> Prop) -> Prop), forall t : A -> Prop, forall u : A -> Prop, (forall s : A -> Prop, (@subset A s (@setU A t u)) -> P s) = (forall t' : A -> Prop, forall u' : A -> Prop, ((@subset A t' t) /\ (@subset A u' u)) -> P (@setU A t' u')).
Axiom thm_EXISTS_SUBSET_UNION : forall {A : Type'} (P : (A -> Prop) -> Prop), forall t : A -> Prop, forall u : A -> Prop, (exists s : A -> Prop, (@subset A s (@setU A t u)) /\ (P s)) = (exists t' : A -> Prop, exists u' : A -> Prop, (@subset A t' t) /\ ((@subset A u' u) /\ (P (@setU A t' u')))).
Axiom thm_FORALL_SUBSET_INSERT : forall {A : Type'} (P : (A -> Prop) -> Prop), forall a : A, forall t : A -> Prop, (forall s : A -> Prop, (@subset A s (@INSERT A a t)) -> P s) = (forall s : A -> Prop, (@subset A s t) -> (P s) /\ (P (@INSERT A a s))).
Axiom thm_EXISTS_SUBSET_INSERT : forall {A : Type'} (P : (A -> Prop) -> Prop), forall a : A, forall t : A -> Prop, (exists s : A -> Prop, (@subset A s (@INSERT A a t)) /\ (P s)) = (exists s : A -> Prop, (@subset A s t) /\ ((P s) \/ (P (@INSERT A a s)))).
Axiom thm_INTER_ASSOC : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@setI A (@setI A s t) u) = (@setI A s (@setI A t u)).
Axiom thm_INTER_IDEMPOT : forall {A : Type'}, forall s : A -> Prop, (@setI A s s) = s.
Axiom thm_INTER_COMM : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setI A s t) = (@setI A t s).
Axiom thm_INTER_SUBSET : forall {A : Type'}, (forall s : A -> Prop, forall t : A -> Prop, @subset A (@setI A s t) s) /\ (forall s : A -> Prop, forall t : A -> Prop, @subset A (@setI A t s) s).
Axiom thm_SUBSET_INTER_ABSORPTION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@subset A s t) = ((@setI A s t) = s).
Axiom thm_INTER_EMPTY : forall {A : Type'}, (forall s : A -> Prop, (@setI A (@set0 A) s) = (@set0 A)) /\ (forall s : A -> Prop, (@setI A s (@set0 A)) = (@set0 A)).
Axiom thm_INTER_UNIV : forall {A : Type'}, (forall s : A -> Prop, (@setI A (@setT A) s) = s) /\ (forall s : A -> Prop, (@setI A s (@setT A)) = s).
Axiom thm_SUBSET_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@subset A s (@setI A t u)) = ((@subset A s t) /\ (@subset A s u)).
Axiom thm_INTER_RESTRICT : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (@GSPEC A (fun GEN_PVAR_37 : A => exists x : A, @SETSPEC A GEN_PVAR_37 ((@IN A x (@setI A s t)) /\ (P x)) x)) = (@setI A (@GSPEC A (fun GEN_PVAR_38 : A => exists x : A, @SETSPEC A GEN_PVAR_38 ((@IN A x s) /\ (P x)) x)) (@GSPEC A (fun GEN_PVAR_39 : A => exists x : A, @SETSPEC A GEN_PVAR_39 ((@IN A x t) /\ (P x)) x))).
Axiom thm_UNION_OVER_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@setI A s (@setU A t u)) = (@setU A (@setI A s t) (@setI A s u)).
Axiom thm_INTER_OVER_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@setU A s (@setI A t u)) = (@setI A (@setU A s t) (@setU A s u)).
Axiom thm_IN_DISJOINT : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@DISJOINT A s t) = (~ (exists x : A, (@IN A x s) /\ (@IN A x t))).
Axiom thm_DISJOINT_SYM : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@DISJOINT A s t) = (@DISJOINT A t s).
Axiom thm_DISJOINT_EMPTY : forall {A : Type'}, forall s : A -> Prop, (@DISJOINT A (@set0 A) s) /\ (@DISJOINT A s (@set0 A)).
Axiom thm_DISJOINT_EMPTY_REFL : forall {A : Type'}, forall s : A -> Prop, (s = (@set0 A)) = (@DISJOINT A s s).
Axiom thm_DISJOINT_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (@DISJOINT A (@setU A s t) u) = ((@DISJOINT A s u) /\ (@DISJOINT A t u)).
Axiom thm_DISJOINT_SING : forall {A : Type'}, (forall s : A -> Prop, forall a : A, (@DISJOINT A s (@INSERT A a (@set0 A))) = (~ (@IN A a s))) /\ (forall s : A -> Prop, forall a : A, (@DISJOINT A (@INSERT A a (@set0 A)) s) = (~ (@IN A a s))).
Axiom thm_DIFF_EMPTY : forall {A : Type'}, forall s : A -> Prop, (@setD A s (@set0 A)) = s.
Axiom thm_EMPTY_DIFF : forall {A : Type'}, forall s : A -> Prop, (@setD A (@set0 A) s) = (@set0 A).
Axiom thm_DIFF_UNIV : forall {A : Type'}, forall s : A -> Prop, (@setD A s (@setT A)) = (@set0 A).
Axiom thm_DIFF_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@setD A (@setD A s t) t) = (@setD A s t).
Axiom thm_DIFF_EQ_EMPTY : forall {A : Type'}, forall s : A -> Prop, (@setD A s s) = (@set0 A).
Axiom thm_SUBSET_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, @subset A (@setD A s t) s.
Axiom thm_COMPL_COMPL : forall {A : Type'}, forall s : A -> Prop, (@setD A (@setT A) (@setD A (@setT A) s)) = s.
Axiom thm_DIFF_RESTRICT : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (@GSPEC A (fun GEN_PVAR_40 : A => exists x : A, @SETSPEC A GEN_PVAR_40 ((@IN A x (@setD A s t)) /\ (P x)) x)) = (@setD A (@GSPEC A (fun GEN_PVAR_41 : A => exists x : A, @SETSPEC A GEN_PVAR_41 ((@IN A x s) /\ (P x)) x)) (@GSPEC A (fun GEN_PVAR_42 : A => exists x : A, @SETSPEC A GEN_PVAR_42 ((@IN A x t) /\ (P x)) x))).
Axiom thm_COMPONENT : forall {A : Type'}, forall x : A, forall s : A -> Prop, @IN A x (@INSERT A x s).
Axiom thm_DECOMPOSITION : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@IN A x s) = (exists t : A -> Prop, (s = (@INSERT A x t)) /\ (~ (@IN A x t))).
Axiom thm_SET_CASES : forall {A : Type'}, forall s : A -> Prop, (s = (@set0 A)) \/ (exists x : A, exists t : A -> Prop, (s = (@INSERT A x t)) /\ (~ (@IN A x t))).
Axiom thm_ABSORPTION : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@IN A x s) = ((@INSERT A x s) = s).
Axiom thm_INSERT_INSERT : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@INSERT A x (@INSERT A x s)) = (@INSERT A x s).
Axiom thm_INSERT_COMM : forall {A : Type'}, forall x : A, forall y : A, forall s : A -> Prop, (@INSERT A x (@INSERT A y s)) = (@INSERT A y (@INSERT A x s)).
Axiom thm_INSERT_UNIV : forall {A : Type'}, forall x : A, (@INSERT A x (@setT A)) = (@setT A).
Axiom thm_NOT_INSERT_EMPTY : forall {A : Type'}, forall x : A, forall s : A -> Prop, ~ ((@INSERT A x s) = (@set0 A)).
Axiom thm_NOT_EMPTY_INSERT : forall {A : Type'}, forall x : A, forall s : A -> Prop, ~ ((@set0 A) = (@INSERT A x s)).
Axiom thm_INSERT_UNION : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@setU A (@INSERT A x s) t) = (@COND (A -> Prop) (@IN A x t) (@setU A s t) (@INSERT A x (@setU A s t))).
Axiom thm_INSERT_UNION_EQ : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@setU A (@INSERT A x s) t) = (@INSERT A x (@setU A s t)).
Axiom thm_INSERT_INTER : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@setI A (@INSERT A x s) t) = (@COND (A -> Prop) (@IN A x t) (@INSERT A x (@setI A s t)) (@setI A s t)).
Axiom thm_DISJOINT_INSERT : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@DISJOINT A (@INSERT A x s) t) = ((@DISJOINT A s t) /\ (~ (@IN A x t))).
Axiom thm_INSERT_SUBSET : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@subset A (@INSERT A x s) t) = ((@IN A x t) /\ (@subset A s t)).
Axiom thm_SUBSET_INSERT : forall {A : Type'}, forall x : A, forall s : A -> Prop, (~ (@IN A x s)) -> forall t : A -> Prop, (@subset A s (@INSERT A x t)) = (@subset A s t).
Axiom thm_INSERT_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@setD A (@INSERT A x s) t) = (@COND (A -> Prop) (@IN A x t) (@setD A s t) (@INSERT A x (@setD A s t))).
Axiom thm_INSERT_AC : forall {A : Type'} (y : A) (x : A) (s : A -> Prop), ((@INSERT A x (@INSERT A y s)) = (@INSERT A y (@INSERT A x s))) /\ ((@INSERT A x (@INSERT A x s)) = (@INSERT A x s)).
Axiom thm_INTER_ACI : forall {A : Type'} (r : A -> Prop) (p : A -> Prop) (q : A -> Prop), ((@setI A p q) = (@setI A q p)) /\ (((@setI A (@setI A p q) r) = (@setI A p (@setI A q r))) /\ (((@setI A p (@setI A q r)) = (@setI A q (@setI A p r))) /\ (((@setI A p p) = p) /\ ((@setI A p (@setI A p q)) = (@setI A p q))))).
Axiom thm_UNION_ACI : forall {A : Type'} (r : A -> Prop) (p : A -> Prop) (q : A -> Prop), ((@setU A p q) = (@setU A q p)) /\ (((@setU A (@setU A p q) r) = (@setU A p (@setU A q r))) /\ (((@setU A p (@setU A q r)) = (@setU A q (@setU A p r))) /\ (((@setU A p p) = p) /\ ((@setU A p (@setU A p q)) = (@setU A p q))))).
Axiom thm_DELETE_NON_ELEMENT : forall {A : Type'}, forall x : A, forall s : A -> Prop, (~ (@IN A x s)) = ((@DELETE A s x) = s).
Axiom thm_IN_DELETE_EQ : forall {A : Type'}, forall s : A -> Prop, forall x : A, forall x' : A, ((@IN A x s) = (@IN A x' s)) = ((@IN A x (@DELETE A s x')) = (@IN A x' (@DELETE A s x))).
Axiom thm_EMPTY_DELETE : forall {A : Type'}, forall x : A, (@DELETE A (@set0 A) x) = (@set0 A).
Axiom thm_DELETE_DELETE : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@DELETE A (@DELETE A s x) x) = (@DELETE A s x).
Axiom thm_DELETE_COMM : forall {A : Type'}, forall x : A, forall y : A, forall s : A -> Prop, (@DELETE A (@DELETE A s x) y) = (@DELETE A (@DELETE A s y) x).
Axiom thm_DELETE_SUBSET : forall {A : Type'}, forall x : A, forall s : A -> Prop, @subset A (@DELETE A s x) s.
Axiom thm_SUBSET_DELETE : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@subset A s (@DELETE A t x)) = ((~ (@IN A x s)) /\ (@subset A s t)).
Axiom thm_SUBSET_INSERT_DELETE : forall {A : Type'}, forall x : A, forall s : A -> Prop, forall t : A -> Prop, (@subset A s (@INSERT A x t)) = (@subset A (@DELETE A s x) t).
Axiom thm_DIFF_INSERT : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@setD A s (@INSERT A x t)) = (@setD A (@DELETE A s x) t).
Axiom thm_PSUBSET_INSERT_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@proper A s t) = (exists x : A, (~ (@IN A x s)) /\ (@subset A (@INSERT A x s) t)).
Axiom thm_DELETE_INSERT : forall {A : Type'}, forall x : A, forall y : A, forall s : A -> Prop, (@DELETE A (@INSERT A x s) y) = (@COND (A -> Prop) (x = y) (@DELETE A s y) (@INSERT A x (@DELETE A s y))).
Axiom thm_INSERT_DELETE : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@IN A x s) -> (@INSERT A x (@DELETE A s x)) = s.
Axiom thm_DELETE_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@setI A (@DELETE A s x) t) = (@DELETE A (@setI A s t) x).
Axiom thm_DISJOINT_DELETE_SYM : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall x : A, (@DISJOINT A (@DELETE A s x) t) = (@DISJOINT A (@DELETE A t x) s).
Axiom thm_UNIONS_0 : forall {A : Type'}, (@UNIONS A (@set0 (A -> Prop))) = (@set0 A).
Axiom thm_UNIONS_1 : forall {A : Type'}, forall s : A -> Prop, (@UNIONS A (@INSERT (A -> Prop) s (@set0 (A -> Prop)))) = s.
Axiom thm_UNIONS_2 : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@UNIONS A (@INSERT (A -> Prop) s (@INSERT (A -> Prop) t (@set0 (A -> Prop))))) = (@setU A s t).
Axiom thm_UNIONS_INSERT : forall {A : Type'}, forall s : A -> Prop, forall u : (A -> Prop) -> Prop, (@UNIONS A (@INSERT (A -> Prop) s u)) = (@setU A s (@UNIONS A u)).
Axiom thm_FORALL_IN_UNIONS : forall {A : Type'}, forall P : A -> Prop, forall s : (A -> Prop) -> Prop, (forall x : A, (@IN A x (@UNIONS A s)) -> P x) = (forall t : A -> Prop, forall x : A, ((@IN (A -> Prop) t s) /\ (@IN A x t)) -> P x).
Axiom thm_EXISTS_IN_UNIONS : forall {A : Type'}, forall P : A -> Prop, forall s : (A -> Prop) -> Prop, (exists x : A, (@IN A x (@UNIONS A s)) /\ (P x)) = (exists t : A -> Prop, exists x : A, (@IN (A -> Prop) t s) /\ ((@IN A x t) /\ (P x))).
Axiom thm_EMPTY_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, ((@UNIONS A s) = (@set0 A)) = (forall t : A -> Prop, (@IN (A -> Prop) t s) -> t = (@set0 A)).
Axiom thm_INTER_UNIONS : forall {A : Type'}, (forall s : (A -> Prop) -> Prop, forall t : A -> Prop, (@setI A (@UNIONS A s) t) = (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_43 : A -> Prop => exists x : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_43 (@IN (A -> Prop) x s) (@setI A x t))))) /\ (forall s : (A -> Prop) -> Prop, forall t : A -> Prop, (@setI A t (@UNIONS A s)) = (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_44 : A -> Prop => exists x : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_44 (@IN (A -> Prop) x s) (@setI A t x))))).
Axiom thm_UNIONS_SUBSET : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall t : A -> Prop, (@subset A (@UNIONS A f) t) = (forall s : A -> Prop, (@IN (A -> Prop) s f) -> @subset A s t).
Axiom thm_SUBSET_UNIONS : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall g : (A -> Prop) -> Prop, (@subset (A -> Prop) f g) -> @subset A (@UNIONS A f) (@UNIONS A g).
Axiom thm_UNIONS_UNION : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, (@UNIONS A (@setU (A -> Prop) s t)) = (@setU A (@UNIONS A s) (@UNIONS A t)).
Axiom thm_INTERS_UNION : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, (@INTERS A (@setU (A -> Prop) s t)) = (@setI A (@INTERS A s) (@INTERS A t)).
Axiom thm_UNIONS_MONO : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, (forall x : A -> Prop, (@IN (A -> Prop) x s) -> exists y : A -> Prop, (@IN (A -> Prop) y t) /\ (@subset A x y)) -> @subset A (@UNIONS A s) (@UNIONS A t).
Axiom thm_UNIONS_MONO_IMAGE : forall {A B : Type'}, forall f : A -> B -> Prop, forall g : A -> B -> Prop, forall s : A -> Prop, (forall x : A, (@IN A x s) -> @subset B (f x) (g x)) -> @subset B (@UNIONS B (@IMAGE A (B -> Prop) f s)) (@UNIONS B (@IMAGE A (B -> Prop) g s)).
Axiom thm_UNIONS_UNIV : forall {A : Type'}, (@UNIONS A (@setT (A -> Prop))) = (@setT A).
Axiom thm_UNIONS_INSERT_EMPTY : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@UNIONS A (@INSERT (A -> Prop) (@set0 A) s)) = (@UNIONS A s).
Axiom thm_UNIONS_DELETE_EMPTY : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@UNIONS A (@DELETE (A -> Prop) s (@set0 A))) = (@UNIONS A s).
Axiom thm_INTERS_0 : forall {A : Type'}, (@INTERS A (@set0 (A -> Prop))) = (@setT A).
Axiom thm_INTERS_1 : forall {A : Type'}, forall s : A -> Prop, (@INTERS A (@INSERT (A -> Prop) s (@set0 (A -> Prop)))) = s.
Axiom thm_INTERS_2 : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@INTERS A (@INSERT (A -> Prop) s (@INSERT (A -> Prop) t (@set0 (A -> Prop))))) = (@setI A s t).
Axiom thm_INTERS_INSERT : forall {A : Type'}, forall s : A -> Prop, forall u : (A -> Prop) -> Prop, (@INTERS A (@INSERT (A -> Prop) s u)) = (@setI A s (@INTERS A u)).
Axiom thm_SUBSET_INTERS : forall {A : Type'}, forall s : A -> Prop, forall f : (A -> Prop) -> Prop, (@subset A s (@INTERS A f)) = (forall t : A -> Prop, (@IN (A -> Prop) t f) -> @subset A s t).
Axiom thm_INTERS_SUBSET : forall {A : Type'}, forall u : (A -> Prop) -> Prop, forall s : A -> Prop, ((~ (u = (@set0 (A -> Prop)))) /\ (forall t : A -> Prop, (@IN (A -> Prop) t u) -> @subset A t s)) -> @subset A (@INTERS A u) s.
Axiom thm_INTERS_SUBSET_STRONG : forall {A : Type'}, forall u : (A -> Prop) -> Prop, forall s : A -> Prop, (exists t : A -> Prop, (@IN (A -> Prop) t u) /\ (@subset A t s)) -> @subset A (@INTERS A u) s.
Axiom thm_INTERS_ANTIMONO : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall g : (A -> Prop) -> Prop, (@subset (A -> Prop) g f) -> @subset A (@INTERS A f) (@INTERS A g).
Axiom thm_INTERS_EQ_UNIV : forall {A : Type'}, forall f : (A -> Prop) -> Prop, ((@INTERS A f) = (@setT A)) = (forall s : A -> Prop, (@IN (A -> Prop) s f) -> s = (@setT A)).
Axiom thm_INTERS_ANTIMONO_GEN : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, (forall y : A -> Prop, (@IN (A -> Prop) y t) -> exists x : A -> Prop, (@IN (A -> Prop) x s) /\ (@subset A x y)) -> @subset A (@INTERS A s) (@INTERS A t).
Axiom thm_IMAGE_CLAUSES : forall {A B : Type'} (x : A) (f : A -> B) (s : A -> Prop), ((@IMAGE A B f (@set0 A)) = (@set0 B)) /\ ((@IMAGE A B f (@INSERT A x s)) = (@INSERT B (f x) (@IMAGE A B f s))).
Axiom thm_IMAGE_UNION : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, (@IMAGE A B f (@setU A s t)) = (@setU B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_ID : forall {A : Type'}, forall s : A -> Prop, (@IMAGE A A (fun x : A => x) s) = s.
Axiom thm_IMAGE_I : forall {A : Type'}, forall s : A -> Prop, (@IMAGE A A (@I A) s) = s.
Axiom thm_IMAGE_o : forall {A B C : Type'}, forall f : B -> C, forall g : A -> B, forall s : A -> Prop, (@IMAGE A C (@o A B C f g) s) = (@IMAGE B C f (@IMAGE A B g s)).
Axiom thm_IMAGE_SUBSET : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, (@subset A s t) -> @subset B (@IMAGE A B f s) (@IMAGE A B f t).
Axiom thm_IMAGE_INTER_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, (forall x : A, forall y : A, ((f x) = (f y)) -> x = y) -> (@IMAGE A B f (@setI A s t)) = (@setI B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_DIFF_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y t) /\ ((f x) = (f y)))) -> x = y) -> (@IMAGE A B f (@setD A s t)) = (@setD B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_DIFF_INJ_ALT : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@subset A t s)) -> (@IMAGE A B f (@setD A s t)) = (@setD B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_DELETE_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall a : A, (forall x : A, ((@IN A x s) /\ ((f x) = (f a))) -> x = a) -> (@IMAGE A B f (@DELETE A s a)) = (@DELETE B (@IMAGE A B f s) (f a)).
Axiom thm_IMAGE_DELETE_INJ_ALT : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall a : A, ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@IN A a s)) -> (@IMAGE A B f (@DELETE A s a)) = (@DELETE B (@IMAGE A B f s) (f a)).
Axiom thm_IMAGE_EQ_EMPTY : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, ((@IMAGE A B f s) = (@set0 B)) = (s = (@set0 A)).
Axiom thm_FORALL_IN_IMAGE_2 : forall {A B : Type'}, forall f : A -> B, forall P : B -> B -> Prop, forall s : A -> Prop, (forall x : B, forall y : B, ((@IN B x (@IMAGE A B f s)) /\ (@IN B y (@IMAGE A B f s))) -> P x y) = (forall x : A, forall y : A, ((@IN A x s) /\ (@IN A y s)) -> P (f x) (f y)).
Axiom thm_IMAGE_CONST : forall {A B : Type'}, forall s : A -> Prop, forall c : B, (@IMAGE A B (fun x : A => c) s) = (@COND (B -> Prop) (s = (@set0 A)) (@set0 B) (@INSERT B c (@set0 B))).
Axiom thm_SIMPLE_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@GSPEC B (fun GEN_PVAR_45 : B => exists x : A, @SETSPEC B GEN_PVAR_45 (@IN A x s) (f x))) = (@IMAGE A B f s).
Axiom thm_SIMPLE_IMAGE_GEN : forall {A B : Type'}, forall f : A -> B, forall P : A -> Prop, (@GSPEC B (fun GEN_PVAR_46 : B => exists x : A, @SETSPEC B GEN_PVAR_46 (P x) (f x))) = (@IMAGE A B f (@GSPEC A (fun GEN_PVAR_47 : A => exists x : A, @SETSPEC A GEN_PVAR_47 (P x) x))).
Axiom thm_IMAGE_UNIONS : forall {A B : Type'}, forall f : A -> B, forall s : (A -> Prop) -> Prop, (@IMAGE A B f (@UNIONS A s)) = (@UNIONS B (@IMAGE (A -> Prop) (B -> Prop) (@IMAGE A B f) s)).
Axiom thm_FUN_IN_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall x : A, (@IN A x s) -> @IN B (f x) (@IMAGE A B f s).
Axiom thm_SURJECTIVE_IMAGE_EQ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, ((forall y : B, (@IN B y t) -> exists x : A, (f x) = y) /\ (forall x : A, (@IN B (f x) t) = (@IN A x s))) -> (@IMAGE A B f s) = t.
Axiom thm_IMAGE_EQ : forall {A B : Type'}, forall f : A -> B, forall g : A -> B, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (g x)) -> (@IMAGE A B f s) = (@IMAGE A B g s).
Axiom thm_EMPTY_GSPEC : forall {A : Type'}, (@GSPEC A (fun GEN_PVAR_48 : A => exists x : A, @SETSPEC A GEN_PVAR_48 False x)) = (@set0 A).
Axiom thm_UNIV_GSPEC : forall {A : Type'}, (@GSPEC A (fun GEN_PVAR_49 : A => exists x : A, @SETSPEC A GEN_PVAR_49 True x)) = (@setT A).
Axiom thm_SING_GSPEC : forall {A : Type'}, (forall a : A, (@GSPEC A (fun GEN_PVAR_50 : A => exists x : A, @SETSPEC A GEN_PVAR_50 (x = a) x)) = (@INSERT A a (@set0 A))) /\ (forall a : A, (@GSPEC A (fun GEN_PVAR_51 : A => exists x : A, @SETSPEC A GEN_PVAR_51 (a = x) x)) = (@INSERT A a (@set0 A))).
Axiom thm_SING_ALT : forall {A : Type'}, forall s : A -> Prop, (exists x : A, s = (@INSERT A x (@set0 A))) = (@ex1 A (fun x : A => @IN A x s)).
Axiom thm_IN_GSPEC : forall {A : Type'}, forall s : A -> Prop, (@GSPEC A (fun GEN_PVAR_52 : A => exists x : A, @SETSPEC A GEN_PVAR_52 (@IN A x s) x)) = s.
Axiom thm_IN_ELIM_PAIR_THM : forall {A B : Type'}, forall P : A -> B -> Prop, forall a : A, forall b : B, (@IN (prod A B) (@pair A B a b) (@GSPEC (prod A B) (fun GEN_PVAR_53 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_53 (P x y) (@pair A B x y)))) = (P a b).
Axiom thm_IN_ELIM_TRIPLE_THM : forall {A B C : Type'}, (forall P : A -> B -> C -> Prop, forall a : A, forall b : B, forall c : C, (@IN (prod A (prod B C)) (@pair A (prod B C) a (@pair B C b c)) (@GSPEC (prod A (prod B C)) (fun GEN_PVAR_54 : prod A (prod B C) => exists x : A, exists y : B, exists z : C, @SETSPEC (prod A (prod B C)) GEN_PVAR_54 (P x y z) (@pair A (prod B C) x (@pair B C y z))))) = (P a b c)) /\ (forall P : A -> B -> C -> Prop, forall a : A, forall b : B, forall c : C, (@IN (prod (prod A B) C) (@pair (prod A B) C (@pair A B a b) c) (@GSPEC (prod (prod A B) C) (fun GEN_PVAR_55 : prod (prod A B) C => exists x : A, exists y : B, exists z : C, @SETSPEC (prod (prod A B) C) GEN_PVAR_55 (P x y z) (@pair (prod A B) C (@pair A B x y) z)))) = (P a b c)).
Axiom thm_IN_ELIM_QUAD_THM : forall {A B C D : Type'}, (forall P : A -> B -> C -> D -> Prop, forall a : A, forall b : B, forall c : C, forall d : D, (@IN (prod A (prod B (prod C D))) (@pair A (prod B (prod C D)) a (@pair B (prod C D) b (@pair C D c d))) (@GSPEC (prod A (prod B (prod C D))) (fun GEN_PVAR_56 : prod A (prod B (prod C D)) => exists w : A, exists x : B, exists y : C, exists z : D, @SETSPEC (prod A (prod B (prod C D))) GEN_PVAR_56 (P w x y z) (@pair A (prod B (prod C D)) w (@pair B (prod C D) x (@pair C D y z)))))) = (P a b c d)) /\ ((forall P : A -> B -> C -> D -> Prop, forall a : A, forall b : B, forall c : C, forall d : D, (@IN (prod (prod A B) (prod C D)) (@pair (prod A B) (prod C D) (@pair A B a b) (@pair C D c d)) (@GSPEC (prod (prod A B) (prod C D)) (fun GEN_PVAR_57 : prod (prod A B) (prod C D) => exists w : A, exists x : B, exists y : C, exists z : D, @SETSPEC (prod (prod A B) (prod C D)) GEN_PVAR_57 (P w x y z) (@pair (prod A B) (prod C D) (@pair A B w x) (@pair C D y z))))) = (P a b c d)) /\ (forall P : A -> B -> C -> D -> Prop, forall a : A, forall b : B, forall c : C, forall d : D, (@IN (prod (prod (prod A B) C) D) (@pair (prod (prod A B) C) D (@pair (prod A B) C (@pair A B a b) c) d) (@GSPEC (prod (prod (prod A B) C) D) (fun GEN_PVAR_58 : prod (prod (prod A B) C) D => exists w : A, exists x : B, exists y : C, exists z : D, @SETSPEC (prod (prod (prod A B) C) D) GEN_PVAR_58 (P w x y z) (@pair (prod (prod A B) C) D (@pair (prod A B) C (@pair A B w x) y) z)))) = (P a b c d))).
Axiom thm_SET_PAIR_THM : forall {A B : Type'}, forall P : (prod A B) -> Prop, (@GSPEC (prod A B) (fun GEN_PVAR_59 : prod A B => exists p : prod A B, @SETSPEC (prod A B) GEN_PVAR_59 (P p) p)) = (@GSPEC (prod A B) (fun GEN_PVAR_60 : prod A B => exists a : A, exists b : B, @SETSPEC (prod A B) GEN_PVAR_60 (P (@pair A B a b)) (@pair A B a b))).
Axiom thm_SET_PROVE_CASES : forall {A : Type'}, forall P : (A -> Prop) -> Prop, ((P (@set0 A)) /\ (forall a : A, forall s : A -> Prop, (~ (@IN A a s)) -> P (@INSERT A a s))) -> forall s : A -> Prop, P s.
Axiom thm_UNIONS_SINGS_GEN : forall {A : Type'}, forall P : A -> Prop, (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_61 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_61 (P x) (@INSERT A x (@set0 A))))) = (@GSPEC A (fun GEN_PVAR_62 : A => exists x : A, @SETSPEC A GEN_PVAR_62 (P x) x)).
Axiom thm_UNIONS_SINGS : forall {A : Type'}, forall s : A -> Prop, (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_63 : A -> Prop => exists x : A, @SETSPEC (A -> Prop) GEN_PVAR_63 (@IN A x s) (@INSERT A x (@set0 A))))) = s.
Axiom thm_IMAGE_INTERS : forall {A B : Type'}, forall f : A -> B, forall s : (A -> Prop) -> Prop, ((~ (s = (@set0 (A -> Prop)))) /\ (forall x : A, forall y : A, ((@IN A x (@UNIONS A s)) /\ ((@IN A y (@UNIONS A s)) /\ ((f x) = (f y)))) -> x = y)) -> (@IMAGE A B f (@INTERS A s)) = (@INTERS B (@IMAGE (A -> Prop) (B -> Prop) (@IMAGE A B f) s)).
Axiom thm_DIFF_INTERS : forall {A : Type'}, forall u : A -> Prop, forall s : (A -> Prop) -> Prop, (@setD A u (@INTERS A s)) = (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_64 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_64 (@IN (A -> Prop) t s) (@setD A u t)))).
Axiom thm_INTERS_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@INTERS A s) = (@setD A (@setT A) (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_65 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_65 (@IN (A -> Prop) t s) (@setD A (@setT A) t))))).
Axiom thm_UNIONS_INTERS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@UNIONS A s) = (@setD A (@setT A) (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_66 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_66 (@IN (A -> Prop) t s) (@setD A (@setT A) t))))).
Axiom thm_UNIONS_DIFF : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : A -> Prop, (@setD A (@UNIONS A s) t) = (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_67 : A -> Prop => exists x : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_67 (@IN (A -> Prop) x s) (@setD A x t)))).
Axiom thm_DIFF_UNIONS : forall {A : Type'}, forall u : A -> Prop, forall s : (A -> Prop) -> Prop, (@setD A u (@UNIONS A s)) = (@setI A u (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_68 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_68 (@IN (A -> Prop) t s) (@setD A u t))))).
Axiom thm_DIFF_UNIONS_NONEMPTY : forall {A : Type'}, forall u : A -> Prop, forall s : (A -> Prop) -> Prop, (~ (s = (@set0 (A -> Prop)))) -> (@setD A u (@UNIONS A s)) = (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_69 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_69 (@IN (A -> Prop) t s) (@setD A u t)))).
Axiom thm_INTERS_OVER_UNIONS : forall {A B : Type'}, forall f : A -> (B -> Prop) -> Prop, forall s : A -> Prop, (@INTERS B (@GSPEC (B -> Prop) (fun GEN_PVAR_70 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_70 (@IN A x s) (@UNIONS B (f x))))) = (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_74 : B -> Prop => exists g : A -> B -> Prop, @SETSPEC (B -> Prop) GEN_PVAR_74 (forall x : A, (@IN A x s) -> @IN (B -> Prop) (g x) (f x)) (@INTERS B (@GSPEC (B -> Prop) (fun GEN_PVAR_73 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_73 (@IN A x s) (g x))))))).
Axiom thm_INTER_INTERS : forall {A : Type'}, (forall f : (A -> Prop) -> Prop, forall s : A -> Prop, (@setI A s (@INTERS A f)) = (@COND (A -> Prop) (f = (@set0 (A -> Prop))) s (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_75 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_75 (@IN (A -> Prop) t f) (@setI A s t)))))) /\ (forall f : (A -> Prop) -> Prop, forall s : A -> Prop, (@setI A (@INTERS A f) s) = (@COND (A -> Prop) (f = (@set0 (A -> Prop))) s (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_76 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_76 (@IN (A -> Prop) t f) (@setI A t s)))))).
Axiom thm_UNIONS_OVER_INTERS : forall {A B : Type'}, forall f : A -> (B -> Prop) -> Prop, forall s : A -> Prop, (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_77 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_77 (@IN A x s) (@INTERS B (f x))))) = (@INTERS B (@GSPEC (B -> Prop) (fun GEN_PVAR_81 : B -> Prop => exists g : A -> B -> Prop, @SETSPEC (B -> Prop) GEN_PVAR_81 (forall x : A, (@IN A x s) -> @IN (B -> Prop) (g x) (f x)) (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_80 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_80 (@IN A x s) (g x))))))).
Axiom thm_UNIONS_EQ_INTERS : forall {A : Type'}, forall f : (A -> Prop) -> Prop, ((@UNIONS A f) = (@INTERS A f)) = (exists s : A -> Prop, f = (@INSERT (A -> Prop) s (@set0 (A -> Prop)))).
Axiom thm_EXISTS_UNIQUE_UNIONS_INTERS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (@ex1 (A -> Prop) (fun s : A -> Prop => P s)) = ((@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_82 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_82 (P s) s))) = (@INTERS A (@GSPEC (A -> Prop) (fun GEN_PVAR_83 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_83 (P s) s)))).
Axiom thm_IMAGE_INTERS_SUBSET : forall {A B : Type'}, forall f : A -> B, forall g : (A -> Prop) -> Prop, @subset B (@IMAGE A B f (@INTERS A g)) (@INTERS B (@IMAGE (A -> Prop) (B -> Prop) (@IMAGE A B f) g)).
Axiom thm_IMAGE_INTER_SUBSET : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, @subset B (@IMAGE A B f (@setI A s t)) (@setI B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_INTER_SATURATED_GEN : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, (((@subset A (@GSPEC A (fun GEN_PVAR_84 : A => exists x : A, @SETSPEC A GEN_PVAR_84 ((@IN A x u) /\ (@IN B (f x) (@IMAGE A B f s))) x)) s) /\ (@subset A t u)) \/ ((@subset A (@GSPEC A (fun GEN_PVAR_85 : A => exists x : A, @SETSPEC A GEN_PVAR_85 ((@IN A x u) /\ (@IN B (f x) (@IMAGE A B f t))) x)) t) /\ (@subset A s u))) -> (@IMAGE A B f (@setI A s t)) = (@setI B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_INTERS_SATURATED_GEN : forall {A B : Type'}, forall f : A -> B, forall g : (A -> Prop) -> Prop, forall s : A -> Prop, forall u : A -> Prop, ((~ (g = (@set0 (A -> Prop)))) /\ ((forall t : A -> Prop, (@IN (A -> Prop) t g) -> @subset A t u) /\ (forall t : A -> Prop, (@IN (A -> Prop) t (@DELETE (A -> Prop) g s)) -> @subset A (@GSPEC A (fun GEN_PVAR_87 : A => exists x : A, @SETSPEC A GEN_PVAR_87 ((@IN A x u) /\ (@IN B (f x) (@IMAGE A B f t))) x)) t))) -> (@IMAGE A B f (@INTERS A g)) = (@INTERS B (@IMAGE (A -> Prop) (B -> Prop) (@IMAGE A B f) g)).
Axiom thm_IMAGE_INTER_SATURATED : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@subset A (@GSPEC A (fun GEN_PVAR_88 : A => exists x : A, @SETSPEC A GEN_PVAR_88 (@IN B (f x) (@IMAGE A B f s)) x)) s) \/ (@subset A (@GSPEC A (fun GEN_PVAR_89 : A => exists x : A, @SETSPEC A GEN_PVAR_89 (@IN B (f x) (@IMAGE A B f t)) x)) t)) -> (@IMAGE A B f (@setI A s t)) = (@setI B (@IMAGE A B f s) (@IMAGE A B f t)).
Axiom thm_IMAGE_INTERS_SATURATED : forall {A B : Type'}, forall f : A -> B, forall g : (A -> Prop) -> Prop, forall s : A -> Prop, ((~ (g = (@set0 (A -> Prop)))) /\ (forall t : A -> Prop, (@IN (A -> Prop) t (@DELETE (A -> Prop) g s)) -> @subset A (@GSPEC A (fun GEN_PVAR_90 : A => exists x : A, @SETSPEC A GEN_PVAR_90 (@IN B (f x) (@IMAGE A B f t)) x)) t)) -> (@IMAGE A B f (@INTERS A g)) = (@INTERS B (@IMAGE (A -> Prop) (B -> Prop) (@IMAGE A B f) g)).
Axiom thm_FINITE_INDUCT_STRONG : forall {A : Type'}, forall P : (A -> Prop) -> Prop, ((P (@set0 A)) /\ (forall x : A, forall s : A -> Prop, ((P s) /\ ((~ (@IN A x s)) /\ (@finite_set A s))) -> P (@INSERT A x s))) -> forall s : A -> Prop, (@finite_set A s) -> P s.
Axiom thm_INJECTIVE_ON_ALT : forall {A B : Type'}, forall P : A -> Prop, forall f : A -> B, (forall x : A, forall y : A, ((P x) /\ ((P y) /\ ((f x) = (f y)))) -> x = y) = (forall x : A, forall y : A, ((P x) /\ (P y)) -> ((f x) = (f y)) = (x = y)).
Axiom thm_INJECTIVE_ALT : forall {A B : Type'}, forall f : A -> B, (forall x : A, forall y : A, ((f x) = (f y)) -> x = y) = (forall x : A, forall y : A, ((f x) = (f y)) = (x = y)).
Axiom thm_SURJECTIVE_ON_RIGHT_INVERSE : forall {A B : Type'} (s : A -> Prop), forall f : A -> B, forall t : B -> Prop, (forall y : B, (@IN B y t) -> exists x : A, (@IN A x s) /\ ((f x) = y)) = (exists g : B -> A, forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y)).
Axiom thm_INJECTIVE_ON_LEFT_INVERSE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) = (exists g : B -> A, forall x : A, (@IN A x s) -> (g (f x)) = x).
Axiom thm_BIJECTIVE_ON_LEFT_RIGHT_INVERSE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, (forall x : A, (@IN A x s) -> @IN B (f x) t) -> ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (forall y : B, (@IN B y t) -> exists x : A, (@IN A x s) /\ ((f x) = y))) = (exists g : B -> A, (forall y : B, (@IN B y t) -> @IN A (g y) s) /\ ((forall y : B, (@IN B y t) -> (f (g y)) = y) /\ (forall x : A, (@IN A x s) -> (g (f x)) = x))).
Axiom thm_SURJECTIVE_RIGHT_INVERSE : forall {A B : Type'}, forall f : A -> B, (forall y : B, exists x : A, (f x) = y) = (exists g : B -> A, forall y : B, (f (g y)) = y).
Axiom thm_INJECTIVE_LEFT_INVERSE : forall {A B : Type'}, forall f : A -> B, (forall x : A, forall y : A, ((f x) = (f y)) -> x = y) = (exists g : B -> A, forall x : A, (g (f x)) = x).
Axiom thm_BIJECTIVE_LEFT_RIGHT_INVERSE : forall {A B : Type'}, forall f : A -> B, ((forall x : A, forall y : A, ((f x) = (f y)) -> x = y) /\ (forall y : B, exists x : A, (f x) = y)) = (exists g : B -> A, (forall y : B, (f (g y)) = y) /\ (forall x : A, (g (f x)) = x)).
Axiom thm_FUNCTION_FACTORS_LEFT_GEN : forall {A B C : Type'}, forall P : A -> Prop, forall f : A -> B, forall g : A -> C, (forall x : A, forall y : A, ((P x) /\ ((P y) /\ ((g x) = (g y)))) -> (f x) = (f y)) = (exists h : C -> B, forall x : A, (P x) -> (f x) = (h (g x))).
Axiom thm_FUNCTION_FACTORS_LEFT : forall {A B C : Type'}, forall f : A -> B, forall g : A -> C, (forall x : A, forall y : A, ((g x) = (g y)) -> (f x) = (f y)) = (exists h : C -> B, f = (@o A C B h g)).
Axiom thm_FUNCTION_FACTORS_RIGHT_GEN : forall {A B C : Type'}, forall P : A -> Prop, forall f : A -> C, forall g : B -> C, (forall x : A, (P x) -> exists y : B, (g y) = (f x)) = (exists h : A -> B, forall x : A, (P x) -> (f x) = (g (h x))).
Axiom thm_FUNCTION_FACTORS_RIGHT : forall {A B C : Type'}, forall f : A -> C, forall g : B -> C, (forall x : A, exists y : B, (g y) = (f x)) = (exists h : A -> B, f = (@o A B C g h)).
Axiom thm_SURJECTIVE_FORALL_THM : forall {A B : Type'}, forall f : A -> B, (forall y : B, exists x : A, (f x) = y) = (forall P : B -> Prop, (forall x : A, P (f x)) = (forall y : B, P y)).
Axiom thm_SURJECTIVE_EXISTS_THM : forall {A B : Type'}, forall f : A -> B, (forall y : B, exists x : A, (f x) = y) = (forall P : B -> Prop, (exists x : A, P (f x)) = (exists y : B, P y)).
Axiom thm_SURJECTIVE_IMAGE_THM : forall {A B : Type'}, forall f : A -> B, (forall y : B, exists x : A, (f x) = y) = (forall P : B -> Prop, (@IMAGE A B f (@GSPEC A (fun GEN_PVAR_91 : A => exists x : A, @SETSPEC A GEN_PVAR_91 (P (f x)) x))) = (@GSPEC B (fun GEN_PVAR_92 : B => exists x : B, @SETSPEC B GEN_PVAR_92 (P x) x))).
Axiom thm_IMAGE_INJECTIVE_IMAGE_OF_SUBSET : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, exists t : A -> Prop, (@subset A t s) /\ (((@IMAGE A B f s) = (@IMAGE A B f t)) /\ (forall x : A, forall y : A, ((@IN A x t) /\ ((@IN A y t) /\ ((f x) = (f y)))) -> x = y)).
Axiom thm_FINITE_EMPTY : forall {A : Type'}, @finite_set A (@set0 A).
Axiom thm_FINITE_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A t) /\ (@subset A s t)) -> @finite_set A s.
Axiom thm_FINITE_RESTRICT : forall {A : Type'}, forall s : A -> Prop, forall P : A -> Prop, (@finite_set A s) -> @finite_set A (@GSPEC A (fun GEN_PVAR_93 : A => exists x : A, @SETSPEC A GEN_PVAR_93 ((@IN A x s) /\ (P x)) x)).
Axiom thm_FINITE_UNION_IMP : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@finite_set A t)) -> @finite_set A (@setU A s t).
Axiom thm_FINITE_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@finite_set A (@setU A s t)) = ((@finite_set A s) /\ (@finite_set A t)).
Axiom thm_FINITE_INTER : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) \/ (@finite_set A t)) -> @finite_set A (@setI A s t).
Axiom thm_FINITE_INSERT : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@finite_set A (@INSERT A x s)) = (@finite_set A s).
Axiom thm_FINITE_SING : forall {A : Type'}, forall a : A, @finite_set A (@INSERT A a (@set0 A)).
Axiom thm_FINITE_DELETE_IMP : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@finite_set A s) -> @finite_set A (@DELETE A s x).
Axiom thm_FINITE_DELETE : forall {A : Type'}, forall s : A -> Prop, forall x : A, (@finite_set A (@DELETE A s x)) = (@finite_set A s).
Axiom thm_FINITE_FINITE_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@finite_set (A -> Prop) s) -> (@finite_set A (@UNIONS A s)) = (forall t : A -> Prop, (@IN (A -> Prop) t s) -> @finite_set A t).
Axiom thm_FINITE_IMAGE_EXPAND : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set A s) -> @finite_set B (@GSPEC B (fun GEN_PVAR_96 : B => exists y : B, @SETSPEC B GEN_PVAR_96 (exists x : A, (@IN A x s) /\ (y = (f x))) y)).
Axiom thm_FINITE_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set A s) -> @finite_set B (@IMAGE A B f s).
Axiom thm_FINITE_IMAGE_INJ_GENERAL : forall {A B : Type'}, forall f : A -> B, forall A' : B -> Prop, forall s : A -> Prop, ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@finite_set B A')) -> @finite_set A (@GSPEC A (fun GEN_PVAR_97 : A => exists x : A, @SETSPEC A GEN_PVAR_97 ((@IN A x s) /\ (@IN B (f x) A')) x)).
Axiom thm_FINITE_FINITE_PREIMAGE_GENERAL : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set B t) /\ (forall y : B, (@IN B y t) -> @finite_set A (@GSPEC A (fun GEN_PVAR_100 : A => exists x : A, @SETSPEC A GEN_PVAR_100 ((@IN A x s) /\ ((f x) = y)) x)))) -> @finite_set A (@GSPEC A (fun GEN_PVAR_101 : A => exists x : A, @SETSPEC A GEN_PVAR_101 ((@IN A x s) /\ (@IN B (f x) t)) x)).
Axiom thm_FINITE_FINITE_PREIMAGE : forall {A B : Type'}, forall f : A -> B, forall t : B -> Prop, ((@finite_set B t) /\ (forall y : B, (@IN B y t) -> @finite_set A (@GSPEC A (fun GEN_PVAR_102 : A => exists x : A, @SETSPEC A GEN_PVAR_102 ((f x) = y) x)))) -> @finite_set A (@GSPEC A (fun GEN_PVAR_103 : A => exists x : A, @SETSPEC A GEN_PVAR_103 (@IN B (f x) t) x)).
Axiom thm_FINITE_IMAGE_INJ_EQ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) -> (@finite_set B (@IMAGE A B f s)) = (@finite_set A s).
Axiom thm_FINITE_IMAGE_INJ : forall {A B : Type'}, forall f : A -> B, forall A' : B -> Prop, ((forall x : A, forall y : A, ((f x) = (f y)) -> x = y) /\ (@finite_set B A')) -> @finite_set A (@GSPEC A (fun GEN_PVAR_104 : A => exists x : A, @SETSPEC A GEN_PVAR_104 (@IN B (f x) A') x)).
Axiom thm_FINITE_IMAGE_GEN : forall {A B C : Type'}, forall f : A -> B, forall g : A -> C, forall s : A -> Prop, forall t : B -> Prop, ((@subset B (@IMAGE A B f s) t) /\ ((@finite_set B t) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> (g x) = (g y)))) -> @finite_set C (@IMAGE A C g s).
Axiom thm_INFINITE_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, ((@INFINITE A s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y)) -> @INFINITE B (@IMAGE A B f s).
Axiom thm_INFINITE_IMAGE_INJ : forall {A B : Type'}, forall f : A -> B, (forall x : A, forall y : A, ((f x) = (f y)) -> x = y) -> forall s : A -> Prop, (@INFINITE A s) -> @INFINITE B (@IMAGE A B f s).
Axiom thm_INFINITE_NONEMPTY : forall {A : Type'}, forall s : A -> Prop, (@INFINITE A s) -> ~ (s = (@set0 A)).
Axiom thm_INFINITE_DIFF_FINITE : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@INFINITE A s) /\ (@finite_set A t)) -> @INFINITE A (@setD A s t).
Axiom thm_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall f : A -> B, forall s : B -> Prop, forall t : A -> Prop, (@subset B s (@IMAGE A B f t)) = (exists u : A -> Prop, (@subset A u t) /\ ((forall x : A, forall y : A, ((@IN A x u) /\ (@IN A y u)) -> ((f x) = (f y)) = (x = y)) /\ (s = (@IMAGE A B f u)))).
Axiom thm_SUBSET_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : B -> Prop, forall t : A -> Prop, (@subset B s (@IMAGE A B f t)) = (exists u : A -> Prop, (@subset A u t) /\ (s = (@IMAGE A B f u))).
Axiom thm_EXISTS_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (exists t : B -> Prop, (@subset B t (@IMAGE A B f s)) /\ (P t)) = (exists t : A -> Prop, (@subset A t s) /\ (P (@IMAGE A B f t))).
Axiom thm_FORALL_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (forall t : B -> Prop, (@subset B t (@IMAGE A B f s)) -> P t) = (forall t : A -> Prop, (@subset A t s) -> P (@IMAGE A B f t)).
Axiom thm_EXISTS_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (exists t : B -> Prop, (@subset B t (@IMAGE A B f s)) /\ (P t)) = (exists t : A -> Prop, (@subset A t s) /\ ((forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y)) /\ (P (@IMAGE A B f t)))).
Axiom thm_FORALL_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (forall t : B -> Prop, (@subset B t (@IMAGE A B f s)) -> P t) = (forall t : A -> Prop, ((@subset A t s) /\ (forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y))) -> P (@IMAGE A B f t)).
Axiom thm_EXISTS_FINITE_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (exists t : B -> Prop, (@finite_set B t) /\ ((@subset B t (@IMAGE A B f s)) /\ (P t))) = (exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ ((forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y)) /\ (P (@IMAGE A B f t))))).
Axiom thm_FORALL_FINITE_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (forall t : B -> Prop, ((@finite_set B t) /\ (@subset B t (@IMAGE A B f s))) -> P t) = (forall t : A -> Prop, ((@finite_set A t) /\ ((@subset A t s) /\ (forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y)))) -> P (@IMAGE A B f t)).
Axiom thm_EXISTS_FINITE_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (exists t : B -> Prop, (@finite_set B t) /\ ((@subset B t (@IMAGE A B f s)) /\ (P t))) = (exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (P (@IMAGE A B f t)))).
Axiom thm_FORALL_FINITE_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, (forall t : B -> Prop, ((@finite_set B t) /\ (@subset B t (@IMAGE A B f s))) -> P t) = (forall t : A -> Prop, ((@finite_set A t) /\ (@subset A t s)) -> P (@IMAGE A B f t)).
Axiom thm_FINITE_SUBSET_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set B t) /\ (@subset B t (@IMAGE A B f s))) = (exists s' : A -> Prop, (@finite_set A s') /\ ((@subset A s' s) /\ (t = (@IMAGE A B f s')))).
Axiom thm_FINITE_SUBSET_IMAGE_IMP : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set B t) /\ (@subset B t (@IMAGE A B f s))) -> exists s' : A -> Prop, (@finite_set A s') /\ ((@subset A s' s) /\ (@subset B t (@IMAGE A B f s'))).
Axiom thm_FINITE_IMAGE_EQ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set B (@IMAGE A B f s)) = (exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ ((@IMAGE A B f s) = (@IMAGE A B f t)))).
Axiom thm_FINITE_IMAGE_EQ_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set B (@IMAGE A B f s)) = (exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (((@IMAGE A B f s) = (@IMAGE A B f t)) /\ (forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y))))).
Axiom thm_FINITE_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, (@finite_set A s) -> @finite_set A (@setD A s t).
Axiom thm_INFINITE_SUPERSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@INFINITE A s) /\ (@subset A s t)) -> @INFINITE A t.
Axiom thm_FINITE_TRANSITIVITY_CHAIN : forall {A : Type'}, forall R' : A -> A -> Prop, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, ~ (R' x x)) /\ ((forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z) /\ (forall x : A, (@IN A x s) -> exists y : A, (@IN A y s) /\ (R' x y))))) -> s = (@set0 A).
Axiom thm_UNIONS_MAXIMAL_SETS : forall {A : Type'}, forall f : (A -> Prop) -> Prop, (@finite_set (A -> Prop) f) -> (@UNIONS A (@GSPEC (A -> Prop) (fun GEN_PVAR_106 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_106 ((@IN (A -> Prop) t f) /\ (forall u : A -> Prop, (@IN (A -> Prop) u f) -> ~ (@proper A t u))) t))) = (@UNIONS A f).
Axiom thm_FINITE_SUBSET_UNIONS : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall s : A -> Prop, ((@finite_set A s) /\ (@subset A s (@UNIONS A f))) -> exists f' : (A -> Prop) -> Prop, (@finite_set (A -> Prop) f') /\ ((@subset (A -> Prop) f' f) /\ (@subset A s (@UNIONS A f'))).
Axiom thm_UNIONS_IN_CHAIN : forall {A : Type'}, forall f : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) f) /\ ((~ (f = (@set0 (A -> Prop)))) /\ (forall s : A -> Prop, forall t : A -> Prop, ((@IN (A -> Prop) s f) /\ (@IN (A -> Prop) t f)) -> (@subset A s t) \/ (@subset A t s)))) -> @IN (A -> Prop) (@UNIONS A f) f.
Axiom thm_INTERS_IN_CHAIN : forall {A : Type'}, forall f : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) f) /\ ((~ (f = (@set0 (A -> Prop)))) /\ (forall s : A -> Prop, forall t : A -> Prop, ((@IN (A -> Prop) s f) /\ (@IN (A -> Prop) t f)) -> (@subset A s t) \/ (@subset A t s)))) -> @IN (A -> Prop) (@INTERS A f) f.
Axiom thm_FINITE_SUBSET_UNIONS_DIRECTED_EQ : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall s : A -> Prop, ((~ (f = (@set0 (A -> Prop)))) /\ ((forall t : A -> Prop, forall u : A -> Prop, ((@IN (A -> Prop) t f) /\ (@IN (A -> Prop) u f)) -> exists v : A -> Prop, (@IN (A -> Prop) v f) /\ ((@subset A t v) /\ (@subset A u v))) /\ (@finite_set A s))) -> (@subset A s (@UNIONS A f)) = (exists t : A -> Prop, (@IN (A -> Prop) t f) /\ (@subset A s t)).
Axiom thm_FINITE_SUBSET_UNIONS_CHAIN : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall s : A -> Prop, ((@finite_set A s) /\ ((@subset A s (@UNIONS A f)) /\ ((~ (f = (@set0 (A -> Prop)))) /\ (forall t : A -> Prop, forall u : A -> Prop, ((@IN (A -> Prop) t f) /\ (@IN (A -> Prop) u f)) -> (@subset A t u) \/ (@subset A u t))))) -> exists t : A -> Prop, (@IN (A -> Prop) t f) /\ (@subset A s t).
Axiom thm_FINREC : forall {A B : Type'} (b : B) (s : A -> Prop) (n : nat) (a : B) (f : A -> B -> B), ((@FINREC A B f b s a (NUMERAL O)) = ((s = (@set0 A)) /\ (a = b))) /\ ((@FINREC A B f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((@FINREC A B f b (@DELETE A s x) c n) /\ (a = (f x c))))).
Axiom thm_FINREC_1_LEMMA : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, forall s : A -> Prop, forall a : B, (@FINREC A B f b s a (S (NUMERAL O))) = (exists x : A, (s = (@INSERT A x (@set0 A))) /\ (a = (f x b))).
Axiom thm_FINREC_SUC_LEMMA : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> forall n : nat, forall s : A -> Prop, forall z : B, (@FINREC A B f b s z (S n)) -> forall x : A, (@IN A x s) -> exists w : B, (@FINREC A B f b (@DELETE A s x) w n) /\ (z = (f x w)).
Axiom thm_FINREC_UNIQUE_LEMMA : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> forall n1 : nat, forall n2 : nat, forall s : A -> Prop, forall a1 : B, forall a2 : B, ((@FINREC A B f b s a1 n1) /\ (@FINREC A B f b s a2 n2)) -> (a1 = a2) /\ (n1 = n2).
Axiom thm_FINREC_EXISTS_LEMMA : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, forall s : A -> Prop, (@finite_set A s) -> exists a : B, exists n : nat, @FINREC A B f b s a n.
Axiom thm_FINREC_FUN_LEMMA : forall {A B C : Type'}, forall P : A -> Prop, forall R' : A -> B -> C -> Prop, ((forall s : A, (P s) -> exists a : B, exists n : C, R' s a n) /\ (forall n1 : C, forall n2 : C, forall s : A, forall a1 : B, forall a2 : B, ((R' s a1 n1) /\ (R' s a2 n2)) -> (a1 = a2) /\ (n1 = n2))) -> exists f : A -> B, forall s : A, forall a : B, (P s) -> (exists n : C, R' s a n) = ((f s) = a).
Axiom thm_FINREC_FUN : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> exists g : (A -> Prop) -> B, ((g (@set0 A)) = b) /\ (forall s : A -> Prop, forall x : A, ((@finite_set A s) /\ (@IN A x s)) -> (g s) = (f x (g (@DELETE A s x)))).
Axiom thm_SET_RECURSION_LEMMA : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> exists g : (A -> Prop) -> B, ((g (@set0 A)) = b) /\ (forall x : A, forall s : A -> Prop, (@finite_set A s) -> (g (@INSERT A x s)) = (@COND B (@IN A x s) (g s) (f x (g s)))).
Axiom thm_ITSET : forall {A B : Type'}, forall b : B, forall f : A -> B -> B, forall s : A -> Prop, (@fold_set A B f s b) = (@ε ((A -> Prop) -> B) (fun g : (A -> Prop) -> B => ((g (@set0 A)) = b) /\ (forall x : A, forall s' : A -> Prop, (@finite_set A s') -> (g (@INSERT A x s')) = (@COND B (@IN A x s') (g s') (f x (g s'))))) s).
Axiom thm_FINITE_RECURSION : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> ((@fold_set A B f (@set0 A) b) = b) /\ (forall x : A, forall s : A -> Prop, (@finite_set A s) -> (@fold_set A B f (@INSERT A x s) b) = (@COND B (@IN A x s) (@fold_set A B f s b) (f x (@fold_set A B f s b)))).
Axiom thm_FINITE_RECURSION_DELETE : forall {A B : Type'}, forall f : A -> B -> B, forall b : B, (forall x : A, forall y : A, forall s : B, (~ (x = y)) -> (f x (f y s)) = (f y (f x s))) -> ((@fold_set A B f (@set0 A) b) = b) /\ (forall x : A, forall s : A -> Prop, (@finite_set A s) -> (@fold_set A B f s b) = (@COND B (@IN A x s) (f x (@fold_set A B f (@DELETE A s x) b)) (@fold_set A B f (@DELETE A s x) b))).
Axiom thm_ITSET_EQ : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B -> B, forall g : A -> B -> B, forall b : B, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> (f x) = (g x)) /\ ((forall x : A, forall y : A, forall s' : B, (~ (x = y)) -> (f x (f y s')) = (f y (f x s'))) /\ (forall x : A, forall y : A, forall s' : B, (~ (x = y)) -> (g x (g y s')) = (g y (g x s')))))) -> (@fold_set A B f s b) = (@fold_set A B g s b).
Axiom thm_CARD : forall {A : Type'}, forall s : A -> Prop, (@CARD A s) = (@fold_set A nat (fun x : A => fun n : nat => S n) s (NUMERAL O)).
Axiom thm_CARD_CLAUSES : forall {A : Type'}, ((@CARD A (@set0 A)) = (NUMERAL O)) /\ (forall x : A, forall s : A -> Prop, (@finite_set A s) -> (@CARD A (@INSERT A x s)) = (@COND nat (@IN A x s) (@CARD A s) (S (@CARD A s)))).
Axiom thm_CARD_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ ((@setI A s t) = (@set0 A)))) -> (@CARD A (@setU A s t)) = (addn (@CARD A s) (@CARD A t)).
Axiom thm_CARD_DELETE : forall {A : Type'}, forall x : A, forall s : A -> Prop, (@finite_set A s) -> (@CARD A (@DELETE A s x)) = (@COND nat (@IN A x s) (subn (@CARD A s) (NUMERAL (BIT1 O))) (@CARD A s)).
Axiom thm_CARD_UNION_EQ : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@finite_set A u) /\ (((@setI A s t) = (@set0 A)) /\ ((@setU A s t) = u))) -> (addn (@CARD A s) (@CARD A t)) = (@CARD A u).
Axiom thm_CARD_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@subset A t s)) -> (@CARD A (@setD A s t)) = (subn (@CARD A s) (@CARD A t)).
Axiom thm_CARD_EQ_0 : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> ((@CARD A s) = (NUMERAL O)) = (s = (@set0 A)).
Axiom thm_CARD_SING : forall {A : Type'}, forall a : A, (@CARD A (@INSERT A a (@set0 A))) = (NUMERAL (BIT1 O)).
Axiom thm_FINITE_INDUCT_DELETE : forall {A : Type'}, forall P : (A -> Prop) -> Prop, ((P (@set0 A)) /\ (forall s : A -> Prop, ((@finite_set A s) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ ((P (@DELETE A s x)) -> P s))) -> forall s : A -> Prop, (@finite_set A s) -> P s.
Axiom thm_HAS_SIZE : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@HAS_SIZE A s n) = ((@finite_set A s) /\ ((@CARD A s) = n)).
Axiom thm_HAS_SIZE_CARD : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@HAS_SIZE A s n) -> (@CARD A s) = n.
Axiom thm_HAS_SIZE_0 : forall {A : Type'}, forall s : A -> Prop, (@HAS_SIZE A s (NUMERAL O)) = (s = (@set0 A)).
Axiom thm_HAS_SIZE_SUC : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@HAS_SIZE A s (S n)) = ((~ (s = (@set0 A))) /\ (forall a : A, (@IN A a s) -> @HAS_SIZE A (@DELETE A s a) n)).
Axiom thm_HAS_SIZE_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ ((@HAS_SIZE A t n) /\ (@DISJOINT A s t))) -> @HAS_SIZE A (@setU A s t) (addn m n).
Axiom thm_HAS_SIZE_DIFF : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ ((@HAS_SIZE A t n) /\ (@subset A t s))) -> @HAS_SIZE A (@setD A s t) (subn m n).
Axiom thm_HAS_SIZE_UNIONS : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> B -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ ((forall x : A, (@IN A x s) -> @HAS_SIZE B (t x) n) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ (~ (x = y)))) -> @DISJOINT B (t x) (t y)))) -> @HAS_SIZE B (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_109 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_109 (@IN A x s) (t x)))) (muln m n).
Axiom thm_FINITE_HAS_SIZE : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) = (@HAS_SIZE A s (@CARD A s)).
Axiom thm_HAS_SIZE_CLAUSES : forall {A : Type'} (n : nat) (s : A -> Prop), ((@HAS_SIZE A s (NUMERAL O)) = (s = (@set0 A))) /\ ((@HAS_SIZE A s (S n)) = (exists a : A, exists t : A -> Prop, (@HAS_SIZE A t n) /\ ((~ (@IN A a t)) /\ (s = (@INSERT A a t))))).
Axiom thm_CARD_SUBSET_EQ : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@finite_set A b) /\ ((@subset A a b) /\ ((@CARD A a) = (@CARD A b)))) -> a = b.
Axiom thm_CARD_SUBSET : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@subset A a b) /\ (@finite_set A b)) -> leqn (@CARD A a) (@CARD A b).
Axiom thm_CARD_SUBSET_LE : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@finite_set A b) /\ ((@subset A a b) /\ (leqn (@CARD A b) (@CARD A a)))) -> a = b.
Axiom thm_SUBSET_CARD_EQ : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A t) /\ (@subset A s t)) -> ((@CARD A s) = (@CARD A t)) = (s = t).
Axiom thm_FINITE_CARD_LE_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall n : nat, ((@subset A s t) /\ ((@finite_set A t) /\ (leqn (@CARD A t) n))) -> (@finite_set A s) /\ (leqn (@CARD A s) n).
Axiom thm_CARD_PSUBSET : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@proper A a b) /\ (@finite_set A b)) -> ltn (@CARD A a) (@CARD A b).
Axiom thm_CARD_PSUBSET_IMP : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@subset A a b) /\ (~ ((@CARD A a) = (@CARD A b)))) -> @proper A a b.
Axiom thm_CARD_PSUBSET_EQ : forall {A : Type'}, forall a : A -> Prop, forall b : A -> Prop, ((@finite_set A b) /\ (@subset A a b)) -> (@proper A a b) = (ltn (@CARD A a) (@CARD A b)).
Axiom thm_CARD_UNION_LE : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@finite_set A t)) -> leqn (@CARD A (@setU A s t)) (addn (@CARD A s) (@CARD A t)).
Axiom thm_FINITE_CARD_LE_UNION : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall m : nat, forall n : nat, (((@finite_set A s) /\ (leqn (@CARD A s) m)) /\ ((@finite_set A t) /\ (leqn (@CARD A t) n))) -> (@finite_set A (@setU A s t)) /\ (leqn (@CARD A (@setU A s t)) (addn m n)).
Axiom thm_CARD_UNIONS_LE : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> B -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ (forall x : A, (@IN A x s) -> (@finite_set B (t x)) /\ (leqn (@CARD B (t x)) n))) -> leqn (@CARD B (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_115 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_115 (@IN A x s) (t x))))) (muln m n).
Axiom thm_CARD_UNION_GEN : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@finite_set A t)) -> (@CARD A (@setU A s t)) = (subn (addn (@CARD A s) (@CARD A t)) (@CARD A (@setI A s t))).
Axiom thm_CARD_UNION_OVERLAP_EQ : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@finite_set A t)) -> ((@CARD A (@setU A s t)) = (addn (@CARD A s) (@CARD A t))) = ((@setI A s t) = (@set0 A)).
Axiom thm_CARD_UNION_OVERLAP : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (ltn (@CARD A (@setU A s t)) (addn (@CARD A s) (@CARD A t))))) -> ~ ((@setI A s t) = (@set0 A)).
Axiom thm_CARD_IMAGE_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@finite_set A s)) -> (@CARD B (@IMAGE A B f s)) = (@CARD A s).
Axiom thm_HAS_SIZE_IMAGE_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall n : nat, ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@HAS_SIZE A s n)) -> @HAS_SIZE B (@IMAGE A B f s) n.
Axiom thm_CARD_IMAGE_LE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set A s) -> leqn (@CARD B (@IMAGE A B f s)) (@CARD A s).
Axiom thm_FINITE_CARD_LE_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall n : nat, ((@finite_set A s) /\ (leqn (@CARD A s) n)) -> (@finite_set B (@IMAGE A B f s)) /\ (leqn (@CARD B (@IMAGE A B f s)) n).
Axiom thm_CARD_IMAGE_INJ_EQ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall y : B, (@IN B y t) -> @ex1 A (fun x : A => (@IN A x s) /\ ((f x) = y))))) -> (@CARD B t) = (@CARD A s).
Axiom thm_CARD_SUBSET_IMAGE : forall {A B : Type'}, forall f : A -> B, forall s : B -> Prop, forall t : A -> Prop, ((@finite_set A t) /\ (@subset B s (@IMAGE A B f t))) -> leqn (@CARD B s) (@CARD A t).
Axiom thm_HAS_SIZE_IMAGE_INJ_EQ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall n : nat, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) -> (@HAS_SIZE B (@IMAGE A B f s) n) = (@HAS_SIZE A s n).
Axiom thm_CARD_IMAGE_EQ_INJ : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, (@finite_set A s) -> ((@CARD B (@IMAGE A B f s)) = (@CARD A s)) = (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y).
Axiom thm_EXISTS_SMALL_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, forall n : nat, (exists t : B -> Prop, (@finite_set B t) /\ ((ltn (@CARD B t) n) /\ ((@subset B t (@IMAGE A B f s)) /\ (P t)))) = (exists t : A -> Prop, (@finite_set A t) /\ ((ltn (@CARD A t) n) /\ ((@subset A t s) /\ ((forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y)) /\ (P (@IMAGE A B f t)))))).
Axiom thm_FORALL_SMALL_SUBSET_IMAGE_INJ : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, forall n : nat, (forall t : B -> Prop, ((@finite_set B t) /\ ((ltn (@CARD B t) n) /\ (@subset B t (@IMAGE A B f s)))) -> P t) = (forall t : A -> Prop, ((@finite_set A t) /\ ((ltn (@CARD A t) n) /\ ((@subset A t s) /\ (forall x : A, forall y : A, ((@IN A x t) /\ (@IN A y t)) -> ((f x) = (f y)) = (x = y))))) -> P (@IMAGE A B f t)).
Axiom thm_EXISTS_SMALL_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, forall n : nat, (exists t : B -> Prop, (@finite_set B t) /\ ((ltn (@CARD B t) n) /\ ((@subset B t (@IMAGE A B f s)) /\ (P t)))) = (exists t : A -> Prop, (@finite_set A t) /\ ((ltn (@CARD A t) n) /\ ((@subset A t s) /\ (P (@IMAGE A B f t))))).
Axiom thm_FORALL_SMALL_SUBSET_IMAGE : forall {A B : Type'}, forall P : (B -> Prop) -> Prop, forall f : A -> B, forall s : A -> Prop, forall n : nat, (forall t : B -> Prop, ((@finite_set B t) /\ ((ltn (@CARD B t) n) /\ (@subset B t (@IMAGE A B f s)))) -> P t) = (forall t : A -> Prop, ((@finite_set A t) /\ ((ltn (@CARD A t) n) /\ (@subset A t s))) -> P (@IMAGE A B f t)).
Axiom thm_CARD_IMAGE_LE2 : forall {A B C : Type'}, forall f : A -> B, forall g : A -> C, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((g x) = (g y)))) -> (f x) = (f y))) -> leqn (@CARD B (@IMAGE A B f s)) (@CARD C (@IMAGE A C g s)).
Axiom thm_CARD_IMAGE_LT2 : forall {A B C : Type'}, forall f : A -> B, forall g : A -> C, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((g x) = (g y)))) -> (f x) = (f y)) /\ (~ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> (g x) = (g y))))) -> ltn (@CARD B (@IMAGE A B f s)) (@CARD C (@IMAGE A C g s)).
Axiom thm_CHOOSE_SUBSET_STRONG : forall {A : Type'}, forall n : nat, forall s : A -> Prop, ((@finite_set A s) -> leqn n (@CARD A s)) -> exists t : A -> Prop, (@subset A t s) /\ (@HAS_SIZE A t n).
Axiom thm_CHOOSE_SUBSET_EQ : forall {A : Type'}, forall n : nat, forall s : A -> Prop, ((@finite_set A s) -> leqn n (@CARD A s)) = (exists t : A -> Prop, (@subset A t s) /\ (@HAS_SIZE A t n)).
Axiom thm_CHOOSE_SUBSET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> forall n : nat, (leqn n (@CARD A s)) -> exists t : A -> Prop, (@subset A t s) /\ (@HAS_SIZE A t n).
Axiom thm_CHOOSE_SUBSET_BETWEEN : forall {A : Type'}, forall n : nat, forall s : A -> Prop, forall u : A -> Prop, ((@subset A s u) /\ ((@finite_set A s) /\ ((leqn (@CARD A s) n) /\ ((@finite_set A u) -> leqn n (@CARD A u))))) -> exists t : A -> Prop, (@subset A s t) /\ ((@subset A t u) /\ (@HAS_SIZE A t n)).
Axiom thm_CARD_LE_UNIONS_CHAIN : forall {A : Type'}, forall f : (A -> Prop) -> Prop, forall n : nat, ((forall t : A -> Prop, forall u : A -> Prop, ((@IN (A -> Prop) t f) /\ (@IN (A -> Prop) u f)) -> (@subset A t u) \/ (@subset A u t)) /\ (forall t : A -> Prop, (@IN (A -> Prop) t f) -> (@finite_set A t) /\ (leqn (@CARD A t) n))) -> (@finite_set A (@UNIONS A f)) /\ (leqn (@CARD A (@UNIONS A f)) n).
Axiom thm_CARD_LE_1 : forall {A : Type'}, forall s : A -> Prop, ((@finite_set A s) /\ (leqn (@CARD A s) (NUMERAL (BIT1 O)))) = (exists a : A, @subset A s (@INSERT A a (@set0 A))).
Axiom thm_INVOLUTION_EVEN_NOFIXPOINTS : forall {A : Type'}, forall f : A -> A, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> (@IN A (f x) s) /\ ((~ ((f x) = x)) /\ ((f (f x)) = x)))) -> even (@CARD A s).
Axiom thm_INVOLUTION_EVEN_FIXPOINTS : forall {A : Type'}, forall f : A -> A, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> (@IN A (f x) s) /\ ((f (f x)) = x))) -> (even (@CARD A (@GSPEC A (fun GEN_PVAR_120 : A => exists x : A, @SETSPEC A GEN_PVAR_120 ((@IN A x s) /\ ((f x) = x)) x)))) = (even (@CARD A s)).
Axiom thm_HAS_SIZE_PRODUCT_DEPENDENT : forall {A B : Type'}, forall s : A -> Prop, forall m : nat, forall t : A -> B -> Prop, forall n : nat, ((@HAS_SIZE A s m) /\ (forall x : A, (@IN A x s) -> @HAS_SIZE B (t x) n)) -> @HAS_SIZE (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_123 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_123 ((@IN A x s) /\ (@IN B y (t x))) (@pair A B x y))) (muln m n).
Axiom thm_FINITE_PRODUCT_DEPENDENT : forall {A B C : Type'}, forall f : A -> B -> C, forall s : A -> Prop, forall t : A -> B -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> @finite_set B (t x))) -> @finite_set C (@GSPEC C (fun GEN_PVAR_128 : C => exists x : A, exists y : B, @SETSPEC C GEN_PVAR_128 ((@IN A x s) /\ (@IN B y (t x))) (f x y))).
Axiom thm_FINITE_PRODUCT : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> @finite_set (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_129 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_129 ((@IN A x s) /\ (@IN B y t)) (@pair A B x y))).
Axiom thm_CARD_PRODUCT : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@CARD (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_130 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_130 ((@IN A x s) /\ (@IN B y t)) (@pair A B x y)))) = (muln (@CARD A s) (@CARD B t)).
Axiom thm_HAS_SIZE_PRODUCT : forall {A B : Type'}, forall s : A -> Prop, forall m : nat, forall t : B -> Prop, forall n : nat, ((@HAS_SIZE A s m) /\ (@HAS_SIZE B t n)) -> @HAS_SIZE (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_131 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_131 ((@IN A x s) /\ (@IN B y t)) (@pair A B x y))) (muln m n).
Axiom thm_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@CROSS A B s t) = (@GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x s) /\ (@IN B y t)) (@pair A B x y))).
Axiom thm_IN_CROSS : forall {A B : Type'}, forall x : A, forall y : B, forall s : A -> Prop, forall t : B -> Prop, (@IN (prod A B) (@pair A B x y) (@CROSS A B s t)) = ((@IN A x s) /\ (@IN B y t)).
Axiom thm_HAS_SIZE_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ (@HAS_SIZE B t n)) -> @HAS_SIZE (prod A B) (@CROSS A B s t) (muln m n).
Axiom thm_FINITE_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> @finite_set (prod A B) (@CROSS A B s t).
Axiom thm_CARD_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@CARD (prod A B) (@CROSS A B s t)) = (muln (@CARD A s) (@CARD B t)).
Axiom thm_CROSS_EQ_EMPTY : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@CROSS A B s t) = (@set0 (prod A B))) = ((s = (@set0 A)) \/ (t = (@set0 B))).
Axiom thm_CROSS_EMPTY : forall {_98772 _98785 A B : Type'}, (forall s : A -> Prop, (@CROSS A _98772 s (@set0 _98772)) = (@set0 (prod A _98772))) /\ (forall t : B -> Prop, (@CROSS _98785 B (@set0 _98785) t) = (@set0 (prod _98785 B))).
Axiom thm_CROSS_SING : forall {A B : Type'}, forall x : A, forall y : B, (@CROSS A B (@INSERT A x (@set0 A)) (@INSERT B y (@set0 B))) = (@INSERT (prod A B) (@pair A B x y) (@set0 (prod A B))).
Axiom thm_CROSS_UNIV : forall {A B : Type'}, (@CROSS A B (@setT A) (@setT B)) = (@setT (prod A B)).
Axiom thm_FINITE_CROSS_EQ : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@finite_set (prod A B) (@CROSS A B s t)) = ((s = (@set0 A)) \/ ((t = (@set0 B)) \/ ((@finite_set A s) /\ (@finite_set B t)))).
Axiom thm_INFINITE_CROSS_EQ : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@INFINITE (prod A B) (@CROSS A B s t)) = (((~ (s = (@set0 A))) /\ (@INFINITE B t)) \/ ((@INFINITE A s) /\ (~ (t = (@set0 B))))).
Axiom thm_FINITE_CROSS_UNIV : forall {A B : Type'}, (@finite_set (prod A B) (@setT (prod A B))) = ((@finite_set A (@setT A)) /\ (@finite_set B (@setT B))).
Axiom thm_INFINITE_CROSS_UNIV : forall {A B : Type'}, (@INFINITE (prod A B) (@setT (prod A B))) = ((@INFINITE A (@setT A)) \/ (@INFINITE B (@setT B))).
Axiom thm_FINITE_UNIV_PAIR : forall {A : Type'}, (@finite_set (prod A A) (@setT (prod A A))) = (@finite_set A (@setT A)).
Axiom thm_INFINITE_UNIV_PAIR : forall {A : Type'}, (@INFINITE (prod A A) (@setT (prod A A))) = (@INFINITE A (@setT A)).
Axiom thm_FORALL_IN_CROSS : forall {A B : Type'}, forall P : (prod A B) -> Prop, forall s : A -> Prop, forall t : B -> Prop, (forall z : prod A B, (@IN (prod A B) z (@CROSS A B s t)) -> P z) = (forall x : A, forall y : B, ((@IN A x s) /\ (@IN B y t)) -> P (@pair A B x y)).
Axiom thm_EXISTS_IN_CROSS : forall {A B : Type'}, forall P : (prod A B) -> Prop, forall s : A -> Prop, forall t : B -> Prop, (exists z : prod A B, (@IN (prod A B) z (@CROSS A B s t)) /\ (P z)) = (exists x : A, exists y : B, (@IN A x s) /\ ((@IN B y t) /\ (P (@pair A B x y)))).
Axiom thm_SUBSET_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall s' : A -> Prop, forall t' : B -> Prop, (@subset (prod A B) (@CROSS A B s t) (@CROSS A B s' t')) = ((s = (@set0 A)) \/ ((t = (@set0 B)) \/ ((@subset A s s') /\ (@subset B t t')))).
Axiom thm_CROSS_MONO : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall s' : A -> Prop, forall t' : B -> Prop, ((@subset A s s') /\ (@subset B t t')) -> @subset (prod A B) (@CROSS A B s t) (@CROSS A B s' t').
Axiom thm_CROSS_EQ : forall {A B : Type'}, forall s : A -> Prop, forall s' : A -> Prop, forall t : B -> Prop, forall t' : B -> Prop, ((@CROSS A B s t) = (@CROSS A B s' t')) = ((((s = (@set0 A)) \/ (t = (@set0 B))) /\ ((s' = (@set0 A)) \/ (t' = (@set0 B)))) \/ ((s = s') /\ (t = t'))).
Axiom thm_IMAGE_FST_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@IMAGE (prod A B) A (@fst A B) (@CROSS A B s t)) = (@COND (A -> Prop) (t = (@set0 B)) (@set0 A) s).
Axiom thm_IMAGE_SND_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@IMAGE (prod A B) B (@snd A B) (@CROSS A B s t)) = (@COND (B -> Prop) (s = (@set0 A)) (@set0 B) t).
Axiom thm_IMAGE_PAIRED_CROSS : forall {A B C D : Type'}, forall f : A -> B, forall g : C -> D, forall s : A -> Prop, forall t : C -> Prop, (@IMAGE (prod A C) (prod B D) (@ε ((prod A C) -> prod B D) (fun f' : (prod A C) -> prod B D => forall x : A, forall y : C, @eq (prod B D) (f' (@pair A C x y)) (@pair B D (f x) (g y)))) (@CROSS A C s t)) = (@CROSS B D (@IMAGE A B f s) (@IMAGE C D g t)).
Axiom thm_CROSS_INTER : forall {A B : Type'}, (forall s : A -> Prop, forall t : B -> Prop, forall u : B -> Prop, (@CROSS A B s (@setI B t u)) = (@setI (prod A B) (@CROSS A B s t) (@CROSS A B s u))) /\ (forall s : A -> Prop, forall t : A -> Prop, forall u : B -> Prop, (@CROSS A B (@setI A s t) u) = (@setI (prod A B) (@CROSS A B s u) (@CROSS A B t u))).
Axiom thm_CROSS_UNION : forall {A B : Type'}, (forall s : A -> Prop, forall t : B -> Prop, forall u : B -> Prop, (@CROSS A B s (@setU B t u)) = (@setU (prod A B) (@CROSS A B s t) (@CROSS A B s u))) /\ (forall s : A -> Prop, forall t : A -> Prop, forall u : B -> Prop, (@CROSS A B (@setU A s t) u) = (@setU (prod A B) (@CROSS A B s u) (@CROSS A B t u))).
Axiom thm_CROSS_DIFF : forall {A B : Type'}, (forall s : A -> Prop, forall t : B -> Prop, forall u : B -> Prop, (@CROSS A B s (@setD B t u)) = (@setD (prod A B) (@CROSS A B s t) (@CROSS A B s u))) /\ (forall s : A -> Prop, forall t : A -> Prop, forall u : B -> Prop, (@CROSS A B (@setD A s t) u) = (@setD (prod A B) (@CROSS A B s u) (@CROSS A B t u))).
Axiom thm_INTER_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall s' : A -> Prop, forall t : B -> Prop, forall t' : B -> Prop, (@setI (prod A B) (@CROSS A B s t) (@CROSS A B s' t')) = (@CROSS A B (@setI A s s') (@setI B t t')).
Axiom thm_CROSS_UNIONS : forall {A B : Type'}, (forall s : A -> Prop, forall f : (A -> Prop) -> Prop, (@CROSS A A s (@UNIONS A f)) = (@UNIONS (prod A A) (@GSPEC ((prod A A) -> Prop) (fun GEN_PVAR_134 : (prod A A) -> Prop => exists t : A -> Prop, @SETSPEC ((prod A A) -> Prop) GEN_PVAR_134 (@IN (A -> Prop) t f) (@CROSS A A s t))))) /\ (forall f : (A -> Prop) -> Prop, forall t : B -> Prop, (@CROSS A B (@UNIONS A f) t) = (@UNIONS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_135 : (prod A B) -> Prop => exists s : A -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_135 (@IN (A -> Prop) s f) (@CROSS A B s t))))).
Axiom thm_CROSS_UNIONS_UNIONS : forall {A B : Type'}, forall f : (A -> Prop) -> Prop, forall g : (B -> Prop) -> Prop, (@CROSS A B (@UNIONS A f) (@UNIONS B g)) = (@UNIONS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_133 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_133 ((@IN (A -> Prop) s f) /\ (@IN (B -> Prop) t g)) (@CROSS A B s t)))).
Axiom thm_CROSS_INTERS : forall {A B : Type'}, (forall s : A -> Prop, forall f : (A -> Prop) -> Prop, (@CROSS A A s (@INTERS A f)) = (@COND ((prod A A) -> Prop) (f = (@set0 (A -> Prop))) (@CROSS A A s (@setT A)) (@INTERS (prod A A) (@GSPEC ((prod A A) -> Prop) (fun GEN_PVAR_139 : (prod A A) -> Prop => exists t : A -> Prop, @SETSPEC ((prod A A) -> Prop) GEN_PVAR_139 (@IN (A -> Prop) t f) (@CROSS A A s t)))))) /\ (forall f : (A -> Prop) -> Prop, forall t : B -> Prop, (@CROSS A B (@INTERS A f) t) = (@COND ((prod A B) -> Prop) (f = (@set0 (A -> Prop))) (@CROSS A B (@setT A) t) (@INTERS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_140 : (prod A B) -> Prop => exists s : A -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_140 (@IN (A -> Prop) s f) (@CROSS A B s t)))))).
Axiom thm_CROSS_INTERS_INTERS : forall {A B : Type'}, forall f : (A -> Prop) -> Prop, forall g : (B -> Prop) -> Prop, (@CROSS A B (@INTERS A f) (@INTERS B g)) = (@COND ((prod A B) -> Prop) (f = (@set0 (A -> Prop))) (@INTERS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_136 : (prod A B) -> Prop => exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_136 (@IN (B -> Prop) t g) (@CROSS A B (@setT A) t)))) (@COND ((prod A B) -> Prop) (g = (@set0 (B -> Prop))) (@INTERS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_137 : (prod A B) -> Prop => exists s : A -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_137 (@IN (A -> Prop) s f) (@CROSS A B s (@setT B))))) (@INTERS (prod A B) (@GSPEC ((prod A B) -> Prop) (fun GEN_PVAR_138 : (prod A B) -> Prop => exists s : A -> Prop, exists t : B -> Prop, @SETSPEC ((prod A B) -> Prop) GEN_PVAR_138 ((@IN (A -> Prop) s f) /\ (@IN (B -> Prop) t g)) (@CROSS A B s t)))))).
Axiom thm_DISJOINT_CROSS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall s' : A -> Prop, forall t' : B -> Prop, (@DISJOINT (prod A B) (@CROSS A B s t) (@CROSS A B s' t')) = ((@DISJOINT A s s') \/ (@DISJOINT B t t')).
Axiom thm_ARB : forall {A : Type'}, (@ARB A) = (@ε A (fun x : A => False)).
Axiom thm_EXTENSIONAL : forall {A B : Type'}, forall s : A -> Prop, (@EXTENSIONAL A B s) = (@GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x s)) -> (f x) = (@ARB B)) f)).
Axiom thm_IN_EXTENSIONAL : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, (@IN (A -> B) f (@EXTENSIONAL A B s)) = (forall x : A, (~ (@IN A x s)) -> (f x) = (@ARB B)).
Axiom thm_IN_EXTENSIONAL_UNDEFINED : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall x : A, ((@IN (A -> B) f (@EXTENSIONAL A B s)) /\ (~ (@IN A x s))) -> (f x) = (@ARB B).
Axiom thm_EXTENSIONAL_EMPTY : forall {A B : Type'}, (@EXTENSIONAL A B (@set0 A)) = (@INSERT (A -> B) (fun x : A => @ARB B) (@set0 (A -> B))).
Axiom thm_EXTENSIONAL_UNIV : forall {A B : Type'}, forall f : A -> B, @EXTENSIONAL A B (@setT A) f.
Axiom thm_EXTENSIONAL_EQ : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall g : A -> B, ((@IN (A -> B) f (@EXTENSIONAL A B s)) /\ ((@IN (A -> B) g (@EXTENSIONAL A B s)) /\ (forall x : A, (@IN A x s) -> (f x) = (g x)))) -> f = g.
Axiom thm_RESTRICTION : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall x : A, (@RESTRICTION A B s f x) = (@COND B (@IN A x s) (f x) (@ARB B)).
Axiom thm_RESTRICTION_THM : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, (@RESTRICTION A B s f) = (fun x : A => @COND B (@IN A x s) (f x) (@ARB B)).
Axiom thm_RESTRICTION_DEFINED : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall x : A, (@IN A x s) -> (@RESTRICTION A B s f x) = (f x).
Axiom thm_RESTRICTION_UNDEFINED : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall x : A, (~ (@IN A x s)) -> (@RESTRICTION A B s f x) = (@ARB B).
Axiom thm_RESTRICTION_EQ : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall x : A, forall y : B, ((@IN A x s) /\ ((f x) = y)) -> (@RESTRICTION A B s f x) = y.
Axiom thm_RESTRICTION_IN_EXTENSIONAL : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, @IN (A -> B) (@RESTRICTION A B s f) (@EXTENSIONAL A B s).
Axiom thm_RESTRICTION_EXTENSION : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall g : A -> B, ((@RESTRICTION A B s f) = (@RESTRICTION A B s g)) = (forall x : A, (@IN A x s) -> (f x) = (g x)).
Axiom thm_RESTRICTION_FIXPOINT : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, ((@RESTRICTION A B s f) = f) = (@IN (A -> B) f (@EXTENSIONAL A B s)).
Axiom thm_RESTRICTION_UNIV : forall {A B : Type'}, forall f : A -> B, (@RESTRICTION A B (@setT A) f) = f.
Axiom thm_RESTRICTION_RESTRICTION : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall f : A -> B, (@subset A s t) -> (@RESTRICTION A B s (@RESTRICTION A B t f)) = (@RESTRICTION A B s f).
Axiom thm_RESTRICTION_IDEMP : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, (@RESTRICTION A B s (@RESTRICTION A B s f)) = (@RESTRICTION A B s f).
Axiom thm_IMAGE_RESTRICTION : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, (@subset A s t) -> (@IMAGE A B (@RESTRICTION A B t f) s) = (@IMAGE A B f s).
Axiom thm_RESTRICTION_COMPOSE_RIGHT : forall {A B C : Type'}, forall f : A -> B, forall g : B -> C, forall s : A -> Prop, (@RESTRICTION A C s (@o A B C g (@RESTRICTION A B s f))) = (@RESTRICTION A C s (@o A B C g f)).
Axiom thm_RESTRICTION_COMPOSE_LEFT : forall {A B C : Type'}, forall f : A -> B, forall g : B -> C, forall s : A -> Prop, forall t : B -> Prop, (@subset B (@IMAGE A B f s) t) -> (@RESTRICTION A C s (@o A B C (@RESTRICTION B C t g) f)) = (@RESTRICTION A C s (@o A B C g f)).
Axiom thm_RESTRICTION_COMPOSE : forall {A B C : Type'}, forall f : A -> B, forall g : B -> C, forall s : A -> Prop, forall t : B -> Prop, (@subset B (@IMAGE A B f s) t) -> (@RESTRICTION A C s (@o A B C (@RESTRICTION B C t g) (@RESTRICTION A B s f))) = (@RESTRICTION A C s (@o A B C g f)).
Axiom thm_RESTRICTION_UNIQUE : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall g : A -> B, ((@RESTRICTION A B s f) = g) = ((@EXTENSIONAL A B s g) /\ (forall x : A, (@IN A x s) -> (f x) = (g x))).
Axiom thm_RESTRICTION_UNIQUE_ALT : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall g : A -> B, (f = (@RESTRICTION A B s g)) = ((@EXTENSIONAL A B s f) /\ (forall x : A, (@IN A x s) -> (f x) = (g x))).
Axiom thm_cartesian_product : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, (@cartesian_product A K k s) = (@GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A k f) /\ (forall i : K, (@IN K i k) -> @IN A (f i) (s i))) f)).
Axiom thm_IN_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall x : K -> A, (@IN (K -> A) x (@cartesian_product A K k s)) = ((@EXTENSIONAL K A k x) /\ (forall i : K, (@IN K i k) -> @IN A (x i) (s i))).
Axiom thm_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, (@cartesian_product A K k s) = (@GSPEC (K -> A) (fun GEN_PVAR_143 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_143 (forall i : K, @IN A (f i) (@COND (A -> Prop) (@IN K i k) (s i) (@INSERT A (@ARB A) (@set0 A)))) f)).
Axiom thm_RESTRICTION_IN_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall f : K -> A, (@IN (K -> A) (@RESTRICTION K A k f) (@cartesian_product A K k s)) = (forall i : K, (@IN K i k) -> @IN A (f i) (s i)).
Axiom thm_CARTESIAN_PRODUCT_AS_RESTRICTIONS : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, (@cartesian_product A K k s) = (@GSPEC (K -> A) (fun GEN_PVAR_144 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_144 (forall i : K, (@IN K i k) -> @IN A (f i) (s i)) (@RESTRICTION K A k f))).
Axiom thm_CARTESIAN_PRODUCT_EQ_EMPTY : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, ((@cartesian_product A K k s) = (@set0 (K -> A))) = (exists i : K, (@IN K i k) /\ ((s i) = (@set0 A))).
Axiom thm_CARTESIAN_PRODUCT_EMPTY : forall {A K : Type'}, forall s : K -> A -> Prop, (@cartesian_product A K (@set0 K) s) = (@INSERT (K -> A) (fun i : K => @ARB A) (@set0 (K -> A))).
Axiom thm_CARTESIAN_PRODUCT_EQ_MEMBERS : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall x : K -> A, forall y : K -> A, ((@IN (K -> A) x (@cartesian_product A K k s)) /\ ((@IN (K -> A) y (@cartesian_product A K k s)) /\ (forall i : K, (@IN K i k) -> (x i) = (y i)))) -> x = y.
Axiom thm_CARTESIAN_PRODUCT_EQ_MEMBERS_EQ : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall x : K -> A, forall y : K -> A, ((@IN (K -> A) x (@cartesian_product A K k s)) /\ (@IN (K -> A) y (@cartesian_product A K k s))) -> (x = y) = (forall i : K, (@IN K i k) -> (x i) = (y i)).
Axiom thm_SUBSET_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@subset (K -> A) (@cartesian_product A K k s) (@cartesian_product A K k t)) = (((@cartesian_product A K k s) = (@set0 (K -> A))) \/ (forall i : K, (@IN K i k) -> @subset A (s i) (t i))).
Axiom thm_CARTESIAN_PRODUCT_EQ : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, ((@cartesian_product A K k s) = (@cartesian_product A K k t)) = ((((@cartesian_product A K k s) = (@set0 (K -> A))) /\ ((@cartesian_product A K k t) = (@set0 (K -> A)))) \/ (forall i : K, (@IN K i k) -> (s i) = (t i))).
Axiom thm_INTER_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@setI (K -> A) (@cartesian_product A K k s) (@cartesian_product A K k t)) = (@cartesian_product A K k (fun i : K => @setI A (s i) (t i))).
Axiom thm_CARTESIAN_PRODUCT_UNIV : forall {A K : Type'}, (@cartesian_product A K (@setT K) (fun i : K => @setT A)) = (@setT (K -> A)).
Axiom thm_CARTESIAN_PRODUCT_SINGS : forall {A K : Type'}, forall k : K -> Prop, forall x : K -> A, (@EXTENSIONAL K A k x) -> (@cartesian_product A K k (fun i : K => @INSERT A (x i) (@set0 A))) = (@INSERT (K -> A) x (@set0 (K -> A))).
Axiom thm_CARTESIAN_PRODUCT_SINGS_GEN : forall {A K : Type'}, forall k : K -> Prop, forall x : K -> A, (@cartesian_product A K k (fun i : K => @INSERT A (x i) (@set0 A))) = (@INSERT (K -> A) (@RESTRICTION K A k x) (@set0 (K -> A))).
Axiom thm_IMAGE_PROJECTION_CARTESIAN_PRODUCT : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall i : K, (@IMAGE (K -> A) A (fun x : K -> A => x i) (@cartesian_product A K k s)) = (@COND (A -> Prop) ((@cartesian_product A K k s) = (@set0 (K -> A))) (@set0 A) (@COND (A -> Prop) (@IN K i k) (s i) (@INSERT A (@ARB A) (@set0 A)))).
Axiom thm_FORALL_CARTESIAN_PRODUCT_ELEMENTS : forall {A K : Type'}, forall P : K -> A -> Prop, forall k : K -> Prop, forall s : K -> A -> Prop, (forall z : K -> A, forall i : K, ((@IN (K -> A) z (@cartesian_product A K k s)) /\ (@IN K i k)) -> P i (z i)) = (((@cartesian_product A K k s) = (@set0 (K -> A))) \/ (forall i : K, forall x : A, ((@IN K i k) /\ (@IN A x (s i))) -> P i x)).
Axiom thm_FORALL_CARTESIAN_PRODUCT_ELEMENTS_EQ : forall {A K : Type'}, forall P : K -> A -> Prop, forall k : K -> Prop, forall s : K -> A -> Prop, (~ ((@cartesian_product A K k s) = (@set0 (K -> A)))) -> (forall i : K, forall x : A, ((@IN K i k) /\ (@IN A x (s i))) -> P i x) = (forall z : K -> A, forall i : K, ((@IN (K -> A) z (@cartesian_product A K k s)) /\ (@IN K i k)) -> P i (z i)).
Axiom thm_EXISTS_CARTESIAN_PRODUCT_ELEMENT : forall {A K : Type'}, forall P : K -> A -> Prop, forall k : K -> Prop, forall s : K -> A -> Prop, (exists z : K -> A, (@IN (K -> A) z (@cartesian_product A K k s)) /\ (forall i : K, (@IN K i k) -> P i (z i))) = (forall i : K, (@IN K i k) -> exists x : A, (@IN A x (s i)) /\ (P i x)).
Axiom thm_product_map : forall {A B K : Type'}, forall k : K -> Prop, forall f : K -> A -> B, (@product_map A B K k f) = (fun x : K -> A => @RESTRICTION K B k (fun i : K => f i (x i))).
Axiom thm_PRODUCT_MAP_RESTRICTION : forall {A B K : Type'}, forall f : K -> A -> B, forall k : K -> Prop, forall x : K -> A, (@product_map A B K k f (@RESTRICTION K A k x)) = (@RESTRICTION K B k (fun i : K => f i (x i))).
Axiom thm_IMAGE_PRODUCT_MAP : forall {A B K : Type'}, forall f : K -> A -> B, forall k : K -> Prop, forall s : K -> A -> Prop, (@IMAGE (K -> A) (K -> B) (@product_map A B K k f) (@cartesian_product A K k s)) = (@cartesian_product B K k (fun i : K => @IMAGE A B (f i) (s i))).
Axiom thm_disjoint_union : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, (@disjoint_union A K k s) = (@GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i k) /\ (@IN A x (s i))) (@pair K A i x))).
Axiom thm_SUBSET_DISJOINT_UNION : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@subset (prod K A) (@disjoint_union A K k s) (@disjoint_union A K k t)) = (forall i : K, (@IN K i k) -> @subset A (s i) (t i)).
Axiom thm_DISJOINT_UNION_EQ : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, ((@disjoint_union A K k s) = (@disjoint_union A K k t)) = (forall i : K, (@IN K i k) -> (s i) = (t i)).
Axiom thm_SUBSET_DISJOINT_UNION_EXISTS : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall u : (prod K A) -> Prop, (@subset (prod K A) u (@disjoint_union A K k s)) = (exists t : K -> A -> Prop, (u = (@disjoint_union A K k t)) /\ (forall i : K, (@IN K i k) -> @subset A (t i) (s i))).
Axiom thm_INTER_DISJOINT_UNION : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@setI (prod K A) (@disjoint_union A K k s) (@disjoint_union A K k t)) = (@disjoint_union A K k (fun i : K => @setI A (s i) (t i))).
Axiom thm_UNION_DISJOINT_UNION : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@setU (prod K A) (@disjoint_union A K k s) (@disjoint_union A K k t)) = (@disjoint_union A K k (fun i : K => @setU A (s i) (t i))).
Axiom thm_DISJOINT_UNION_EQ_EMPTY : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, ((@disjoint_union A K k s) = (@set0 (prod K A))) = (forall i : K, (@IN K i k) -> (s i) = (@set0 A)).
Axiom thm_DISJOINT_DISJOINT_UNION : forall {A K : Type'}, forall k : K -> Prop, forall s : K -> A -> Prop, forall t : K -> A -> Prop, (@DISJOINT (prod K A) (@disjoint_union A K k s) (@disjoint_union A K k t)) = (forall i : K, (@IN K i k) -> @DISJOINT A (s i) (t i)).
Axiom thm_HAS_SIZE_FUNSPACE : forall {A B : Type'}, forall d : B, forall n : nat, forall t : B -> Prop, forall m : nat, forall s : A -> Prop, ((@HAS_SIZE A s m) /\ (@HAS_SIZE B t n)) -> @HAS_SIZE (A -> B) (@GSPEC (A -> B) (fun GEN_PVAR_150 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_150 ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : A, (~ (@IN A x s)) -> (f x) = d)) f)) (expn n m).
Axiom thm_CARD_FUNSPACE : forall {A B : Type'} (d : B), forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@CARD (A -> B) (@GSPEC (A -> B) (fun GEN_PVAR_151 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_151 ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : A, (~ (@IN A x s)) -> (f x) = d)) f))) = (expn (@CARD B t) (@CARD A s)).
Axiom thm_FINITE_FUNSPACE : forall {A B : Type'} (d : B), forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> @finite_set (A -> B) (@GSPEC (A -> B) (fun GEN_PVAR_152 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_152 ((forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : A, (~ (@IN A x s)) -> (f x) = d)) f)).
Axiom thm_HAS_SIZE_FUNSPACE_UNIV : forall {A B : Type'}, forall m : nat, forall n : nat, ((@HAS_SIZE A (@setT A) m) /\ (@HAS_SIZE B (@setT B) n)) -> @HAS_SIZE (A -> B) (@setT (A -> B)) (expn n m).
Axiom thm_CARD_FUNSPACE_UNIV : forall {A B : Type'}, ((@finite_set A (@setT A)) /\ (@finite_set B (@setT B))) -> (@CARD (A -> B) (@setT (A -> B))) = (expn (@CARD B (@setT B)) (@CARD A (@setT A))).
Axiom thm_FINITE_FUNSPACE_UNIV : forall {A B : Type'}, ((@finite_set A (@setT A)) /\ (@finite_set B (@setT B))) -> @finite_set (A -> B) (@setT (A -> B)).
Axiom thm_HAS_SIZE_BOOL : @HAS_SIZE Prop (@setT Prop) (NUMERAL (BIT0 (BIT1 O))).
Axiom thm_CARD_BOOL : (@CARD Prop (@setT Prop)) = (NUMERAL (BIT0 (BIT1 O))).
Axiom thm_FINITE_BOOL : @finite_set Prop (@setT Prop).
Axiom thm_HAS_SIZE_POWERSET : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@HAS_SIZE A s n) -> @HAS_SIZE (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_155 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_155 (@subset A t s) t)) (expn (NUMERAL (BIT0 (BIT1 O))) n).
Axiom thm_CARD_POWERSET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> (@CARD (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_156 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_156 (@subset A t s) t))) = (expn (NUMERAL (BIT0 (BIT1 O))) (@CARD A s)).
Axiom thm_FINITE_POWERSET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> @finite_set (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_157 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_157 (@subset A t s) t)).
Axiom thm_FINITE_POWERSET_EQ : forall {A : Type'}, forall s : A -> Prop, (@finite_set (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_158 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_158 (@subset A t s) t))) = (@finite_set A s).
Axiom thm_FINITE_RESTRICTED_SUBSETS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (@finite_set A s) -> @finite_set (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_160 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_160 ((@subset A t s) /\ (P t)) t)).
Axiom thm_FINITE_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@finite_set A (@UNIONS A s)) = ((@finite_set (A -> Prop) s) /\ (forall t : A -> Prop, (@IN (A -> Prop) t s) -> @finite_set A t)).
Axiom thm_FINITE_CARD_LE_UNIONS : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> B -> Prop, forall m : nat, forall n : nat, ((forall x : A, (@IN A x s) -> (@finite_set B (t x)) /\ (leqn (@CARD B (t x)) n)) /\ ((@finite_set A s) /\ (leqn (@CARD A s) m))) -> (@finite_set B (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_161 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_161 (@IN A x s) (t x))))) /\ (leqn (@CARD B (@UNIONS B (@GSPEC (B -> Prop) (fun GEN_PVAR_162 : B -> Prop => exists x : A, @SETSPEC (B -> Prop) GEN_PVAR_162 (@IN A x s) (t x))))) (muln m n)).
Axiom thm_POWERSET_CLAUSES : forall {A : Type'}, ((@GSPEC (A -> Prop) (fun GEN_PVAR_163 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_163 (@subset A s (@set0 A)) s)) = (@INSERT (A -> Prop) (@set0 A) (@set0 (A -> Prop)))) /\ (forall a : A, forall t : A -> Prop, (@GSPEC (A -> Prop) (fun GEN_PVAR_164 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_164 (@subset A s (@INSERT A a t)) s)) = (@setU (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_165 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_165 (@subset A s t) s)) (@IMAGE (A -> Prop) (A -> Prop) (fun s : A -> Prop => @INSERT A a s) (@GSPEC (A -> Prop) (fun GEN_PVAR_166 : A -> Prop => exists s : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_166 (@subset A s t) s))))).
Axiom thm_FINITE_IMAGE_INFINITE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, ((@INFINITE A s) /\ (@finite_set B (@IMAGE A B f s))) -> exists a : A, (@IN A a s) /\ (@INFINITE A (@GSPEC A (fun GEN_PVAR_171 : A => exists x : A, @SETSPEC A GEN_PVAR_171 ((@IN A x s) /\ ((f x) = (f a))) x))).
Axiom thm_FINITE_RESTRICTED_POWERSET : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@finite_set (A -> Prop) (@GSPEC (A -> Prop) (fun GEN_PVAR_176 : A -> Prop => exists t : A -> Prop, @SETSPEC (A -> Prop) GEN_PVAR_176 ((@subset A t s) /\ (@HAS_SIZE A t n)) t))) = ((@finite_set A s) \/ (n = (NUMERAL O))).
Axiom thm_FINITE_RESTRICTED_FUNSPACE : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall k : A -> B, ((@finite_set A s) /\ (@finite_set B t)) -> @finite_set (A -> B) (@GSPEC (A -> B) (fun GEN_PVAR_180 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_180 ((@subset B (@IMAGE A B f s) t) /\ (@subset A (@GSPEC A (fun GEN_PVAR_179 : A => exists x : A, @SETSPEC A GEN_PVAR_179 (~ ((f x) = (k x))) x)) s)) f)).
Axiom thm_NUMSEG_CLAUSES_LT : ((@GSPEC nat (fun GEN_PVAR_181 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_181 (ltn i (NUMERAL O)) i)) = (@set0 nat)) /\ (forall k : nat, (@GSPEC nat (fun GEN_PVAR_182 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_182 (ltn i (S k)) i)) = (@INSERT nat k (@GSPEC nat (fun GEN_PVAR_183 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_183 (ltn i k) i)))).
Axiom thm_HAS_SIZE_NUMSEG_LT : forall n : nat, @HAS_SIZE nat (@GSPEC nat (fun GEN_PVAR_184 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_184 (ltn m n) m)) n.
Axiom thm_CARD_NUMSEG_LT : forall n : nat, (@CARD nat (@GSPEC nat (fun GEN_PVAR_185 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_185 (ltn m n) m))) = n.
Axiom thm_FINITE_NUMSEG_LT : forall n : nat, @finite_set nat (@GSPEC nat (fun GEN_PVAR_186 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_186 (ltn m n) m)).
Axiom thm_NUMSEG_CLAUSES_LE : ((@GSPEC nat (fun GEN_PVAR_187 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_187 (leqn i (NUMERAL O)) i)) = (@INSERT nat (NUMERAL O) (@set0 nat))) /\ (forall k : nat, (@GSPEC nat (fun GEN_PVAR_188 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_188 (leqn i (S k)) i)) = (@INSERT nat (S k) (@GSPEC nat (fun GEN_PVAR_189 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_189 (leqn i k) i)))).
Axiom thm_HAS_SIZE_NUMSEG_LE : forall n : nat, @HAS_SIZE nat (@GSPEC nat (fun GEN_PVAR_190 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_190 (leqn m n) m)) (addn n (NUMERAL (BIT1 O))).
Axiom thm_FINITE_NUMSEG_LE : forall n : nat, @finite_set nat (@GSPEC nat (fun GEN_PVAR_191 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_191 (leqn m n) m)).
Axiom thm_CARD_NUMSEG_LE : forall n : nat, (@CARD nat (@GSPEC nat (fun GEN_PVAR_192 : nat => exists m : nat, @SETSPEC nat GEN_PVAR_192 (leqn m n) m))) = (addn n (NUMERAL (BIT1 O))).
Axiom thm_num_FINITE : forall s : nat -> Prop, (@finite_set nat s) = (exists a : nat, forall x : nat, (@IN nat x s) -> leqn x a).
Axiom thm_num_FINITE_AVOID : forall s : nat -> Prop, (@finite_set nat s) -> exists a : nat, ~ (@IN nat a s).
Axiom thm_num_INFINITE_EQ : forall s : nat -> Prop, (@INFINITE nat s) = (forall N' : nat, exists n : nat, (leqn N' n) /\ (@IN nat n s)).
Axiom thm_num_INFINITE : @INFINITE nat (@setT nat).
Axiom thm_string_INFINITE : @INFINITE (seq Ascii.ascii) (@setT (seq Ascii.ascii)).
Axiom thm_FINITE_REAL_INTERVAL : (forall a : R, ~ (@finite_set R (@GSPEC R (fun GEN_PVAR_202 : R => exists x : R, @SETSPEC R GEN_PVAR_202 (ltr a x) x)))) /\ ((forall a : R, ~ (@finite_set R (@GSPEC R (fun GEN_PVAR_203 : R => exists x : R, @SETSPEC R GEN_PVAR_203 (ler a x) x)))) /\ ((forall b : R, ~ (@finite_set R (@GSPEC R (fun GEN_PVAR_204 : R => exists x : R, @SETSPEC R GEN_PVAR_204 (ltr x b) x)))) /\ ((forall b : R, ~ (@finite_set R (@GSPEC R (fun GEN_PVAR_205 : R => exists x : R, @SETSPEC R GEN_PVAR_205 (ler x b) x)))) /\ ((forall a : R, forall b : R, (@finite_set R (@GSPEC R (fun GEN_PVAR_206 : R => exists x : R, @SETSPEC R GEN_PVAR_206 ((ltr a x) /\ (ltr x b)) x))) = (ler b a)) /\ ((forall a : R, forall b : R, (@finite_set R (@GSPEC R (fun GEN_PVAR_207 : R => exists x : R, @SETSPEC R GEN_PVAR_207 ((ler a x) /\ (ltr x b)) x))) = (ler b a)) /\ ((forall a : R, forall b : R, (@finite_set R (@GSPEC R (fun GEN_PVAR_208 : R => exists x : R, @SETSPEC R GEN_PVAR_208 ((ltr a x) /\ (ler x b)) x))) = (ler b a)) /\ (forall a : R, forall b : R, (@finite_set R (@GSPEC R (fun GEN_PVAR_209 : R => exists x : R, @SETSPEC R GEN_PVAR_209 ((ler a x) /\ (ler x b)) x))) = (ler b a)))))))).
Axiom thm_real_INFINITE : @INFINITE R (@setT R).
Axiom thm_HAS_SIZE_INDEX : forall {A : Type'}, forall s : A -> Prop, forall n : nat, (@HAS_SIZE A s n) -> exists f : nat -> A, (forall m : nat, (ltn m n) -> @IN A (f m) s) /\ (forall x : A, (@IN A x s) -> @ex1 nat (fun m : nat => (ltn m n) /\ ((f m) = x))).
Axiom thm_INFINITE_ENUMERATE : forall s : nat -> Prop, (@INFINITE nat s) -> exists r : nat -> nat, (forall m : nat, forall n : nat, (ltn m n) -> ltn (r m) (r n)) /\ ((@IMAGE nat nat r (@setT nat)) = s).
Axiom thm_INFINITE_ENUMERATE_EQ : forall s : nat -> Prop, (@INFINITE nat s) = (exists r : nat -> nat, (forall m : nat, forall n : nat, (ltn m n) -> ltn (r m) (r n)) /\ ((@IMAGE nat nat r (@setT nat)) = s)).
Axiom thm_INFINITE_ENUMERATE_SUBSET : forall {A : Type'}, forall s : A -> Prop, (@INFINITE A s) = (exists f : nat -> A, (forall x : nat, @IN A (f x) s) /\ (forall x : nat, forall y : nat, ((f x) = (f y)) -> x = y)).
Axiom thm_set_of_list : forall {A : Type'} (h : A) (t : seq A), ((@set_of_list A (@nil A)) = (@set0 A)) /\ ((@set_of_list A (@cons A h t)) = (@INSERT A h (@set_of_list A t))).
Axiom thm_list_of_set : forall {A : Type'}, forall s : A -> Prop, (@list_of_set A s) = (@ε (seq A) (fun l : seq A => ((@set_of_list A l) = s) /\ ((@size A l) = (@CARD A s)))).
Axiom thm_LIST_OF_SET_PROPERTIES : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> ((@set_of_list A (@list_of_set A s)) = s) /\ ((@size A (@list_of_set A s)) = (@CARD A s)).
Axiom thm_SET_OF_LIST_OF_SET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> (@set_of_list A (@list_of_set A s)) = s.
Axiom thm_LENGTH_LIST_OF_SET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> (@size A (@list_of_set A s)) = (@CARD A s).
Axiom thm_MEM_LIST_OF_SET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> forall x : A, (@MEM A x (@list_of_set A s)) = (@IN A x s).
Axiom thm_FINITE_SET_OF_LIST : forall {A : Type'}, forall l : seq A, @finite_set A (@set_of_list A l).
Axiom thm_IN_SET_OF_LIST : forall {A : Type'}, forall x : A, forall l : seq A, (@IN A x (@set_of_list A l)) = (@MEM A x l).
Axiom thm_SET_OF_LIST_APPEND : forall {A : Type'}, forall l1 : seq A, forall l2 : seq A, (@set_of_list A (@cat A l1 l2)) = (@setU A (@set_of_list A l1) (@set_of_list A l2)).
Axiom thm_SET_OF_LIST_MAP : forall {A B : Type'}, forall f : A -> B, forall l : seq A, (@set_of_list B (@map A B f l)) = (@IMAGE A B f (@set_of_list A l)).
Axiom thm_SET_OF_LIST_EQ_EMPTY : forall {A : Type'}, forall l : seq A, ((@set_of_list A l) = (@set0 A)) = (l = (@nil A)).
Axiom thm_LIST_OF_SET_EMPTY : forall {A : Type'}, (@list_of_set A (@set0 A)) = (@nil A).
Axiom thm_LIST_OF_SET_SING : forall {A : Type'}, forall a : A, (@list_of_set A (@INSERT A a (@set0 A))) = (@cons A a (@nil A)).
Axiom thm_pairwise : forall {A : Type'}, forall s : A -> Prop, forall r : A -> A -> Prop, (@pairwise A r s) = (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ (~ (x = y)))) -> r x y).
Axiom thm_PAIRWISE_EMPTY : forall {A : Type'}, forall r : A -> A -> Prop, (@pairwise A r (@set0 A)) = True.
Axiom thm_PAIRWISE_SING : forall {A : Type'}, forall r : A -> A -> Prop, forall x : A, (@pairwise A r (@INSERT A x (@set0 A))) = True.
Axiom thm_PAIRWISE_IMP : forall {A : Type'}, forall P : A -> A -> Prop, forall Q : A -> A -> Prop, forall s : A -> Prop, ((@pairwise A P s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((P x y) /\ (~ (x = y))))) -> Q x y)) -> @pairwise A Q s.
Axiom thm_PAIRWISE_MONO : forall {A : Type'}, forall r : A -> A -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@pairwise A r s) /\ (@subset A t s)) -> @pairwise A r t.
Axiom thm_PAIRWISE_AND : forall {A : Type'}, forall R' : A -> A -> Prop, forall R'' : A -> A -> Prop, forall s : A -> Prop, ((@pairwise A R' s) /\ (@pairwise A R'' s)) = (@pairwise A (fun x : A => fun y : A => (R' x y) /\ (R'' x y)) s).
Axiom thm_PAIRWISE_INSERT : forall {A : Type'}, forall r : A -> A -> Prop, forall x : A, forall s : A -> Prop, (@pairwise A r (@INSERT A x s)) = ((forall y : A, ((@IN A y s) /\ (~ (y = x))) -> (r x y) /\ (r y x)) /\ (@pairwise A r s)).
Axiom thm_PAIRWISE_INSERT_SYMMETRIC : forall {A : Type'}, forall r : A -> A -> Prop, forall x : A, forall s : A -> Prop, (forall y : A, (@IN A y s) -> (r x y) = (r y x)) -> (@pairwise A r (@INSERT A x s)) = ((forall y : A, ((@IN A y s) /\ (~ (y = x))) -> r x y) /\ (@pairwise A r s)).
Axiom thm_PAIRWISE_IMAGE : forall {A B : Type'} (s : A -> Prop), forall r : B -> B -> Prop, forall f : A -> B, (@pairwise B r (@IMAGE A B f s)) = (@pairwise A (fun x : A => fun y : A => (~ ((f x) = (f y))) -> r (f x) (f y)) s).
Axiom thm_PAIRWISE_UNION : forall {A : Type'}, forall R' : A -> A -> Prop, forall s : A -> Prop, forall t : A -> Prop, (@pairwise A R' (@setU A s t)) = ((@pairwise A R' s) /\ ((@pairwise A R' t) /\ (forall x : A, forall y : A, ((@IN A x (@setD A s t)) /\ (@IN A y (@setD A t s))) -> (R' x y) /\ (R' y x)))).
Axiom thm_PAIRWISE_CHAIN_UNIONS : forall {A : Type'}, forall R' : A -> A -> Prop, forall c : (A -> Prop) -> Prop, ((forall s : A -> Prop, (@IN (A -> Prop) s c) -> @pairwise A R' s) /\ (forall s : A -> Prop, forall t : A -> Prop, ((@IN (A -> Prop) s c) /\ (@IN (A -> Prop) t c)) -> (@subset A s t) \/ (@subset A t s))) -> @pairwise A R' (@UNIONS A c).
Axiom thm_DIFF_UNIONS_PAIRWISE_DISJOINT : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, ((@pairwise (A -> Prop) (@DISJOINT A) s) /\ (@subset (A -> Prop) t s)) -> (@setD A (@UNIONS A s) (@UNIONS A t)) = (@UNIONS A (@setD (A -> Prop) s t)).
Axiom thm_INTER_UNIONS_PAIRWISE_DISJOINT : forall {A : Type'}, forall s : (A -> Prop) -> Prop, forall t : (A -> Prop) -> Prop, (@pairwise (A -> Prop) (@DISJOINT A) (@setU (A -> Prop) s t)) -> (@setI A (@UNIONS A s) (@UNIONS A t)) = (@UNIONS A (@setI (A -> Prop) s t)).
Axiom thm_PSUBSET_UNIONS_PAIRWISE_DISJOINT : forall {A : Type'}, forall u : (A -> Prop) -> Prop, forall v : (A -> Prop) -> Prop, ((@pairwise (A -> Prop) (@DISJOINT A) v) /\ (@proper (A -> Prop) u (@DELETE (A -> Prop) v (@set0 A)))) -> @proper A (@UNIONS A u) (@UNIONS A v).
Axiom thm_UNION_OF : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, (@UNION_OF A P Q) = (fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (P u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> Q c) /\ ((@UNIONS A u) = s))).
Axiom thm_INTERSECTION_OF : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, (@INTERSECTION_OF A P Q) = (fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (P u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> Q c) /\ ((@INTERS A u) = s))).
Axiom thm_UNION_OF_INC : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, forall s : A -> Prop, ((P (@INSERT (A -> Prop) s (@set0 (A -> Prop)))) /\ (Q s)) -> @UNION_OF A P Q s.
Axiom thm_INTERSECTION_OF_INC : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, forall s : A -> Prop, ((P (@INSERT (A -> Prop) s (@set0 (A -> Prop)))) /\ (Q s)) -> @INTERSECTION_OF A P Q s.
Axiom thm_UNION_OF_MONO : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, forall Q' : (A -> Prop) -> Prop, forall s : A -> Prop, ((@UNION_OF A P Q s) /\ (forall x : A -> Prop, (Q x) -> Q' x)) -> @UNION_OF A P Q' s.
Axiom thm_INTERSECTION_OF_MONO : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, forall Q' : (A -> Prop) -> Prop, forall s : A -> Prop, ((@INTERSECTION_OF A P Q s) /\ (forall x : A -> Prop, (Q x) -> Q' x)) -> @INTERSECTION_OF A P Q' s.
Axiom thm_FORALL_UNION_OF : forall {A : Type'} (P : ((A -> Prop) -> Prop) -> Prop) (Q : (A -> Prop) -> Prop) (R' : (A -> Prop) -> Prop), (forall s : A -> Prop, (@UNION_OF A P Q s) -> R' s) = (forall t : (A -> Prop) -> Prop, ((P t) /\ (forall c : A -> Prop, (@IN (A -> Prop) c t) -> Q c)) -> R' (@UNIONS A t)).
Axiom thm_FORALL_INTERSECTION_OF : forall {A : Type'} (P : ((A -> Prop) -> Prop) -> Prop) (Q : (A -> Prop) -> Prop) (R' : (A -> Prop) -> Prop), (forall s : A -> Prop, (@INTERSECTION_OF A P Q s) -> R' s) = (forall t : (A -> Prop) -> Prop, ((P t) /\ (forall c : A -> Prop, (@IN (A -> Prop) c t) -> Q c)) -> R' (@INTERS A t)).
Axiom thm_UNION_OF_EMPTY : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, (P (@set0 (A -> Prop))) -> @UNION_OF A P Q (@set0 A).
Axiom thm_INTERSECTION_OF_EMPTY : forall {A : Type'}, forall P : ((A -> Prop) -> Prop) -> Prop, forall Q : (A -> Prop) -> Prop, (P (@set0 (A -> Prop))) -> @INTERSECTION_OF A P Q (@setT A).
Axiom thm_ARBITRARY : forall {A : Type'}, forall s : (A -> Prop) -> Prop, (@ARBITRARY A s) = True.
Axiom thm_ARBITRARY_UNION_OF_ALT : forall {A : Type'}, forall B : (A -> Prop) -> Prop, forall s : A -> Prop, (@UNION_OF A (@ARBITRARY A) B s) = (forall x : A, (@IN A x s) -> exists u : A -> Prop, (@IN (A -> Prop) u B) /\ ((@IN A x u) /\ (@subset A u s))).
Axiom thm_ARBITRARY_UNION_OF_EMPTY : forall {A : Type'}, forall P : (A -> Prop) -> Prop, @UNION_OF A (@ARBITRARY A) P (@set0 A).
Axiom thm_ARBITRARY_INTERSECTION_OF_EMPTY : forall {A : Type'}, forall P : (A -> Prop) -> Prop, @INTERSECTION_OF A (@ARBITRARY A) P (@setT A).
Axiom thm_ARBITRARY_UNION_OF_INC : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (P s) -> @UNION_OF A (@ARBITRARY A) P s.
Axiom thm_ARBITRARY_INTERSECTION_OF_INC : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (P s) -> @INTERSECTION_OF A (@ARBITRARY A) P s.
Axiom thm_ARBITRARY_UNION_OF_COMPLEMENT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (@UNION_OF A (@ARBITRARY A) P s) = (@INTERSECTION_OF A (@ARBITRARY A) (fun s' : A -> Prop => P (@setD A (@setT A) s')) (@setD A (@setT A) s)).
Axiom thm_ARBITRARY_INTERSECTION_OF_COMPLEMENT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (@INTERSECTION_OF A (@ARBITRARY A) P s) = (@UNION_OF A (@ARBITRARY A) (fun s' : A -> Prop => P (@setD A (@setT A) s')) (@setD A (@setT A) s)).
Axiom thm_ARBITRARY_UNION_OF_IDEMPOT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (@UNION_OF A (@ARBITRARY A) (@UNION_OF A (@ARBITRARY A) P)) = (@UNION_OF A (@ARBITRARY A) P).
Axiom thm_ARBITRARY_INTERSECTION_OF_IDEMPOT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (@INTERSECTION_OF A (@ARBITRARY A) (@INTERSECTION_OF A (@ARBITRARY A) P)) = (@INTERSECTION_OF A (@ARBITRARY A) P).
Axiom thm_ARBITRARY_UNION_OF_UNIONS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall u : (A -> Prop) -> Prop, (forall s : A -> Prop, (@IN (A -> Prop) s u) -> @UNION_OF A (@ARBITRARY A) P s) -> @UNION_OF A (@ARBITRARY A) P (@UNIONS A u).
Axiom thm_ARBITRARY_UNION_OF_UNION : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@ARBITRARY A) P s) /\ (@UNION_OF A (@ARBITRARY A) P t)) -> @UNION_OF A (@ARBITRARY A) P (@setU A s t).
Axiom thm_ARBITRARY_INTERSECTION_OF_INTERS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall u : (A -> Prop) -> Prop, (forall s : A -> Prop, (@IN (A -> Prop) s u) -> @INTERSECTION_OF A (@ARBITRARY A) P s) -> @INTERSECTION_OF A (@ARBITRARY A) P (@INTERS A u).
Axiom thm_ARBITRARY_INTERSECTION_OF_INTER : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@ARBITRARY A) P s) /\ (@INTERSECTION_OF A (@ARBITRARY A) P t)) -> @INTERSECTION_OF A (@ARBITRARY A) P (@setI A s t).
Axiom thm_ARBITRARY_UNION_OF_INTER_EQ : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@ARBITRARY A) P s) /\ (@UNION_OF A (@ARBITRARY A) P t)) -> @UNION_OF A (@ARBITRARY A) P (@setI A s t)) = (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> @UNION_OF A (@ARBITRARY A) P (@setI A s t)).
Axiom thm_ARBITRARY_UNION_OF_INTER : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> P (@setI A s t)) -> forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@ARBITRARY A) P s) /\ (@UNION_OF A (@ARBITRARY A) P t)) -> @UNION_OF A (@ARBITRARY A) P (@setI A s t).
Axiom thm_ARBITRARY_INTERSECTION_OF_UNION_EQ : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@ARBITRARY A) P s) /\ (@INTERSECTION_OF A (@ARBITRARY A) P t)) -> @INTERSECTION_OF A (@ARBITRARY A) P (@setU A s t)) = (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> @INTERSECTION_OF A (@ARBITRARY A) P (@setU A s t)).
Axiom thm_ARBITRARY_INTERSECTION_OF_UNION : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> P (@setU A s t)) -> forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@ARBITRARY A) P s) /\ (@INTERSECTION_OF A (@ARBITRARY A) P t)) -> @INTERSECTION_OF A (@ARBITRARY A) P (@setU A s t).
Axiom thm_FINITE_UNION_OF_EMPTY : forall {A : Type'}, forall P : (A -> Prop) -> Prop, @UNION_OF A (@finite_set (A -> Prop)) P (@set0 A).
Axiom thm_FINITE_INTERSECTION_OF_EMPTY : forall {A : Type'}, forall P : (A -> Prop) -> Prop, @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@setT A).
Axiom thm_FINITE_UNION_OF_INC : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (P s) -> @UNION_OF A (@finite_set (A -> Prop)) P s.
Axiom thm_FINITE_INTERSECTION_OF_INC : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (P s) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P s.
Axiom thm_FINITE_UNION_OF_COMPLEMENT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (@UNION_OF A (@finite_set (A -> Prop)) P s) = (@INTERSECTION_OF A (@finite_set (A -> Prop)) (fun s' : A -> Prop => P (@setD A (@setT A) s')) (@setD A (@setT A) s)).
Axiom thm_FINITE_INTERSECTION_OF_COMPLEMENT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, (@INTERSECTION_OF A (@finite_set (A -> Prop)) P s) = (@UNION_OF A (@finite_set (A -> Prop)) (fun s' : A -> Prop => P (@setD A (@setT A) s')) (@setD A (@setT A) s)).
Axiom thm_FINITE_UNION_OF_IDEMPOT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (@UNION_OF A (@finite_set (A -> Prop)) (@UNION_OF A (@finite_set (A -> Prop)) P)) = (@UNION_OF A (@finite_set (A -> Prop)) P).
Axiom thm_FINITE_INTERSECTION_OF_IDEMPOT : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (@INTERSECTION_OF A (@finite_set (A -> Prop)) (@INTERSECTION_OF A (@finite_set (A -> Prop)) P)) = (@INTERSECTION_OF A (@finite_set (A -> Prop)) P).
Axiom thm_FINITE_UNION_OF_UNIONS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall u : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) u) /\ (forall s : A -> Prop, (@IN (A -> Prop) s u) -> @UNION_OF A (@finite_set (A -> Prop)) P s)) -> @UNION_OF A (@finite_set (A -> Prop)) P (@UNIONS A u).
Axiom thm_FINITE_UNION_OF_UNION : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@finite_set (A -> Prop)) P s) /\ (@UNION_OF A (@finite_set (A -> Prop)) P t)) -> @UNION_OF A (@finite_set (A -> Prop)) P (@setU A s t).
Axiom thm_FINITE_INTERSECTION_OF_INTERS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall u : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) u) /\ (forall s : A -> Prop, (@IN (A -> Prop) s u) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P s)) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@INTERS A u).
Axiom thm_FINITE_INTERSECTION_OF_INTER : forall {A : Type'}, forall P : (A -> Prop) -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@finite_set (A -> Prop)) P s) /\ (@INTERSECTION_OF A (@finite_set (A -> Prop)) P t)) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@setI A s t).
Axiom thm_FINITE_UNION_OF_INTER_EQ : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@finite_set (A -> Prop)) P s) /\ (@UNION_OF A (@finite_set (A -> Prop)) P t)) -> @UNION_OF A (@finite_set (A -> Prop)) P (@setI A s t)) = (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> @UNION_OF A (@finite_set (A -> Prop)) P (@setI A s t)).
Axiom thm_FINITE_UNION_OF_INTER : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> P (@setI A s t)) -> forall s : A -> Prop, forall t : A -> Prop, ((@UNION_OF A (@finite_set (A -> Prop)) P s) /\ (@UNION_OF A (@finite_set (A -> Prop)) P t)) -> @UNION_OF A (@finite_set (A -> Prop)) P (@setI A s t).
Axiom thm_FINITE_INTERSECTION_OF_UNION_EQ : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@finite_set (A -> Prop)) P s) /\ (@INTERSECTION_OF A (@finite_set (A -> Prop)) P t)) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@setU A s t)) = (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@setU A s t)).
Axiom thm_FINITE_INTERSECTION_OF_UNION : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((P s) /\ (P t)) -> P (@setU A s t)) -> forall s : A -> Prop, forall t : A -> Prop, ((@INTERSECTION_OF A (@finite_set (A -> Prop)) P s) /\ (@INTERSECTION_OF A (@finite_set (A -> Prop)) P t)) -> @INTERSECTION_OF A (@finite_set (A -> Prop)) P (@setU A s t).
Axiom thm_CARD_SET_OF_LIST_LE : forall {A : Type'}, forall l : seq A, leqn (@CARD A (@set_of_list A l)) (@size A l).
Axiom thm_HAS_SIZE_SET_OF_LIST : forall {A : Type'}, forall l : seq A, (@HAS_SIZE A (@set_of_list A l) (@size A l)) = (@PAIRWISE A (fun x : A => fun y : A => ~ (x = y)) l).
Axiom thm_SURJECTIVE_IFF_INJECTIVE_GEN : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> B, ((@finite_set A s) /\ ((@finite_set B t) /\ (((@CARD A s) = (@CARD B t)) /\ (@subset B (@IMAGE A B f s) t)))) -> (forall y : B, (@IN B y t) -> exists x : A, (@IN A x s) /\ ((f x) = y)) = (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y).
Axiom thm_SURJECTIVE_IFF_INJECTIVE : forall {A : Type'}, forall s : A -> Prop, forall f : A -> A, ((@finite_set A s) /\ (@subset A (@IMAGE A A f s) s)) -> (forall y : A, (@IN A y s) -> exists x : A, (@IN A x s) /\ ((f x) = y)) = (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y).
Axiom thm_IMAGE_IMP_INJECTIVE_GEN : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> B, ((@finite_set A s) /\ (((@CARD A s) = (@CARD B t)) /\ ((@IMAGE A B f s) = t))) -> forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y.
Axiom thm_IMAGE_IMP_INJECTIVE : forall {A : Type'}, forall s : A -> Prop, forall f : A -> A, ((@finite_set A s) /\ ((@IMAGE A A f s) = s)) -> forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y.
Axiom thm_HAS_SIZE_IMAGE_INJ_RESTRICT : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall t : B -> Prop, forall P : B -> Prop, forall n : nat, ((@finite_set A s) /\ ((@finite_set B t) /\ (((@CARD A s) = (@CARD B t)) /\ ((@subset B (@IMAGE A B f s) t) /\ ((forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) /\ (@HAS_SIZE A (@GSPEC A (fun GEN_PVAR_219 : A => exists x : A, @SETSPEC A GEN_PVAR_219 ((@IN A x s) /\ (P (f x))) x)) n)))))) -> @HAS_SIZE B (@GSPEC B (fun GEN_PVAR_220 : B => exists x : B, @SETSPEC B GEN_PVAR_220 ((@IN B x t) /\ (P x)) x)) n.
Axiom thm_CARD_LE_INJ : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ ((@finite_set B t) /\ (leqn (@CARD A s) (@CARD B t)))) -> exists f : A -> B, (@subset B (@IMAGE A B f s) t) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y).
Axiom thm_FORALL_IN_CLAUSES : forall {A : Type'}, (forall P : A -> Prop, (forall x : A, (@IN A x (@set0 A)) -> P x) = True) /\ (forall P : A -> Prop, forall a : A, forall s : A -> Prop, (forall x : A, (@IN A x (@INSERT A a s)) -> P x) = ((P a) /\ (forall x : A, (@IN A x s) -> P x))).
Axiom thm_EXISTS_IN_CLAUSES : forall {A : Type'}, (forall P : A -> Prop, (exists x : A, (@IN A x (@set0 A)) /\ (P x)) = False) /\ (forall P : A -> Prop, forall a : A, forall s : A -> Prop, (exists x : A, (@IN A x (@INSERT A a s)) /\ (P x)) = ((P a) \/ (exists x : A, (@IN A x s) /\ (P x)))).
Axiom thm_INJECTIVE_ON_IMAGE : forall {A B : Type'}, forall f : A -> B, forall u : A -> Prop, (forall s : A -> Prop, forall t : A -> Prop, ((@subset A s u) /\ ((@subset A t u) /\ ((@IMAGE A B f s) = (@IMAGE A B f t)))) -> s = t) = (forall x : A, forall y : A, ((@IN A x u) /\ ((@IN A y u) /\ ((f x) = (f y)))) -> x = y).
Axiom thm_INJECTIVE_IMAGE : forall {A B : Type'}, forall f : A -> B, (forall s : A -> Prop, forall t : A -> Prop, ((@IMAGE A B f s) = (@IMAGE A B f t)) -> s = t) = (forall x : A, forall y : A, ((f x) = (f y)) -> x = y).
Axiom thm_SURJECTIVE_ON_IMAGE : forall {A B : Type'}, forall f : A -> B, forall u : A -> Prop, forall v : B -> Prop, (forall t : B -> Prop, (@subset B t v) -> exists s : A -> Prop, (@subset A s u) /\ ((@IMAGE A B f s) = t)) = (forall y : B, (@IN B y v) -> exists x : A, (@IN A x u) /\ ((f x) = y)).
Axiom thm_SURJECTIVE_IMAGE : forall {A B : Type'}, forall f : A -> B, (forall t : B -> Prop, exists s : A -> Prop, (@IMAGE A B f s) = t) = (forall y : B, exists x : A, (f x) = y).
Axiom thm_INJECTIVE_ON_PREIMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall u : B -> Prop, (forall t : B -> Prop, forall t' : B -> Prop, ((@subset B t u) /\ ((@subset B t' u) /\ ((@GSPEC A (fun GEN_PVAR_222 : A => exists x : A, @SETSPEC A GEN_PVAR_222 ((@IN A x s) /\ (@IN B (f x) t)) x)) = (@GSPEC A (fun GEN_PVAR_223 : A => exists x : A, @SETSPEC A GEN_PVAR_223 ((@IN A x s) /\ (@IN B (f x) t')) x))))) -> t = t') = (@subset B u (@IMAGE A B f s)).
Axiom thm_SURJECTIVE_ON_PREIMAGE : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall u : B -> Prop, (forall k : A -> Prop, (@subset A k s) -> exists t : B -> Prop, (@subset B t u) /\ ((@GSPEC A (fun GEN_PVAR_224 : A => exists x : A, @SETSPEC A GEN_PVAR_224 ((@IN A x s) /\ (@IN B (f x) t)) x)) = k)) = ((@subset B (@IMAGE A B f s) u) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y)).
Axiom thm_INJECTIVE_PREIMAGE : forall {A B : Type'}, forall f : A -> B, (forall t : B -> Prop, forall t' : B -> Prop, ((@GSPEC A (fun GEN_PVAR_225 : A => exists x : A, @SETSPEC A GEN_PVAR_225 (@IN B (f x) t) x)) = (@GSPEC A (fun GEN_PVAR_226 : A => exists x : A, @SETSPEC A GEN_PVAR_226 (@IN B (f x) t') x))) -> t = t') = ((@IMAGE A B f (@setT A)) = (@setT B)).
Axiom thm_SURJECTIVE_PREIMAGE : forall {A B : Type'}, forall f : A -> B, (forall k : A -> Prop, exists t : B -> Prop, (@GSPEC A (fun GEN_PVAR_227 : A => exists x : A, @SETSPEC A GEN_PVAR_227 (@IN B (f x) t) x)) = k) = (forall x : A, forall y : A, ((f x) = (f y)) -> x = y).
Axiom thm_CARD_EQ_BIJECTION : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ ((@finite_set B t) /\ ((@CARD A s) = (@CARD B t)))) -> exists f : A -> B, (forall x : A, (@IN A x s) -> @IN B (f x) t) /\ ((forall y : B, (@IN B y t) -> exists x : A, (@IN A x s) /\ ((f x) = y)) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y)).
Axiom thm_CARD_EQ_BIJECTIONS : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ ((@finite_set B t) /\ ((@CARD A s) = (@CARD B t)))) -> exists f : A -> B, exists g : B -> A, (forall x : A, (@IN A x s) -> (@IN B (f x) t) /\ ((g (f x)) = x)) /\ (forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y)).
Axiom thm_CARD_EQ_BIJECTIONS_SPECIAL : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall a : A, forall b : B, ((@finite_set A s) /\ ((@finite_set B t) /\ (((@CARD A s) = (@CARD B t)) /\ ((@IN A a s) /\ (@IN B b t))))) -> exists f : A -> B, exists g : B -> A, ((f a) = b) /\ (((g b) = a) /\ ((forall x : A, (@IN A x s) -> (@IN B (f x) t) /\ ((g (f x)) = x)) /\ (forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y)))).
Axiom thm_BIJECTIONS_HAS_SIZE : forall {A B : Type'} (n : nat), forall s : A -> Prop, forall t : B -> Prop, forall f : A -> B, forall g : B -> A, ((forall x : A, (@IN A x s) -> (@IN B (f x) t) /\ ((g (f x)) = x)) /\ ((forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y)) /\ (@HAS_SIZE A s n))) -> @HAS_SIZE B t n.
Axiom thm_BIJECTIONS_HAS_SIZE_EQ : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> B, forall g : B -> A, ((forall x : A, (@IN A x s) -> (@IN B (f x) t) /\ ((g (f x)) = x)) /\ (forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y))) -> forall n : nat, (@HAS_SIZE A s n) = (@HAS_SIZE B t n).
Axiom thm_BIJECTIONS_CARD_EQ : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> B, forall g : B -> A, (((@finite_set A s) \/ (@finite_set B t)) /\ ((forall x : A, (@IN A x s) -> (@IN B (f x) t) /\ ((g (f x)) = x)) /\ (forall y : B, (@IN B y t) -> (@IN A (g y) s) /\ ((f (g y)) = y)))) -> (@CARD A s) = (@CARD B t).
Axiom thm_WF_FINITE : forall {A : Type'}, forall lt2' : A -> A -> Prop, ((forall x : A, ~ (lt2' x x)) /\ ((forall x : A, forall y : A, forall z : A, ((lt2' x y) /\ (lt2' y z)) -> lt2' x z) /\ (forall x : A, @finite_set A (@GSPEC A (fun GEN_PVAR_229 : A => exists y : A, @SETSPEC A GEN_PVAR_229 (lt2' y x) y))))) -> @well_founded A lt2'.
Axiom thm_WF_PSUBSET : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> @well_founded (A -> Prop) (fun t1 : A -> Prop => fun t2 : A -> Prop => (@proper A t1 t2) /\ (@subset A t2 s)).
Axiom thm_le_c : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, (@le_c A B s t) = (exists f : A -> B, (forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y)).
Axiom thm_lt_c : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, (@lt_c A B s t) = ((@le_c A B s t) /\ (~ (@le_c B A t s))).
Axiom thm_eq_c : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, (@eq_c A B s t) = (exists f : A -> B, (forall x : A, (@IN A x s) -> @IN B (f x) t) /\ (forall y : B, (@IN B y t) -> @ex1 A (fun x : A => (@IN A x s) /\ ((f x) = y)))).
Axiom thm_ge_c : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, (@ge_c A B s t) = (@le_c B A t s).
Axiom thm_gt_c : forall {A B : Type'}, forall t : B -> Prop, forall s : A -> Prop, (@gt_c A B s t) = (@lt_c B A t s).
Axiom thm_LE_C : forall {A B : Type'}, forall s : B -> Prop, forall t : A -> Prop, (@le_c B A s t) = (exists g : A -> B, forall x : B, (@IN B x s) -> exists y : A, (@IN A y t) /\ ((g y) = x)).
Axiom thm_GE_C : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, (@ge_c A B s t) = (exists f : A -> B, forall y : B, (@IN B y t) -> exists x : A, (@IN A x s) /\ (y = (f x))).
Axiom thm_COUNTABLE : forall {A : Type'}, forall t : A -> Prop, (@COUNTABLE A t) = (@ge_c nat A (@setT nat) t).
Axiom thm_SUP_EQ : forall s : R -> Prop, forall t : R -> Prop, (forall b : R, (forall x : R, (@IN R x s) -> ler x b) = (forall x : R, (@IN R x t) -> ler x b)) -> (sup s) = (sup t).
Axiom thm_SUP : forall s : R -> Prop, ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler x b)) -> (forall x : R, (@IN R x s) -> ler x (sup s)) /\ (forall b : R, (forall x : R, (@IN R x s) -> ler x b) -> ler (sup s) b).
Axiom thm_SUP_FINITE_LEMMA : forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> exists b : R, (@IN R b s) /\ (forall x : R, (@IN R x s) -> ler x b).
Axiom thm_SUP_FINITE : forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (@IN R (sup s) s) /\ (forall x : R, (@IN R x s) -> ler x (sup s)).
Axiom thm_REAL_LE_SUP_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ler a (sup s)) = (exists x : R, (@IN R x s) /\ (ler a x)).
Axiom thm_REAL_SUP_LE_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ler (sup s) a) = (forall x : R, (@IN R x s) -> ler x a).
Axiom thm_REAL_LT_SUP_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ltr a (sup s)) = (exists x : R, (@IN R x s) /\ (ltr a x)).
Axiom thm_REAL_SUP_LT_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ltr (sup s) a) = (forall x : R, (@IN R x s) -> ltr x a).
Axiom thm_REAL_SUP_UNIQUE : forall s : R -> Prop, forall b : R, ((forall x : R, (@IN R x s) -> ler x b) /\ (forall b' : R, (ltr b' b) -> exists x : R, (@IN R x s) /\ (ltr b' x))) -> (sup s) = b.
Axiom thm_REAL_SUP_LE_SUBSET : forall s : R -> Prop, forall t : R -> Prop, ((~ (s = (@set0 R))) /\ ((@subset R s t) /\ (exists b : R, forall x : R, (@IN R x t) -> ler x b))) -> ler (sup s) (sup t).
Axiom thm_REAL_SUP_BOUNDS : forall s : R -> Prop, forall a : R, forall b : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> (ler a x) /\ (ler x b))) -> (ler a (sup s)) /\ (ler (sup s) b).
Axiom thm_REAL_ABS_SUP_LE : forall s : R -> Prop, forall a : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> ler (normr x) a)) -> ler (normr (sup s)) a.
Axiom thm_REAL_SUP_ASCLOSE : forall s : R -> Prop, forall l : R, forall e : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> ler (normr (subr x l)) e)) -> ler (normr (subr (sup s) l)) e.
Axiom thm_SUP_UNIQUE_FINITE : forall (a : R), forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> ((sup s) = a) = ((@IN R a s) /\ (forall y : R, (@IN R y s) -> ler y a)).
Axiom thm_SUP_INSERT_FINITE : forall x : R, forall s : R -> Prop, (@finite_set R s) -> (sup (@INSERT R x s)) = (@COND R (s = (@set0 R)) x (maxr x (sup s))).
Axiom thm_SUP_SING : forall a : R, (sup (@INSERT R a (@set0 R))) = a.
Axiom thm_SUP_INSERT_INSERT : forall a : R, forall b : R, forall s : R -> Prop, (sup (@INSERT R b (@INSERT R a s))) = (sup (@INSERT R (maxr a b) s)).
Axiom thm_REAL_LE_SUP : forall s : R -> Prop, forall a : R, forall b : R, forall y : R, ((@IN R y s) /\ ((ler a y) /\ (forall x : R, (@IN R x s) -> ler x b))) -> ler a (sup s).
Axiom thm_REAL_SUP_LE_EQ : forall s : R -> Prop, forall y : R, ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler x b)) -> (ler (sup s) y) = (forall x : R, (@IN R x s) -> ler x y).
Axiom thm_SUP_UNIQUE : forall s : R -> Prop, forall b : R, (forall c : R, (forall x : R, (@IN R x s) -> ler x c) = (ler b c)) -> (sup s) = b.
Axiom thm_SUP_UNION : forall s : R -> Prop, forall t : R -> Prop, ((~ (s = (@set0 R))) /\ ((~ (t = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler x b) /\ (exists c : R, forall x : R, (@IN R x t) -> ler x c)))) -> (sup (@setU R s t)) = (maxr (sup s) (sup t)).
Axiom thm_ELEMENT_LE_SUP : forall s : R -> Prop, forall a : R, ((exists b : R, forall x : R, (@IN R x s) -> ler x b) /\ (@IN R a s)) -> ler a (sup s).
Axiom thm_SUP_APPROACH : forall s : R -> Prop, forall c : R, ((~ (s = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler x b) /\ (ltr c (sup s)))) -> exists x : R, (@IN R x s) /\ (ltr c x).
Axiom thm_REAL_MAX_SUP : forall x : R, forall y : R, (maxr x y) = (sup (@INSERT R x (@INSERT R y (@set0 R)))).
Axiom thm_inf : forall s : R -> Prop, (inf s) = (@ε R (fun a : R => (forall x : R, (@IN R x s) -> ler a x) /\ (forall b : R, (forall x : R, (@IN R x s) -> ler b x) -> ler b a))).
Axiom thm_INF_EQ : forall s : R -> Prop, forall t : R -> Prop, (forall a : R, (forall x : R, (@IN R x s) -> ler a x) = (forall x : R, (@IN R x t) -> ler a x)) -> (inf s) = (inf t).
Axiom thm_INF : forall s : R -> Prop, ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler b x)) -> (forall x : R, (@IN R x s) -> ler (inf s) x) /\ (forall b : R, (forall x : R, (@IN R x s) -> ler b x) -> ler b (inf s)).
Axiom thm_INF_FINITE_LEMMA : forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> exists b : R, (@IN R b s) /\ (forall x : R, (@IN R x s) -> ler b x).
Axiom thm_INF_FINITE : forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (@IN R (inf s) s) /\ (forall x : R, (@IN R x s) -> ler (inf s) x).
Axiom thm_REAL_LE_INF_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ler a (inf s)) = (forall x : R, (@IN R x s) -> ler a x).
Axiom thm_REAL_INF_LE_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ler (inf s) a) = (exists x : R, (@IN R x s) /\ (ler x a)).
Axiom thm_REAL_LT_INF_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ltr a (inf s)) = (forall x : R, (@IN R x s) -> ltr a x).
Axiom thm_REAL_INF_LT_FINITE : forall s : R -> Prop, forall a : R, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> (ltr (inf s) a) = (exists x : R, (@IN R x s) /\ (ltr x a)).
Axiom thm_REAL_INF_UNIQUE : forall s : R -> Prop, forall b : R, ((forall x : R, (@IN R x s) -> ler b x) /\ (forall b' : R, (ltr b b') -> exists x : R, (@IN R x s) /\ (ltr x b'))) -> (inf s) = b.
Axiom thm_REAL_LE_INF : forall (s : R -> Prop), forall b : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> ler b x)) -> ler b (inf s).
Axiom thm_REAL_LE_INF_SUBSET : forall s : R -> Prop, forall t : R -> Prop, ((~ (t = (@set0 R))) /\ ((@subset R t s) /\ (exists b : R, forall x : R, (@IN R x s) -> ler b x))) -> ler (inf s) (inf t).
Axiom thm_REAL_INF_BOUNDS : forall s : R -> Prop, forall a : R, forall b : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> (ler a x) /\ (ler x b))) -> (ler a (inf s)) /\ (ler (inf s) b).
Axiom thm_REAL_ABS_INF_LE : forall s : R -> Prop, forall a : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> ler (normr x) a)) -> ler (normr (inf s)) a.
Axiom thm_REAL_INF_ASCLOSE : forall s : R -> Prop, forall l : R, forall e : R, ((~ (s = (@set0 R))) /\ (forall x : R, (@IN R x s) -> ler (normr (subr x l)) e)) -> ler (normr (subr (inf s) l)) e.
Axiom thm_INF_UNIQUE_FINITE : forall (a : R), forall s : R -> Prop, ((@finite_set R s) /\ (~ (s = (@set0 R)))) -> ((inf s) = a) = ((@IN R a s) /\ (forall y : R, (@IN R y s) -> ler a y)).
Axiom thm_INF_INSERT_FINITE : forall x : R, forall s : R -> Prop, (@finite_set R s) -> (inf (@INSERT R x s)) = (@COND R (s = (@set0 R)) x (minr x (inf s))).
Axiom thm_INF_SING : forall a : R, (inf (@INSERT R a (@set0 R))) = a.
Axiom thm_INF_INSERT_INSERT : forall a : R, forall b : R, forall s : R -> Prop, (inf (@INSERT R b (@INSERT R a s))) = (inf (@INSERT R (minr a b) s)).
Axiom thm_REAL_SUP_EQ_INF : forall s : R -> Prop, ((~ (s = (@set0 R))) /\ (exists B : R, forall x : R, (@IN R x s) -> ler (normr x) B)) -> ((sup s) = (inf s)) = (exists a : R, s = (@INSERT R a (@set0 R))).
Axiom thm_REAL_INF_LE : forall s : R -> Prop, forall a : R, forall b : R, forall y : R, ((@IN R y s) /\ ((ler y b) /\ (forall x : R, (@IN R x s) -> ler a x))) -> ler (inf s) b.
Axiom thm_REAL_LE_INF_EQ : forall s : R -> Prop, forall y : R, ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler b x)) -> (ler y (inf s)) = (forall x : R, (@IN R x s) -> ler y x).
Axiom thm_INF_UNIQUE : forall s : R -> Prop, forall b : R, (forall c : R, (forall x : R, (@IN R x s) -> ler c x) = (ler c b)) -> (inf s) = b.
Axiom thm_INF_UNION : forall s : R -> Prop, forall t : R -> Prop, ((~ (s = (@set0 R))) /\ ((~ (t = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler b x) /\ (exists c : R, forall x : R, (@IN R x t) -> ler c x)))) -> (inf (@setU R s t)) = (minr (inf s) (inf t)).
Axiom thm_INF_LE_ELEMENT : forall s : R -> Prop, forall a : R, ((exists b : R, forall x : R, (@IN R x s) -> ler b x) /\ (@IN R a s)) -> ler (inf s) a.
Axiom thm_INF_APPROACH : forall s : R -> Prop, forall c : R, ((~ (s = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler b x) /\ (ltr (inf s) c))) -> exists x : R, (@IN R x s) /\ (ltr x c).
Axiom thm_REAL_MIN_INF : forall x : R, forall y : R, (minr x y) = (inf (@INSERT R x (@INSERT R y (@set0 R)))).
Axiom thm_has_inf : forall s : R -> Prop, forall b : R, (has_inf s b) = (forall c : R, (forall x : R, (@IN R x s) -> ler c x) = (ler c b)).
Axiom thm_has_sup : forall s : R -> Prop, forall b : R, (has_sup s b) = (forall c : R, (forall x : R, (@IN R x s) -> ler x c) = (ler b c)).
Axiom thm_HAS_INF_LBOUND : forall s : R -> Prop, forall b : R, forall x : R, ((has_inf s b) /\ (@IN R x s)) -> ler b x.
Axiom thm_HAS_SUP_UBOUND : forall s : R -> Prop, forall b : R, forall x : R, ((has_sup s b) /\ (@IN R x s)) -> ler x b.
Axiom thm_HAS_INF_INF : forall s : R -> Prop, forall l : R, (has_inf s l) = ((~ (s = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler b x) /\ ((inf s) = l))).
Axiom thm_HAS_SUP_SUP : forall s : R -> Prop, forall l : R, (has_sup s l) = ((~ (s = (@set0 R))) /\ ((exists b : R, forall x : R, (@IN R x s) -> ler x b) /\ ((sup s) = l))).
Axiom thm_INF_EXISTS : forall s : R -> Prop, (exists l : R, has_inf s l) = ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler b x)).
Axiom thm_SUP_EXISTS : forall s : R -> Prop, (exists l : R, has_sup s l) = ((~ (s = (@set0 R))) /\ (exists b : R, forall x : R, (@IN R x s) -> ler x b)).
Axiom thm_HAS_INF_APPROACH : forall s : R -> Prop, forall l : R, forall c : R, ((has_inf s l) /\ (ltr l c)) -> exists x : R, (@IN R x s) /\ (ltr x c).
Axiom thm_HAS_SUP_APPROACH : forall s : R -> Prop, forall l : R, forall c : R, ((has_sup s l) /\ (ltr c l)) -> exists x : R, (@IN R x s) /\ (ltr c x).
Axiom thm_HAS_INF : forall s : R -> Prop, forall l : R, (has_inf s l) = ((~ (s = (@set0 R))) /\ ((forall x : R, (@IN R x s) -> ler l x) /\ (forall c : R, (ltr l c) -> exists x : R, (@IN R x s) /\ (ltr x c)))).
Axiom thm_HAS_SUP : forall s : R -> Prop, forall l : R, (has_sup s l) = ((~ (s = (@set0 R))) /\ ((forall x : R, (@IN R x s) -> ler x l) /\ (forall c : R, (ltr c l) -> exists x : R, (@IN R x s) /\ (ltr c x)))).
Axiom thm_HAS_INF_LE : forall s : R -> Prop, forall t : R -> Prop, forall l : R, forall m : R, ((has_inf s l) /\ ((has_inf t m) /\ (forall y : R, (@IN R y t) -> exists x : R, (@IN R x s) /\ (ler x y)))) -> ler l m.
Axiom thm_HAS_SUP_LE : forall s : R -> Prop, forall t : R -> Prop, forall l : R, forall m : R, ((has_sup s l) /\ ((has_sup t m) /\ (forall y : R, (@IN R y t) -> exists x : R, (@IN R x s) /\ (ler y x)))) -> ler m l.
Axiom thm_numseg : forall m : nat, forall n : nat, (dotdot m n) = (@GSPEC nat (fun GEN_PVAR_231 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_231 ((leqn m x) /\ (leqn x n)) x)).
Axiom thm_FINITE_NUMSEG : forall m : nat, forall n : nat, @finite_set nat (dotdot m n).
Axiom thm_NUMSEG_COMBINE_R : forall m : nat, forall p : nat, forall n : nat, ((leqn m (addn p (NUMERAL (BIT1 O)))) /\ (leqn p n)) -> (@setU nat (dotdot m p) (dotdot (addn p (NUMERAL (BIT1 O))) n)) = (dotdot m n).
Axiom thm_NUMSEG_COMBINE_L : forall m : nat, forall p : nat, forall n : nat, ((leqn m p) /\ (leqn p (addn n (NUMERAL (BIT1 O))))) -> (@setU nat (dotdot m (subn p (NUMERAL (BIT1 O)))) (dotdot p n)) = (dotdot m n).
Axiom thm_NUMSEG_LREC : forall m : nat, forall n : nat, (leqn m n) -> (@INSERT nat m (dotdot (addn m (NUMERAL (BIT1 O))) n)) = (dotdot m n).
Axiom thm_NUMSEG_RREC : forall m : nat, forall n : nat, (leqn m n) -> (@INSERT nat n (dotdot m (subn n (NUMERAL (BIT1 O))))) = (dotdot m n).
Axiom thm_NUMSEG_REC : forall m : nat, forall n : nat, (leqn m (S n)) -> (dotdot m (S n)) = (@INSERT nat (S n) (dotdot m n)).
Axiom thm_IN_NUMSEG : forall m : nat, forall n : nat, forall p : nat, (@IN nat p (dotdot m n)) = ((leqn m p) /\ (leqn p n)).
Axiom thm_IN_NUMSEG_0 : forall m : nat, forall n : nat, (@IN nat m (dotdot (NUMERAL O) n)) = (leqn m n).
Axiom thm_NUMSEG_SING : forall n : nat, (dotdot n n) = (@INSERT nat n (@set0 nat)).
Axiom thm_NUMSEG_EMPTY : forall m : nat, forall n : nat, ((dotdot m n) = (@set0 nat)) = (ltn n m).
Axiom thm_EMPTY_NUMSEG : forall m : nat, forall n : nat, (ltn n m) -> (dotdot m n) = (@set0 nat).
Axiom thm_FINITE_SUBSET_NUMSEG : forall s : nat -> Prop, (@finite_set nat s) = (exists n : nat, @subset nat s (dotdot (NUMERAL O) n)).
Axiom thm_CARD_NUMSEG_LEMMA : forall m : nat, forall d : nat, (@CARD nat (dotdot m (addn m d))) = (addn d (NUMERAL (BIT1 O))).
Axiom thm_CARD_NUMSEG : forall m : nat, forall n : nat, (@CARD nat (dotdot m n)) = (subn (addn n (NUMERAL (BIT1 O))) m).
Axiom thm_HAS_SIZE_NUMSEG : forall m : nat, forall n : nat, @HAS_SIZE nat (dotdot m n) (subn (addn n (NUMERAL (BIT1 O))) m).
Axiom thm_CARD_NUMSEG_1 : forall n : nat, (@CARD nat (dotdot (NUMERAL (BIT1 O)) n)) = n.
Axiom thm_HAS_SIZE_NUMSEG_1 : forall n : nat, @HAS_SIZE nat (dotdot (NUMERAL (BIT1 O)) n) n.
Axiom thm_NUMSEG_CLAUSES : (forall m : nat, (dotdot m (NUMERAL O)) = (@COND (nat -> Prop) (m = (NUMERAL O)) (@INSERT nat (NUMERAL O) (@set0 nat)) (@set0 nat))) /\ (forall m : nat, forall n : nat, (dotdot m (S n)) = (@COND (nat -> Prop) (leqn m (S n)) (@INSERT nat (S n) (dotdot m n)) (dotdot m n))).
Axiom thm_FINITE_INDEX_NUMSEG : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) = (exists f : nat -> A, (forall i : nat, forall j : nat, ((@IN nat i (dotdot (NUMERAL (BIT1 O)) (@CARD A s))) /\ ((@IN nat j (dotdot (NUMERAL (BIT1 O)) (@CARD A s))) /\ ((f i) = (f j)))) -> i = j) /\ (s = (@IMAGE nat A f (dotdot (NUMERAL (BIT1 O)) (@CARD A s))))).
Axiom thm_FINITE_INDEX_NUMBERS : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) = (exists k : nat -> Prop, exists f : nat -> A, (forall i : nat, forall j : nat, ((@IN nat i k) /\ ((@IN nat j k) /\ ((f i) = (f j)))) -> i = j) /\ ((@finite_set nat k) /\ (s = (@IMAGE nat A f k)))).
Axiom thm_INTER_NUMSEG : forall m : nat, forall n : nat, forall p : nat, forall q : nat, (@setI nat (dotdot m n) (dotdot p q)) = (dotdot (maxn m p) (minn n q)).
Axiom thm_DISJOINT_NUMSEG : forall m : nat, forall n : nat, forall p : nat, forall q : nat, (@DISJOINT nat (dotdot m n) (dotdot p q)) = ((ltn n p) \/ ((ltn q m) \/ ((ltn n m) \/ (ltn q p)))).
Axiom thm_NUMSEG_ADD_SPLIT : forall m : nat, forall n : nat, forall p : nat, (leqn m (addn n (NUMERAL (BIT1 O)))) -> (dotdot m (addn n p)) = (@setU nat (dotdot m n) (dotdot (addn n (NUMERAL (BIT1 O))) (addn n p))).
Axiom thm_NUMSEG_OFFSET_IMAGE : forall m : nat, forall n : nat, forall p : nat, (dotdot (addn m p) (addn n p)) = (@IMAGE nat nat (fun i : nat => addn i p) (dotdot m n)).
Axiom thm_SUBSET_NUMSEG : forall m : nat, forall n : nat, forall p : nat, forall q : nat, (@subset nat (dotdot m n) (dotdot p q)) = ((ltn n m) \/ ((leqn p m) /\ (leqn n q))).
Axiom thm_NUMSEG_LE : forall n : nat, (@GSPEC nat (fun GEN_PVAR_233 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_233 (leqn x n) x)) = (dotdot (NUMERAL O) n).
Axiom thm_NUMSEG_LT : forall n : nat, (@GSPEC nat (fun GEN_PVAR_234 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_234 (ltn x n) x)) = (@COND (nat -> Prop) (n = (NUMERAL O)) (@set0 nat) (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O))))).
Axiom thm_TOPOLOGICAL_SORT : forall {A : Type'}, forall lt2' : A -> A -> Prop, ((forall x : A, forall y : A, ((lt2' x y) /\ (lt2' y x)) -> x = y) /\ (forall x : A, forall y : A, forall z : A, ((lt2' x y) /\ (lt2' y z)) -> lt2' x z)) -> forall n : nat, forall s : A -> Prop, (@HAS_SIZE A s n) -> exists f : nat -> A, (s = (@IMAGE nat A f (dotdot (NUMERAL (BIT1 O)) n))) /\ (forall j : nat, forall k : nat, ((@IN nat j (dotdot (NUMERAL (BIT1 O)) n)) /\ ((@IN nat k (dotdot (NUMERAL (BIT1 O)) n)) /\ (ltn j k))) -> ~ (lt2' (f k) (f j))).
Axiom thm_FINITE_INT_SEG : (forall l : int, forall r : int, @finite_set int (@GSPEC int (fun GEN_PVAR_235 : int => exists x : int, @SETSPEC int GEN_PVAR_235 ((lez l x) /\ (lez x r)) x))) /\ ((forall l : int, forall r : int, @finite_set int (@GSPEC int (fun GEN_PVAR_236 : int => exists x : int, @SETSPEC int GEN_PVAR_236 ((lez l x) /\ (ltz x r)) x))) /\ ((forall l : int, forall r : int, @finite_set int (@GSPEC int (fun GEN_PVAR_237 : int => exists x : int, @SETSPEC int GEN_PVAR_237 ((ltz l x) /\ (lez x r)) x))) /\ (forall l : int, forall r : int, @finite_set int (@GSPEC int (fun GEN_PVAR_238 : int => exists x : int, @SETSPEC int GEN_PVAR_238 ((ltz l x) /\ (ltz x r)) x))))).
Axiom thm_neutral : forall {A : Type'}, forall op : A -> A -> A, (@neutral A op) = (@ε A (fun x : A => forall y : A, ((op x y) = y) /\ ((op y x) = y))).
Axiom thm_monoidal : forall {A : Type'}, forall op : A -> A -> A, (@monoidal A op) = ((forall x : A, forall y : A, (op x y) = (op y x)) /\ ((forall x : A, forall y : A, forall z : A, (op x (op y z)) = (op (op x y) z)) /\ (forall x : A, (op (@neutral A op) x) = x))).
Axiom thm_MONOIDAL_AC : forall {A : Type'}, forall op : A -> A -> A, (@monoidal A op) -> (forall a : A, (op (@neutral A op) a) = a) /\ ((forall a : A, (op a (@neutral A op)) = a) /\ ((forall a : A, forall b : A, (op a b) = (op b a)) /\ ((forall a : A, forall b : A, forall c : A, (op (op a b) c) = (op a (op b c))) /\ (forall a : A, forall b : A, forall c : A, (op a (op b c)) = (op b (op a c)))))).
Axiom thm_support : forall {A B : Type'}, forall s : A -> Prop, forall f : A -> B, forall op : B -> B -> B, (@support A B op f s) = (@GSPEC A (fun GEN_PVAR_239 : A => exists x : A, @SETSPEC A GEN_PVAR_239 ((@IN A x s) /\ (~ ((f x) = (@neutral B op)))) x)).
Axiom thm_iterate : forall {A B : Type'}, forall f : A -> B, forall s : A -> Prop, forall op : B -> B -> B, (@iterate A B op s f) = (@COND B (@finite_set A (@support A B op f s)) (@fold_set A B (fun x : A => fun a : B => op (f x) a) (@support A B op f s) (@neutral B op)) (@neutral B op)).
Axiom thm_IN_SUPPORT : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall x : A, forall s : A -> Prop, (@IN A x (@support A B op f s)) = ((@IN A x s) /\ (~ ((f x) = (@neutral B op)))).
Axiom thm_SUPPORT_SUPPORT : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, (@support A B op f (@support A B op f s)) = (@support A B op f s).
Axiom thm_SUPPORT_EMPTY : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (@neutral B op)) = ((@support A B op f s) = (@set0 A)).
Axiom thm_SUPPORT_SUBSET : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, @subset A (@support A B op f s) s.
Axiom thm_FINITE_SUPPORT : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, (@finite_set A s) -> @finite_set A (@support A B op f s).
Axiom thm_SUPPORT_CLAUSES : forall {A B C : Type'} (op : C -> C -> C), (forall f : A -> C, (@support A C op f (@set0 A)) = (@set0 A)) /\ ((forall f : A -> C, forall x : A, forall s : A -> Prop, (@support A C op f (@INSERT A x s)) = (@COND (A -> Prop) ((f x) = (@neutral C op)) (@support A C op f s) (@INSERT A x (@support A C op f s)))) /\ ((forall f : A -> C, forall x : A, forall s : A -> Prop, (@support A C op f (@DELETE A s x)) = (@DELETE A (@support A C op f s) x)) /\ ((forall f : A -> C, forall s : A -> Prop, forall t : A -> Prop, (@support A C op f (@setU A s t)) = (@setU A (@support A C op f s) (@support A C op f t))) /\ ((forall f : A -> C, forall s : A -> Prop, forall t : A -> Prop, (@support A C op f (@setI A s t)) = (@setI A (@support A C op f s) (@support A C op f t))) /\ ((forall f : A -> C, forall s : A -> Prop, forall t : A -> Prop, (@support A C op f (@setD A s t)) = (@setD A (@support A C op f s) (@support A C op f t))) /\ (forall f : A -> B, forall g : B -> C, forall s : A -> Prop, (@support B C op g (@IMAGE A B f s)) = (@IMAGE A B f (@support A C op (@o A B C g f) s)))))))).
Axiom thm_SUPPORT_DELTA : forall {A B : Type'}, forall op : B -> B -> B, forall s : A -> Prop, forall f : A -> B, forall a : A, (@support A B op (fun x : A => @COND B (x = a) (f x) (@neutral B op)) s) = (@COND (A -> Prop) (@IN A a s) (@support A B op f (@INSERT A a (@set0 A))) (@set0 A)).
Axiom thm_FINITE_SUPPORT_DELTA : forall {A B : Type'} (s : A -> Prop), forall op : B -> B -> B, forall f : A -> B, forall a : A, @finite_set A (@support A B op (fun x : A => @COND B (x = a) (f x) (@neutral B op)) s).
Axiom thm_ITERATE_SUPPORT : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, (@iterate A B op (@support A B op f s) f) = (@iterate A B op s f).
Axiom thm_ITERATE_EXPAND_CASES : forall {A B : Type'}, forall op : B -> B -> B, forall f : A -> B, forall s : A -> Prop, (@iterate A B op s f) = (@COND B (@finite_set A (@support A B op f s)) (@iterate A B op (@support A B op f s) f) (@neutral B op)).
Axiom thm_ITERATE_CLAUSES_GEN : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> (forall f : A -> B, (@iterate A B op (@set0 A) f) = (@neutral B op)) /\ (forall f : A -> B, forall x : A, forall s : A -> Prop, (@finite_set A (@support A B op f s)) -> (@iterate A B op (@INSERT A x s) f) = (@COND B (@IN A x s) (@iterate A B op s f) (op (f x) (@iterate A B op s f)))).
Axiom thm_ITERATE_CLAUSES : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> (forall f : A -> C, (@iterate A C op (@set0 A) f) = (@neutral C op)) /\ (forall f : B -> C, forall x : B, forall s : B -> Prop, (@finite_set B s) -> (@iterate B C op (@INSERT B x s) f) = (@COND C (@IN B x s) (@iterate B C op s f) (op (f x) (@iterate B C op s f)))).
Axiom thm_ITERATE_UNION : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (@DISJOINT A s t))) -> (@iterate A B op (@setU A s t) f) = (op (@iterate A B op s f) (@iterate A B op t f)).
Axiom thm_ITERATE_UNION_GEN : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A (@support A B op f s)) /\ ((@finite_set A (@support A B op f t)) /\ (@DISJOINT A (@support A B op f s) (@support A B op f t)))) -> (@iterate A B op (@setU A s t) f) = (op (@iterate A B op s f) (@iterate A B op t f)).
Axiom thm_ITERATE_DIFF : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@subset A t s)) -> (op (@iterate A B op (@setD A s t) f) (@iterate A B op t f)) = (@iterate A B op s f).
Axiom thm_ITERATE_DIFF_GEN : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A (@support A B op f s)) /\ (@subset A (@support A B op f t) (@support A B op f s))) -> (op (@iterate A B op (@setD A s t) f) (@iterate A B op t f)) = (@iterate A B op s f).
Axiom thm_ITERATE_INCL_EXCL : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall s : A -> Prop, forall t : A -> Prop, forall f : A -> B, ((@finite_set A s) /\ (@finite_set A t)) -> (op (@iterate A B op s f) (@iterate A B op t f)) = (op (@iterate A B op (@setU A s t) f) (@iterate A B op (@setI A s t) f)).
Axiom thm_ITERATE_CLOSED : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall P : B -> Prop, ((P (@neutral B op)) /\ (forall x : B, forall y : B, ((P x) /\ (P y)) -> P (op x y))) -> forall f : A -> B, forall s : A -> Prop, (forall x : A, ((@IN A x s) /\ (~ ((f x) = (@neutral B op)))) -> P (f x)) -> P (@iterate A B op s f).
Axiom thm_ITERATE_RELATED : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall R' : B -> B -> Prop, ((R' (@neutral B op) (@neutral B op)) /\ (forall x1 : B, forall y1 : B, forall x2 : B, forall y2 : B, ((R' x1 x2) /\ (R' y1 y2)) -> R' (op x1 y1) (op x2 y2))) -> forall f : A -> B, forall g : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x))) -> R' (@iterate A B op s f) (@iterate A B op s g).
Axiom thm_ITERATE_EQ_NEUTRAL : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (@neutral B op)) -> (@iterate A B op s f) = (@neutral B op).
Axiom thm_ITERATE_SING : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall x : A, (@iterate A B op (@INSERT A x (@set0 A)) f) = (f x).
Axiom thm_ITERATE_CLOSED_NONEMPTY : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall P : B -> Prop, (forall x : B, forall y : B, ((P x) /\ (P y)) -> P (op x y)) -> forall f : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> P (f x)))) -> P (@iterate A B op s f).
Axiom thm_ITERATE_RELATED_NONEMPTY : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall R' : B -> B -> Prop, (forall x1 : B, forall y1 : B, forall x2 : B, forall y2 : B, ((R' x1 x2) /\ (R' y1 y2)) -> R' (op x1 y1) (op x2 y2)) -> forall f : A -> B, forall g : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x)))) -> R' (@iterate A B op s f) (@iterate A B op s g).
Axiom thm_ITERATE_DELETE : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall a : A, ((@finite_set A s) /\ (@IN A a s)) -> (op (f a) (@iterate A B op (@DELETE A s a) f)) = (@iterate A B op s f).
Axiom thm_ITERATE_DELTA : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall a : A, forall s : A -> Prop, (@iterate A B op s (fun x : A => @COND B (x = a) (f x) (@neutral B op))) = (@COND B (@IN A a s) (f a) (@neutral B op)).
Axiom thm_ITERATE_IMAGE : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall f : A -> B, forall g : B -> C, forall s : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) -> (@iterate B C op (@IMAGE A B f s) g) = (@iterate A C op s (@o A B C g f)).
Axiom thm_ITERATE_BIJECTION : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall p : A -> A, forall s : A -> Prop, ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall y : A, (@IN A y s) -> @ex1 A (fun x : A => (@IN A x s) /\ ((p x) = y)))) -> (@iterate A B op s f) = (@iterate A B op s (@o A A B f p)).
Axiom thm_ITERATE_ITERATE_PRODUCT : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall s : A -> Prop, forall t : A -> B -> Prop, forall x : A -> B -> C, ((@finite_set A s) /\ (forall i : A, (@IN A i s) -> @finite_set B (t i))) -> (@iterate A C op s (fun i : A => @iterate B C op (t i) (x i))) = (@iterate (prod A B) C op (@GSPEC (prod A B) (fun GEN_PVAR_243 : prod A B => exists i : A, exists j : B, @SETSPEC (prod A B) GEN_PVAR_243 ((@IN A i s) /\ (@IN B j (t i))) (@pair A B i j))) (@ε ((prod A B) -> C) (fun f : (prod A B) -> C => forall i : A, forall j : B, @eq C (f (@pair A B i j)) (x i j)))).
Axiom thm_ITERATE_EQ : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall g : A -> B, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (g x)) -> (@iterate A B op s f) = (@iterate A B op s g).
Axiom thm_ITERATE_RESTRICT_SET : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall P : A -> Prop, forall s : A -> Prop, forall f : A -> B, (@iterate A B op (@GSPEC A (fun GEN_PVAR_244 : A => exists x : A, @SETSPEC A GEN_PVAR_244 ((@IN A x s) /\ (P x)) x)) f) = (@iterate A B op s (fun x : A => @COND B (P x) (f x) (@neutral B op))).
Axiom thm_ITERATE_EQ_GENERAL : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall s : A -> Prop, forall t : B -> Prop, forall f : A -> C, forall g : B -> C, forall h : A -> B, ((forall y : B, (@IN B y t) -> @ex1 A (fun x : A => (@IN A x s) /\ ((h x) = y))) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ ((g (h x)) = (f x)))) -> (@iterate A C op s f) = (@iterate B C op t g).
Axiom thm_ITERATE_EQ_GENERAL_INVERSES : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall s : A -> Prop, forall t : B -> Prop, forall f : A -> C, forall g : B -> C, forall h : A -> B, forall k : B -> A, ((forall y : B, (@IN B y t) -> (@IN A (k y) s) /\ ((h (k y)) = y)) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ (((k (h x)) = x) /\ ((g (h x)) = (f x))))) -> (@iterate A C op s f) = (@iterate B C op t g).
Axiom thm_ITERATE_INJECTION : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall p : A -> A, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((p x) = (p y)))) -> x = y))) -> (@iterate A B op s (@o A A B f p)) = (@iterate A B op s f).
Axiom thm_ITERATE_UNION_NONZERO : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (forall x : A, (@IN A x (@setI A s t)) -> (f x) = (@neutral B op)))) -> (@iterate A B op (@setU A s t) f) = (op (@iterate A B op s f) (@iterate A B op t f)).
Axiom thm_ITERATE_OP : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall g : A -> B, forall s : A -> Prop, (@finite_set A s) -> (@iterate A B op s (fun x : A => op (f x) (g x))) = (op (@iterate A B op s f) (@iterate A B op s g)).
Axiom thm_ITERATE_SUPERSET : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall u : A -> Prop, forall v : A -> Prop, ((@subset A u v) /\ (forall x : A, ((@IN A x v) /\ (~ (@IN A x u))) -> (f x) = (@neutral B op))) -> (@iterate A B op v f) = (@iterate A B op u f).
Axiom thm_ITERATE_UNIV : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall s : A -> Prop, (@subset A (@support A B op f (@setT A)) s) -> (@iterate A B op s f) = (@iterate A B op (@setT A) f).
Axiom thm_ITERATE_SWAP : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall f : A -> B -> C, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@iterate A C op s (fun i : A => @iterate B C op t (f i))) = (@iterate B C op t (fun j : B => @iterate A C op s (fun i : A => f i j))).
Axiom thm_ITERATE_IMAGE_NONZERO : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall g : B -> C, forall f : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((~ (x = y)) /\ ((f x) = (f y))))) -> (g (f x)) = (@neutral C op))) -> (@iterate B C op (@IMAGE A B f s) g) = (@iterate A C op s (@o A B C g f)).
Axiom thm_ITERATE_IMAGE_GEN : forall {A B C : Type'}, forall op : C -> C -> C, (@monoidal C op) -> forall f : A -> B, forall g : A -> C, forall s : A -> Prop, (@finite_set A s) -> (@iterate A C op s g) = (@iterate B C op (@IMAGE A B f s) (fun y : B => @iterate A C op (@GSPEC A (fun GEN_PVAR_247 : A => exists x : A, @SETSPEC A GEN_PVAR_247 ((@IN A x s) /\ ((f x) = y)) x)) g)).
Axiom thm_ITERATE_CASES : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall s : A -> Prop, forall P : A -> Prop, forall f : A -> B, forall g : A -> B, (@finite_set A s) -> (@iterate A B op s (fun x : A => @COND B (P x) (f x) (g x))) = (op (@iterate A B op (@GSPEC A (fun GEN_PVAR_250 : A => exists x : A, @SETSPEC A GEN_PVAR_250 ((@IN A x s) /\ (P x)) x)) f) (@iterate A B op (@GSPEC A (fun GEN_PVAR_251 : A => exists x : A, @SETSPEC A GEN_PVAR_251 ((@IN A x s) /\ (~ (P x))) x)) g)).
Axiom thm_ITERATE_OP_GEN : forall {A B : Type'}, forall op : B -> B -> B, (@monoidal B op) -> forall f : A -> B, forall g : A -> B, forall s : A -> Prop, ((@finite_set A (@support A B op f s)) /\ (@finite_set A (@support A B op g s))) -> (@iterate A B op s (fun x : A => op (f x) (g x))) = (op (@iterate A B op s f) (@iterate A B op s g)).
Axiom thm_ITERATE_CLAUSES_NUMSEG : forall {A : Type'} (f : nat -> A), forall op : A -> A -> A, (@monoidal A op) -> (forall m : nat, (@iterate nat A op (dotdot m (NUMERAL O)) f) = (@COND A (m = (NUMERAL O)) (f (NUMERAL O)) (@neutral A op))) /\ (forall m : nat, forall n : nat, (@iterate nat A op (dotdot m (S n)) f) = (@COND A (leqn m (S n)) (op (@iterate nat A op (dotdot m n) f) (f (S n))) (@iterate nat A op (dotdot m n) f))).
Axiom thm_ITERATE_CLAUSES_NUMSEG_LT : forall {A : Type'} (f : nat -> A), forall op : A -> A -> A, (@monoidal A op) -> ((@iterate nat A op (@GSPEC nat (fun GEN_PVAR_256 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_256 (ltn i (NUMERAL O)) i)) f) = (@neutral A op)) /\ (forall k : nat, (@iterate nat A op (@GSPEC nat (fun GEN_PVAR_257 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_257 (ltn i (S k)) i)) f) = (op (@iterate nat A op (@GSPEC nat (fun GEN_PVAR_258 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_258 (ltn i k) i)) f) (f k))).
Axiom thm_ITERATE_CLAUSES_NUMSEG_LE : forall {A : Type'} (f : nat -> A), forall op : A -> A -> A, (@monoidal A op) -> ((@iterate nat A op (@GSPEC nat (fun GEN_PVAR_259 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_259 (leqn i (NUMERAL O)) i)) f) = (f (NUMERAL O))) /\ (forall k : nat, (@iterate nat A op (@GSPEC nat (fun GEN_PVAR_260 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_260 (leqn i (S k)) i)) f) = (op (@iterate nat A op (@GSPEC nat (fun GEN_PVAR_261 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_261 (leqn i k) i)) f) (f (S k)))).
Axiom thm_ITERATE_PAIR : forall {A : Type'}, forall op : A -> A -> A, (@monoidal A op) -> forall f : nat -> A, forall m : nat, forall n : nat, (@iterate nat A op (dotdot (muln (NUMERAL (BIT0 (BIT1 O))) m) (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O)))) f) = (@iterate nat A op (dotdot m n) (fun i : nat => op (f (muln (NUMERAL (BIT0 (BIT1 O))) i)) (f (addn (muln (NUMERAL (BIT0 (BIT1 O))) i) (NUMERAL (BIT1 O)))))).
Axiom thm_ITERATE_REFLECT : forall {A : Type'}, forall op : A -> A -> A, (@monoidal A op) -> forall x : nat -> A, forall m : nat, forall n : nat, (@iterate nat A op (dotdot m n) x) = (@COND A (ltn n m) (@neutral A op) (@iterate nat A op (dotdot (NUMERAL O) (subn n m)) (fun i : nat => x (subn n i)))).
Axiom thm_ITERATO_SUPPORT : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (@iterato A K dom neut op ltle (@GSPEC K (fun GEN_PVAR_270 : K => exists i : K, @SETSPEC K GEN_PVAR_270 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) f) = (@iterato A K dom neut op ltle k f).
Axiom thm_ITERATO_EXPAND_CASES : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (@iterato A K dom neut op ltle k f) = (@COND A (@finite_set K (@GSPEC K (fun GEN_PVAR_271 : K => exists i : K, @SETSPEC K GEN_PVAR_271 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) (@iterato A K dom neut op ltle (@GSPEC K (fun GEN_PVAR_272 : K => exists i : K, @SETSPEC K GEN_PVAR_272 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) f) neut).
Axiom thm_ITERATO_CLAUSES_GEN : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall f : K -> A, ((@iterato A K dom neut op ltle (@set0 K) f) = neut) /\ (forall i : K, forall k : K -> Prop, ((@finite_set K (@GSPEC K (fun GEN_PVAR_274 : K => exists j : K, @SETSPEC K GEN_PVAR_274 ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A))))) j))) /\ ((forall j : K, (@IN K j k) -> (i = j) \/ ((ltle i j) \/ (ltle j i))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i))) -> (@iterato A K dom neut op ltle (@INSERT K i k) f) = (@COND A ((@IN A (f i) dom) -> ((f i) = neut) \/ (@IN K i k)) (@iterato A K dom neut op ltle k f) (op (f i) (@iterato A K dom neut op ltle k f)))).
Axiom thm_ITERATO_CLAUSES : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall f : K -> A, ((@iterato A K dom neut op ltle (@set0 K) f) = neut) /\ (forall i : K, forall k : K -> Prop, ((@finite_set K (@GSPEC K (fun GEN_PVAR_275 : K => exists i' : K, @SETSPEC K GEN_PVAR_275 ((@IN K i' k) /\ (@IN A (f i') (@setD A dom (@INSERT A neut (@set0 A))))) i'))) /\ (forall j : K, (@IN K j k) -> (ltle i j) /\ (~ (ltle j i)))) -> (@iterato A K dom neut op ltle (@INSERT K i k) f) = (@COND A ((@IN A (f i) dom) -> ((f i) = neut) \/ (@IN K i k)) (@iterato A K dom neut op ltle k f) (op (f i) (@iterato A K dom neut op ltle k f)))).
Axiom thm_ITERATO_CLAUSES_EXISTS : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall f : K -> A, ((@iterato A K dom neut op ltle (@set0 K) f) = neut) /\ (forall k : K -> Prop, ((@finite_set K (@GSPEC K (fun GEN_PVAR_276 : K => exists i : K, @SETSPEC K GEN_PVAR_276 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_277 : K => exists i : K, @SETSPEC K GEN_PVAR_277 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) = (@set0 K)))) -> exists i : K, (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ ((@iterato A K dom neut op ltle k f) = (op (f i) (@iterato A K dom neut op ltle (@DELETE K k i) f))))).
Axiom thm_ITERATO_EQ : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, forall g : K -> A, (forall i : K, (@IN K i k) -> (f i) = (g i)) -> (@iterato A K dom neut op ltle k f) = (@iterato A K dom neut op ltle k g).
Axiom thm_ITERATO_INDUCT : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, forall P : A -> Prop, ((P neut) /\ (forall i : K, forall x : A, ((@IN K i k) /\ ((@IN A (f i) dom) /\ ((~ ((f i) = neut)) /\ (P x)))) -> P (op (f i) x))) -> P (@iterato A K dom neut op ltle k f).
Axiom thm_ITERATO_CLOSED : forall {A K : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, forall P : A -> Prop, ((P neut) /\ ((forall x : A, forall y : A, ((P x) /\ (P y)) -> P (op x y)) /\ (forall i : K, ((@IN K i k) /\ ((@IN A (f i) dom) /\ (~ ((f i) = neut)))) -> P (f i)))) -> P (@iterato A K dom neut op ltle k f).
Axiom thm_ITERATO_ITERATE : forall {A K : Type'}, forall op : A -> A -> A, forall ltle : K -> K -> Prop, (@monoidal A op) -> (@iterato A K (@setT A) (@neutral A op) op ltle) = (@iterate K A op).
Axiom thm_ITERATO_CLAUSES_NUMSEG_LEFT : forall {A : Type'}, forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall f : nat -> A, forall m : nat, forall n : nat, (@iterato A nat dom neut op leqn (dotdot m n) f) = (@COND A (leqn m n) (@COND A ((@IN A (f m) dom) -> (f m) = neut) (@iterato A nat dom neut op leqn (dotdot (addn m (NUMERAL (BIT1 O))) n) f) (op (f m) (@iterato A nat dom neut op leqn (dotdot (addn m (NUMERAL (BIT1 O))) n) f))) neut).
Axiom thm_nproduct : forall {A : Type'}, (@nproduct A) = (@iterate A nat muln).
Axiom thm_NEUTRAL_MUL : (@neutral nat muln) = (NUMERAL (BIT1 O)).
Axiom thm_MONOIDAL_MUL : @monoidal nat muln.
Axiom thm_NPRODUCT_CLAUSES : forall {A B : Type'}, (forall f : A -> nat, (@nproduct A (@set0 A) f) = (NUMERAL (BIT1 O))) /\ (forall x : B, forall f : B -> nat, forall s : B -> Prop, (@finite_set B s) -> (@nproduct B (@INSERT B x s) f) = (@COND nat (@IN B x s) (@nproduct B s f) (muln (f x) (@nproduct B s f)))).
Axiom thm_iproduct : forall {A : Type'}, (@iproduct A) = (@iterate A int mulz).
Axiom thm_NEUTRAL_INT_MUL : (@neutral int mulz) = (int_of_nat (NUMERAL (BIT1 O))).
Axiom thm_MONOIDAL_INT_MUL : @monoidal int mulz.
Axiom thm_IPRODUCT_CLAUSES : forall {A B : Type'}, (forall f : A -> int, (@iproduct A (@set0 A) f) = (int_of_nat (NUMERAL (BIT1 O)))) /\ (forall x : B, forall f : B -> int, forall s : B -> Prop, (@finite_set B s) -> (@iproduct B (@INSERT B x s) f) = (@COND int (@IN B x s) (@iproduct B s f) (mulz (f x) (@iproduct B s f)))).
Axiom thm_product : forall {A : Type'}, (@product A) = (@iterate A R mulr).
Axiom thm_NEUTRAL_REAL_MUL : (@neutral R mulr) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_MONOIDAL_REAL_MUL : @monoidal R mulr.
Axiom thm_PRODUCT_CLAUSES : forall {A B : Type'}, (forall f : A -> R, (@product A (@set0 A) f) = (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall x : B, forall f : B -> R, forall s : B -> Prop, (@finite_set B s) -> (@product B (@INSERT B x s) f) = (@COND R (@IN B x s) (@product B s f) (mulr (f x) (@product B s f)))).
Axiom thm_isum : forall {A : Type'}, (@isum A) = (@iterate A int addz).
Axiom thm_NEUTRAL_INT_ADD : (@neutral int addz) = (int_of_nat (NUMERAL O)).
Axiom thm_MONOIDAL_INT_ADD : @monoidal int addz.
Axiom thm_ISUM_CLAUSES : forall {A B : Type'}, (forall f : A -> int, (@isum A (@set0 A) f) = (int_of_nat (NUMERAL O))) /\ (forall x : B, forall f : B -> int, forall s : B -> Prop, (@finite_set B s) -> (@isum B (@INSERT B x s) f) = (@COND int (@IN B x s) (@isum B s f) (addz (f x) (@isum B s f)))).
Axiom thm_nsum : forall {A : Type'}, (@nsum A) = (@iterate A nat addn).
Axiom thm_NEUTRAL_ADD : (@neutral nat addn) = (NUMERAL O).
Axiom thm_MONOIDAL_ADD : @monoidal nat addn.
Axiom thm_NSUM_DEGENERATE : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (~ (@finite_set A (@GSPEC A (fun GEN_PVAR_286 : A => exists x : A, @SETSPEC A GEN_PVAR_286 ((@IN A x s) /\ (~ ((f x) = (NUMERAL O)))) x)))) -> (@nsum A s f) = (NUMERAL O).
Axiom thm_NSUM_CLAUSES : forall {A B : Type'}, (forall f : A -> nat, (@nsum A (@set0 A) f) = (NUMERAL O)) /\ (forall x : B, forall f : B -> nat, forall s : B -> Prop, (@finite_set B s) -> (@nsum B (@INSERT B x s) f) = (@COND nat (@IN B x s) (@nsum B s f) (addn (f x) (@nsum B s f)))).
Axiom thm_NSUM_UNION : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (@DISJOINT A s t))) -> (@nsum A (@setU A s t) f) = (addn (@nsum A s f) (@nsum A t f)).
Axiom thm_NSUM_DIFF : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ (@subset A t s)) -> (@nsum A (@setD A s t) f) = (subn (@nsum A s f) (@nsum A t f)).
Axiom thm_NSUM_INCL_EXCL : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall f : A -> nat, ((@finite_set A s) /\ (@finite_set A t)) -> (addn (@nsum A s f) (@nsum A t f)) = (addn (@nsum A (@setU A s t) f) (@nsum A (@setI A s t) f)).
Axiom thm_NSUM_SUPPORT : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (@nsum A (@support A nat addn f s) f) = (@nsum A s f).
Axiom thm_NSUM_ADD : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, (@finite_set A s) -> (@nsum A s (fun x : A => addn (f x) (g x))) = (addn (@nsum A s f) (@nsum A s g)).
Axiom thm_NSUM_ADD_GEN : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((@finite_set A (@GSPEC A (fun GEN_PVAR_287 : A => exists x : A, @SETSPEC A GEN_PVAR_287 ((@IN A x s) /\ (~ ((f x) = (NUMERAL O)))) x))) /\ (@finite_set A (@GSPEC A (fun GEN_PVAR_288 : A => exists x : A, @SETSPEC A GEN_PVAR_288 ((@IN A x s) /\ (~ ((g x) = (NUMERAL O)))) x)))) -> (@nsum A s (fun x : A => addn (f x) (g x))) = (addn (@nsum A s f) (@nsum A s g)).
Axiom thm_NSUM_EQ_0 : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (NUMERAL O)) -> (@nsum A s f) = (NUMERAL O).
Axiom thm_NSUM_0 : forall {A : Type'}, forall s : A -> Prop, (@nsum A s (fun n : A => NUMERAL O)) = (NUMERAL O).
Axiom thm_NSUM_LMUL : forall {A : Type'}, forall f : A -> nat, forall c : nat, forall s : A -> Prop, (@nsum A s (fun x : A => muln c (f x))) = (muln c (@nsum A s f)).
Axiom thm_NSUM_RMUL : forall {A : Type'}, forall f : A -> nat, forall c : nat, forall s : A -> Prop, (@nsum A s (fun x : A => muln (f x) c)) = (muln (@nsum A s f) c).
Axiom thm_NSUM_LE : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> leqn (f x) (g x))) -> leqn (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_LT : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> leqn (f x) (g x)) /\ (exists x : A, (@IN A x s) /\ (ltn (f x) (g x))))) -> ltn (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_LT_ALL : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltn (f x) (g x)))) -> ltn (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_EQ : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, (forall x : A, (@IN A x s) -> (f x) = (g x)) -> (@nsum A s f) = (@nsum A s g).
Axiom thm_NSUM_CONST : forall {A : Type'}, forall c : nat, forall s : A -> Prop, (@finite_set A s) -> (@nsum A s (fun n : A => c)) = (muln (@CARD A s) c).
Axiom thm_NSUM_POS_BOUND : forall {A : Type'}, forall f : A -> nat, forall b : nat, forall s : A -> Prop, ((@finite_set A s) /\ (leqn (@nsum A s f) b)) -> forall x : A, (@IN A x s) -> leqn (f x) b.
Axiom thm_NSUM_EQ_0_IFF : forall {A : Type'} (f : A -> nat), forall s : A -> Prop, (@finite_set A s) -> ((@nsum A s f) = (NUMERAL O)) = (forall x : A, (@IN A x s) -> (f x) = (NUMERAL O)).
Axiom thm_NSUM_POS_LT : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ (exists x : A, (@IN A x s) /\ (ltn (NUMERAL O) (f x)))) -> ltn (NUMERAL O) (@nsum A s f).
Axiom thm_NSUM_POS_LT_ALL : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall i : A, (@IN A i s) -> ltn (NUMERAL O) (f i)))) -> ltn (NUMERAL O) (@nsum A s f).
Axiom thm_NSUM_DELETE : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, forall a : A, ((@finite_set A s) /\ (@IN A a s)) -> (addn (f a) (@nsum A (@DELETE A s a) f)) = (@nsum A s f).
Axiom thm_NSUM_SING : forall {A : Type'}, forall f : A -> nat, forall x : A, (@nsum A (@INSERT A x (@set0 A)) f) = (f x).
Axiom thm_NSUM_DELTA : forall {A : Type'} (b : nat), forall s : A -> Prop, forall a : A, (@nsum A s (fun x : A => @COND nat (x = a) b (NUMERAL O))) = (@COND nat (@IN A a s) b (NUMERAL O)).
Axiom thm_NSUM_SWAP : forall {A B : Type'}, forall f : A -> B -> nat, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@nsum A s (fun i : A => @nsum B t (f i))) = (@nsum B t (fun j : B => @nsum A s (fun i : A => f i j))).
Axiom thm_NSUM_IMAGE : forall {A B : Type'}, forall f : A -> B, forall g : B -> nat, forall s : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) -> (@nsum B (@IMAGE A B f s) g) = (@nsum A s (@o A B nat g f)).
Axiom thm_NSUM_SUPERSET : forall {A : Type'}, forall f : A -> nat, forall u : A -> Prop, forall v : A -> Prop, ((@subset A u v) /\ (forall x : A, ((@IN A x v) /\ (~ (@IN A x u))) -> (f x) = (NUMERAL O))) -> (@nsum A v f) = (@nsum A u f).
Axiom thm_NSUM_UNIV : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (@subset A (@support A nat addn f (@setT A)) s) -> (@nsum A s f) = (@nsum A (@setT A) f).
Axiom thm_NSUM_UNION_RZERO : forall {A : Type'}, forall f : A -> nat, forall u : A -> Prop, forall v : A -> Prop, ((@finite_set A u) /\ (forall x : A, ((@IN A x v) /\ (~ (@IN A x u))) -> (f x) = (NUMERAL O))) -> (@nsum A (@setU A u v) f) = (@nsum A u f).
Axiom thm_NSUM_UNION_LZERO : forall {A : Type'}, forall f : A -> nat, forall u : A -> Prop, forall v : A -> Prop, ((@finite_set A v) /\ (forall x : A, ((@IN A x u) /\ (~ (@IN A x v))) -> (f x) = (NUMERAL O))) -> (@nsum A (@setU A u v) f) = (@nsum A v f).
Axiom thm_NSUM_RESTRICT : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (@finite_set A s) -> (@nsum A s (fun x : A => @COND nat (@IN A x s) (f x) (NUMERAL O))) = (@nsum A s f).
Axiom thm_NSUM_BOUND : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, forall b : nat, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> leqn (f x) b)) -> leqn (@nsum A s f) (muln (@CARD A s) b).
Axiom thm_NSUM_BOUND_GEN : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, forall b : nat, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> leqn (f x) (divn b (@CARD A s))))) -> leqn (@nsum A s f) b.
Axiom thm_NSUM_BOUND_LT : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, forall b : nat, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> leqn (f x) b) /\ (exists x : A, (@IN A x s) /\ (ltn (f x) b)))) -> ltn (@nsum A s f) (muln (@CARD A s) b).
Axiom thm_NSUM_BOUND_LT_ALL : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, forall b : nat, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltn (f x) b))) -> ltn (@nsum A s f) (muln (@CARD A s) b).
Axiom thm_NSUM_BOUND_LT_GEN : forall {A : Type'}, forall s : A -> Prop, forall f : A -> nat, forall b : nat, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltn (f x) (divn b (@CARD A s))))) -> ltn (@nsum A s f) b.
Axiom thm_NSUM_UNION_EQ : forall {A : Type'} (f : A -> nat), forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@finite_set A u) /\ (((@setI A s t) = (@set0 A)) /\ ((@setU A s t) = u))) -> (addn (@nsum A s f) (@nsum A t f)) = (@nsum A u f).
Axiom thm_NSUM_EQ_SUPERSET : forall {A : Type'} (g : A -> nat), forall f : A -> nat, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A t) /\ ((@subset A t s) /\ ((forall x : A, (@IN A x t) -> (f x) = (g x)) /\ (forall x : A, ((@IN A x s) /\ (~ (@IN A x t))) -> (f x) = (NUMERAL O))))) -> (@nsum A s f) = (@nsum A t g).
Axiom thm_NSUM_RESTRICT_SET : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall f : A -> nat, (@nsum A (@GSPEC A (fun GEN_PVAR_289 : A => exists x : A, @SETSPEC A GEN_PVAR_289 ((@IN A x s) /\ (P x)) x)) f) = (@nsum A s (fun x : A => @COND nat (P x) (f x) (NUMERAL O))).
Axiom thm_NSUM_NSUM_RESTRICT : forall {A B : Type'}, forall R' : A -> B -> Prop, forall f : A -> B -> nat, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@nsum A s (fun x : A => @nsum B (@GSPEC B (fun GEN_PVAR_290 : B => exists y : B, @SETSPEC B GEN_PVAR_290 ((@IN B y t) /\ (R' x y)) y)) (fun y : B => f x y))) = (@nsum B t (fun y : B => @nsum A (@GSPEC A (fun GEN_PVAR_291 : A => exists x : A, @SETSPEC A GEN_PVAR_291 ((@IN A x s) /\ (R' x y)) x)) (fun x : A => f x y))).
Axiom thm_CARD_EQ_NSUM : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> (@CARD A s) = (@nsum A s (fun x : A => NUMERAL (BIT1 O))).
Axiom thm_NSUM_MULTICOUNT_GEN : forall {A B : Type'}, forall R' : A -> B -> Prop, forall s : A -> Prop, forall t : B -> Prop, forall k : B -> nat, ((@finite_set A s) /\ ((@finite_set B t) /\ (forall j : B, (@IN B j t) -> (@CARD A (@GSPEC A (fun GEN_PVAR_293 : A => exists i : A, @SETSPEC A GEN_PVAR_293 ((@IN A i s) /\ (R' i j)) i))) = (k j)))) -> (@nsum A s (fun i : A => @CARD B (@GSPEC B (fun GEN_PVAR_294 : B => exists j : B, @SETSPEC B GEN_PVAR_294 ((@IN B j t) /\ (R' i j)) j)))) = (@nsum B t (fun i : B => k i)).
Axiom thm_NSUM_MULTICOUNT : forall {A B : Type'}, forall R' : A -> B -> Prop, forall s : A -> Prop, forall t : B -> Prop, forall k : nat, ((@finite_set A s) /\ ((@finite_set B t) /\ (forall j : B, (@IN B j t) -> (@CARD A (@GSPEC A (fun GEN_PVAR_295 : A => exists i : A, @SETSPEC A GEN_PVAR_295 ((@IN A i s) /\ (R' i j)) i))) = k))) -> (@nsum A s (fun i : A => @CARD B (@GSPEC B (fun GEN_PVAR_296 : B => exists j : B, @SETSPEC B GEN_PVAR_296 ((@IN B j t) /\ (R' i j)) j)))) = (muln k (@CARD B t)).
Axiom thm_NSUM_IMAGE_GEN : forall {A B : Type'}, forall f : A -> B, forall g : A -> nat, forall s : A -> Prop, (@finite_set A s) -> (@nsum A s g) = (@nsum B (@IMAGE A B f s) (fun y : B => @nsum A (@GSPEC A (fun GEN_PVAR_297 : A => exists x : A, @SETSPEC A GEN_PVAR_297 ((@IN A x s) /\ ((f x) = y)) x)) g)).
Axiom thm_NSUM_GROUP : forall {A B : Type'}, forall f : A -> B, forall g : A -> nat, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@subset B (@IMAGE A B f s) t)) -> (@nsum B t (fun y : B => @nsum A (@GSPEC A (fun GEN_PVAR_298 : A => exists x : A, @SETSPEC A GEN_PVAR_298 ((@IN A x s) /\ ((f x) = y)) x)) g)) = (@nsum A s g).
Axiom thm_NSUM_GROUP_RELATION : forall {A B : Type'}, forall R' : A -> B -> Prop, forall g : A -> nat, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> @ex1 B (fun y : B => (@IN B y t) /\ (R' x y)))) -> (@nsum B t (fun y : B => @nsum A (@GSPEC A (fun GEN_PVAR_299 : A => exists x : A, @SETSPEC A GEN_PVAR_299 ((@IN A x s) /\ (R' x y)) x)) g)) = (@nsum A s g).
Axiom thm_NSUM_SUBSET : forall {A : Type'}, forall u : A -> Prop, forall v : A -> Prop, forall f : A -> nat, ((@finite_set A u) /\ ((@finite_set A v) /\ (forall x : A, (@IN A x (@setD A u v)) -> (f x) = (NUMERAL O)))) -> leqn (@nsum A u f) (@nsum A v f).
Axiom thm_NSUM_SUBSET_SIMPLE : forall {A : Type'}, forall u : A -> Prop, forall v : A -> Prop, forall f : A -> nat, ((@finite_set A v) /\ (@subset A u v)) -> leqn (@nsum A u f) (@nsum A v f).
Axiom thm_NSUM_LE_GEN : forall {A : Type'}, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((forall x : A, (@IN A x s) -> leqn (f x) (g x)) /\ (@finite_set A (@GSPEC A (fun GEN_PVAR_301 : A => exists x : A, @SETSPEC A GEN_PVAR_301 ((@IN A x s) /\ (~ ((g x) = (NUMERAL O)))) x)))) -> leqn (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_MUL_BOUND : forall {A : Type'}, forall a : A -> nat, forall b : A -> nat, forall s : A -> Prop, (@finite_set A s) -> leqn (@nsum A s (fun i : A => muln (a i) (b i))) (muln (@nsum A s a) (@nsum A s b)).
Axiom thm_NSUM_IMAGE_NONZERO : forall {A B : Type'}, forall d : B -> nat, forall i : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((~ (x = y)) /\ ((i x) = (i y))))) -> (d (i x)) = (NUMERAL O))) -> (@nsum B (@IMAGE A B i s) d) = (@nsum A s (@o A B nat d i)).
Axiom thm_NSUM_BIJECTION : forall {A : Type'}, forall f : A -> nat, forall p : A -> A, forall s : A -> Prop, ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall y : A, (@IN A y s) -> @ex1 A (fun x : A => (@IN A x s) /\ ((p x) = y)))) -> (@nsum A s f) = (@nsum A s (@o A A nat f p)).
Axiom thm_NSUM_NSUM_PRODUCT : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> B -> Prop, forall x : A -> B -> nat, ((@finite_set A s) /\ (forall i : A, (@IN A i s) -> @finite_set B (t i))) -> (@nsum A s (fun i : A => @nsum B (t i) (x i))) = (@nsum (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_302 : prod A B => exists i : A, exists j : B, @SETSPEC (prod A B) GEN_PVAR_302 ((@IN A i s) /\ (@IN B j (t i))) (@pair A B i j))) (@ε ((prod A B) -> nat) (fun f : (prod A B) -> nat => forall i : A, forall j : B, @eq nat (f (@pair A B i j)) (x i j)))).
Axiom thm_NSUM_EQ_GENERAL : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> nat, forall g : B -> nat, forall h : A -> B, ((forall y : B, (@IN B y t) -> @ex1 A (fun x : A => (@IN A x s) /\ ((h x) = y))) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ ((g (h x)) = (f x)))) -> (@nsum A s f) = (@nsum B t g).
Axiom thm_NSUM_EQ_GENERAL_INVERSES : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> nat, forall g : B -> nat, forall h : A -> B, forall k : B -> A, ((forall y : B, (@IN B y t) -> (@IN A (k y) s) /\ ((h (k y)) = y)) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ (((k (h x)) = x) /\ ((g (h x)) = (f x))))) -> (@nsum A s f) = (@nsum B t g).
Axiom thm_NSUM_INJECTION : forall {A : Type'}, forall f : A -> nat, forall p : A -> A, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((p x) = (p y)))) -> x = y))) -> (@nsum A s (@o A A nat f p)) = (@nsum A s f).
Axiom thm_NSUM_UNION_NONZERO : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (forall x : A, (@IN A x (@setI A s t)) -> (f x) = (NUMERAL O)))) -> (@nsum A (@setU A s t) f) = (addn (@nsum A s f) (@nsum A t f)).
Axiom thm_NSUM_UNIONS_NONZERO : forall {A : Type'}, forall f : A -> nat, forall s : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) s) /\ ((forall t : A -> Prop, (@IN (A -> Prop) t s) -> @finite_set A t) /\ (forall t1 : A -> Prop, forall t2 : A -> Prop, forall x : A, ((@IN (A -> Prop) t1 s) /\ ((@IN (A -> Prop) t2 s) /\ ((~ (t1 = t2)) /\ ((@IN A x t1) /\ (@IN A x t2))))) -> (f x) = (NUMERAL O)))) -> (@nsum A (@UNIONS A s) f) = (@nsum (A -> Prop) s (fun t : A -> Prop => @nsum A t f)).
Axiom thm_NSUM_CASES : forall {A : Type'}, forall s : A -> Prop, forall P : A -> Prop, forall f : A -> nat, forall g : A -> nat, (@finite_set A s) -> (@nsum A s (fun x : A => @COND nat (P x) (f x) (g x))) = (addn (@nsum A (@GSPEC A (fun GEN_PVAR_303 : A => exists x : A, @SETSPEC A GEN_PVAR_303 ((@IN A x s) /\ (P x)) x)) f) (@nsum A (@GSPEC A (fun GEN_PVAR_304 : A => exists x : A, @SETSPEC A GEN_PVAR_304 ((@IN A x s) /\ (~ (P x))) x)) g)).
Axiom thm_NSUM_CLOSED : forall {A : Type'}, forall P : nat -> Prop, forall f : A -> nat, forall s : A -> Prop, ((P (NUMERAL O)) /\ ((forall x : nat, forall y : nat, ((P x) /\ (P y)) -> P (addn x y)) /\ (forall a : A, (@IN A a s) -> P (f a)))) -> P (@nsum A s f).
Axiom thm_NSUM_RELATED : forall {A : Type'}, forall R' : nat -> nat -> Prop, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((R' (NUMERAL O) (NUMERAL O)) /\ ((forall m : nat, forall n : nat, forall m' : nat, forall n' : nat, ((R' m n) /\ (R' m' n')) -> R' (addn m m') (addn n n')) /\ ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x))))) -> R' (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_CLOSED_NONEMPTY : forall {A : Type'}, forall P : nat -> Prop, forall f : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ ((forall x : nat, forall y : nat, ((P x) /\ (P y)) -> P (addn x y)) /\ (forall a : A, (@IN A a s) -> P (f a))))) -> P (@nsum A s f).
Axiom thm_NSUM_RELATED_NONEMPTY : forall {A : Type'}, forall R' : nat -> nat -> Prop, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((forall m : nat, forall n : nat, forall m' : nat, forall n' : nat, ((R' m n) /\ (R' m' n')) -> R' (addn m m') (addn n n')) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x))))) -> R' (@nsum A s f) (@nsum A s g).
Axiom thm_NSUM_ADD_NUMSEG : forall f : nat -> nat, forall g : nat -> nat, forall m : nat, forall n : nat, (@nsum nat (dotdot m n) (fun i : nat => addn (f i) (g i))) = (addn (@nsum nat (dotdot m n) f) (@nsum nat (dotdot m n) g)).
Axiom thm_NSUM_LE_NUMSEG : forall f : nat -> nat, forall g : nat -> nat, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> leqn (f i) (g i)) -> leqn (@nsum nat (dotdot m n) f) (@nsum nat (dotdot m n) g).
Axiom thm_NSUM_EQ_NUMSEG : forall f : nat -> nat, forall g : nat -> nat, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> (f i) = (g i)) -> (@nsum nat (dotdot m n) f) = (@nsum nat (dotdot m n) g).
Axiom thm_NSUM_CONST_NUMSEG : forall c : nat, forall m : nat, forall n : nat, (@nsum nat (dotdot m n) (fun n' : nat => c)) = (muln (subn (addn n (NUMERAL (BIT1 O))) m) c).
Axiom thm_NSUM_EQ_0_NUMSEG : forall f : nat -> nat, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> (f i) = (NUMERAL O)) -> (@nsum nat (dotdot m n) f) = (NUMERAL O).
Axiom thm_NSUM_EQ_0_IFF_NUMSEG : forall f : nat -> nat, forall m : nat, forall n : nat, ((@nsum nat (dotdot m n) f) = (NUMERAL O)) = (forall i : nat, ((leqn m i) /\ (leqn i n)) -> (f i) = (NUMERAL O)).
Axiom thm_NSUM_TRIV_NUMSEG : forall f : nat -> nat, forall m : nat, forall n : nat, (ltn n m) -> (@nsum nat (dotdot m n) f) = (NUMERAL O).
Axiom thm_NSUM_SING_NUMSEG : forall f : nat -> nat, forall n : nat, (@nsum nat (dotdot n n) f) = (f n).
Axiom thm_NSUM_CLAUSES_NUMSEG : forall (f : nat -> nat), (forall m : nat, (@nsum nat (dotdot m (NUMERAL O)) f) = (@COND nat (m = (NUMERAL O)) (f (NUMERAL O)) (NUMERAL O))) /\ (forall m : nat, forall n : nat, (@nsum nat (dotdot m (S n)) f) = (@COND nat (leqn m (S n)) (addn (@nsum nat (dotdot m n) f) (f (S n))) (@nsum nat (dotdot m n) f))).
Axiom thm_NSUM_CLAUSES_NUMSEG_LT : forall (f : nat -> nat), ((@nsum nat (@GSPEC nat (fun GEN_PVAR_305 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_305 (ltn i (NUMERAL O)) i)) f) = (NUMERAL O)) /\ (forall k : nat, (@nsum nat (@GSPEC nat (fun GEN_PVAR_306 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_306 (ltn i (S k)) i)) f) = (addn (@nsum nat (@GSPEC nat (fun GEN_PVAR_307 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_307 (ltn i k) i)) f) (f k))).
Axiom thm_NSUM_CLAUSES_NUMSEG_LE : forall (f : nat -> nat), ((@nsum nat (@GSPEC nat (fun GEN_PVAR_308 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_308 (leqn i (NUMERAL O)) i)) f) = (f (NUMERAL O))) /\ (forall k : nat, (@nsum nat (@GSPEC nat (fun GEN_PVAR_309 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_309 (leqn i (S k)) i)) f) = (addn (@nsum nat (@GSPEC nat (fun GEN_PVAR_310 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_310 (leqn i k) i)) f) (f (S k)))).
Axiom thm_NSUM_SWAP_NUMSEG : forall a : nat, forall b : nat, forall c : nat, forall d : nat, forall f : nat -> nat -> nat, (@nsum nat (dotdot a b) (fun i : nat => @nsum nat (dotdot c d) (f i))) = (@nsum nat (dotdot c d) (fun j : nat => @nsum nat (dotdot a b) (fun i : nat => f i j))).
Axiom thm_NSUM_ADD_SPLIT : forall f : nat -> nat, forall m : nat, forall n : nat, forall p : nat, (leqn m (addn n (NUMERAL (BIT1 O)))) -> (@nsum nat (dotdot m (addn n p)) f) = (addn (@nsum nat (dotdot m n) f) (@nsum nat (dotdot (addn n (NUMERAL (BIT1 O))) (addn n p)) f)).
Axiom thm_NSUM_OFFSET : forall p : nat, forall f : nat -> nat, forall m : nat, forall n : nat, (@nsum nat (dotdot (addn m p) (addn n p)) f) = (@nsum nat (dotdot m n) (fun i : nat => f (addn i p))).
Axiom thm_NSUM_OFFSET_0 : forall f : nat -> nat, forall m : nat, forall n : nat, (leqn m n) -> (@nsum nat (dotdot m n) f) = (@nsum nat (dotdot (NUMERAL O) (subn n m)) (fun i : nat => f (addn i m))).
Axiom thm_NSUM_CLAUSES_LEFT : forall f : nat -> nat, forall m : nat, forall n : nat, (leqn m n) -> (@nsum nat (dotdot m n) f) = (addn (f m) (@nsum nat (dotdot (addn m (NUMERAL (BIT1 O))) n) f)).
Axiom thm_NSUM_CLAUSES_RIGHT : forall f : nat -> nat, forall m : nat, forall n : nat, ((ltn (NUMERAL O) n) /\ (leqn m n)) -> (@nsum nat (dotdot m n) f) = (addn (@nsum nat (dotdot m (subn n (NUMERAL (BIT1 O)))) f) (f n)).
Axiom thm_NSUM_PAIR : forall f : nat -> nat, forall m : nat, forall n : nat, (@nsum nat (dotdot (muln (NUMERAL (BIT0 (BIT1 O))) m) (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O)))) f) = (@nsum nat (dotdot m n) (fun i : nat => addn (f (muln (NUMERAL (BIT0 (BIT1 O))) i)) (f (addn (muln (NUMERAL (BIT0 (BIT1 O))) i) (NUMERAL (BIT1 O)))))).
Axiom thm_NSUM_REFLECT : forall x : nat -> nat, forall m : nat, forall n : nat, (@nsum nat (dotdot m n) x) = (@COND nat (ltn n m) (NUMERAL O) (@nsum nat (dotdot (NUMERAL O) (subn n m)) (fun i : nat => x (subn n i)))).
Axiom thm_MOD_NSUM_MOD : forall {A : Type'}, forall f : A -> nat, forall n : nat, forall s : A -> Prop, (@finite_set A s) -> (modn (@nsum A s f) n) = (modn (@nsum A s (fun i : A => modn (f i) n)) n).
Axiom thm_MOD_NSUM_MOD_NUMSEG : forall f : nat -> nat, forall a : nat, forall b : nat, forall n : nat, (modn (@nsum nat (dotdot a b) f) n) = (modn (@nsum nat (dotdot a b) (fun i : nat => modn (f i) n)) n).
Axiom thm_CONG_NSUM : forall {A : Type'}, forall n : nat, forall f : A -> nat, forall g : A -> nat, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> @eq2 nat (f x) (g x) (num_mod n))) -> @eq2 nat (@nsum A s f) (@nsum A s g) (num_mod n).
Axiom thm_CARD_UNIONS : forall {A : Type'}, forall s : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) s) /\ ((forall t : A -> Prop, (@IN (A -> Prop) t s) -> @finite_set A t) /\ (forall t : A -> Prop, forall u : A -> Prop, ((@IN (A -> Prop) t s) /\ ((@IN (A -> Prop) u s) /\ (~ (t = u)))) -> (@setI A t u) = (@set0 A)))) -> (@CARD A (@UNIONS A s)) = (@nsum (A -> Prop) s (@CARD A)).
Axiom thm_NEUTRAL_REAL_ADD : (@neutral R addr) = (R_of_nat (NUMERAL O)).
Axiom thm_MONOIDAL_REAL_ADD : @monoidal R addr.
Axiom thm_SUM_DEGENERATE : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, (~ (@finite_set A (@GSPEC A (fun GEN_PVAR_313 : A => exists x : A, @SETSPEC A GEN_PVAR_313 ((@IN A x s) /\ (~ ((f x) = (R_of_nat (NUMERAL O))))) x)))) -> (@sum A s f) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_CLAUSES : forall {A B : Type'}, (forall f : A -> R, (@sum A (@set0 A) f) = (R_of_nat (NUMERAL O))) /\ (forall x : B, forall f : B -> R, forall s : B -> Prop, (@finite_set B s) -> (@sum B (@INSERT B x s) f) = (@COND R (@IN B x s) (@sum B s f) (addr (f x) (@sum B s f)))).
Axiom thm_SUM_UNION : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (@DISJOINT A s t))) -> (@sum A (@setU A s t) f) = (addr (@sum A s f) (@sum A t f)).
Axiom thm_SUM_INCL_EXCL : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall f : A -> R, ((@finite_set A s) /\ (@finite_set A t)) -> (addr (@sum A s f) (@sum A t f)) = (addr (@sum A (@setU A s t) f) (@sum A (@setI A s t) f)).
Axiom thm_SUM_SUPPORT : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, (@sum A (@support A R addr f s) f) = (@sum A s f).
Axiom thm_SUM_ADD_GEN : forall {A : Type'}, forall f : A -> R, forall g : A -> R, forall s : A -> Prop, ((@finite_set A (@GSPEC A (fun GEN_PVAR_314 : A => exists x : A, @SETSPEC A GEN_PVAR_314 ((@IN A x s) /\ (~ ((f x) = (R_of_nat (NUMERAL O))))) x))) /\ (@finite_set A (@GSPEC A (fun GEN_PVAR_315 : A => exists x : A, @SETSPEC A GEN_PVAR_315 ((@IN A x s) /\ (~ ((g x) = (R_of_nat (NUMERAL O))))) x)))) -> (@sum A s (fun x : A => addr (f x) (g x))) = (addr (@sum A s f) (@sum A s g)).
Axiom thm_SUM_LMUL : forall {A : Type'}, forall f : A -> R, forall c : R, forall s : A -> Prop, (@sum A s (fun x : A => mulr c (f x))) = (mulr c (@sum A s f)).
Axiom thm_SUM_RMUL : forall {A : Type'}, forall f : A -> R, forall c : R, forall s : A -> Prop, (@sum A s (fun x : A => mulr (f x) c)) = (mulr (@sum A s f) c).
Axiom thm_SUM_LT : forall {A : Type'}, forall f : A -> R, forall g : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> ler (f x) (g x)) /\ (exists x : A, (@IN A x s) /\ (ltr (f x) (g x))))) -> ltr (@sum A s f) (@sum A s g).
Axiom thm_SUM_LT_ALL : forall {A : Type'}, forall f : A -> R, forall g : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltr (f x) (g x)))) -> ltr (@sum A s f) (@sum A s g).
Axiom thm_SUM_POS_LT : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> ler (R_of_nat (NUMERAL O)) (f x)) /\ (exists x : A, (@IN A x s) /\ (ltr (R_of_nat (NUMERAL O)) (f x))))) -> ltr (R_of_nat (NUMERAL O)) (@sum A s f).
Axiom thm_SUM_POS_LT_ALL : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall i : A, (@IN A i s) -> ltr (R_of_nat (NUMERAL O)) (f i)))) -> ltr (R_of_nat (NUMERAL O)) (@sum A s f).
Axiom thm_SUM_POS_LE : forall {A : Type'} (f : A -> R), forall s : A -> Prop, (forall x : A, (@IN A x s) -> ler (R_of_nat (NUMERAL O)) (f x)) -> ler (R_of_nat (NUMERAL O)) (@sum A s f).
Axiom thm_SUM_POS_BOUND : forall {A : Type'}, forall f : A -> R, forall b : R, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> ler (R_of_nat (NUMERAL O)) (f x)) /\ (ler (@sum A s f) b))) -> forall x : A, (@IN A x s) -> ler (f x) b.
Axiom thm_SUM_POS_EQ_0 : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> ler (R_of_nat (NUMERAL O)) (f x)) /\ ((@sum A s f) = (R_of_nat (NUMERAL O))))) -> forall x : A, (@IN A x s) -> (f x) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_ZERO_EXISTS : forall {A : Type'}, forall u : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((@sum A s u) = (R_of_nat (NUMERAL O)))) -> (forall i : A, (@IN A i s) -> (u i) = (R_of_nat (NUMERAL O))) \/ (exists j : A, exists k : A, (@IN A j s) /\ ((ltr (u j) (R_of_nat (NUMERAL O))) /\ ((@IN A k s) /\ (gtr (u k) (R_of_nat (NUMERAL O)))))).
Axiom thm_SUM_DELETE : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, forall a : A, ((@finite_set A s) /\ (@IN A a s)) -> (@sum A (@DELETE A s a) f) = (subr (@sum A s f) (f a)).
Axiom thm_SUM_DELETE_CASES : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, forall a : A, (@finite_set A s) -> (@sum A (@DELETE A s a) f) = (@COND R (@IN A a s) (subr (@sum A s f) (f a)) (@sum A s f)).
Axiom thm_SUM_SING : forall {A : Type'}, forall f : A -> R, forall x : A, (@sum A (@INSERT A x (@set0 A)) f) = (f x).
Axiom thm_SUM_DELTA : forall {A : Type'} (b : R), forall s : A -> Prop, forall a : A, (@sum A s (fun x : A => @COND R (x = a) b (R_of_nat (NUMERAL O)))) = (@COND R (@IN A a s) b (R_of_nat (NUMERAL O))).
Axiom thm_SUM_IMAGE : forall {A B : Type'}, forall f : A -> B, forall g : B -> R, forall s : A -> Prop, (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((f x) = (f y)))) -> x = y) -> (@sum B (@IMAGE A B f s) g) = (@sum A s (@o A B R g f)).
Axiom thm_SUM_SUPERSET : forall {A : Type'}, forall f : A -> R, forall u : A -> Prop, forall v : A -> Prop, ((@subset A u v) /\ (forall x : A, ((@IN A x v) /\ (~ (@IN A x u))) -> (f x) = (R_of_nat (NUMERAL O)))) -> (@sum A v f) = (@sum A u f).
Axiom thm_SUM_UNIV : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, (@subset A (@support A R addr f (@setT A)) s) -> (@sum A s f) = (@sum A (@setT A) f).
Axiom thm_SUM_UNION_RZERO : forall {A : Type'}, forall f : A -> R, forall u : A -> Prop, forall v : A -> Prop, ((@finite_set A u) /\ (forall x : A, ((@IN A x v) /\ (~ (@IN A x u))) -> (f x) = (R_of_nat (NUMERAL O)))) -> (@sum A (@setU A u v) f) = (@sum A u f).
Axiom thm_SUM_UNION_LZERO : forall {A : Type'}, forall f : A -> R, forall u : A -> Prop, forall v : A -> Prop, ((@finite_set A v) /\ (forall x : A, ((@IN A x u) /\ (~ (@IN A x v))) -> (f x) = (R_of_nat (NUMERAL O)))) -> (@sum A (@setU A u v) f) = (@sum A v f).
Axiom thm_SUM_RESTRICT : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, (@finite_set A s) -> (@sum A s (fun x : A => @COND R (@IN A x s) (f x) (R_of_nat (NUMERAL O)))) = (@sum A s f).
Axiom thm_SUM_BOUND_GEN : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, forall b : R, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ler (f x) (divr b (R_of_nat (@CARD A s)))))) -> ler (@sum A s f) b.
Axiom thm_SUM_ABS_BOUND : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, forall b : R, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> ler (normr (f x)) b)) -> ler (normr (@sum A s f)) (mulr (R_of_nat (@CARD A s)) b).
Axiom thm_SUM_BOUND_LT : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, forall b : R, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> ler (f x) b) /\ (exists x : A, (@IN A x s) /\ (ltr (f x) b)))) -> ltr (@sum A s f) (mulr (R_of_nat (@CARD A s)) b).
Axiom thm_SUM_BOUND_LT_ALL : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, forall b : R, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltr (f x) b))) -> ltr (@sum A s f) (mulr (R_of_nat (@CARD A s)) b).
Axiom thm_SUM_BOUND_LT_GEN : forall {A : Type'}, forall s : A -> Prop, forall f : A -> R, forall b : R, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> ltr (f x) (divr b (R_of_nat (@CARD A s)))))) -> ltr (@sum A s f) b.
Axiom thm_SUM_UNION_EQ : forall {A : Type'} (f : A -> R), forall s : A -> Prop, forall t : A -> Prop, forall u : A -> Prop, ((@finite_set A u) /\ (((@setI A s t) = (@set0 A)) /\ ((@setU A s t) = u))) -> (addr (@sum A s f) (@sum A t f)) = (@sum A u f).
Axiom thm_SUM_EQ_SUPERSET : forall {A : Type'} (g : A -> R), forall f : A -> R, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A t) /\ ((@subset A t s) /\ ((forall x : A, (@IN A x t) -> (f x) = (g x)) /\ (forall x : A, ((@IN A x s) /\ (~ (@IN A x t))) -> (f x) = (R_of_nat (NUMERAL O)))))) -> (@sum A s f) = (@sum A t g).
Axiom thm_SUM_RESTRICT_SET : forall {A : Type'}, forall P : A -> Prop, forall s : A -> Prop, forall f : A -> R, (@sum A (@GSPEC A (fun GEN_PVAR_318 : A => exists x : A, @SETSPEC A GEN_PVAR_318 ((@IN A x s) /\ (P x)) x)) f) = (@sum A s (fun x : A => @COND R (P x) (f x) (R_of_nat (NUMERAL O)))).
Axiom thm_SUM_SUM_RESTRICT : forall {A B : Type'}, forall R' : A -> B -> Prop, forall f : A -> B -> R, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (@finite_set B t)) -> (@sum A s (fun x : A => @sum B (@GSPEC B (fun GEN_PVAR_319 : B => exists y : B, @SETSPEC B GEN_PVAR_319 ((@IN B y t) /\ (R' x y)) y)) (fun y : B => f x y))) = (@sum B t (fun y : B => @sum A (@GSPEC A (fun GEN_PVAR_320 : A => exists x : A, @SETSPEC A GEN_PVAR_320 ((@IN A x s) /\ (R' x y)) x)) (fun x : A => f x y))).
Axiom thm_CARD_EQ_SUM : forall {A : Type'}, forall s : A -> Prop, (@finite_set A s) -> (R_of_nat (@CARD A s)) = (@sum A s (fun x : A => R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_SUM_MULTICOUNT_GEN : forall {A B : Type'}, forall R' : A -> B -> Prop, forall s : A -> Prop, forall t : B -> Prop, forall k : B -> nat, ((@finite_set A s) /\ ((@finite_set B t) /\ (forall j : B, (@IN B j t) -> (@CARD A (@GSPEC A (fun GEN_PVAR_322 : A => exists i : A, @SETSPEC A GEN_PVAR_322 ((@IN A i s) /\ (R' i j)) i))) = (k j)))) -> (@sum A s (fun i : A => R_of_nat (@CARD B (@GSPEC B (fun GEN_PVAR_323 : B => exists j : B, @SETSPEC B GEN_PVAR_323 ((@IN B j t) /\ (R' i j)) j))))) = (@sum B t (fun i : B => R_of_nat (k i))).
Axiom thm_SUM_MULTICOUNT : forall {A B : Type'}, forall R' : A -> B -> Prop, forall s : A -> Prop, forall t : B -> Prop, forall k : nat, ((@finite_set A s) /\ ((@finite_set B t) /\ (forall j : B, (@IN B j t) -> (@CARD A (@GSPEC A (fun GEN_PVAR_324 : A => exists i : A, @SETSPEC A GEN_PVAR_324 ((@IN A i s) /\ (R' i j)) i))) = k))) -> (@sum A s (fun i : A => R_of_nat (@CARD B (@GSPEC B (fun GEN_PVAR_325 : B => exists j : B, @SETSPEC B GEN_PVAR_325 ((@IN B j t) /\ (R' i j)) j))))) = (R_of_nat (muln k (@CARD B t))).
Axiom thm_SUM_IMAGE_GEN : forall {A B : Type'}, forall f : A -> B, forall g : A -> R, forall s : A -> Prop, (@finite_set A s) -> (@sum A s g) = (@sum B (@IMAGE A B f s) (fun y : B => @sum A (@GSPEC A (fun GEN_PVAR_326 : A => exists x : A, @SETSPEC A GEN_PVAR_326 ((@IN A x s) /\ ((f x) = y)) x)) g)).
Axiom thm_SUM_GROUP_RELATION : forall {A B : Type'}, forall R' : A -> B -> Prop, forall g : A -> R, forall s : A -> Prop, forall t : B -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> @ex1 B (fun y : B => (@IN B y t) /\ (R' x y)))) -> (@sum B t (fun y : B => @sum A (@GSPEC A (fun GEN_PVAR_328 : A => exists x : A, @SETSPEC A GEN_PVAR_328 ((@IN A x s) /\ (R' x y)) x)) g)) = (@sum A s g).
Axiom thm_REAL_OF_NUM_SUM : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (@finite_set A s) -> (R_of_nat (@nsum A s f)) = (@sum A s (fun x : A => R_of_nat (f x))).
Axiom thm_SUM_SUBSET : forall {A : Type'}, forall u : A -> Prop, forall v : A -> Prop, forall f : A -> R, ((@finite_set A u) /\ ((@finite_set A v) /\ ((forall x : A, (@IN A x (@setD A u v)) -> ler (f x) (R_of_nat (NUMERAL O))) /\ (forall x : A, (@IN A x (@setD A v u)) -> ler (R_of_nat (NUMERAL O)) (f x))))) -> ler (@sum A u f) (@sum A v f).
Axiom thm_SUM_SUBSET_SIMPLE : forall {A : Type'}, forall u : A -> Prop, forall v : A -> Prop, forall f : A -> R, ((@finite_set A v) /\ ((@subset A u v) /\ (forall x : A, (@IN A x (@setD A v u)) -> ler (R_of_nat (NUMERAL O)) (f x)))) -> ler (@sum A u f) (@sum A v f).
Axiom thm_SUM_MUL_BOUND : forall {A : Type'}, forall a : A -> R, forall b : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ (forall i : A, (@IN A i s) -> (ler (R_of_nat (NUMERAL O)) (a i)) /\ (ler (R_of_nat (NUMERAL O)) (b i)))) -> ler (@sum A s (fun i : A => mulr (a i) (b i))) (mulr (@sum A s a) (@sum A s b)).
Axiom thm_SUM_IMAGE_NONZERO : forall {A B : Type'}, forall d : B -> R, forall i : A -> B, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((~ (x = y)) /\ ((i x) = (i y))))) -> (d (i x)) = (R_of_nat (NUMERAL O)))) -> (@sum B (@IMAGE A B i s) d) = (@sum A s (@o A B R d i)).
Axiom thm_SUM_BIJECTION : forall {A : Type'}, forall f : A -> R, forall p : A -> A, forall s : A -> Prop, ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall y : A, (@IN A y s) -> @ex1 A (fun x : A => (@IN A x s) /\ ((p x) = y)))) -> (@sum A s f) = (@sum A s (@o A A R f p)).
Axiom thm_SUM_SUM_PRODUCT : forall {A B : Type'}, forall s : A -> Prop, forall t : A -> B -> Prop, forall x : A -> B -> R, ((@finite_set A s) /\ (forall i : A, (@IN A i s) -> @finite_set B (t i))) -> (@sum A s (fun i : A => @sum B (t i) (x i))) = (@sum (prod A B) (@GSPEC (prod A B) (fun GEN_PVAR_329 : prod A B => exists i : A, exists j : B, @SETSPEC (prod A B) GEN_PVAR_329 ((@IN A i s) /\ (@IN B j (t i))) (@pair A B i j))) (@ε ((prod A B) -> R) (fun f : (prod A B) -> R => forall i : A, forall j : B, @eq R (f (@pair A B i j)) (x i j)))).
Axiom thm_SUM_EQ_GENERAL : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> R, forall g : B -> R, forall h : A -> B, ((forall y : B, (@IN B y t) -> @ex1 A (fun x : A => (@IN A x s) /\ ((h x) = y))) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ ((g (h x)) = (f x)))) -> (@sum A s f) = (@sum B t g).
Axiom thm_SUM_EQ_GENERAL_INVERSES : forall {A B : Type'}, forall s : A -> Prop, forall t : B -> Prop, forall f : A -> R, forall g : B -> R, forall h : A -> B, forall k : B -> A, ((forall y : B, (@IN B y t) -> (@IN A (k y) s) /\ ((h (k y)) = y)) /\ (forall x : A, (@IN A x s) -> (@IN B (h x) t) /\ (((k (h x)) = x) /\ ((g (h x)) = (f x))))) -> (@sum A s f) = (@sum B t g).
Axiom thm_SUM_INJECTION : forall {A : Type'}, forall f : A -> R, forall p : A -> A, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, (@IN A x s) -> @IN A (p x) s) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ ((p x) = (p y)))) -> x = y))) -> (@sum A s (@o A A R f p)) = (@sum A s f).
Axiom thm_SUM_UNION_NONZERO : forall {A : Type'}, forall f : A -> R, forall s : A -> Prop, forall t : A -> Prop, ((@finite_set A s) /\ ((@finite_set A t) /\ (forall x : A, (@IN A x (@setI A s t)) -> (f x) = (R_of_nat (NUMERAL O))))) -> (@sum A (@setU A s t) f) = (addr (@sum A s f) (@sum A t f)).
Axiom thm_SUM_UNIONS_NONZERO : forall {A : Type'}, forall f : A -> R, forall s : (A -> Prop) -> Prop, ((@finite_set (A -> Prop) s) /\ ((forall t : A -> Prop, (@IN (A -> Prop) t s) -> @finite_set A t) /\ (forall t1 : A -> Prop, forall t2 : A -> Prop, forall x : A, ((@IN (A -> Prop) t1 s) /\ ((@IN (A -> Prop) t2 s) /\ ((~ (t1 = t2)) /\ ((@IN A x t1) /\ (@IN A x t2))))) -> (f x) = (R_of_nat (NUMERAL O))))) -> (@sum A (@UNIONS A s) f) = (@sum (A -> Prop) s (fun t : A -> Prop => @sum A t f)).
Axiom thm_SUM_CASES : forall {A : Type'}, forall s : A -> Prop, forall P : A -> Prop, forall f : A -> R, forall g : A -> R, (@finite_set A s) -> (@sum A s (fun x : A => @COND R (P x) (f x) (g x))) = (addr (@sum A (@GSPEC A (fun GEN_PVAR_330 : A => exists x : A, @SETSPEC A GEN_PVAR_330 ((@IN A x s) /\ (P x)) x)) f) (@sum A (@GSPEC A (fun GEN_PVAR_331 : A => exists x : A, @SETSPEC A GEN_PVAR_331 ((@IN A x s) /\ (~ (P x))) x)) g)).
Axiom thm_SUM_CASES_1 : forall {A : Type'} (y : R) (f : A -> R), forall s : A -> Prop, forall a : A, ((@finite_set A s) /\ (@IN A a s)) -> (@sum A s (fun x : A => @COND R (x = a) y (f x))) = (addr (@sum A s f) (subr y (f a))).
Axiom thm_SUM_LE_INCLUDED : forall {A B : Type'}, forall f : A -> R, forall g : B -> R, forall s : A -> Prop, forall t : B -> Prop, forall i : B -> A, ((@finite_set A s) /\ ((@finite_set B t) /\ ((forall y : B, (@IN B y t) -> ler (R_of_nat (NUMERAL O)) (g y)) /\ (forall x : A, (@IN A x s) -> exists y : B, (@IN B y t) /\ (((i y) = x) /\ (ler (f x) (g y))))))) -> ler (@sum A s f) (@sum B t g).
Axiom thm_SUM_IMAGE_LE : forall {A B : Type'}, forall f : A -> B, forall g : B -> R, forall s : A -> Prop, ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> ler (R_of_nat (NUMERAL O)) (g (f x)))) -> ler (@sum B (@IMAGE A B f s) g) (@sum A s (@o A B R g f)).
Axiom thm_SUM_CLOSED : forall {A : Type'}, forall P : R -> Prop, forall f : A -> R, forall s : A -> Prop, ((P (R_of_nat (NUMERAL O))) /\ ((forall x : R, forall y : R, ((P x) /\ (P y)) -> P (addr x y)) /\ (forall a : A, (@IN A a s) -> P (f a)))) -> P (@sum A s f).
Axiom thm_SUM_RELATED : forall {A : Type'}, forall R' : R -> R -> Prop, forall f : A -> R, forall g : A -> R, forall s : A -> Prop, ((R' (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL O))) /\ ((forall m : R, forall n : R, forall m' : R, forall n' : R, ((R' m n) /\ (R' m' n')) -> R' (addr m m') (addr n n')) /\ ((@finite_set A s) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x))))) -> R' (@sum A s f) (@sum A s g).
Axiom thm_SUM_CLOSED_NONEMPTY : forall {A : Type'}, forall P : R -> Prop, forall f : A -> R, forall s : A -> Prop, ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ ((forall x : R, forall y : R, ((P x) /\ (P y)) -> P (addr x y)) /\ (forall a : A, (@IN A a s) -> P (f a))))) -> P (@sum A s f).
Axiom thm_SUM_RELATED_NONEMPTY : forall {A : Type'}, forall R' : R -> R -> Prop, forall f : A -> R, forall g : A -> R, forall s : A -> Prop, ((forall m : R, forall n : R, forall m' : R, forall n' : R, ((R' m n) /\ (R' m' n')) -> R' (addr m m') (addr n n')) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (forall x : A, (@IN A x s) -> R' (f x) (g x))))) -> R' (@sum A s f) (@sum A s g).
Axiom thm_REAL_OF_NUM_SUM_GEN : forall {A : Type'}, forall f : A -> nat, forall s : A -> Prop, (@finite_set A (@GSPEC A (fun GEN_PVAR_335 : A => exists i : A, @SETSPEC A GEN_PVAR_335 ((@IN A i s) /\ (~ ((f i) = (NUMERAL O)))) i))) -> (R_of_nat (@nsum A s f)) = (@sum A s (fun x : A => R_of_nat (f x))).
Axiom thm_SUM_ADD_NUMSEG : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun i : nat => addr (f i) (g i))) = (addr (@sum nat (dotdot m n) f) (@sum nat (dotdot m n) g)).
Axiom thm_SUM_SUB_NUMSEG : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun i : nat => subr (f i) (g i))) = (subr (@sum nat (dotdot m n) f) (@sum nat (dotdot m n) g)).
Axiom thm_SUM_LE_NUMSEG : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> ler (f i) (g i)) -> ler (@sum nat (dotdot m n) f) (@sum nat (dotdot m n) g).
Axiom thm_SUM_EQ_NUMSEG : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> (f i) = (g i)) -> (@sum nat (dotdot m n) f) = (@sum nat (dotdot m n) g).
Axiom thm_SUM_ABS_NUMSEG : forall f : nat -> R, forall m : nat, forall n : nat, ler (normr (@sum nat (dotdot m n) f)) (@sum nat (dotdot m n) (fun i : nat => normr (f i))).
Axiom thm_SUM_CONST_NUMSEG : forall c : R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun n' : nat => c)) = (mulr (R_of_nat (subn (addn n (NUMERAL (BIT1 O))) m)) c).
Axiom thm_SUM_EQ_0_NUMSEG : forall f : nat -> R, forall m : nat, forall n : nat, (forall i : nat, ((leqn m i) /\ (leqn i n)) -> (f i) = (R_of_nat (NUMERAL O))) -> (@sum nat (dotdot m n) f) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_TRIV_NUMSEG : forall f : nat -> R, forall m : nat, forall n : nat, (ltn n m) -> (@sum nat (dotdot m n) f) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_POS_LE_NUMSEG : forall m : nat, forall n : nat, forall f : nat -> R, (forall p : nat, ((leqn m p) /\ (leqn p n)) -> ler (R_of_nat (NUMERAL O)) (f p)) -> ler (R_of_nat (NUMERAL O)) (@sum nat (dotdot m n) f).
Axiom thm_SUM_POS_EQ_0_NUMSEG : forall f : nat -> R, forall m : nat, forall n : nat, ((forall p : nat, ((leqn m p) /\ (leqn p n)) -> ler (R_of_nat (NUMERAL O)) (f p)) /\ ((@sum nat (dotdot m n) f) = (R_of_nat (NUMERAL O)))) -> forall p : nat, ((leqn m p) /\ (leqn p n)) -> (f p) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_SING_NUMSEG : forall f : nat -> R, forall n : nat, (@sum nat (dotdot n n) f) = (f n).
Axiom thm_SUM_CLAUSES_NUMSEG : forall (f : nat -> R), (forall m : nat, (@sum nat (dotdot m (NUMERAL O)) f) = (@COND R (m = (NUMERAL O)) (f (NUMERAL O)) (R_of_nat (NUMERAL O)))) /\ (forall m : nat, forall n : nat, (@sum nat (dotdot m (S n)) f) = (@COND R (leqn m (S n)) (addr (@sum nat (dotdot m n) f) (f (S n))) (@sum nat (dotdot m n) f))).
Axiom thm_SUM_CLAUSES_NUMSEG_LT : forall (f : nat -> R), ((@sum nat (@GSPEC nat (fun GEN_PVAR_336 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_336 (ltn i (NUMERAL O)) i)) f) = (R_of_nat (NUMERAL O))) /\ (forall k : nat, (@sum nat (@GSPEC nat (fun GEN_PVAR_337 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_337 (ltn i (S k)) i)) f) = (addr (@sum nat (@GSPEC nat (fun GEN_PVAR_338 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_338 (ltn i k) i)) f) (f k))).
Axiom thm_SUM_CLAUSES_NUMSEG_LE : forall (f : nat -> R), ((@sum nat (@GSPEC nat (fun GEN_PVAR_339 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_339 (leqn i (NUMERAL O)) i)) f) = (f (NUMERAL O))) /\ (forall k : nat, (@sum nat (@GSPEC nat (fun GEN_PVAR_340 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_340 (leqn i (S k)) i)) f) = (addr (@sum nat (@GSPEC nat (fun GEN_PVAR_341 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_341 (leqn i k) i)) f) (f (S k)))).
Axiom thm_SUM_SWAP_NUMSEG : forall a : nat, forall b : nat, forall c : nat, forall d : nat, forall f : nat -> nat -> R, (@sum nat (dotdot a b) (fun i : nat => @sum nat (dotdot c d) (f i))) = (@sum nat (dotdot c d) (fun j : nat => @sum nat (dotdot a b) (fun i : nat => f i j))).
Axiom thm_SUM_ADD_SPLIT : forall f : nat -> R, forall m : nat, forall n : nat, forall p : nat, (leqn m (addn n (NUMERAL (BIT1 O)))) -> (@sum nat (dotdot m (addn n p)) f) = (addr (@sum nat (dotdot m n) f) (@sum nat (dotdot (addn n (NUMERAL (BIT1 O))) (addn n p)) f)).
Axiom thm_SUM_OFFSET_0 : forall f : nat -> R, forall m : nat, forall n : nat, (leqn m n) -> (@sum nat (dotdot m n) f) = (@sum nat (dotdot (NUMERAL O) (subn n m)) (fun i : nat => f (addn i m))).
Axiom thm_SUM_CLAUSES_LEFT : forall f : nat -> R, forall m : nat, forall n : nat, (leqn m n) -> (@sum nat (dotdot m n) f) = (addr (f m) (@sum nat (dotdot (addn m (NUMERAL (BIT1 O))) n) f)).
Axiom thm_SUM_CLAUSES_RIGHT : forall f : nat -> R, forall m : nat, forall n : nat, ((ltn (NUMERAL O) n) /\ (leqn m n)) -> (@sum nat (dotdot m n) f) = (addr (@sum nat (dotdot m (subn n (NUMERAL (BIT1 O)))) f) (f n)).
Axiom thm_SUM_PAIR : forall f : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot (muln (NUMERAL (BIT0 (BIT1 O))) m) (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O)))) f) = (@sum nat (dotdot m n) (fun i : nat => addr (f (muln (NUMERAL (BIT0 (BIT1 O))) i)) (f (addn (muln (NUMERAL (BIT0 (BIT1 O))) i) (NUMERAL (BIT1 O)))))).
Axiom thm_SUM_REFLECT : forall x : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) x) = (@COND R (ltn n m) (R_of_nat (NUMERAL O)) (@sum nat (dotdot (NUMERAL O) (subn n m)) (fun i : nat => x (subn n i)))).
Axiom thm_REAL_OF_NUM_SUM_NUMSEG : forall f : nat -> nat, forall m : nat, forall n : nat, (R_of_nat (@nsum nat (dotdot m n) f)) = (@sum nat (dotdot m n) (fun i : nat => R_of_nat (f i))).
Axiom thm_SUM_PARTIAL_SUC : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun k : nat => mulr (f k) (subr (g (addn k (NUMERAL (BIT1 O)))) (g k)))) = (@COND R (leqn m n) (subr (subr (mulr (f (addn n (NUMERAL (BIT1 O)))) (g (addn n (NUMERAL (BIT1 O))))) (mulr (f m) (g m))) (@sum nat (dotdot m n) (fun k : nat => mulr (g (addn k (NUMERAL (BIT1 O)))) (subr (f (addn k (NUMERAL (BIT1 O)))) (f k))))) (R_of_nat (NUMERAL O))).
Axiom thm_SUM_PARTIAL_PRE : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun k : nat => mulr (f k) (subr (g k) (g (subn k (NUMERAL (BIT1 O))))))) = (@COND R (leqn m n) (subr (subr (mulr (f (addn n (NUMERAL (BIT1 O)))) (g n)) (mulr (f m) (g (subn m (NUMERAL (BIT1 O)))))) (@sum nat (dotdot m n) (fun k : nat => mulr (g k) (subr (f (addn k (NUMERAL (BIT1 O)))) (f k))))) (R_of_nat (NUMERAL O))).
Axiom thm_SUM_DIFFS : forall (f : nat -> R), forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun k : nat => subr (f k) (f (addn k (NUMERAL (BIT1 O)))))) = (@COND R (leqn m n) (subr (f m) (f (addn n (NUMERAL (BIT1 O))))) (R_of_nat (NUMERAL O))).
Axiom thm_SUM_DIFFS_ALT : forall (f : nat -> R), forall m : nat, forall n : nat, (@sum nat (dotdot m n) (fun k : nat => subr (f (addn k (NUMERAL (BIT1 O)))) (f k))) = (@COND R (leqn m n) (subr (f (addn n (NUMERAL (BIT1 O)))) (f m)) (R_of_nat (NUMERAL O))).
Axiom thm_SUM_COMBINE_R : forall f : nat -> R, forall m : nat, forall n : nat, forall p : nat, ((leqn m (addn n (NUMERAL (BIT1 O)))) /\ (leqn n p)) -> (addr (@sum nat (dotdot m n) f) (@sum nat (dotdot (addn n (NUMERAL (BIT1 O))) p) f)) = (@sum nat (dotdot m p) f).
Axiom thm_SUM_COMBINE_L : forall f : nat -> R, forall m : nat, forall n : nat, forall p : nat, ((ltn (NUMERAL O) n) /\ ((leqn m n) /\ (leqn n (addn p (NUMERAL (BIT1 O)))))) -> (addr (@sum nat (dotdot m (subn n (NUMERAL (BIT1 O)))) f) (@sum nat (dotdot n p) f)) = (@sum nat (dotdot m p) f).
Axiom thm_REAL_SUB_POW : forall x : R, forall y : R, forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> (subr (expr x n) (expr y n)) = (mulr (subr x y) (@sum nat (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O)))) (fun i : nat => mulr (expr x i) (expr y (subn (subn n (NUMERAL (BIT1 O))) i))))).
Axiom thm_REAL_SUB_POW_R1 : forall x : R, forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> (subr (expr x n) (R_of_nat (NUMERAL (BIT1 O)))) = (mulr (subr x (R_of_nat (NUMERAL (BIT1 O)))) (@sum nat (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O)))) (fun i : nat => expr x i))).
Axiom thm_REAL_SUB_POW_L1 : forall x : R, forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> (subr (R_of_nat (NUMERAL (BIT1 O))) (expr x n)) = (mulr (subr (R_of_nat (NUMERAL (BIT1 O))) x) (@sum nat (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O)))) (fun i : nat => expr x i))).
Axiom thm_REAL_SUB_POLYFUN : forall a : nat -> R, forall x : R, forall y : R, forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> (subr (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (a i) (expr x i))) (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (a i) (expr y i)))) = (mulr (subr x y) (@sum nat (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O)))) (fun j : nat => mulr (@sum nat (dotdot (addn j (NUMERAL (BIT1 O))) n) (fun i : nat => mulr (a i) (expr y (subn (subn i j) (NUMERAL (BIT1 O)))))) (expr x j)))).
Axiom thm_REAL_SUB_POLYFUN_ALT : forall a : nat -> R, forall x : R, forall y : R, forall n : nat, (leqn (NUMERAL (BIT1 O)) n) -> (subr (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (a i) (expr x i))) (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (a i) (expr y i)))) = (mulr (subr x y) (@sum nat (dotdot (NUMERAL O) (subn n (NUMERAL (BIT1 O)))) (fun j : nat => mulr (@sum nat (dotdot (NUMERAL O) (subn (subn n j) (NUMERAL (BIT1 O)))) (fun k : nat => mulr (a (addn j (addn k (NUMERAL (BIT1 O))))) (expr y k))) (expr x j)))).
Axiom thm_REAL_POLYFUN_ROOTBOUND : forall n : nat, forall c : nat -> R, (~ (forall i : nat, (@IN nat i (dotdot (NUMERAL O) n)) -> (c i) = (R_of_nat (NUMERAL O)))) -> (@finite_set R (@GSPEC R (fun GEN_PVAR_347 : R => exists x : R, @SETSPEC R GEN_PVAR_347 ((@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (c i) (expr x i))) = (R_of_nat (NUMERAL O))) x))) /\ (leqn (@CARD R (@GSPEC R (fun GEN_PVAR_348 : R => exists x : R, @SETSPEC R GEN_PVAR_348 ((@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (c i) (expr x i))) = (R_of_nat (NUMERAL O))) x))) n).
Axiom thm_REAL_POLYFUN_FINITE_ROOTS : forall n : nat, forall c : nat -> R, (@finite_set R (@GSPEC R (fun GEN_PVAR_350 : R => exists x : R, @SETSPEC R GEN_PVAR_350 ((@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (c i) (expr x i))) = (R_of_nat (NUMERAL O))) x))) = (exists i : nat, (@IN nat i (dotdot (NUMERAL O) n)) /\ (~ ((c i) = (R_of_nat (NUMERAL O))))).
Axiom thm_REAL_POLYFUN_EQ_0 : forall n : nat, forall c : nat -> R, (forall x : R, (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (c i) (expr x i))) = (R_of_nat (NUMERAL O))) = (forall i : nat, (@IN nat i (dotdot (NUMERAL O) n)) -> (c i) = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_POLYFUN_EQ_CONST : forall n : nat, forall c : nat -> R, forall k : R, (forall x : R, (@sum nat (dotdot (NUMERAL O) n) (fun i : nat => mulr (c i) (expr x i))) = k) = (((c (NUMERAL O)) = k) /\ (forall i : nat, (@IN nat i (dotdot (NUMERAL (BIT1 O)) n)) -> (c i) = (R_of_nat (NUMERAL O)))).
Axiom thm_polynomial_function : forall p : R -> R, (polynomial_function p) = (exists m : nat, exists c : nat -> R, forall x : R, (p x) = (@sum nat (dotdot (NUMERAL O) m) (fun i : nat => mulr (c i) (expr x i)))).
Axiom thm_POLYNOMIAL_FUNCTION_CONST : forall c : R, polynomial_function (fun x : R => c).
Axiom thm_POLYNOMIAL_FUNCTION_ID : polynomial_function (fun x : R => x).
Axiom thm_POLYNOMIAL_FUNCTION_I : polynomial_function (@I R).
Axiom thm_POLYNOMIAL_FUNCTION_ADD : forall p : R -> R, forall q : R -> R, ((polynomial_function p) /\ (polynomial_function q)) -> polynomial_function (fun x : R => addr (p x) (q x)).
Axiom thm_POLYNOMIAL_FUNCTION_LMUL : forall p : R -> R, forall c : R, (polynomial_function p) -> polynomial_function (fun x : R => mulr c (p x)).
Axiom thm_POLYNOMIAL_FUNCTION_RMUL : forall p : R -> R, forall c : R, (polynomial_function p) -> polynomial_function (fun x : R => mulr (p x) c).
Axiom thm_POLYNOMIAL_FUNCTION_NEG : forall p : R -> R, (polynomial_function (fun x : R => oppr (p x))) = (polynomial_function p).
Axiom thm_POLYNOMIAL_FUNCTION_SUB : forall p : R -> R, forall q : R -> R, ((polynomial_function p) /\ (polynomial_function q)) -> polynomial_function (fun x : R => subr (p x) (q x)).
Axiom thm_POLYNOMIAL_FUNCTION_MUL : forall p : R -> R, forall q : R -> R, ((polynomial_function p) /\ (polynomial_function q)) -> polynomial_function (fun x : R => mulr (p x) (q x)).
Axiom thm_POLYNOMIAL_FUNCTION_SUM : forall {A : Type'}, forall s : A -> Prop, forall p : R -> A -> R, ((@finite_set A s) /\ (forall i : A, (@IN A i s) -> polynomial_function (fun x : R => p x i))) -> polynomial_function (fun x : R => @sum A s (p x)).
Axiom thm_POLYNOMIAL_FUNCTION_POW : forall p : R -> R, forall n : nat, (polynomial_function p) -> polynomial_function (fun x : R => expr (p x) n).
Axiom thm_POLYNOMIAL_FUNCTION_INDUCT : forall P : (R -> R) -> Prop, ((P (fun x : R => x)) /\ ((forall c : R, P (fun x : R => c)) /\ ((forall p : R -> R, forall q : R -> R, ((P p) /\ (P q)) -> P (fun x : R => addr (p x) (q x))) /\ (forall p : R -> R, forall q : R -> R, ((P p) /\ (P q)) -> P (fun x : R => mulr (p x) (q x)))))) -> forall p : R -> R, (polynomial_function p) -> P p.
Axiom thm_POLYNOMIAL_FUNCTION_o : forall p : R -> R, forall q : R -> R, ((polynomial_function p) /\ (polynomial_function q)) -> polynomial_function (@o R R R p q).
Axiom thm_POLYNOMIAL_FUNCTION_FINITE_ROOTS : forall p : R -> R, forall a : R, (polynomial_function p) -> (@finite_set R (@GSPEC R (fun GEN_PVAR_353 : R => exists x : R, @SETSPEC R GEN_PVAR_353 ((p x) = a) x))) = (~ (forall x : R, (p x) = a)).
Axiom thm_dimindex : forall {A : Type'}, forall s : A -> Prop, (@dimindex A s) = (@COND nat (@finite_set A (@setT A)) (@CARD A (@setT A)) (NUMERAL (BIT1 O))).
Axiom thm_DIMINDEX_NONZERO : forall {A : Type'}, forall s : A -> Prop, ~ ((@dimindex A s) = (NUMERAL O)).
Axiom thm_DIMINDEX_GE_1 : forall {A : Type'}, forall s : A -> Prop, leqn (NUMERAL (BIT1 O)) (@dimindex A s).
Axiom thm_DIMINDEX_UNIV : forall {A : Type'}, forall s : A -> Prop, (@dimindex A s) = (@dimindex A (@setT A)).
Axiom thm_DIMINDEX_UNIQUE : forall {A : Type'} (n : nat), (@HAS_SIZE A (@setT A) n) -> (@dimindex A (@setT A)) = n.
Axiom thm_UNIV_HAS_SIZE_DIMINDEX : forall {N' : Type'}, (@HAS_SIZE N' (@setT N') (@dimindex N' (@setT N'))) = (@finite_set N' (@setT N')).
Axiom thm_HAS_SIZE_1 : @HAS_SIZE unit (@setT unit) (NUMERAL (BIT1 O)).
Axiom thm_NUMSEG_LT_DIMINDEX : forall {N' : Type'}, (@GSPEC nat (fun GEN_PVAR_354 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_354 (ltn i (@dimindex N' (@setT N'))) i)) = (dotdot (NUMERAL O) (subn (@dimindex N' (@setT N')) (NUMERAL (BIT1 O)))).
Axiom thm_FINITE_IMAGE_IMAGE : forall {A : Type'}, (@setT (finite_image A)) = (@IMAGE nat (finite_image A) (@finite_index A) (dotdot (NUMERAL (BIT1 O)) (@dimindex A (@setT A)))).
Axiom thm_HAS_SIZE_FINITE_IMAGE : forall {A : Type'}, forall s : A -> Prop, @HAS_SIZE (finite_image A) (@setT (finite_image A)) (@dimindex A s).
Axiom thm_CARD_FINITE_IMAGE : forall {A : Type'}, forall s : A -> Prop, (@CARD (finite_image A) (@setT (finite_image A))) = (@dimindex A s).
Axiom thm_FINITE_FINITE_IMAGE : forall {A : Type'}, @finite_set (finite_image A) (@setT (finite_image A)).
Axiom thm_DIMINDEX_FINITE_IMAGE : forall {A : Type'}, forall s : (finite_image A) -> Prop, forall t : A -> Prop, (@dimindex (finite_image A) s) = (@dimindex A t).
Axiom thm_FINITE_INDEX_WORKS : forall {A : Type'}, forall i : finite_image A, @ex1 nat (fun n : nat => (leqn (NUMERAL (BIT1 O)) n) /\ ((leqn n (@dimindex A (@setT A))) /\ ((@finite_index A n) = i))).
Axiom thm_FINITE_INDEX_INJ : forall {A : Type'}, forall i : nat, forall j : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ ((leqn i (@dimindex A (@setT A))) /\ ((leqn (NUMERAL (BIT1 O)) j) /\ (leqn j (@dimindex A (@setT A)))))) -> ((@finite_index A i) = (@finite_index A j)) = (i = j).
Axiom thm_FORALL_FINITE_INDEX : forall {N' : Type'} (P : (finite_image N') -> Prop), (forall k : finite_image N', P k) = (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> P (@finite_index N' i)).
Axiom thm_finite_index : forall {A N' : Type'}, forall x : cart A N', forall i : nat, (@dollar A N' x i) = (@dest_cart A N' x (@finite_index N' i)).
Axiom thm_CART_EQ : forall {A B : Type'}, forall x : cart A B, forall y : cart A B, (x = y) = (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B x i) = (@dollar A B y i)).
Axiom thm_lambda : forall {A B : Type'}, forall g : nat -> A, (@lambda A B g) = (@ε (cart A B) (fun f : cart A B => forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B f i) = (g i))).
Axiom thm_LAMBDA_BETA : forall {A B : Type'} (g : nat -> A), forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B (@lambda A B g) i) = (g i).
Axiom thm_LAMBDA_UNIQUE : forall {A B : Type'}, forall f : cart A B, forall g : nat -> A, (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B f i) = (g i)) = ((@lambda A B g) = f).
Axiom thm_LAMBDA_ETA : forall {A B : Type'}, forall g : cart A B, (@lambda A B (fun i : nat => @dollar A B g i)) = g.
Axiom thm_FINITE_INDEX_INRANGE : forall {A N' : Type'}, forall i : nat, exists k : nat, (leqn (NUMERAL (BIT1 O)) k) /\ ((leqn k (@dimindex N' (@setT N'))) /\ (forall x : cart A N', (@dollar A N' x i) = (@dollar A N' x k))).
Axiom thm_FINITE_INDEX_INRANGE_2 : forall {A B N' : Type'}, forall i : nat, exists k : nat, (leqn (NUMERAL (BIT1 O)) k) /\ ((leqn k (@dimindex N' (@setT N'))) /\ ((forall x : cart A N', (@dollar A N' x i) = (@dollar A N' x k)) /\ (forall y : cart B N', (@dollar B N' y i) = (@dollar B N' y k)))).
Axiom thm_CART_EQ_FULL : forall {A N' : Type'}, forall x : cart A N', forall y : cart A N', (x = y) = (forall i : nat, (@dollar A N' x i) = (@dollar A N' y i)).
Axiom thm_pastecart : forall {A M N' : Type'}, forall f : cart A M, forall g : cart A N', (@pastecart A M N' f g) = (@lambda A (finite_sum M N') (fun i : nat => @COND A (leqn i (@dimindex M (@setT M))) (@dollar A M f i) (@dollar A N' g (subn i (@dimindex M (@setT M)))))).
Axiom thm_fstcart : forall {A M N' : Type'}, forall f : cart A (finite_sum M N'), (@fstcart A M N' f) = (@lambda A M (fun i : nat => @dollar A (finite_sum M N') f i)).
Axiom thm_sndcart : forall {A M N' : Type'}, forall f : cart A (finite_sum M N'), (@sndcart A M N' f) = (@lambda A N' (fun i : nat => @dollar A (finite_sum M N') f (addn i (@dimindex M (@setT M))))).
Axiom thm_FINITE_SUM_IMAGE : forall {A B : Type'}, (@setT (finite_sum A B)) = (@IMAGE nat (finite_sum A B) (@mk_finite_sum A B) (dotdot (NUMERAL (BIT1 O)) (addn (@dimindex A (@setT A)) (@dimindex B (@setT B))))).
Axiom thm_DIMINDEX_HAS_SIZE_FINITE_SUM : forall {M N' : Type'}, @HAS_SIZE (finite_sum M N') (@setT (finite_sum M N')) (addn (@dimindex M (@setT M)) (@dimindex N' (@setT N'))).
Axiom thm_DIMINDEX_FINITE_SUM : forall {M N' : Type'}, (@dimindex (finite_sum M N') (@setT (finite_sum M N'))) = (addn (@dimindex M (@setT M)) (@dimindex N' (@setT N'))).
Axiom thm_FSTCART_PASTECART : forall {A M N' : Type'}, forall x : cart A M, forall y : cart A N', (@fstcart A M N' (@pastecart A M N' x y)) = x.
Axiom thm_SNDCART_PASTECART : forall {A M N' : Type'}, forall x : cart A M, forall y : cart A N', (@sndcart A M N' (@pastecart A M N' x y)) = y.
Axiom thm_PASTECART_FST_SND : forall {A M N' : Type'}, forall z : cart A (finite_sum M N'), (@pastecart A M N' (@fstcart A M N' z) (@sndcart A M N' z)) = z.
Axiom thm_PASTECART_EQ : forall {A M N' : Type'}, forall x : cart A (finite_sum M N'), forall y : cart A (finite_sum M N'), (x = y) = (((@fstcart A M N' x) = (@fstcart A M N' y)) /\ ((@sndcart A M N' x) = (@sndcart A M N' y))).
Axiom thm_FORALL_PASTECART : forall {A M N' : Type'} (P : (cart A (finite_sum M N')) -> Prop), (forall p : cart A (finite_sum M N'), P p) = (forall x : cart A M, forall y : cart A N', P (@pastecart A M N' x y)).
Axiom thm_EXISTS_PASTECART : forall {A M N' : Type'} (P : (cart A (finite_sum M N')) -> Prop), (exists p : cart A (finite_sum M N'), P p) = (exists x : cart A M, exists y : cart A N', P (@pastecart A M N' x y)).
Axiom thm_PASTECART_INJ : forall {A M N' : Type'}, forall x : cart A M, forall y : cart A N', forall w : cart A M, forall z : cart A N', ((@pastecart A M N' x y) = (@pastecart A M N' w z)) = ((x = w) /\ (y = z)).
Axiom thm_FSTCART_COMPONENT : forall {A M N' : Type'}, forall x : cart A (finite_sum M N'), forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex M (@setT M)))) -> (@dollar A M (@fstcart A M N' x) i) = (@dollar A (finite_sum M N') x i).
Axiom thm_SNDCART_COMPONENT : forall {A M N' : Type'}, forall x : cart A (finite_sum M N'), forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> (@dollar A N' (@sndcart A M N' x) i) = (@dollar A (finite_sum M N') x (addn i (@dimindex M (@setT M)))).
Axiom thm_PASTECART_COMPONENT : forall {A M N' : Type'}, (forall u : cart A M, forall v : cart A N', forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex M (@setT M)))) -> (@dollar A (finite_sum M N') (@pastecart A M N' u v) i) = (@dollar A M u i)) /\ (forall u : cart A M, forall v : cart A N', forall i : nat, ((leqn (addn (@dimindex M (@setT M)) (NUMERAL (BIT1 O))) i) /\ (leqn i (addn (@dimindex M (@setT M)) (@dimindex N' (@setT N'))))) -> (@dollar A (finite_sum M N') (@pastecart A M N' u v) i) = (@dollar A N' v (subn i (@dimindex M (@setT M))))).
Axiom thm_FINITE_DIFF_IMAGE : forall {A B : Type'}, (@setT (finite_diff A B)) = (@IMAGE nat (finite_diff A B) (@mk_finite_diff A B) (dotdot (NUMERAL (BIT1 O)) (@COND nat (ltn (@dimindex B (@setT B)) (@dimindex A (@setT A))) (subn (@dimindex A (@setT A)) (@dimindex B (@setT B))) (NUMERAL (BIT1 O))))).
Axiom thm_DIMINDEX_HAS_SIZE_FINITE_DIFF : forall {M N' : Type'}, @HAS_SIZE (finite_diff M N') (@setT (finite_diff M N')) (@COND nat (ltn (@dimindex N' (@setT N')) (@dimindex M (@setT M))) (subn (@dimindex M (@setT M)) (@dimindex N' (@setT N'))) (NUMERAL (BIT1 O))).
Axiom thm_DIMINDEX_FINITE_DIFF : forall {M N' : Type'}, (@dimindex (finite_diff M N') (@setT (finite_diff M N'))) = (@COND nat (ltn (@dimindex N' (@setT N')) (@dimindex M (@setT M))) (subn (@dimindex M (@setT M)) (@dimindex N' (@setT N'))) (NUMERAL (BIT1 O))).
Axiom thm_FINITE_PROD_IMAGE : forall {A B : Type'}, (@setT (finite_prod A B)) = (@IMAGE nat (finite_prod A B) (@mk_finite_prod A B) (dotdot (NUMERAL (BIT1 O)) (muln (@dimindex A (@setT A)) (@dimindex B (@setT B))))).
Axiom thm_DIMINDEX_HAS_SIZE_FINITE_PROD : forall {M N' : Type'}, @HAS_SIZE (finite_prod M N') (@setT (finite_prod M N')) (muln (@dimindex M (@setT M)) (@dimindex N' (@setT N'))).
Axiom thm_DIMINDEX_FINITE_PROD : forall {M N' : Type'}, (@dimindex (finite_prod M N') (@setT (finite_prod M N'))) = (muln (@dimindex M (@setT M)) (@dimindex N' (@setT N'))).
Axiom thm_tybit0_INDUCT : forall {A : Type'}, forall P : (tybit0 A) -> Prop, (forall a : finite_sum A A, P (@mktybit0 A a)) -> forall x : tybit0 A, P x.
Axiom thm_tybit0_RECURSION : forall {A Z' : Type'}, forall f : (finite_sum A A) -> Z', exists fn : (tybit0 A) -> Z', forall a : finite_sum A A, (fn (@mktybit0 A a)) = (f a).
Axiom thm_tybit1_INDUCT : forall {A : Type'}, forall P : (tybit1 A) -> Prop, (forall a : finite_sum (finite_sum A A) unit, P (@mktybit1 A a)) -> forall x : tybit1 A, P x.
Axiom thm_tybit1_RECURSION : forall {A Z' : Type'}, forall f : (finite_sum (finite_sum A A) unit) -> Z', exists fn : (tybit1 A) -> Z', forall a : finite_sum (finite_sum A A) unit, (fn (@mktybit1 A a)) = (f a).
Axiom thm_HAS_SIZE_TYBIT0 : forall {A : Type'}, @HAS_SIZE (tybit0 A) (@setT (tybit0 A)) (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A))).
Axiom thm_HAS_SIZE_TYBIT1 : forall {A : Type'}, @HAS_SIZE (tybit1 A) (@setT (tybit1 A)) (addn (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A))) (NUMERAL (BIT1 O))).
Axiom thm_DIMINDEX_TYBIT0 : forall {A : Type'}, (@dimindex (tybit0 A) (@setT (tybit0 A))) = (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A))).
Axiom thm_DIMINDEX_TYBIT1 : forall {A : Type'}, (@dimindex (tybit1 A) (@setT (tybit1 A))) = (addn (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A))) (NUMERAL (BIT1 O))).
Axiom thm_DIMINDEX_CLAUSES : forall {A : Type'}, ((@dimindex unit (@setT unit)) = (NUMERAL (BIT1 O))) /\ (((@dimindex (tybit0 A) (@setT (tybit0 A))) = (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A)))) /\ ((@dimindex (tybit1 A) (@setT (tybit1 A))) = (addn (muln (NUMERAL (BIT0 (BIT1 O))) (@dimindex A (@setT A))) (NUMERAL (BIT1 O))))).
Axiom thm_FINITE_1 : @finite_set unit (@setT unit).
Axiom thm_FINITE_TYBIT0 : forall {A : Type'}, @finite_set (tybit0 A) (@setT (tybit0 A)).
Axiom thm_FINITE_TYBIT1 : forall {A : Type'}, @finite_set (tybit1 A) (@setT (tybit1 A)).
Axiom thm_FINITE_CLAUSES : forall {A : Type'}, (@finite_set unit (@setT unit)) /\ ((@finite_set (tybit0 A) (@setT (tybit0 A))) /\ (@finite_set (tybit1 A) (@setT (tybit1 A)))).
Axiom thm_DIMINDEX_2 : (@dimindex (tybit0 unit) (@setT (tybit0 unit))) = (NUMERAL (BIT0 (BIT1 O))).
Axiom thm_DIMINDEX_3 : (@dimindex (tybit1 unit) (@setT (tybit1 unit))) = (NUMERAL (BIT1 (BIT1 O))).
Axiom thm_DIMINDEX_4 : (@dimindex (tybit0 (tybit0 unit)) (@setT (tybit0 (tybit0 unit)))) = (NUMERAL (BIT0 (BIT0 (BIT1 O)))).
Axiom thm_FINITE_CART : forall {A N' : Type'}, forall P : nat -> A -> Prop, (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> @finite_set A (@GSPEC A (fun GEN_PVAR_360 : A => exists x : A, @SETSPEC A GEN_PVAR_360 (P i x) x))) -> @finite_set (cart A N') (@GSPEC (cart A N') (fun GEN_PVAR_361 : cart A N' => exists v : cart A N', @SETSPEC (cart A N') GEN_PVAR_361 (forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex N' (@setT N')))) -> P i (@dollar A N' v i)) v)).
Axiom thm_HAS_SIZE_CART_UNIV : forall {A N' : Type'}, forall m : nat, (@HAS_SIZE A (@setT A) m) -> @HAS_SIZE (cart A N') (@setT (cart A N')) (expn m (@dimindex N' (@setT N'))).
Axiom thm_CARD_CART_UNIV : forall {A N' : Type'}, (@finite_set A (@setT A)) -> (@CARD (cart A N') (@setT (cart A N'))) = (expn (@CARD A (@setT A)) (@dimindex N' (@setT N'))).
Axiom thm_FINITE_CART_UNIV : forall {A N' : Type'}, (@finite_set A (@setT A)) -> @finite_set (cart A N') (@setT (cart A N')).
Axiom thm_vector : forall {A N' : Type'}, forall l : seq A, (@vector A N' l) = (@lambda A N' (fun i : nat => @EL A (subn i (NUMERAL (BIT1 O))) l)).
Axiom thm_IN_ELIM_PASTECART_THM : forall {A M N' : Type'}, forall P : (cart A M) -> (cart A N') -> Prop, forall a : cart A M, forall b : cart A N', (@IN (cart A (finite_sum M N')) (@pastecart A M N' a b) (@GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_362 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_362 (P x y) (@pastecart A M N' x y)))) = (P a b).
Axiom thm_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, (@PCROSS A M N' s t) = (@GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x s) /\ (@IN (cart A N') y t)) (@pastecart A M N' x y))).
Axiom thm_FORALL_IN_PCROSS : forall {A M N' : Type'} (s : (cart A M) -> Prop) (t : (cart A N') -> Prop) (P : (cart A (finite_sum M N')) -> Prop), (forall z : cart A (finite_sum M N'), (@IN (cart A (finite_sum M N')) z (@PCROSS A M N' s t)) -> P z) = (forall x : cart A M, forall y : cart A N', ((@IN (cart A M) x s) /\ (@IN (cart A N') y t)) -> P (@pastecart A M N' x y)).
Axiom thm_EXISTS_IN_PCROSS : forall {A M N' : Type'} (s : (cart A M) -> Prop) (t : (cart A N') -> Prop) (P : (cart A (finite_sum M N')) -> Prop), (exists z : cart A (finite_sum M N'), (@IN (cart A (finite_sum M N')) z (@PCROSS A M N' s t)) /\ (P z)) = (exists x : cart A M, exists y : cart A N', (@IN (cart A M) x s) /\ ((@IN (cart A N') y t) /\ (P (@pastecart A M N' x y)))).
Axiom thm_PASTECART_IN_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall x : cart A M, forall y : cart A N', (@IN (cart A (finite_sum M N')) (@pastecart A M N' x y) (@PCROSS A M N' s t)) = ((@IN (cart A M) x s) /\ (@IN (cart A N') y t)).
Axiom thm_PCROSS_EQ_EMPTY : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, ((@PCROSS A M N' s t) = (@set0 (cart A (finite_sum M N')))) = ((s = (@set0 (cart A M))) \/ (t = (@set0 (cart A N')))).
Axiom thm_PCROSS_EMPTY : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, (@PCROSS A M N' s (@set0 (cart A N'))) = (@set0 (cart A (finite_sum M N')))) /\ (forall t : (cart A N') -> Prop, (@PCROSS A M N' (@set0 (cart A M)) t) = (@set0 (cart A (finite_sum M N')))).
Axiom thm_PCROSS_SING : forall {A M N' : Type'}, forall x : cart A M, forall y : cart A N', (@PCROSS A M N' (@INSERT (cart A M) x (@set0 (cart A M))) (@INSERT (cart A N') y (@set0 (cart A N')))) = (@INSERT (cart A (finite_sum M N')) (@pastecart A M N' x y) (@set0 (cart A (finite_sum M N')))).
Axiom thm_SUBSET_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall s' : (cart A M) -> Prop, forall t' : (cart A N') -> Prop, (@subset (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s' t')) = ((s = (@set0 (cart A M))) \/ ((t = (@set0 (cart A N'))) \/ ((@subset (cart A M) s s') /\ (@subset (cart A N') t t')))).
Axiom thm_PCROSS_MONO : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall s' : (cart A M) -> Prop, forall t' : (cart A N') -> Prop, ((@subset (cart A M) s s') /\ (@subset (cart A N') t t')) -> @subset (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s' t').
Axiom thm_PCROSS_EQ : forall {M N' : Type'}, forall s : (cart R M) -> Prop, forall s' : (cart R M) -> Prop, forall t : (cart R N') -> Prop, forall t' : (cart R N') -> Prop, ((@PCROSS R M N' s t) = (@PCROSS R M N' s' t')) = ((((s = (@set0 (cart R M))) \/ (t = (@set0 (cart R N')))) /\ ((s' = (@set0 (cart R M))) \/ (t' = (@set0 (cart R N'))))) \/ ((s = s') /\ (t = t'))).
Axiom thm_UNIV_PCROSS_UNIV : forall {A M N' : Type'}, (@PCROSS A M N' (@setT (cart A M)) (@setT (cart A N'))) = (@setT (cart A (finite_sum M N'))).
Axiom thm_HAS_SIZE_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE (cart A M) s m) /\ (@HAS_SIZE (cart A N') t n)) -> @HAS_SIZE (cart A (finite_sum M N')) (@PCROSS A M N' s t) (muln m n).
Axiom thm_FINITE_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, ((@finite_set (cart A M) s) /\ (@finite_set (cart A N') t)) -> @finite_set (cart A (finite_sum M N')) (@PCROSS A M N' s t).
Axiom thm_FINITE_PCROSS_EQ : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, (@finite_set (cart A (finite_sum M N')) (@PCROSS A M N' s t)) = ((s = (@set0 (cart A M))) \/ ((t = (@set0 (cart A N'))) \/ ((@finite_set (cart A M) s) /\ (@finite_set (cart A N') t)))).
Axiom thm_IMAGE_FSTCART_PCROSS : forall {M N' : Type'}, forall s : (cart R M) -> Prop, forall t : (cart R N') -> Prop, (@IMAGE (cart R (finite_sum M N')) (cart R M) (@fstcart R M N') (@PCROSS R M N' s t)) = (@COND ((cart R M) -> Prop) (t = (@set0 (cart R N'))) (@set0 (cart R M)) s).
Axiom thm_IMAGE_SNDCART_PCROSS : forall {M N' : Type'}, forall s : (cart R M) -> Prop, forall t : (cart R N') -> Prop, (@IMAGE (cart R (finite_sum M N')) (cart R N') (@sndcart R M N') (@PCROSS R M N' s t)) = (@COND ((cart R N') -> Prop) (s = (@set0 (cart R M))) (@set0 (cart R N')) t).
Axiom thm_PCROSS_INTER : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' s (@setI (cart A N') t u)) = (@setI (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s u))) /\ (forall s : (cart A M) -> Prop, forall t : (cart A M) -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' (@setI (cart A M) s t) u) = (@setI (cart A (finite_sum M N')) (@PCROSS A M N' s u) (@PCROSS A M N' t u))).
Axiom thm_PCROSS_UNION : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' s (@setU (cart A N') t u)) = (@setU (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s u))) /\ (forall s : (cart A M) -> Prop, forall t : (cart A M) -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' (@setU (cart A M) s t) u) = (@setU (cart A (finite_sum M N')) (@PCROSS A M N' s u) (@PCROSS A M N' t u))).
Axiom thm_PCROSS_DIFF : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' s (@setD (cart A N') t u)) = (@setD (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s u))) /\ (forall s : (cart A M) -> Prop, forall t : (cart A M) -> Prop, forall u : (cart A N') -> Prop, (@PCROSS A M N' (@setD (cart A M) s t) u) = (@setD (cart A (finite_sum M N')) (@PCROSS A M N' s u) (@PCROSS A M N' t u))).
Axiom thm_INTER_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall s' : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall t' : (cart A N') -> Prop, (@setI (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s' t')) = (@PCROSS A M N' (@setI (cart A M) s s') (@setI (cart A N') t t')).
Axiom thm_PCROSS_UNIONS : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, forall f : ((cart A N') -> Prop) -> Prop, (@PCROSS A M N' s (@UNIONS (cart A N') f)) = (@UNIONS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_365 : (cart A (finite_sum M N')) -> Prop => exists t : (cart A N') -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_365 (@IN ((cart A N') -> Prop) t f) (@PCROSS A M N' s t))))) /\ (forall f : ((cart A M) -> Prop) -> Prop, forall t : (cart A N') -> Prop, (@PCROSS A M N' (@UNIONS (cart A M) f) t) = (@UNIONS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_366 : (cart A (finite_sum M N')) -> Prop => exists s : (cart A M) -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_366 (@IN ((cart A M) -> Prop) s f) (@PCROSS A M N' s t))))).
Axiom thm_PCROSS_UNIONS_UNIONS : forall {A M N' : Type'}, forall f : ((cart A M) -> Prop) -> Prop, forall g : ((cart A N') -> Prop) -> Prop, (@PCROSS A M N' (@UNIONS (cart A M) f) (@UNIONS (cart A N') g)) = (@UNIONS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_364 : (cart A (finite_sum M N')) -> Prop => exists s : (cart A M) -> Prop, exists t : (cart A N') -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_364 ((@IN ((cart A M) -> Prop) s f) /\ (@IN ((cart A N') -> Prop) t g)) (@PCROSS A M N' s t)))).
Axiom thm_PCROSS_INTERS : forall {A M N' : Type'}, (forall s : (cart A M) -> Prop, forall f : ((cart A N') -> Prop) -> Prop, (@PCROSS A M N' s (@INTERS (cart A N') f)) = (@COND ((cart A (finite_sum M N')) -> Prop) (f = (@set0 ((cart A N') -> Prop))) (@PCROSS A M N' s (@setT (cart A N'))) (@INTERS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_370 : (cart A (finite_sum M N')) -> Prop => exists t : (cart A N') -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_370 (@IN ((cart A N') -> Prop) t f) (@PCROSS A M N' s t)))))) /\ (forall f : ((cart A M) -> Prop) -> Prop, forall t : (cart A N') -> Prop, (@PCROSS A M N' (@INTERS (cart A M) f) t) = (@COND ((cart A (finite_sum M N')) -> Prop) (f = (@set0 ((cart A M) -> Prop))) (@PCROSS A M N' (@setT (cart A M)) t) (@INTERS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_371 : (cart A (finite_sum M N')) -> Prop => exists s : (cart A M) -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_371 (@IN ((cart A M) -> Prop) s f) (@PCROSS A M N' s t)))))).
Axiom thm_PCROSS_INTERS_INTERS : forall {A M N' : Type'}, forall f : ((cart A M) -> Prop) -> Prop, forall g : ((cart A N') -> Prop) -> Prop, (@PCROSS A M N' (@INTERS (cart A M) f) (@INTERS (cart A N') g)) = (@COND ((cart A (finite_sum M N')) -> Prop) (f = (@set0 ((cart A M) -> Prop))) (@INTERS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_367 : (cart A (finite_sum M N')) -> Prop => exists t : (cart A N') -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_367 (@IN ((cart A N') -> Prop) t g) (@PCROSS A M N' (@setT (cart A M)) t)))) (@COND ((cart A (finite_sum M N')) -> Prop) (g = (@set0 ((cart A N') -> Prop))) (@INTERS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_368 : (cart A (finite_sum M N')) -> Prop => exists s : (cart A M) -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_368 (@IN ((cart A M) -> Prop) s f) (@PCROSS A M N' s (@setT (cart A N')))))) (@INTERS (cart A (finite_sum M N')) (@GSPEC ((cart A (finite_sum M N')) -> Prop) (fun GEN_PVAR_369 : (cart A (finite_sum M N')) -> Prop => exists s : (cart A M) -> Prop, exists t : (cart A N') -> Prop, @SETSPEC ((cart A (finite_sum M N')) -> Prop) GEN_PVAR_369 ((@IN ((cart A M) -> Prop) s f) /\ (@IN ((cart A N') -> Prop) t g)) (@PCROSS A M N' s t)))))).
Axiom thm_DISJOINT_PCROSS : forall {A M N' : Type'}, forall s : (cart A M) -> Prop, forall t : (cart A N') -> Prop, forall s' : (cart A M) -> Prop, forall t' : (cart A N') -> Prop, (@DISJOINT (cart A (finite_sum M N')) (@PCROSS A M N' s t) (@PCROSS A M N' s' t')) = ((@DISJOINT (cart A M) s s') \/ (@DISJOINT (cart A N') t t')).
Axiom thm_CASEWISE_DEF : forall {_138002 _138038 _138042 _138043 : Type'} (h : prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) (t : seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) (f : _138043) (x : _138042), ((@CASEWISE _138002 _138038 _138042 _138043 (@nil (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) f x) = (@ε _138002 (fun y : _138002 => True))) /\ ((@CASEWISE _138002 _138038 _138042 _138043 (@cons (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) h t) f x) = (@COND _138002 (exists y : _138038, (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x) (@snd (_138038 -> _138042) (_138043 -> _138038 -> _138002) h f (@ε _138038 (fun y : _138038 => (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x))) (@CASEWISE _138002 _138038 _138042 _138043 t f x))).
Axiom thm_CASEWISE : forall {_138054 _138062 _138063 _138102 _138103 _138105 : Type'} (t : _138103 -> _138105 -> _138063) (s : _138105 -> _138102) (clauses : seq (prod (_138105 -> _138102) (_138103 -> _138105 -> _138063))) (f : _138103) (x : _138102), ((@CASEWISE _138062 _138054 _138102 _138103 (@nil (prod (_138054 -> _138102) (_138103 -> _138054 -> _138062))) f x) = (@ε _138062 (fun y : _138062 => True))) /\ ((@CASEWISE _138063 _138105 _138102 _138103 (@cons (prod (_138105 -> _138102) (_138103 -> _138105 -> _138063)) (@pair (_138105 -> _138102) (_138103 -> _138105 -> _138063) s t) clauses) f x) = (@COND _138063 (exists y : _138105, (s y) = x) (t f (@ε _138105 (fun y : _138105 => (s y) = x))) (@CASEWISE _138063 _138105 _138102 _138103 clauses f x))).
Axiom thm_CASEWISE_CASES : forall {_138194 _138195 _138197 _138204 : Type'}, forall clauses : seq (prod (_138197 -> _138194) (_138195 -> _138197 -> _138204)), forall c : _138195, forall x : _138194, (exists s : _138197 -> _138194, exists t : _138195 -> _138197 -> _138204, exists a : _138197, (@MEM (prod (_138197 -> _138194) (_138195 -> _138197 -> _138204)) (@pair (_138197 -> _138194) (_138195 -> _138197 -> _138204) s t) clauses) /\ (((s a) = x) /\ ((@CASEWISE _138204 _138197 _138194 _138195 clauses c x) = (t c a)))) \/ ((~ (exists s : _138197 -> _138194, exists t : _138195 -> _138197 -> _138204, exists a : _138197, (@MEM (prod (_138197 -> _138194) (_138195 -> _138197 -> _138204)) (@pair (_138197 -> _138194) (_138195 -> _138197 -> _138204) s t) clauses) /\ ((s a) = x))) /\ ((@CASEWISE _138204 _138197 _138194 _138195 clauses c x) = (@ε _138204 (fun y : _138204 => True)))).
Axiom thm_CASEWISE_WORKS : forall {A B C P : Type'}, forall clauses : seq (prod (P -> A) (C -> P -> B)), forall c : C, (forall s : P -> A, forall t : C -> P -> B, forall s' : P -> A, forall t' : C -> P -> B, forall x : P, forall y : P, ((@MEM (prod (P -> A) (C -> P -> B)) (@pair (P -> A) (C -> P -> B) s t) clauses) /\ ((@MEM (prod (P -> A) (C -> P -> B)) (@pair (P -> A) (C -> P -> B) s' t') clauses) /\ ((s x) = (s' y)))) -> (t c x) = (t' c y)) -> @ALL (prod (P -> A) (C -> P -> B)) (@ε ((prod (P -> A) (C -> P -> B)) -> Prop) (fun f : (prod (P -> A) (C -> P -> B)) -> Prop => forall s : P -> A, forall t : C -> P -> B, @eq Prop (f (@pair (P -> A) (C -> P -> B) s t)) (forall x : P, (@CASEWISE B P A C clauses c (s x)) = (t c x)))) clauses.
Axiom thm_admissible : forall {_138333 _138336 _138340 _138341 _138346 : Type'}, forall p : (_138340 -> _138336) -> _138346 -> Prop, forall lt2' : _138340 -> _138333 -> Prop, forall s : _138346 -> _138333, forall t : (_138340 -> _138336) -> _138346 -> _138341, (@admissible _138333 _138336 _138340 _138341 _138346 lt2' p s t) = (forall f : _138340 -> _138336, forall g : _138340 -> _138336, forall a : _138346, ((p f a) /\ ((p g a) /\ (forall z : _138340, (lt2' z (s a)) -> (f z) = (g z)))) -> (t f a) = (t g a)).
Axiom thm_tailadmissible : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall s : P -> A, forall p : (A -> B) -> P -> Prop, forall t : (A -> B) -> P -> B, (@tailadmissible A B P lt2' p s t) = (exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (lt2' y (G f a))) -> lt2' y (s a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (lt2' z (s a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (p f a) -> (t f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Axiom thm_superadmissible : forall {_138490 _138492 _138498 : Type'}, forall lt2' : _138490 -> _138490 -> Prop, forall p : (_138490 -> _138492) -> _138498 -> Prop, forall s : _138498 -> _138490, forall t : (_138490 -> _138492) -> _138498 -> _138492, (@superadmissible _138490 _138492 _138498 lt2' p s t) = ((@admissible _138490 _138492 _138490 Prop _138498 lt2' (fun f : _138490 -> _138492 => fun a : _138498 => True) s p) -> @tailadmissible _138490 _138492 _138498 lt2' p s t).
Axiom thm_MATCH_SEQPATTERN : forall {_138526 _138533 : Type'} (r : _138533 -> _138526 -> Prop) (x : _138533) (s : _138533 -> _138526 -> Prop), (@_MATCH _138533 _138526 x (@_SEQPATTERN _138533 _138526 r s)) = (@COND _138526 (exists y : _138526, r x y) (@_MATCH _138533 _138526 x r) (@_MATCH _138533 _138526 x s)).
Axiom thm_ADMISSIBLE_CONST : forall {_138553 _138554 _138555 _138556 _138557 : Type'} (lt2' : _138554 -> _138553 -> Prop), forall p : (_138554 -> _138555) -> _138556 -> Prop, forall s : _138556 -> _138553, forall c : _138556 -> _138557, @admissible _138553 _138555 _138554 _138557 _138556 lt2' p s (fun f : _138554 -> _138555 => c).
Axiom thm_ADMISSIBLE_BASE : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall t : P -> A, (forall f : A -> B, forall a : P, (p f a) -> lt2' (t a) (s a)) -> @admissible A B A B P lt2' p s (fun f : A -> B => fun x : P => f (t x)).
Axiom thm_ADMISSIBLE_COMB : forall {A B C D P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall g : (A -> B) -> P -> C -> D, forall y : (A -> B) -> P -> C, ((@admissible A B A (C -> D) P lt2' p s g) /\ (@admissible A B A C P lt2' p s y)) -> @admissible A B A D P lt2' p s (fun f : A -> B => fun x : P => g f x (y f x)).
Axiom thm_ADMISSIBLE_RAND : forall {A B C D P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall g : P -> C -> D, forall y : (A -> B) -> P -> C, (@admissible A B A C P lt2' p s y) -> @admissible A B A D P lt2' p s (fun f : A -> B => fun x : P => g x (y f x)).
Axiom thm_ADMISSIBLE_LAMBDA : forall {A B C P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall t : (A -> B) -> C -> P -> Prop, (@admissible A B A Prop (prod C P) lt2' (fun f : A -> B => @ε ((prod C P) -> Prop) (fun f' : (prod C P) -> Prop => forall u : C, forall x : P, @eq Prop (f' (@pair C P u x)) (p f x))) (@ε ((prod C P) -> A) (fun f : (prod C P) -> A => forall u : C, forall x : P, @eq A (f (@pair C P u x)) (s x))) (fun f : A -> B => @ε ((prod C P) -> Prop) (fun f' : (prod C P) -> Prop => forall u : C, forall x : P, @eq Prop (f' (@pair C P u x)) (t f u x)))) -> @admissible A B A (C -> Prop) P lt2' p s (fun f : A -> B => fun x : P => fun u : C => t f u x).
Axiom thm_ADMISSIBLE_NEST : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall t : (A -> B) -> P -> A, ((@admissible A B A A P lt2' p s t) /\ (forall f : A -> B, forall a : P, (p f a) -> lt2' (t f a) (s a))) -> @admissible A B A B P lt2' p s (fun f : A -> B => fun x : P => f (t f x)).
Axiom thm_ADMISSIBLE_COND : forall {_138890 _138891 _138922 _138947 P : Type'}, forall lt2' : _138891 -> _138890 -> Prop, forall p : (_138891 -> _138922) -> P -> Prop, forall P' : (_138891 -> _138922) -> P -> Prop, forall s : P -> _138890, forall h : (_138891 -> _138922) -> P -> _138947, forall k : (_138891 -> _138922) -> P -> _138947, ((@admissible _138890 _138922 _138891 Prop P lt2' p s P') /\ ((@admissible _138890 _138922 _138891 _138947 P lt2' (fun f : _138891 -> _138922 => fun x : P => (p f x) /\ (P' f x)) s h) /\ (@admissible _138890 _138922 _138891 _138947 P lt2' (fun f : _138891 -> _138922 => fun x : P => (p f x) /\ (~ (P' f x))) s k))) -> @admissible _138890 _138922 _138891 _138947 P lt2' p s (fun f : _138891 -> _138922 => fun x : P => @COND _138947 (P' f x) (h f x) (k f x)).
Axiom thm_ADMISSIBLE_MATCH : forall {_138988 _138989 _138990 _139022 _139025 P : Type'}, forall lt2' : _138989 -> _138988 -> Prop, forall p : (_138989 -> _138990) -> P -> Prop, forall s : P -> _138988, forall e : (_138989 -> _138990) -> P -> _139025, forall c : (_138989 -> _138990) -> P -> _139025 -> _139022 -> Prop, ((@admissible _138988 _138990 _138989 _139025 P lt2' p s e) /\ (@admissible _138988 _138990 _138989 (_139022 -> Prop) P lt2' p s (fun f : _138989 -> _138990 => fun x : P => c f x (e f x)))) -> @admissible _138988 _138990 _138989 _139022 P lt2' p s (fun f : _138989 -> _138990 => fun x : P => @_MATCH _139025 _139022 (e f x) (c f x)).
Axiom thm_ADMISSIBLE_SEQPATTERN : forall {_139065 _139066 _139128 _139144 _139154 P : Type'}, forall lt2' : _139066 -> _139065 -> Prop, forall p : (_139066 -> _139128) -> P -> Prop, forall s : P -> _139065, forall c1 : (_139066 -> _139128) -> P -> _139154 -> _139144 -> Prop, forall c2 : (_139066 -> _139128) -> P -> _139154 -> _139144 -> Prop, forall e : (_139066 -> _139128) -> P -> _139154, ((@admissible _139065 _139128 _139066 Prop P lt2' p s (fun f : _139066 -> _139128 => fun x : P => exists y : _139144, c1 f x (e f x) y)) /\ ((@admissible _139065 _139128 _139066 (_139144 -> Prop) P lt2' (fun f : _139066 -> _139128 => fun x : P => (p f x) /\ (exists y : _139144, c1 f x (e f x) y)) s (fun f : _139066 -> _139128 => fun x : P => c1 f x (e f x))) /\ (@admissible _139065 _139128 _139066 (_139144 -> Prop) P lt2' (fun f : _139066 -> _139128 => fun x : P => (p f x) /\ (~ (exists y : _139144, c1 f x (e f x) y))) s (fun f : _139066 -> _139128 => fun x : P => c2 f x (e f x))))) -> @admissible _139065 _139128 _139066 (_139144 -> Prop) P lt2' p s (fun f : _139066 -> _139128 => fun x : P => @_SEQPATTERN _139154 _139144 (c1 f x) (c2 f x) (e f x)).
Axiom thm_ADMISSIBLE_UNGUARDED_PATTERN : forall {_139239 _139240 _139287 _139320 _139327 P : Type'}, forall lt2' : _139240 -> _139239 -> Prop, forall p : (_139240 -> _139287) -> P -> Prop, forall s : P -> _139239, forall pat : (_139240 -> _139287) -> P -> _139320, forall e : (_139240 -> _139287) -> P -> _139320, forall t : (_139240 -> _139287) -> P -> _139327, forall y : (_139240 -> _139287) -> P -> _139327, ((@admissible _139239 _139287 _139240 _139320 P lt2' p s pat) /\ ((@admissible _139239 _139287 _139240 _139320 P lt2' p s e) /\ ((@admissible _139239 _139287 _139240 _139327 P lt2' (fun f : _139240 -> _139287 => fun x : P => (p f x) /\ ((pat f x) = (e f x))) s t) /\ (@admissible _139239 _139287 _139240 _139327 P lt2' (fun f : _139240 -> _139287 => fun x : P => (p f x) /\ ((pat f x) = (e f x))) s y)))) -> @admissible _139239 _139287 _139240 Prop P lt2' p s (fun f : _139240 -> _139287 => fun x : P => and (@eq _139320 (pat f x) (e f x)) (@eq _139327 (t f x) (y f x))).
Axiom thm_ADMISSIBLE_GUARDED_PATTERN : forall {_139413 _139414 _139491 _139529 _139538 P : Type'}, forall lt2' : _139414 -> _139413 -> Prop, forall p : (_139414 -> _139491) -> P -> Prop, forall s : P -> _139413, forall pat : (_139414 -> _139491) -> P -> _139529, forall q : (_139414 -> _139491) -> P -> Prop, forall e : (_139414 -> _139491) -> P -> _139529, forall t : (_139414 -> _139491) -> P -> _139538, forall y : (_139414 -> _139491) -> P -> _139538, ((@admissible _139413 _139491 _139414 _139529 P lt2' p s pat) /\ ((@admissible _139413 _139491 _139414 _139529 P lt2' p s e) /\ ((@admissible _139413 _139491 _139414 _139538 P lt2' (fun f : _139414 -> _139491 => fun x : P => (p f x) /\ (((pat f x) = (e f x)) /\ (q f x))) s t) /\ ((@admissible _139413 _139491 _139414 Prop P lt2' (fun f : _139414 -> _139491 => fun x : P => (p f x) /\ ((pat f x) = (e f x))) s q) /\ (@admissible _139413 _139491 _139414 _139538 P lt2' (fun f : _139414 -> _139491 => fun x : P => (p f x) /\ (((pat f x) = (e f x)) /\ (q f x))) s y))))) -> @admissible _139413 _139491 _139414 Prop P lt2' p s (fun f : _139414 -> _139491 => fun x : P => _GUARDED_PATTERN (@eq _139529 (pat f x) (e f x)) (q f x) (@eq _139538 (t f x) (y f x))).
Axiom thm_ADMISSIBLE_NSUM : forall {A B C P : Type'}, forall lt2' : B -> A -> Prop, forall p : (B -> C) -> P -> Prop, forall s : P -> A, forall h : (B -> C) -> P -> nat -> nat, forall a : P -> nat, forall b : P -> nat, (@admissible A C B nat (prod nat P) lt2' (fun f : B -> C => @ε ((prod nat P) -> Prop) (fun f' : (prod nat P) -> Prop => forall k : nat, forall x : P, @eq Prop (f' (@pair nat P k x)) ((leqn (a x) k) /\ ((leqn k (b x)) /\ (p f x))))) (@ε ((prod nat P) -> A) (fun f : (prod nat P) -> A => forall k : nat, forall x : P, @eq A (f (@pair nat P k x)) (s x))) (fun f : B -> C => @ε ((prod nat P) -> nat) (fun f' : (prod nat P) -> nat => forall k : nat, forall x : P, @eq nat (f' (@pair nat P k x)) (h f x k)))) -> @admissible A C B nat P lt2' p s (fun f : B -> C => fun x : P => @nsum nat (dotdot (a x) (b x)) (h f x)).
Axiom thm_ADMISSIBLE_SUM : forall {A B C P : Type'}, forall lt2' : B -> A -> Prop, forall p : (B -> C) -> P -> Prop, forall s : P -> A, forall h : (B -> C) -> P -> nat -> R, forall a : P -> nat, forall b : P -> nat, (@admissible A C B R (prod nat P) lt2' (fun f : B -> C => @ε ((prod nat P) -> Prop) (fun f' : (prod nat P) -> Prop => forall k : nat, forall x : P, @eq Prop (f' (@pair nat P k x)) ((leqn (a x) k) /\ ((leqn k (b x)) /\ (p f x))))) (@ε ((prod nat P) -> A) (fun f : (prod nat P) -> A => forall k : nat, forall x : P, @eq A (f (@pair nat P k x)) (s x))) (fun f : B -> C => @ε ((prod nat P) -> R) (fun f' : (prod nat P) -> R => forall k : nat, forall x : P, @eq R (f' (@pair nat P k x)) (h f x k)))) -> @admissible A C B R P lt2' p s (fun f : B -> C => fun x : P => @sum nat (dotdot (a x) (b x)) (h f x)).
Axiom thm_ADMISSIBLE_MAP : forall {_139831 _139840 _139846 A B P : Type'}, forall lt2' : A -> _139831 -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> _139831, forall h : (A -> B) -> P -> _139846 -> _139840, forall l : (A -> B) -> P -> seq _139846, ((@admissible _139831 B A (seq _139846) P lt2' p s l) /\ (@admissible _139831 B A _139840 (prod _139846 P) lt2' (fun f : A -> B => @ε ((prod _139846 P) -> Prop) (fun f' : (prod _139846 P) -> Prop => forall y : _139846, forall x : P, @eq Prop (f' (@pair _139846 P y x)) ((p f x) /\ (@MEM _139846 y (l f x))))) (@ε ((prod _139846 P) -> _139831) (fun f : (prod _139846 P) -> _139831 => forall y : _139846, forall x : P, @eq _139831 (f (@pair _139846 P y x)) (s x))) (fun f : A -> B => @ε ((prod _139846 P) -> _139840) (fun f' : (prod _139846 P) -> _139840 => forall y : _139846, forall x : P, @eq _139840 (f' (@pair _139846 P y x)) (h f x y))))) -> @admissible _139831 B A (seq _139840) P lt2' p s (fun f : A -> B => fun x : P => @map _139846 _139840 (h f x) (l f x)).
Axiom thm_ADMISSIBLE_MATCH_SEQPATTERN : forall {_139903 _139904 _139969 _139993 _140024 P : Type'}, forall lt2' : _139904 -> _139903 -> Prop, forall p : (_139904 -> _139969) -> P -> Prop, forall s : P -> _139903, forall c1 : (_139904 -> _139969) -> P -> _140024 -> _139993 -> Prop, forall c2 : (_139904 -> _139969) -> P -> _140024 -> _139993 -> Prop, forall e : (_139904 -> _139969) -> P -> _140024, ((@admissible _139903 _139969 _139904 Prop P lt2' p s (fun f : _139904 -> _139969 => fun x : P => exists y : _139993, c1 f x (e f x) y)) /\ ((@admissible _139903 _139969 _139904 _139993 P lt2' (fun f : _139904 -> _139969 => fun x : P => (p f x) /\ (exists y : _139993, c1 f x (e f x) y)) s (fun f : _139904 -> _139969 => fun x : P => @_MATCH _140024 _139993 (e f x) (c1 f x))) /\ (@admissible _139903 _139969 _139904 _139993 P lt2' (fun f : _139904 -> _139969 => fun x : P => (p f x) /\ (~ (exists y : _139993, c1 f x (e f x) y))) s (fun f : _139904 -> _139969 => fun x : P => @_MATCH _140024 _139993 (e f x) (c2 f x))))) -> @admissible _139903 _139969 _139904 _139993 P lt2' p s (fun f : _139904 -> _139969 => fun x : P => @_MATCH _140024 _139993 (e f x) (@_SEQPATTERN _140024 _139993 (c1 f x) (c2 f x))).
Axiom thm_ADMISSIBLE_IMP_SUPERADMISSIBLE : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall t : (A -> B) -> P -> B, (@admissible A B A B P lt2' p s t) -> @superadmissible A B P lt2' p s t.
Axiom thm_SUPERADMISSIBLE_CONST : forall {_140103 _140104 _140105 : Type'} (lt2' : _140103 -> _140103 -> Prop), forall p : (_140103 -> _140105) -> _140104 -> Prop, forall s : _140104 -> _140103, forall c : _140104 -> _140105, @superadmissible _140103 _140105 _140104 lt2' p s (fun f : _140103 -> _140105 => c).
Axiom thm_SUPERADMISSIBLE_TAIL : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall t : (A -> B) -> P -> A, ((@admissible A B A A P lt2' p s t) /\ (forall f : A -> B, forall a : P, (p f a) -> forall y : A, (lt2' y (t f a)) -> lt2' y (s a))) -> @superadmissible A B P lt2' p s (fun f : A -> B => fun x : P => f (t f x)).
Axiom thm_SUPERADMISSIBLE_COND : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall P' : (A -> B) -> P -> Prop, forall s : P -> A, forall h : (A -> B) -> P -> B, forall k : (A -> B) -> P -> B, ((@admissible A B A Prop P lt2' p s P') /\ ((@superadmissible A B P lt2' (fun f : A -> B => fun x : P => (p f x) /\ (P' f x)) s h) /\ (@superadmissible A B P lt2' (fun f : A -> B => fun x : P => (p f x) /\ (~ (P' f x))) s k))) -> @superadmissible A B P lt2' p s (fun f : A -> B => fun x : P => @COND B (P' f x) (h f x) (k f x)).
Axiom thm_SUPERADMISSIBLE_MATCH_SEQPATTERN : forall {_140424 _140539 _140540 P : Type'}, forall lt2' : _140424 -> _140424 -> Prop, forall p : (_140424 -> _140540) -> P -> Prop, forall s : P -> _140424, forall c1 : (_140424 -> _140540) -> P -> _140539 -> _140540 -> Prop, forall c2 : (_140424 -> _140540) -> P -> _140539 -> _140540 -> Prop, forall e : (_140424 -> _140540) -> P -> _140539, ((@admissible _140424 _140540 _140424 Prop P lt2' p s (fun f : _140424 -> _140540 => fun x : P => exists y : _140540, c1 f x (e f x) y)) /\ ((@superadmissible _140424 _140540 P lt2' (fun f : _140424 -> _140540 => fun x : P => (p f x) /\ (exists y : _140540, c1 f x (e f x) y)) s (fun f : _140424 -> _140540 => fun x : P => @_MATCH _140539 _140540 (e f x) (c1 f x))) /\ (@superadmissible _140424 _140540 P lt2' (fun f : _140424 -> _140540 => fun x : P => (p f x) /\ (~ (exists y : _140540, c1 f x (e f x) y))) s (fun f : _140424 -> _140540 => fun x : P => @_MATCH _140539 _140540 (e f x) (c2 f x))))) -> @superadmissible _140424 _140540 P lt2' p s (fun f : _140424 -> _140540 => fun x : P => @_MATCH _140539 _140540 (e f x) (@_SEQPATTERN _140539 _140540 (c1 f x) (c2 f x))).
Axiom thm_SUPERADMISSIBLE_MATCH_UNGUARDED_PATTERN : forall {A B D P Q : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall e : P -> D, forall pat : Q -> D, forall arg : P -> Q -> A, ((forall f : A -> B, forall a : P, forall t : Q, forall u : Q, ((p f a) /\ (((pat t) = (e a)) /\ ((pat u) = (e a)))) -> (arg a t) = (arg a u)) /\ (forall f : A -> B, forall a : P, forall t : Q, ((p f a) /\ ((pat t) = (e a))) -> forall y : A, (lt2' y (arg a t)) -> lt2' y (s a))) -> @superadmissible A B P lt2' p s (fun f : A -> B => fun x : P => @_MATCH D B (e x) (fun u : D => fun v : B => exists t : Q, and (@eq D (pat t) u) (@eq B (f (arg x t)) v))).
Axiom thm_SUPERADMISSIBLE_MATCH_GUARDED_PATTERN : forall {A B D P Q : Type'}, forall lt2' : A -> A -> Prop, forall p : (A -> B) -> P -> Prop, forall s : P -> A, forall e : P -> D, forall pat : Q -> D, forall q : P -> Q -> Prop, forall arg : P -> Q -> A, ((forall f : A -> B, forall a : P, forall t : Q, forall u : Q, ((p f a) /\ (((pat t) = (e a)) /\ ((q a t) /\ (((pat u) = (e a)) /\ (q a u))))) -> (arg a t) = (arg a u)) /\ (forall f : A -> B, forall a : P, forall t : Q, ((p f a) /\ ((q a t) /\ ((pat t) = (e a)))) -> forall y : A, (lt2' y (arg a t)) -> lt2' y (s a))) -> @superadmissible A B P lt2' p s (fun f : A -> B => fun x : P => @_MATCH D B (e x) (fun u : D => fun v : B => exists t : Q, _GUARDED_PATTERN (@eq D (pat t) u) (q x t) (@eq B (f (arg x t)) v))).
Axiom thm_WF_REC_CASES : forall {A B P : Type'}, forall lt2' : A -> A -> Prop, forall clauses : seq (prod (P -> A) ((A -> B) -> P -> B)), ((@well_founded A lt2') /\ (@ALL (prod (P -> A) ((A -> B) -> P -> B)) (@ε ((prod (P -> A) ((A -> B) -> P -> B)) -> Prop) (fun f : (prod (P -> A) ((A -> B) -> P -> B)) -> Prop => forall s : P -> A, forall t : (A -> B) -> P -> B, @eq Prop (f (@pair (P -> A) ((A -> B) -> P -> B) s t)) (exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f' : A -> B, forall a : P, forall y : A, ((P' f' a) /\ (lt2' y (G f' a))) -> lt2' y (s a)) /\ ((forall f' : A -> B, forall g : A -> B, forall a : P, (forall z : A, (lt2' z (s a)) -> (f' z) = (g z)) -> ((P' f' a) = (P' g a)) /\ (((G f' a) = (G g a)) /\ ((H f' a) = (H g a)))) /\ (forall f' : A -> B, forall a : P, (t f' a) = (@COND B (P' f' a) (f' (G f' a)) (H f' a))))))) clauses)) -> exists f : A -> B, forall x : A, (f x) = (@CASEWISE B P A (A -> B) clauses f x).
Axiom thm_RECURSION_CASEWISE : forall {A B P : Type'}, forall clauses : seq (prod (P -> A) ((A -> B) -> P -> B)), ((exists lt2' : A -> A -> Prop, (@well_founded A lt2') /\ (@ALL (prod (P -> A) ((A -> B) -> P -> B)) (@ε ((prod (P -> A) ((A -> B) -> P -> B)) -> Prop) (fun f : (prod (P -> A) ((A -> B) -> P -> B)) -> Prop => forall s : P -> A, forall t : (A -> B) -> P -> B, @eq Prop (f (@pair (P -> A) ((A -> B) -> P -> B) s t)) (@tailadmissible A B P lt2' (fun f' : A -> B => fun a : P => True) s t))) clauses)) /\ (forall s : P -> A, forall t : (A -> B) -> P -> B, forall s' : P -> A, forall t' : (A -> B) -> P -> B, forall f : A -> B, forall x : P, forall y : P, ((@MEM (prod (P -> A) ((A -> B) -> P -> B)) (@pair (P -> A) ((A -> B) -> P -> B) s t) clauses) /\ (@MEM (prod (P -> A) ((A -> B) -> P -> B)) (@pair (P -> A) ((A -> B) -> P -> B) s' t') clauses)) -> ((s x) = (s' y)) -> (t f x) = (t' f y))) -> exists f : A -> B, @ALL (prod (P -> A) ((A -> B) -> P -> B)) (@ε ((prod (P -> A) ((A -> B) -> P -> B)) -> Prop) (fun f' : (prod (P -> A) ((A -> B) -> P -> B)) -> Prop => forall s : P -> A, forall t : (A -> B) -> P -> B, @eq Prop (f' (@pair (P -> A) ((A -> B) -> P -> B) s t)) (forall x : P, (f (s x)) = (t f x)))) clauses.
Axiom thm_RECURSION_CASEWISE_PAIRWISE : forall {_141763 _141779 _141783 : Type'}, forall clauses : seq (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)), ((exists lt2' : _141763 -> _141763 -> Prop, (@well_founded _141763 lt2') /\ (@ALL (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) (@ε ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (fun f : (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop => forall s : _141783 -> _141763, forall t : (_141763 -> _141779) -> _141783 -> _141779, @eq Prop (f (@pair (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779) s t)) (@tailadmissible _141763 _141779 _141783 lt2' (fun f' : _141763 -> _141779 => fun a : _141783 => True) s t))) clauses)) /\ ((@ALL (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) (@ε ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (fun f : (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop => forall s : _141783 -> _141763, forall t : (_141763 -> _141779) -> _141783 -> _141779, @eq Prop (f (@pair (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779) s t)) (forall f' : _141763 -> _141779, forall x : _141783, forall y : _141783, ((s x) = (s y)) -> (t f' x) = (t f' y)))) clauses) /\ (@PAIRWISE (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) (@ε ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (fun f : (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop => forall s : _141783 -> _141763, forall t : (_141763 -> _141779) -> _141783 -> _141779, @eq ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (f (@pair (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779) s t)) (@ε ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (fun f' : (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop => forall s' : _141783 -> _141763, forall t' : (_141763 -> _141779) -> _141783 -> _141779, @eq Prop (f' (@pair (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779) s' t')) (forall f'' : _141763 -> _141779, forall x : _141783, forall y : _141783, ((s x) = (s' y)) -> (t f'' x) = (t' f'' y)))))) clauses))) -> exists f : _141763 -> _141779, @ALL (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) (@ε ((prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop) (fun f' : (prod (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779)) -> Prop => forall s : _141783 -> _141763, forall t : (_141763 -> _141779) -> _141783 -> _141779, @eq Prop (f' (@pair (_141783 -> _141763) ((_141763 -> _141779) -> _141783 -> _141779) s t)) (forall x : _141783, (f (s x)) = (t f x)))) clauses.
Axiom thm_SUPERADMISSIBLE_T : forall {_141893 _141895 _141899 : Type'} (lt2' : _141893 -> _141893 -> Prop) (s : _141899 -> _141893) (t : (_141893 -> _141895) -> _141899 -> _141895), (@superadmissible _141893 _141895 _141899 lt2' (fun f : _141893 -> _141895 => fun x : _141899 => True) s t) = (@tailadmissible _141893 _141895 _141899 lt2' (fun f : _141893 -> _141895 => fun x : _141899 => True) s t).
Axiom thm_F_IMP : forall t : Prop, (~ t) -> t -> False.
Axiom thm_LEFT_AND_OVER_OR : forall t1 : Prop, forall t2 : Prop, forall t3 : Prop, (t1 /\ (t2 \/ t3)) = ((t1 /\ t2) \/ (t1 /\ t3)).
Axiom thm_RIGHT_AND_OVER_OR : forall t1 : Prop, forall t2 : Prop, forall t3 : Prop, ((t2 \/ t3) /\ t1) = ((t2 /\ t1) \/ (t3 /\ t1)).
Axiom thm_SUC_SUB1 : forall m : nat, (subn (S m) (NUMERAL (BIT1 O))) = m.
Axiom thm_SUB_SUB : forall b : nat, forall c : nat, (leqn c b) -> forall a : nat, (subn a (subn b c)) = (subn (addn a c) b).
Axiom thm_SUB_OLD : (forall m : nat, (subn (NUMERAL O) m) = (NUMERAL O)) /\ (forall m : nat, forall n : nat, (subn (S m) n) = (@COND nat (ltn m n) (NUMERAL O) (S (subn m n)))).
Axiom thm_real_le : forall x : R, forall y : R, (ler x y) = (~ (ltr y x)).
Axiom thm_REAL_MUL_RID : forall x : R, (mulr x (R_of_nat (NUMERAL (BIT1 O)))) = x.
Axiom thm_REAL_MUL_RINV : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (mulr x (invr x)) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_RDISTRIB : forall x : R, forall y : R, forall z : R, (mulr (addr x y) z) = (addr (mulr x z) (mulr y z)).
Axiom thm_REAL_EQ_LADD : forall x : R, forall y : R, forall z : R, ((addr x y) = (addr x z)) = (y = z).
Axiom thm_REAL_EQ_RADD : forall x : R, forall y : R, forall z : R, ((addr x z) = (addr y z)) = (x = y).
Axiom thm_REAL_ADD_LID_UNIQ : forall x : R, forall y : R, ((addr x y) = y) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_ADD_RID_UNIQ : forall x : R, forall y : R, ((addr x y) = x) = (y = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_LNEG_UNIQ : forall x : R, forall y : R, ((addr x y) = (R_of_nat (NUMERAL O))) = (x = (oppr y)).
Axiom thm_REAL_RNEG_UNIQ : forall x : R, forall y : R, ((addr x y) = (R_of_nat (NUMERAL O))) = (y = (oppr x)).
Axiom thm_REAL_NEG_ADD : forall x : R, forall y : R, (oppr (addr x y)) = (addr (oppr x) (oppr y)).
Axiom thm_REAL_MUL_LZERO : forall x : R, (mulr (R_of_nat (NUMERAL O)) x) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_MUL_RZERO : forall x : R, (mulr x (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_NEG_LMUL : forall x : R, forall y : R, (oppr (mulr x y)) = (mulr (oppr x) y).
Axiom thm_REAL_NEG_RMUL : forall x : R, forall y : R, (oppr (mulr x y)) = (mulr x (oppr y)).
Axiom thm_REAL_NEG_NEG : forall x : R, (oppr (oppr x)) = x.
Axiom thm_REAL_NEG_MUL2 : forall x : R, forall y : R, (mulr (oppr x) (oppr y)) = (mulr x y).
Axiom thm_REAL_LT_LADD : forall x : R, forall y : R, forall z : R, (ltr (addr x y) (addr x z)) = (ltr y z).
Axiom thm_REAL_LT_RADD : forall x : R, forall y : R, forall z : R, (ltr (addr x z) (addr y z)) = (ltr x y).
Axiom thm_REAL_NOT_LT : forall x : R, forall y : R, (~ (ltr x y)) = (ler y x).
Axiom thm_REAL_LT_ANTISYM : forall x : R, forall y : R, ~ ((ltr x y) /\ (ltr y x)).
Axiom thm_REAL_LT_GT : forall x : R, forall y : R, (ltr x y) -> ~ (ltr y x).
Axiom thm_REAL_NOT_LE : forall x : R, forall y : R, (~ (ler x y)) = (ltr y x).
Axiom thm_REAL_LE_TOTAL : forall x : R, forall y : R, (ler x y) \/ (ler y x).
Axiom thm_REAL_LE_REFL : forall x : R, ler x x.
Axiom thm_REAL_LE_LT : forall x : R, forall y : R, (ler x y) = ((ltr x y) \/ (x = y)).
Axiom thm_REAL_LT_LE : forall x : R, forall y : R, (ltr x y) = ((ler x y) /\ (~ (x = y))).
Axiom thm_REAL_LT_IMP_LE : forall x : R, forall y : R, (ltr x y) -> ler x y.
Axiom thm_REAL_LTE_TRANS : forall x : R, forall y : R, forall z : R, ((ltr x y) /\ (ler y z)) -> ltr x z.
Axiom thm_REAL_LE_TRANS : forall x : R, forall y : R, forall z : R, ((ler x y) /\ (ler y z)) -> ler x z.
Axiom thm_REAL_NEG_LT0 : forall x : R, (ltr (oppr x) (R_of_nat (NUMERAL O))) = (ltr (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_NEG_GT0 : forall x : R, (ltr (R_of_nat (NUMERAL O)) (oppr x)) = (ltr x (R_of_nat (NUMERAL O))).
Axiom thm_REAL_NEG_LE0 : forall x : R, (ler (oppr x) (R_of_nat (NUMERAL O))) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_NEG_GE0 : forall x : R, (ler (R_of_nat (NUMERAL O)) (oppr x)) = (ler x (R_of_nat (NUMERAL O))).
Axiom thm_REAL_LT_NEGTOTAL : forall x : R, (x = (R_of_nat (NUMERAL O))) \/ ((ltr (R_of_nat (NUMERAL O)) x) \/ (ltr (R_of_nat (NUMERAL O)) (oppr x))).
Axiom thm_REAL_LE_NEGTOTAL : forall x : R, (ler (R_of_nat (NUMERAL O)) x) \/ (ler (R_of_nat (NUMERAL O)) (oppr x)).
Axiom thm_REAL_LE_MUL : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler (R_of_nat (NUMERAL O)) y)) -> ler (R_of_nat (NUMERAL O)) (mulr x y).
Axiom thm_REAL_LE_SQUARE : forall x : R, ler (R_of_nat (NUMERAL O)) (mulr x x).
Axiom thm_REAL_LT_01 : ltr (R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_LE_LADD : forall x : R, forall y : R, forall z : R, (ler (addr x y) (addr x z)) = (ler y z).
Axiom thm_REAL_LE_RADD : forall x : R, forall y : R, forall z : R, (ler (addr x z) (addr y z)) = (ler x y).
Axiom thm_REAL_LT_ADD2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ltr w x) /\ (ltr y z)) -> ltr (addr w y) (addr x z).
Axiom thm_REAL_LT_ADD : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr (R_of_nat (NUMERAL O)) y)) -> ltr (R_of_nat (NUMERAL O)) (addr x y).
Axiom thm_REAL_LT_ADDNEG : forall x : R, forall y : R, forall z : R, (ltr y (addr x (oppr z))) = (ltr (addr y z) x).
Axiom thm_REAL_LT_ADDNEG2 : forall x : R, forall y : R, forall z : R, (ltr (addr x (oppr y)) z) = (ltr x (addr z y)).
Axiom thm_REAL_LT_ADD1 : forall x : R, forall y : R, (ler x y) -> ltr x (addr y (R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_REAL_SUB_ADD : forall x : R, forall y : R, (addr (subr x y) y) = x.
Axiom thm_REAL_SUB_ADD2 : forall x : R, forall y : R, (addr y (subr x y)) = x.
Axiom thm_REAL_SUB_REFL : forall x : R, (subr x x) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_SUB_0 : forall x : R, forall y : R, ((subr x y) = (R_of_nat (NUMERAL O))) = (x = y).
Axiom thm_REAL_LE_DOUBLE : forall x : R, (ler (R_of_nat (NUMERAL O)) (addr x x)) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_LE_NEGL : forall x : R, (ler (oppr x) x) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_LE_NEGR : forall x : R, (ler x (oppr x)) = (ler x (R_of_nat (NUMERAL O))).
Axiom thm_REAL_NEG_EQ0 : forall x : R, ((oppr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_NEG_0 : (oppr (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_NEG_SUB : forall x : R, forall y : R, (oppr (subr x y)) = (subr y x).
Axiom thm_REAL_SUB_LT : forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) (subr x y)) = (ltr y x).
Axiom thm_REAL_SUB_LE : forall x : R, forall y : R, (ler (R_of_nat (NUMERAL O)) (subr x y)) = (ler y x).
Axiom thm_REAL_EQ_LMUL : forall x : R, forall y : R, forall z : R, ((mulr x y) = (mulr x z)) = ((x = (R_of_nat (NUMERAL O))) \/ (y = z)).
Axiom thm_REAL_EQ_RMUL : forall x : R, forall y : R, forall z : R, ((mulr x z) = (mulr y z)) = ((z = (R_of_nat (NUMERAL O))) \/ (x = y)).
Axiom thm_REAL_SUB_LDISTRIB : forall x : R, forall y : R, forall z : R, (mulr x (subr y z)) = (subr (mulr x y) (mulr x z)).
Axiom thm_REAL_SUB_RDISTRIB : forall x : R, forall y : R, forall z : R, (mulr (subr x y) z) = (subr (mulr x z) (mulr y z)).
Axiom thm_REAL_NEG_EQ : forall x : R, forall y : R, ((oppr x) = y) = (x = (oppr y)).
Axiom thm_REAL_NEG_MINUS1 : forall x : R, (oppr x) = (mulr (oppr (R_of_nat (NUMERAL (BIT1 O)))) x).
Axiom thm_REAL_INV_NZ : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> ~ ((invr x) = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_INVINV : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (invr (invr x)) = x.
Axiom thm_REAL_LT_IMP_NE : forall x : R, forall y : R, (ltr x y) -> ~ (x = y).
Axiom thm_REAL_INV_POS : forall x : R, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (invr x).
Axiom thm_REAL_LT_LMUL_0 : forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) x) -> (ltr (R_of_nat (NUMERAL O)) (mulr x y)) = (ltr (R_of_nat (NUMERAL O)) y).
Axiom thm_REAL_LT_RMUL_0 : forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL O)) y) -> (ltr (R_of_nat (NUMERAL O)) (mulr x y)) = (ltr (R_of_nat (NUMERAL O)) x).
Axiom thm_REAL_LT_LMUL_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) x) -> (ltr (mulr x y) (mulr x z)) = (ltr y z).
Axiom thm_REAL_LT_RMUL_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr (mulr x z) (mulr y z)) = (ltr x y).
Axiom thm_REAL_LT_RMUL_IMP : forall x : R, forall y : R, forall z : R, ((ltr x y) /\ (ltr (R_of_nat (NUMERAL O)) z)) -> ltr (mulr x z) (mulr y z).
Axiom thm_REAL_LT_LMUL_IMP : forall x : R, forall y : R, forall z : R, ((ltr y z) /\ (ltr (R_of_nat (NUMERAL O)) x)) -> ltr (mulr x y) (mulr x z).
Axiom thm_REAL_LINV_UNIQ : forall x : R, forall y : R, ((mulr x y) = (R_of_nat (NUMERAL (BIT1 O)))) -> x = (invr y).
Axiom thm_REAL_RINV_UNIQ : forall x : R, forall y : R, ((mulr x y) = (R_of_nat (NUMERAL (BIT1 O)))) -> y = (invr x).
Axiom thm_REAL_NEG_INV : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (oppr (invr x)) = (invr (oppr x)).
Axiom thm_REAL_INV_1OVER : forall x : R, (invr x) = (divr (R_of_nat (NUMERAL (BIT1 O))) x).
Axiom thm_REAL : forall n : nat, (R_of_nat (S n)) = (addr (R_of_nat n) (R_of_nat (NUMERAL (BIT1 O)))).
Axiom thm_REAL_POS : forall n : nat, ler (R_of_nat (NUMERAL O)) (R_of_nat n).
Axiom thm_REAL_LE : forall m : nat, forall n : nat, (ler (R_of_nat m) (R_of_nat n)) = (leqn m n).
Axiom thm_REAL_LT : forall m : nat, forall n : nat, (ltr (R_of_nat m) (R_of_nat n)) = (ltn m n).
Axiom thm_REAL_INJ : forall m : nat, forall n : nat, ((R_of_nat m) = (R_of_nat n)) = (m = n).
Axiom thm_REAL_ADD : forall m : nat, forall n : nat, (addr (R_of_nat m) (R_of_nat n)) = (R_of_nat (addn m n)).
Axiom thm_REAL_MUL : forall m : nat, forall n : nat, (mulr (R_of_nat m) (R_of_nat n)) = (R_of_nat (muln m n)).
Axiom thm_REAL_INV1 : (invr (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_DIV_LZERO : forall x : R, (divr (R_of_nat (NUMERAL O)) x) = (R_of_nat (NUMERAL O)).
Axiom thm_REAL_LT_NZ : forall n : nat, (~ ((R_of_nat n) = (R_of_nat (NUMERAL O)))) = (ltr (R_of_nat (NUMERAL O)) (R_of_nat n)).
Axiom thm_REAL_NZ_IMP_LT : forall n : nat, (~ (n = (NUMERAL O))) -> ltr (R_of_nat (NUMERAL O)) (R_of_nat n).
Axiom thm_REAL_LT_RDIV_0 : forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr (R_of_nat (NUMERAL O)) (divr y z)) = (ltr (R_of_nat (NUMERAL O)) y).
Axiom thm_REAL_LT_RDIV : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ltr (divr x z) (divr y z)) = (ltr x y).
Axiom thm_REAL_LT_FRACTION_0 : forall n : nat, forall d : R, (~ (n = (NUMERAL O))) -> (ltr (R_of_nat (NUMERAL O)) (divr d (R_of_nat n))) = (ltr (R_of_nat (NUMERAL O)) d).
Axiom thm_REAL_LT_MULTIPLE : forall n : nat, forall d : R, (ltn (NUMERAL (BIT1 O)) n) -> (ltr d (mulr (R_of_nat n) d)) = (ltr (R_of_nat (NUMERAL O)) d).
Axiom thm_REAL_LT_FRACTION : forall n : nat, forall d : R, (ltn (NUMERAL (BIT1 O)) n) -> (ltr (divr d (R_of_nat n)) d) = (ltr (R_of_nat (NUMERAL O)) d).
Axiom thm_REAL_LT_HALF1 : forall d : R, (ltr (R_of_nat (NUMERAL O)) (divr d (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) = (ltr (R_of_nat (NUMERAL O)) d).
Axiom thm_REAL_LT_HALF2 : forall d : R, (ltr (divr d (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) d) = (ltr (R_of_nat (NUMERAL O)) d).
Axiom thm_REAL_DOUBLE : forall x : R, (addr x x) = (mulr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) x).
Axiom thm_REAL_HALF_DOUBLE : forall x : R, (addr (divr x (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) (divr x (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) = x.
Axiom thm_REAL_SUB_SUB : forall x : R, forall y : R, (subr (subr x y) x) = (oppr y).
Axiom thm_REAL_LT_ADD_SUB : forall x : R, forall y : R, forall z : R, (ltr (addr x y) z) = (ltr x (subr z y)).
Axiom thm_REAL_LT_SUB_RADD : forall x : R, forall y : R, forall z : R, (ltr (subr x y) z) = (ltr x (addr z y)).
Axiom thm_REAL_LT_SUB_LADD : forall x : R, forall y : R, forall z : R, (ltr x (subr y z)) = (ltr (addr x z) y).
Axiom thm_REAL_LE_SUB_LADD : forall x : R, forall y : R, forall z : R, (ler x (subr y z)) = (ler (addr x z) y).
Axiom thm_REAL_LE_SUB_RADD : forall x : R, forall y : R, forall z : R, (ler (subr x y) z) = (ler x (addr z y)).
Axiom thm_REAL_LT_NEG2 : forall x : R, forall y : R, (ltr (oppr x) (oppr y)) = (ltr y x).
Axiom thm_REAL_LE_NEG2 : forall x : R, forall y : R, (ler (oppr x) (oppr y)) = (ler y x).
Axiom thm_REAL_SUB_LZERO : forall x : R, (subr (R_of_nat (NUMERAL O)) x) = (oppr x).
Axiom thm_REAL_SUB_RZERO : forall x : R, (subr x (R_of_nat (NUMERAL O))) = x.
Axiom thm_REAL_LTE_ADD2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ltr w x) /\ (ler y z)) -> ltr (addr w y) (addr x z).
Axiom thm_REAL_LTE_ADD : forall x : R, forall y : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler (R_of_nat (NUMERAL O)) y)) -> ltr (R_of_nat (NUMERAL O)) (addr x y).
Axiom thm_REAL_LT_MUL2_ALT : forall x1 : R, forall x2 : R, forall y1 : R, forall y2 : R, ((ler (R_of_nat (NUMERAL O)) x1) /\ ((ler (R_of_nat (NUMERAL O)) y1) /\ ((ltr x1 x2) /\ (ltr y1 y2)))) -> ltr (mulr x1 y1) (mulr x2 y2).
Axiom thm_REAL_SUB_LNEG : forall x : R, forall y : R, (subr (oppr x) y) = (oppr (addr x y)).
Axiom thm_REAL_SUB_RNEG : forall x : R, forall y : R, (subr x (oppr y)) = (addr x y).
Axiom thm_REAL_SUB_NEG2 : forall x : R, forall y : R, (subr (oppr x) (oppr y)) = (subr y x).
Axiom thm_REAL_SUB_TRIANGLE : forall a : R, forall b : R, forall c : R, (addr (subr a b) (subr b c)) = (subr a c).
Axiom thm_REAL_INV_MUL_WEAK : forall x : R, forall y : R, ((~ (x = (R_of_nat (NUMERAL O)))) /\ (~ (y = (R_of_nat (NUMERAL O))))) -> (invr (mulr x y)) = (mulr (invr x) (invr y)).
Axiom thm_REAL_LE_LMUL_LOCAL : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) x) -> (ler (mulr x y) (mulr x z)) = (ler y z).
Axiom thm_REAL_LE_RMUL_EQ : forall x : R, forall y : R, forall z : R, (ltr (R_of_nat (NUMERAL O)) z) -> (ler (mulr x z) (mulr y z)) = (ler x y).
Axiom thm_REAL_SUB_INV2 : forall x : R, forall y : R, ((~ (x = (R_of_nat (NUMERAL O)))) /\ (~ (y = (R_of_nat (NUMERAL O))))) -> (subr (invr x) (invr y)) = (divr (subr y x) (mulr x y)).
Axiom thm_REAL_SUB_SUB2 : forall x : R, forall y : R, (subr x (subr x y)) = y.
Axiom thm_REAL_MEAN : forall x : R, forall y : R, (ltr x y) -> exists z : R, (ltr x z) /\ (ltr z y).
Axiom thm_REAL_EQ_LMUL2 : forall x : R, forall y : R, forall z : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (y = z) = ((mulr x y) = (mulr x z)).
Axiom thm_REAL_LE_MUL2V : forall x1 : R, forall x2 : R, forall y1 : R, forall y2 : R, ((ler (R_of_nat (NUMERAL O)) x1) /\ ((ler (R_of_nat (NUMERAL O)) y1) /\ ((ler x1 x2) /\ (ler y1 y2)))) -> ler (mulr x1 y1) (mulr x2 y2).
Axiom thm_REAL_LE_LDIV : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler y (mulr z x))) -> ler (divr y x) z.
Axiom thm_REAL_LE_RDIV : forall x : R, forall y : R, forall z : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ler (mulr y x) z)) -> ler y (divr z x).
Axiom thm_REAL_LT_1 : forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ltr x y)) -> ltr (divr x y) (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_LE_LMUL_IMP : forall x : R, forall y : R, forall z : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler y z)) -> ler (mulr x y) (mulr x z).
Axiom thm_REAL_LE_RMUL_IMP : forall x : R, forall y : R, forall z : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler y z)) -> ler (mulr y x) (mulr z x).
Axiom thm_REAL_INV_LT1 : forall x : R, ((ltr (R_of_nat (NUMERAL O)) x) /\ (ltr x (R_of_nat (NUMERAL (BIT1 O))))) -> ltr (R_of_nat (NUMERAL (BIT1 O))) (invr x).
Axiom thm_REAL_LT_IMP_NZ : forall x : R, (ltr (R_of_nat (NUMERAL O)) x) -> ~ (x = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_EQ_RMUL_IMP : forall x : R, forall y : R, forall z : R, ((~ (z = (R_of_nat (NUMERAL O)))) /\ ((mulr x z) = (mulr y z))) -> x = y.
Axiom thm_REAL_EQ_LMUL_IMP : forall x : R, forall y : R, forall z : R, ((~ (x = (R_of_nat (NUMERAL O)))) /\ ((mulr x y) = (mulr x z))) -> y = z.
Axiom thm_REAL_FACT_NZ : forall n : nat, ~ ((R_of_nat (factorial n)) = (R_of_nat (NUMERAL O))).
Axiom thm_REAL_POSSQ : forall x : R, (ltr (R_of_nat (NUMERAL O)) (mulr x x)) = (~ (x = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_SUMSQ : forall x : R, forall y : R, ((addr (mulr x x) (mulr y y)) = (R_of_nat (NUMERAL O))) = ((x = (R_of_nat (NUMERAL O))) /\ (y = (R_of_nat (NUMERAL O)))).
Axiom thm_REAL_EQ_NEG : forall x : R, forall y : R, ((oppr x) = (oppr y)) = (x = y).
Axiom thm_REAL_DIV_MUL2 : forall x : R, forall z : R, ((~ (x = (R_of_nat (NUMERAL O)))) /\ (~ (z = (R_of_nat (NUMERAL O))))) -> forall y : R, (divr y z) = (divr (mulr x y) (mulr x z)).
Axiom thm_REAL_MIDDLE1 : forall a : R, forall b : R, (ler a b) -> ler a (divr (addr a b) (R_of_nat (NUMERAL (BIT0 (BIT1 O))))).
Axiom thm_REAL_MIDDLE2 : forall a : R, forall b : R, (ler a b) -> ler (divr (addr a b) (R_of_nat (NUMERAL (BIT0 (BIT1 O))))) b.
Axiom thm_ABS_ZERO : forall x : R, ((normr x) = (R_of_nat (NUMERAL O))) = (x = (R_of_nat (NUMERAL O))).
Axiom thm_ABS_0 : (normr (R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_ABS_1 : (normr (R_of_nat (NUMERAL (BIT1 O)))) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_ABS_NEG : forall x : R, (normr (oppr x)) = (normr x).
Axiom thm_ABS_TRIANGLE : forall x : R, forall y : R, ler (normr (addr x y)) (addr (normr x) (normr y)).
Axiom thm_ABS_POS : forall x : R, ler (R_of_nat (NUMERAL O)) (normr x).
Axiom thm_ABS_MUL : forall x : R, forall y : R, (normr (mulr x y)) = (mulr (normr x) (normr y)).
Axiom thm_ABS_LT_MUL2 : forall w : R, forall x : R, forall y : R, forall z : R, ((ltr (normr w) y) /\ (ltr (normr x) z)) -> ltr (normr (mulr w x)) (mulr y z).
Axiom thm_ABS_SUB : forall x : R, forall y : R, (normr (subr x y)) = (normr (subr y x)).
Axiom thm_ABS_NZ : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) = (ltr (R_of_nat (NUMERAL O)) (normr x)).
Axiom thm_ABS_INV : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> (normr (invr x)) = (invr (normr x)).
Axiom thm_ABS_ABS : forall x : R, (normr (normr x)) = (normr x).
Axiom thm_ABS_LE : forall x : R, ler x (normr x).
Axiom thm_ABS_REFL : forall x : R, ((normr x) = x) = (ler (R_of_nat (NUMERAL O)) x).
Axiom thm_ABS_N : forall n : nat, (normr (R_of_nat n)) = (R_of_nat n).
Axiom thm_ABS_BETWEEN : forall x : R, forall y : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((ltr (subr x d) y) /\ (ltr y (addr x d)))) = (ltr (normr (subr y x)) d).
Axiom thm_ABS_BOUND : forall x : R, forall y : R, forall d : R, (ltr (normr (subr x y)) d) -> ltr y (addr x d).
Axiom thm_ABS_STILLNZ : forall x : R, forall y : R, (ltr (normr (subr x y)) (normr y)) -> ~ (x = (R_of_nat (NUMERAL O))).
Axiom thm_ABS_CASES : forall x : R, (x = (R_of_nat (NUMERAL O))) \/ (ltr (R_of_nat (NUMERAL O)) (normr x)).
Axiom thm_ABS_BETWEEN1 : forall x : R, forall y : R, forall z : R, ((ltr x z) /\ (ltr (normr (subr y x)) (subr z x))) -> ltr y z.
Axiom thm_ABS_SIGN : forall x : R, forall y : R, (ltr (normr (subr x y)) y) -> ltr (R_of_nat (NUMERAL O)) x.
Axiom thm_ABS_SIGN2 : forall x : R, forall y : R, (ltr (normr (subr x y)) (oppr y)) -> ltr x (R_of_nat (NUMERAL O)).
Axiom thm_ABS_DIV : forall y : R, (~ (y = (R_of_nat (NUMERAL O)))) -> forall x : R, (normr (divr x y)) = (divr (normr x) (normr y)).
Axiom thm_ABS_CIRCLE : forall x : R, forall y : R, forall h : R, (ltr (normr h) (subr (normr y) (normr x))) -> ltr (normr (addr x h)) (normr y).
Axiom thm_REAL_SUB_ABS : forall x : R, forall y : R, ler (subr (normr x) (normr y)) (normr (subr x y)).
Axiom thm_ABS_SUB_ABS : forall x : R, forall y : R, ler (normr (subr (normr x) (normr y))) (normr (subr x y)).
Axiom thm_ABS_BETWEEN2 : forall x0 : R, forall x : R, forall y0 : R, forall y : R, ((ltr x0 y0) /\ ((ltr (normr (subr x x0)) (divr (subr y0 x0) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))) /\ (ltr (normr (subr y y0)) (divr (subr y0 x0) (R_of_nat (NUMERAL (BIT0 (BIT1 O)))))))) -> ltr x y.
Axiom thm_ABS_BOUNDS : forall x : R, forall k : R, (ler (normr x) k) = ((ler (oppr k) x) /\ (ler x k)).
Axiom thm_POW_0 : forall n : nat, (expr (R_of_nat (NUMERAL O)) (S n)) = (R_of_nat (NUMERAL O)).
Axiom thm_POW_NZ : forall c : R, forall n : nat, (~ (c = (R_of_nat (NUMERAL O)))) -> ~ ((expr c n) = (R_of_nat (NUMERAL O))).
Axiom thm_POW_INV : forall c : R, forall n : nat, (~ (c = (R_of_nat (NUMERAL O)))) -> (invr (expr c n)) = (expr (invr c) n).
Axiom thm_POW_ABS : forall c : R, forall n : nat, (expr (normr c) n) = (normr (expr c n)).
Axiom thm_POW_PLUS1 : forall e : R, forall n : nat, (ltr (R_of_nat (NUMERAL O)) e) -> ler (addr (R_of_nat (NUMERAL (BIT1 O))) (mulr (R_of_nat n) e)) (expr (addr (R_of_nat (NUMERAL (BIT1 O))) e) n).
Axiom thm_POW_ADD : forall c : R, forall m : nat, forall n : nat, (expr c (addn m n)) = (mulr (expr c m) (expr c n)).
Axiom thm_POW_1 : forall x : R, (expr x (NUMERAL (BIT1 O))) = x.
Axiom thm_POW_2 : forall x : R, (expr x (NUMERAL (BIT0 (BIT1 O)))) = (mulr x x).
Axiom thm_POW_POS : forall x : R, forall n : nat, (ler (R_of_nat (NUMERAL O)) x) -> ler (R_of_nat (NUMERAL O)) (expr x n).
Axiom thm_POW_LE : forall n : nat, forall x : R, forall y : R, ((ler (R_of_nat (NUMERAL O)) x) /\ (ler x y)) -> ler (expr x n) (expr y n).
Axiom thm_POW_M1 : forall n : nat, (normr (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) n)) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_POW_MUL : forall n : nat, forall x : R, forall y : R, (expr (mulr x y) n) = (mulr (expr x n) (expr y n)).
Axiom thm_REAL_LE_SQUARE_POW : forall x : R, ler (R_of_nat (NUMERAL O)) (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_ABS_POW2 : forall x : R, (normr (expr x (NUMERAL (BIT0 (BIT1 O))))) = (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_REAL_LE1_POW2 : forall x : R, (ler (R_of_nat (NUMERAL (BIT1 O))) x) -> ler (R_of_nat (NUMERAL (BIT1 O))) (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_REAL_LT1_POW2 : forall x : R, (ltr (R_of_nat (NUMERAL (BIT1 O))) x) -> ltr (R_of_nat (NUMERAL (BIT1 O))) (expr x (NUMERAL (BIT0 (BIT1 O)))).
Axiom thm_POW_POS_LT : forall x : R, forall n : nat, (ltr (R_of_nat (NUMERAL O)) x) -> ltr (R_of_nat (NUMERAL O)) (expr x (S n)).
Axiom thm_POW_2_LE1 : forall n : nat, ler (R_of_nat (NUMERAL (BIT1 O))) (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_POW_2_LT : forall n : nat, ltr (R_of_nat n) (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_POW_MINUS1 : forall n : nat, (expr (oppr (R_of_nat (NUMERAL (BIT1 O)))) (muln (NUMERAL (BIT0 (BIT1 O))) n)) = (R_of_nat (NUMERAL (BIT1 O))).
Axiom thm_REAL_SUP_EXISTS : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ltr x z)) -> exists s : R, forall y : R, (exists x : R, (P x) /\ (ltr y x)) = (ltr y s).
Axiom thm_sup_def : forall s : R -> Prop, (sup s) = (@ε R (fun a : R => (forall x : R, (@IN R x s) -> ler x a) /\ (forall b : R, (forall x : R, (@IN R x s) -> ler x b) -> ler a b))).
Axiom thm_sup : forall (P : R -> Prop), (sup P) = (@ε R (fun s : R => forall y : R, (exists x : R, (P x) /\ (ltr y x)) = (ltr y s))).
Axiom thm_REAL_SUP : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ltr x z)) -> forall y : R, (exists x : R, (P x) /\ (ltr y x)) = (ltr y (sup P)).
Axiom thm_REAL_SUP_UBOUND : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ltr x z)) -> forall y : R, (P y) -> ler y (sup P).
Axiom thm_SETOK_LE_LT : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ler x z)) = ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ltr x z)).
Axiom thm_REAL_SUP_LE : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ler x z)) -> forall y : R, (exists x : R, (P x) /\ (ltr y x)) = (ltr y (sup P)).
Axiom thm_REAL_SUP_UBOUND_LE : forall P : R -> Prop, ((exists x : R, P x) /\ (exists z : R, forall x : R, (P x) -> ler x z)) -> forall y : R, (P y) -> ler y (sup P).
Axiom thm_REAL_ARCH_SIMPLE : forall x : R, exists n : nat, ler x (R_of_nat n).
Axiom thm_REAL_ARCH : forall x : R, (ltr (R_of_nat (NUMERAL O)) x) -> forall y : R, exists n : nat, ltr y (mulr (R_of_nat n) x).
Axiom thm_REAL_ARCH_LEAST : forall y : R, (ltr (R_of_nat (NUMERAL O)) y) -> forall x : R, (ler (R_of_nat (NUMERAL O)) x) -> exists n : nat, (ler (mulr (R_of_nat n) y) x) /\ (ltr x (mulr (R_of_nat (S n)) y)).
Axiom thm_REAL_POW_LBOUND : forall x : R, forall n : nat, (ler (R_of_nat (NUMERAL O)) x) -> ler (addr (R_of_nat (NUMERAL (BIT1 O))) (mulr (R_of_nat n) x)) (expr (addr (R_of_nat (NUMERAL (BIT1 O))) x) n).
Axiom thm_REAL_ARCH_POW : forall x : R, forall y : R, (ltr (R_of_nat (NUMERAL (BIT1 O))) x) -> exists n : nat, ltr y (expr x n).
Axiom thm_REAL_ARCH_POW2 : forall x : R, exists n : nat, ltr x (expr (R_of_nat (NUMERAL (BIT0 (BIT1 O)))) n).
Axiom thm_sum_EXISTS : exists sum' : (prod nat nat) -> (nat -> R) -> R, (forall f : nat -> R, forall n : nat, (sum' (@pair nat nat n (NUMERAL O)) f) = (R_of_nat (NUMERAL O))) /\ (forall f : nat -> R, forall m : nat, forall n : nat, (sum' (@pair nat nat n (S m)) f) = (addr (sum' (@pair nat nat n m) f) (f (addn n m)))).
Axiom thm_sum : forall (f : nat -> R) (n : nat) (m : nat), ((psum (@pair nat nat n (NUMERAL O)) f) = (R_of_nat (NUMERAL O))) /\ ((psum (@pair nat nat n (S m)) f) = (addr (psum (@pair nat nat n m) f) (f (addn n m)))).
Axiom thm_PSUM_SUM : forall f : nat -> R, forall m : nat, forall n : nat, (psum (@pair nat nat m n) f) = (@sum nat (@GSPEC nat (fun GEN_PVAR_376 : nat => exists i : nat, @SETSPEC nat GEN_PVAR_376 ((leqn m i) /\ (ltn i (addn m n))) i)) f).
Axiom thm_PSUM_SUM_NUMSEG : forall f : nat -> R, forall m : nat, forall n : nat, (~ ((m = (NUMERAL O)) /\ (n = (NUMERAL O)))) -> (psum (@pair nat nat m n) f) = (@sum nat (dotdot m (subn (addn m n) (NUMERAL (BIT1 O)))) f).
Axiom thm_SUM_TWO : forall f : nat -> R, forall n : nat, forall p : nat, (addr (psum (@pair nat nat (NUMERAL O) n) f) (psum (@pair nat nat n p) f)) = (psum (@pair nat nat (NUMERAL O) (addn n p)) f).
Axiom thm_SUM_DIFF : forall f : nat -> R, forall m : nat, forall n : nat, (psum (@pair nat nat m n) f) = (subr (psum (@pair nat nat (NUMERAL O) (addn m n)) f) (psum (@pair nat nat (NUMERAL O) m) f)).
Axiom thm_ABS_SUM : forall f : nat -> R, forall m : nat, forall n : nat, ler (normr (psum (@pair nat nat m n) f)) (psum (@pair nat nat m n) (fun n' : nat => normr (f n'))).
Axiom thm_SUM_LE : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (forall r : nat, ((leqn m r) /\ (ltn r (addn n m))) -> ler (f r) (g r)) -> ler (psum (@pair nat nat m n) f) (psum (@pair nat nat m n) g).
Axiom thm_SUM_EQ : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (forall r : nat, ((leqn m r) /\ (ltn r (addn n m))) -> (f r) = (g r)) -> (psum (@pair nat nat m n) f) = (psum (@pair nat nat m n) g).
Axiom thm_SUM_POS : forall f : nat -> R, (forall n : nat, ler (R_of_nat (NUMERAL O)) (f n)) -> forall m : nat, forall n : nat, ler (R_of_nat (NUMERAL O)) (psum (@pair nat nat m n) f).
Axiom thm_SUM_POS_GEN : forall f : nat -> R, forall m : nat, forall n : nat, (forall n' : nat, (leqn m n') -> ler (R_of_nat (NUMERAL O)) (f n')) -> ler (R_of_nat (NUMERAL O)) (psum (@pair nat nat m n) f).
Axiom thm_SUM_ABS : forall f : nat -> R, forall m : nat, forall n : nat, (normr (psum (@pair nat nat m n) (fun m' : nat => normr (f m')))) = (psum (@pair nat nat m n) (fun m' : nat => normr (f m'))).
Axiom thm_SUM_ABS_LE : forall f : nat -> R, forall m : nat, forall n : nat, ler (normr (psum (@pair nat nat m n) f)) (psum (@pair nat nat m n) (fun n' : nat => normr (f n'))).
Axiom thm_SUM_ZERO : forall f : nat -> R, forall N' : nat, (forall n : nat, (geqn n N') -> (f n) = (R_of_nat (NUMERAL O))) -> forall m : nat, forall n : nat, (geqn m N') -> (psum (@pair nat nat m n) f) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_ADD : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (psum (@pair nat nat m n) (fun n' : nat => addr (f n') (g n'))) = (addr (psum (@pair nat nat m n) f) (psum (@pair nat nat m n) g)).
Axiom thm_SUM_CMUL : forall f : nat -> R, forall c : R, forall m : nat, forall n : nat, (psum (@pair nat nat m n) (fun n' : nat => mulr c (f n'))) = (mulr c (psum (@pair nat nat m n) f)).
Axiom thm_SUM_NEG : forall f : nat -> R, forall n : nat, forall d : nat, (psum (@pair nat nat n d) (fun n' : nat => oppr (f n'))) = (oppr (psum (@pair nat nat n d) f)).
Axiom thm_SUM_SUB : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (psum (@pair nat nat m n) (fun n' : nat => subr (f n') (g n'))) = (subr (psum (@pair nat nat m n) f) (psum (@pair nat nat m n) g)).
Axiom thm_SUM_SUBST : forall f : nat -> R, forall g : nat -> R, forall m : nat, forall n : nat, (forall p : nat, ((leqn m p) /\ (ltn p (addn m n))) -> (f p) = (g p)) -> (psum (@pair nat nat m n) f) = (psum (@pair nat nat m n) g).
Axiom thm_SUM_NSUB : forall n : nat, forall f : nat -> R, forall c : R, (subr (psum (@pair nat nat (NUMERAL O) n) f) (mulr (R_of_nat n) c)) = (psum (@pair nat nat (NUMERAL O) n) (fun p : nat => subr (f p) c)).
Axiom thm_SUM_BOUND : forall f : nat -> R, forall K : R, forall m : nat, forall n : nat, (forall p : nat, ((leqn m p) /\ (ltn p (addn m n))) -> ler (f p) K) -> ler (psum (@pair nat nat m n) f) (mulr (R_of_nat n) K).
Axiom thm_SUM_GROUP : forall n : nat, forall k : nat, forall f : nat -> R, (psum (@pair nat nat (NUMERAL O) n) (fun m : nat => psum (@pair nat nat (muln m k) k) f)) = (psum (@pair nat nat (NUMERAL O) (muln n k)) f).
Axiom thm_SUM_1 : forall f : nat -> R, forall n : nat, (psum (@pair nat nat n (NUMERAL (BIT1 O))) f) = (f n).
Axiom thm_SUM_2 : forall f : nat -> R, forall n : nat, (psum (@pair nat nat n (NUMERAL (BIT0 (BIT1 O)))) f) = (addr (f n) (f (addn n (NUMERAL (BIT1 O))))).
Axiom thm_SUM_OFFSET : forall f : nat -> R, forall n : nat, forall k : nat, (psum (@pair nat nat (NUMERAL O) n) (fun m : nat => f (addn m k))) = (subr (psum (@pair nat nat (NUMERAL O) (addn n k)) f) (psum (@pair nat nat (NUMERAL O) k) f)).
Axiom thm_SUM_REINDEX : forall f : nat -> R, forall m : nat, forall k : nat, forall n : nat, (psum (@pair nat nat (addn m k) n) f) = (psum (@pair nat nat m n) (fun r : nat => f (addn r k))).
Axiom thm_SUM_0 : forall m : nat, forall n : nat, (psum (@pair nat nat m n) (fun r : nat => R_of_nat (NUMERAL O))) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_CANCEL : forall f : nat -> R, forall n : nat, forall d : nat, (psum (@pair nat nat n d) (fun n' : nat => subr (f (S n')) (f n'))) = (subr (f (addn n d)) (f n)).
Axiom thm_SUM_HORNER : forall f : nat -> R, forall n : nat, forall x : R, (psum (@pair nat nat (NUMERAL O) (S n)) (fun i : nat => mulr (f i) (expr x i))) = (addr (f (NUMERAL O)) (mulr x (psum (@pair nat nat (NUMERAL O) n) (fun i : nat => mulr (f (S i)) (expr x i))))).
Axiom thm_SUM_CONST : forall c : R, forall n : nat, (psum (@pair nat nat (NUMERAL O) n) (fun m : nat => c)) = (mulr (R_of_nat n) c).
Axiom thm_SUM_SPLIT : forall (m : nat), forall f : nat -> R, forall n : nat, forall p : nat, (addr (psum (@pair nat nat m n) f) (psum (@pair nat nat (addn m n) p) f)) = (psum (@pair nat nat m (addn n p)) f).
Axiom thm_SUM_SWAP : forall f : nat -> nat -> R, forall m1 : nat, forall n1 : nat, forall m2 : nat, forall n2 : nat, (psum (@pair nat nat m1 n1) (fun a : nat => psum (@pair nat nat m2 n2) (fun b : nat => f a b))) = (psum (@pair nat nat m2 n2) (fun b : nat => psum (@pair nat nat m1 n1) (fun a : nat => f a b))).
Axiom thm_SUM_EQ_0 : forall (m : nat) (n : nat) (f : nat -> R), (forall r : nat, ((leqn m r) /\ (ltn r (addn m n))) -> (f r) = (R_of_nat (NUMERAL O))) -> (psum (@pair nat nat m n) f) = (R_of_nat (NUMERAL O)).
Axiom thm_SUM_MORETERMS_EQ : forall (f : nat -> R), forall m : nat, forall n : nat, forall p : nat, ((leqn n p) /\ (forall r : nat, ((leqn (addn m n) r) /\ (ltn r (addn m p))) -> (f r) = (R_of_nat (NUMERAL O)))) -> (psum (@pair nat nat m p) f) = (psum (@pair nat nat m n) f).
Axiom thm_SUM_DIFFERENCES_EQ : forall (f : nat -> R) (g : nat -> R), forall m : nat, forall n : nat, forall p : nat, ((leqn n p) /\ (forall r : nat, ((leqn (addn m n) r) /\ (ltn r (addn m p))) -> (f r) = (g r))) -> (subr (psum (@pair nat nat m p) f) (psum (@pair nat nat m n) f)) = (subr (psum (@pair nat nat m p) g) (psum (@pair nat nat m n) g)).
Axiom thm_re_Union : forall {A : Type'}, forall S' : (A -> Prop) -> Prop, (@re_Union A S') = (fun x : A => exists s : A -> Prop, (S' s) /\ (s x)).
Axiom thm_re_union : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, (@re_union A P Q) = (fun x : A => (P x) \/ (Q x)).
Axiom thm_re_intersect : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, (@re_intersect A P Q) = (fun x : A => (P x) /\ (Q x)).
Axiom thm_re_null : forall {A : Type'}, (@re_null A) = (fun x : A => False).
Axiom thm_re_universe : forall {A : Type'}, (@re_universe A) = (fun x : A => True).
Axiom thm_re_subset : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, (@re_subset A P Q) = (forall x : A, (P x) -> Q x).
Axiom thm_re_compl : forall {A : Type'}, forall S' : A -> Prop, (@re_compl A S') = (fun x : A => ~ (S' x)).
Axiom thm_SUBSETA_REFL : forall {A : Type'}, forall S' : A -> Prop, @re_subset A S' S'.
Axiom thm_COMPL_MEM : forall {A : Type'}, forall S' : A -> Prop, forall x : A, (S' x) = (~ (@re_compl A S' x)).
Axiom thm_SUBSETA_ANTISYM : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, ((@re_subset A P Q) /\ (@re_subset A Q P)) = (P = Q).
Axiom thm_SUBSETA_TRANS : forall {A : Type'}, forall P : A -> Prop, forall Q : A -> Prop, forall R' : A -> Prop, ((@re_subset A P Q) /\ (@re_subset A Q R')) -> @re_subset A P R'.
Axiom thm_istopology : forall {A : Type'}, forall L : (A -> Prop) -> Prop, (@istopology A L) = ((L (@re_null A)) /\ ((L (@re_universe A)) /\ ((forall a : A -> Prop, forall b : A -> Prop, ((L a) /\ (L b)) -> L (@re_intersect A a b)) /\ (forall P : (A -> Prop) -> Prop, (@re_subset (A -> Prop) P L) -> L (@re_Union A P))))).
Axiom thm_TOPOLOGY : forall {A : Type'}, forall L : Topology A, (@open A L (@re_null A)) /\ ((@open A L (@re_universe A)) /\ ((forall x : A -> Prop, forall y : A -> Prop, ((@open A L x) /\ (@open A L y)) -> @open A L (@re_intersect A x y)) /\ (forall P : (A -> Prop) -> Prop, (@re_subset (A -> Prop) P (@open A L)) -> @open A L (@re_Union A P)))).
Axiom thm_TOPOLOGY_UNION : forall {A : Type'}, forall L : Topology A, forall P : (A -> Prop) -> Prop, (@re_subset (A -> Prop) P (@open A L)) -> @open A L (@re_Union A P).
Axiom thm_neigh : forall {A : Type'}, forall top : Topology A, forall N' : A -> Prop, forall x : A, (@neigh A top (@pair (A -> Prop) A N' x)) = (exists P : A -> Prop, (@open A top P) /\ ((@re_subset A P N') /\ (P x))).
Axiom thm_OPEN_OWN_NEIGH : forall {A : Type'}, forall S' : A -> Prop, forall top : Topology A, forall x : A, ((@open A top S') /\ (S' x)) -> @neigh A top (@pair (A -> Prop) A S' x).
Axiom thm_OPEN_UNOPEN : forall {A : Type'}, forall S' : A -> Prop, forall top : Topology A, (@open A top S') = ((@re_Union A (fun P : A -> Prop => (@open A top P) /\ (@re_subset A P S'))) = S').
Axiom thm_OPEN_SUBOPEN : forall {A : Type'}, forall S' : A -> Prop, forall top : Topology A, (@open A top S') = (forall x : A, (S' x) -> exists P : A -> Prop, (P x) /\ ((@open A top P) /\ (@re_subset A P S'))).
Axiom thm_OPEN_NEIGH : forall {A : Type'}, forall S' : A -> Prop, forall top : Topology A, (@open A top S') = (forall x : A, (S' x) -> exists N' : A -> Prop, (@neigh A top (@pair (A -> Prop) A N' x)) /\ (@re_subset A N' S')).
Axiom thm_closed : forall {A : Type'}, forall L : Topology A, forall S' : A -> Prop, (@closed A L S') = (@open A L (@re_compl A S')).
Axiom thm_limpt : forall {A : Type'}, forall top : Topology A, forall x : A, forall S' : A -> Prop, (@limpt A top x S') = (forall N' : A -> Prop, (@neigh A top (@pair (A -> Prop) A N' x)) -> exists y : A, (~ (x = y)) /\ ((S' y) /\ (N' y))).
Axiom thm_CLOSED_LIMPT : forall {A : Type'}, forall top : Topology A, forall S' : A -> Prop, (@closed A top S') = (forall x : A, (@limpt A top x S') -> S' x).
Axiom thm_ismet : forall {A : Type'}, forall m : (prod A A) -> R, (@ismet A m) = ((forall x : A, forall y : A, ((m (@pair A A x y)) = (R_of_nat (NUMERAL O))) = (x = y)) /\ (forall x : A, forall y : A, forall z : A, ler (m (@pair A A y z)) (addr (m (@pair A A x y)) (m (@pair A A x z))))).
Axiom thm_METRIC_ISMET : forall {A : Type'}, forall m : Metric A, @ismet A (@mdist A m).
Axiom thm_METRIC_ZERO : forall {A : Type'}, forall m : Metric A, forall x : A, forall y : A, ((@mdist A m (@pair A A x y)) = (R_of_nat (NUMERAL O))) = (x = y).
Axiom thm_METRIC_SAME : forall {A : Type'}, forall m : Metric A, forall x : A, (@mdist A m (@pair A A x x)) = (R_of_nat (NUMERAL O)).
Axiom thm_METRIC_POS : forall {A : Type'}, forall m : Metric A, forall x : A, forall y : A, ler (R_of_nat (NUMERAL O)) (@mdist A m (@pair A A x y)).
Axiom thm_METRIC_SYM : forall {A : Type'}, forall m : Metric A, forall x : A, forall y : A, (@mdist A m (@pair A A x y)) = (@mdist A m (@pair A A y x)).
Axiom thm_METRIC_TRIANGLE : forall {A : Type'}, forall m : Metric A, forall x : A, forall y : A, forall z : A, ler (@mdist A m (@pair A A x z)) (addr (@mdist A m (@pair A A x y)) (@mdist A m (@pair A A y z))).
Axiom thm_METRIC_NZ : forall {A : Type'}, forall m : Metric A, forall x : A, forall y : A, (~ (x = y)) -> ltr (R_of_nat (NUMERAL O)) (@mdist A m (@pair A A x y)).
Axiom thm_mtop : forall {A : Type'}, forall m : Metric A, (@mtop A m) = (@topology A (fun S' : A -> Prop => forall x : A, (S' x) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall y : A, (ltr (@mdist A m (@pair A A x y)) e) -> S' y))).
Axiom thm_mtop_istopology : forall {A : Type'}, forall m : Metric A, @istopology A (fun S' : A -> Prop => forall x : A, (S' x) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall y : A, (ltr (@mdist A m (@pair A A x y)) e) -> S' y)).
Axiom thm_MTOP_OPEN : forall {A : Type'} (S' : A -> Prop), forall m : Metric A, (@open A (@mtop A m) S') = (forall x : A, (S' x) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall y : A, (ltr (@mdist A m (@pair A A x y)) e) -> S' y)).
Axiom thm_ball : forall {A : Type'}, forall m : Metric A, forall x : A, forall e : R, (@ball A m (@pair A R x e)) = (fun y : A => ltr (@mdist A m (@pair A A x y)) e).
Axiom thm_BALL_OPEN : forall {A : Type'}, forall m : Metric A, forall x : A, forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> @open A (@mtop A m) (@ball A m (@pair A R x e)).
Axiom thm_BALL_NEIGH : forall {A : Type'}, forall m : Metric A, forall x : A, forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> @neigh A (@mtop A m) (@pair (A -> Prop) A (@ball A m (@pair A R x e)) x).
Axiom thm_MTOP_LIMPT : forall {A : Type'}, forall m : Metric A, forall x : A, forall S' : A -> Prop, (@limpt A (@mtop A m) x S') = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists y : A, (~ (x = y)) /\ ((S' y) /\ (ltr (@mdist A m (@pair A A x y)) e))).
Axiom thm_ISMET_R1 : @ismet R (@ε ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (normr (subr y x)))).
Axiom thm_mr1 : mr1 = (@metric R (@ε ((prod R R) -> R) (fun f : (prod R R) -> R => forall x : R, forall y : R, @eq R (f (@pair R R x y)) (normr (subr y x))))).
Axiom thm_MR1_DEF : forall x : R, forall y : R, (@mdist R mr1 (@pair R R x y)) = (normr (subr y x)).
Axiom thm_MR1_ADD : forall x : R, forall d : R, (@mdist R mr1 (@pair R R x (addr x d))) = (normr d).
Axiom thm_MR1_SUB : forall x : R, forall d : R, (@mdist R mr1 (@pair R R x (subr x d))) = (normr d).
Axiom thm_MR1_ADD_LE : forall x : R, forall d : R, (ler (R_of_nat (NUMERAL O)) d) -> (@mdist R mr1 (@pair R R x (addr x d))) = d.
Axiom thm_MR1_SUB_LE : forall x : R, forall d : R, (ler (R_of_nat (NUMERAL O)) d) -> (@mdist R mr1 (@pair R R x (subr x d))) = d.
Axiom thm_MR1_ADD_LT : forall x : R, forall d : R, (ltr (R_of_nat (NUMERAL O)) d) -> (@mdist R mr1 (@pair R R x (addr x d))) = d.
Axiom thm_MR1_SUB_LT : forall x : R, forall d : R, (ltr (R_of_nat (NUMERAL O)) d) -> (@mdist R mr1 (@pair R R x (subr x d))) = d.
Axiom thm_MR1_BETWEEN1 : forall x : R, forall y : R, forall z : R, ((ltr x z) /\ (ltr (@mdist R mr1 (@pair R R x y)) (subr z x))) -> ltr y z.
Axiom thm_MR1_LIMPT : forall x : R, @limpt R (@mtop R mr1) x (@re_universe R).
Axiom thm_dorder : forall {A : Type'}, forall g : A -> A -> Prop, (@dorder A g) = (forall x : A, forall y : A, ((g x x) /\ (g y y)) -> exists z : A, (g z z) /\ (forall w : A, (g w z) -> (g w x) /\ (g w y))).
Axiom thm_tends : forall {A B : Type'}, forall top : Topology A, forall l : A, forall g : B -> B -> Prop, forall s : B -> A, (@tends A B s l (@pair (Topology A) (B -> B -> Prop) top g)) = (forall N' : A -> Prop, (@neigh A top (@pair (A -> Prop) A N' l)) -> exists n : B, (g n n) /\ (forall m : B, (g m n) -> N' (s m))).
Axiom thm_bounded : forall {A B : Type'}, forall g : B -> B -> Prop, forall m : Metric A, forall f : B -> A, (@bounded A B (@pair (Metric A) (B -> B -> Prop) m g) f) = (exists k : R, exists x : A, exists N' : B, (g N' N') /\ (forall n : B, (g n N') -> ltr (@mdist A m (@pair A A (f n) x)) k)).
Axiom thm_tendsto : forall {A : Type'}, forall y : A, forall m : Metric A, forall x : A, forall z : A, (@tendsto A (@pair (Metric A) A m x) y z) = ((ltr (R_of_nat (NUMERAL O)) (@mdist A m (@pair A A x y))) /\ (ler (@mdist A m (@pair A A x y)) (@mdist A m (@pair A A x z)))).
Axiom thm_DORDER_LEMMA : forall {A : Type'}, forall g : A -> A -> Prop, (@dorder A g) -> forall P : A -> Prop, forall Q : A -> Prop, ((exists n : A, (g n n) /\ (forall m : A, (g m n) -> P m)) /\ (exists n : A, (g n n) /\ (forall m : A, (g m n) -> Q m))) -> exists n : A, (g n n) /\ (forall m : A, (g m n) -> (P m) /\ (Q m)).
Axiom thm_DORDER_NGE : @dorder nat geqn.
Axiom thm_DORDER_TENDSTO : forall {A : Type'}, forall m : Metric A, forall x : A, @dorder A (@tendsto A (@pair (Metric A) A m x)).
Axiom thm_MTOP_TENDS : forall {A B : Type'}, forall d : Metric A, forall g : B -> B -> Prop, forall x : B -> A, forall x0 : A, (@tends A B x x0 (@pair (Topology A) (B -> B -> Prop) (@mtop A d) g)) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists n : B, (g n n) /\ (forall m : B, (g m n) -> ltr (@mdist A d (@pair A A (x m) x0)) e)).
Axiom thm_MTOP_TENDS_UNIQ : forall {A B : Type'} (x : B -> A) (x0 : A) (x1 : A), forall g : B -> B -> Prop, forall d : Metric A, (@dorder B g) -> ((@tends A B x x0 (@pair (Topology A) (B -> B -> Prop) (@mtop A d) g)) /\ (@tends A B x x1 (@pair (Topology A) (B -> B -> Prop) (@mtop A d) g))) -> x0 = x1.
Axiom thm_SEQ_TENDS : forall {A : Type'}, forall d : Metric A, forall x : nat -> A, forall x0 : A, (@tends A nat x x0 (@pair (Topology A) (nat -> nat -> Prop) (@mtop A d) geqn)) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall n : nat, (geqn n N') -> ltr (@mdist A d (@pair A A (x n) x0)) e).
Axiom thm_LIM_TENDS : forall {A B : Type'}, forall m1 : Metric A, forall m2 : Metric B, forall f : A -> B, forall x0 : A, forall y0 : B, (@limpt A (@mtop A m1) x0 (@re_universe A)) -> (@tends B A f y0 (@pair (Topology B) (A -> A -> Prop) (@mtop B m2) (@tendsto A (@pair (Metric A) A m1 x0)))) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : A, ((ltr (R_of_nat (NUMERAL O)) (@mdist A m1 (@pair A A x x0))) /\ (ler (@mdist A m1 (@pair A A x x0)) d)) -> ltr (@mdist B m2 (@pair B B (f x) y0)) e)).
Axiom thm_LIM_TENDS2 : forall {A B : Type'}, forall m1 : Metric A, forall m2 : Metric B, forall f : A -> B, forall x0 : A, forall y0 : B, (@limpt A (@mtop A m1) x0 (@re_universe A)) -> (@tends B A f y0 (@pair (Topology B) (A -> A -> Prop) (@mtop B m2) (@tendsto A (@pair (Metric A) A m1 x0)))) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : A, ((ltr (R_of_nat (NUMERAL O)) (@mdist A m1 (@pair A A x x0))) /\ (ltr (@mdist A m1 (@pair A A x x0)) d)) -> ltr (@mdist B m2 (@pair B B (f x) y0)) e)).
Axiom thm_MR1_BOUNDED : forall {A : Type'}, forall g : A -> A -> Prop, forall f : A -> R, (@bounded R A (@pair (Metric R) (A -> A -> Prop) mr1 g) f) = (exists k : R, exists N' : A, (g N' N') /\ (forall n : A, (g n N') -> ltr (normr (f n)) k)).
Axiom thm_NET_NULL : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, (@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) = (@tends R A (fun n : A => subr (x n) x0) (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)).
Axiom thm_NET_CONV_BOUNDED : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, (@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) -> @bounded R A (@pair (Metric R) (A -> A -> Prop) mr1 g) x.
Axiom thm_NET_CONV_NZ : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (~ (x0 = (R_of_nat (NUMERAL O))))) -> exists N' : A, (g N' N') /\ (forall n : A, (g n N') -> ~ ((x n) = (R_of_nat (NUMERAL O)))).
Axiom thm_NET_CONV_IBOUNDED : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (~ (x0 = (R_of_nat (NUMERAL O))))) -> @bounded R A (@pair (Metric R) (A -> A -> Prop) mr1 g) (fun n : A => invr (x n)).
Axiom thm_NET_NULL_ADD : forall {A : Type'}, forall g : A -> A -> Prop, (@dorder A g) -> forall x : A -> R, forall y : A -> R, ((@tends R A x (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (@tends R A y (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g))) -> @tends R A (fun n : A => addr (x n) (y n)) (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_NULL_MUL : forall {A : Type'}, forall g : A -> A -> Prop, (@dorder A g) -> forall x : A -> R, forall y : A -> R, ((@bounded R A (@pair (Metric R) (A -> A -> Prop) mr1 g) x) /\ (@tends R A y (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g))) -> @tends R A (fun n : A => mulr (x n) (y n)) (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_NULL_CMUL : forall {A : Type'}, forall g : A -> A -> Prop, forall k : R, forall x : A -> R, (@tends R A x (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) -> @tends R A (fun n : A => mulr k (x n)) (R_of_nat (NUMERAL O)) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_ADD : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, forall y : A -> R, forall y0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (@tends R A y y0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g))) -> @tends R A (fun n : A => addr (x n) (y n)) (addr x0 y0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_NEG : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, (@dorder A g) -> (@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) = (@tends R A (fun n : A => oppr (x n)) (oppr x0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)).
Axiom thm_NET_SUB : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, forall y : A -> R, forall y0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (@tends R A y y0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g))) -> @tends R A (fun n : A => subr (x n) (y n)) (subr x0 y0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_MUL : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall y : A -> R, forall x0 : R, forall y0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (@tends R A y y0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g))) -> @tends R A (fun n : A => mulr (x n) (y n)) (mulr x0 y0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_INV : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (~ (x0 = (R_of_nat (NUMERAL O))))) -> @tends R A (fun n : A => invr (x n)) (invr x0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_DIV : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, forall y : A -> R, forall y0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ ((@tends R A y y0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (~ (y0 = (R_of_nat (NUMERAL O)))))) -> @tends R A (fun n : A => divr (x n) (y n)) (divr x0 y0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_ABS : forall {A : Type'} (g : A -> A -> Prop), forall x : A -> R, forall x0 : R, (@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) -> @tends R A (fun n : A => normr (x n)) (normr x0) (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g).
Axiom thm_NET_SUM : forall {_155420 : Type'} (f : nat -> _155420 -> R) (l : nat -> R), forall g : _155420 -> _155420 -> Prop, ((@dorder _155420 g) /\ (@tends R _155420 (fun x : _155420 => R_of_nat (NUMERAL O)) (R_of_nat (NUMERAL O)) (@pair (Topology R) (_155420 -> _155420 -> Prop) (@mtop R mr1) g))) -> forall m : nat, forall n : nat, (forall r : nat, ((leqn m r) /\ (ltn r (addn m n))) -> @tends R _155420 (f r) (l r) (@pair (Topology R) (_155420 -> _155420 -> Prop) (@mtop R mr1) g)) -> @tends R _155420 (fun x : _155420 => psum (@pair nat nat m n) (fun r : nat => f r x)) (psum (@pair nat nat m n) l) (@pair (Topology R) (_155420 -> _155420 -> Prop) (@mtop R mr1) g).
Axiom thm_NET_LE : forall {A : Type'}, forall g : A -> A -> Prop, forall x : A -> R, forall x0 : R, forall y : A -> R, forall y0 : R, (@dorder A g) -> ((@tends R A x x0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ ((@tends R A y y0 (@pair (Topology R) (A -> A -> Prop) (@mtop R mr1) g)) /\ (exists N' : A, (g N' N') /\ (forall n : A, (g n N') -> ler (x n) (y n))))) -> ler x0 y0.
Axiom thm_tends_num_real : forall x : nat -> R, forall x0 : R, (tends_num_real x x0) = (@tends R nat x x0 (@pair (Topology R) (nat -> nat -> Prop) (@mtop R mr1) geqn)).
Axiom thm_SEQ : forall x : nat -> R, forall x0 : R, (tends_num_real x x0) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall n : nat, (geqn n N') -> ltr (normr (subr (x n) x0)) e).
Axiom thm_SEQ_CONST : forall k : R, tends_num_real (fun x : nat => k) k.
Axiom thm_SEQ_ADD : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((tends_num_real x x0) /\ (tends_num_real y y0)) -> tends_num_real (fun n : nat => addr (x n) (y n)) (addr x0 y0).
Axiom thm_SEQ_MUL : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((tends_num_real x x0) /\ (tends_num_real y y0)) -> tends_num_real (fun n : nat => mulr (x n) (y n)) (mulr x0 y0).
Axiom thm_SEQ_NEG : forall x : nat -> R, forall x0 : R, (tends_num_real x x0) = (tends_num_real (fun n : nat => oppr (x n)) (oppr x0)).
Axiom thm_SEQ_INV : forall x : nat -> R, forall x0 : R, ((tends_num_real x x0) /\ (~ (x0 = (R_of_nat (NUMERAL O))))) -> tends_num_real (fun n : nat => invr (x n)) (invr x0).
Axiom thm_SEQ_SUB : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((tends_num_real x x0) /\ (tends_num_real y y0)) -> tends_num_real (fun n : nat => subr (x n) (y n)) (subr x0 y0).
Axiom thm_SEQ_DIV : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((tends_num_real x x0) /\ ((tends_num_real y y0) /\ (~ (y0 = (R_of_nat (NUMERAL O)))))) -> tends_num_real (fun n : nat => divr (x n) (y n)) (divr x0 y0).
Axiom thm_SEQ_UNIQ : forall x : nat -> R, forall x1 : R, forall x2 : R, ((tends_num_real x x1) /\ (tends_num_real x x2)) -> x1 = x2.
Axiom thm_SEQ_NULL : forall s : nat -> R, forall l : R, (tends_num_real s l) = (tends_num_real (fun n : nat => subr (s n) l) (R_of_nat (NUMERAL O))).
Axiom thm_SEQ_SUM : forall f : nat -> nat -> R, forall l : nat -> R, forall m : nat, forall n : nat, (forall r : nat, ((leqn m r) /\ (ltn r (addn m n))) -> tends_num_real (f r) (l r)) -> tends_num_real (fun k : nat => psum (@pair nat nat m n) (fun r : nat => f r k)) (psum (@pair nat nat m n) l).
Axiom thm_SEQ_TRANSFORM : forall s : nat -> R, forall t : nat -> R, forall l : R, forall N' : nat, ((forall n : nat, (leqn N' n) -> (s n) = (t n)) /\ (tends_num_real s l)) -> tends_num_real t l.
Axiom thm_convergent : forall f : nat -> R, (convergent f) = (exists l : R, tends_num_real f l).
Axiom thm_cauchy : forall f : nat -> R, (cauchy f) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall m : nat, forall n : nat, ((geqn m N') /\ (geqn n N')) -> ltr (normr (subr (f m) (f n))) e).
Axiom thm_lim : forall f : nat -> R, (lim f) = (@ε R (fun l : R => tends_num_real f l)).
Axiom thm_SEQ_LIM : forall f : nat -> R, (convergent f) = (tends_num_real f (lim f)).
Axiom thm_subseq : forall f : nat -> nat, (subseq f) = (forall m : nat, forall n : nat, (ltn m n) -> ltn (f m) (f n)).
Axiom thm_SUBSEQ_SUC : forall f : nat -> nat, (subseq f) = (forall n : nat, ltn (f n) (f (S n))).
Axiom thm_mono : forall f : nat -> R, (mono f) = ((forall m : nat, forall n : nat, (leqn m n) -> ler (f m) (f n)) \/ (forall m : nat, forall n : nat, (leqn m n) -> ger (f m) (f n))).
Axiom thm_MONO_SUC : forall f : nat -> R, (mono f) = ((forall n : nat, ger (f (S n)) (f n)) \/ (forall n : nat, ler (f (S n)) (f n))).
Axiom thm_MAX_LEMMA : forall s : nat -> R, forall N' : nat, exists k : R, forall n : nat, (ltn n N') -> ltr (normr (s n)) k.
Axiom thm_SEQ_BOUNDED : forall s : nat -> R, (@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) s) = (exists k : R, forall n : nat, ltr (normr (s n)) k).
Axiom thm_SEQ_BOUNDED_2 : forall f : nat -> R, forall k : R, forall K : R, (forall n : nat, (ler k (f n)) /\ (ler (f n) K)) -> @bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) f.
Axiom thm_SEQ_CBOUNDED : forall f : nat -> R, (cauchy f) -> @bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) f.
Axiom thm_SEQ_ICONV : forall f : nat -> R, ((@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) f) /\ (forall m : nat, forall n : nat, (geqn m n) -> ger (f m) (f n))) -> convergent f.
Axiom thm_SEQ_NEG_CONV : forall f : nat -> R, (convergent f) = (convergent (fun n : nat => oppr (f n))).
Axiom thm_SEQ_NEG_BOUNDED : forall f : nat -> R, (@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) (fun n : nat => oppr (f n))) = (@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) f).
Axiom thm_SEQ_BCONV : forall f : nat -> R, ((@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) f) /\ (mono f)) -> convergent f.
Axiom thm_SEQ_MONOSUB : forall s : nat -> R, exists f : nat -> nat, (subseq f) /\ (mono (fun n : nat => s (f n))).
Axiom thm_SEQ_SBOUNDED : forall s : nat -> R, forall f : nat -> nat, (@bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) s) -> @bounded R nat (@pair (Metric R) (nat -> nat -> Prop) mr1 geqn) (fun n : nat => s (f n)).
Axiom thm_SEQ_SUBLE : forall f : nat -> nat, forall n : nat, (subseq f) -> leqn n (f n).
Axiom thm_SEQ_DIRECT : forall f : nat -> nat, (subseq f) -> forall N1 : nat, forall N2 : nat, exists n : nat, (geqn n N1) /\ (geqn (f n) N2).
Axiom thm_SEQ_CAUCHY : forall f : nat -> R, (cauchy f) = (convergent f).
Axiom thm_SEQ_LE : forall f : nat -> R, forall g : nat -> R, forall l : R, forall m : R, ((tends_num_real f l) /\ ((tends_num_real g m) /\ (exists N' : nat, forall n : nat, (geqn n N') -> ler (f n) (g n)))) -> ler l m.
Axiom thm_SEQ_LE_0 : forall f : nat -> R, forall g : nat -> R, ((tends_num_real f (R_of_nat (NUMERAL O))) /\ (exists N' : nat, forall n : nat, (geqn n N') -> ler (normr (g n)) (normr (f n)))) -> tends_num_real g (R_of_nat (NUMERAL O)).
Axiom thm_SEQ_SUC : forall f : nat -> R, forall l : R, (tends_num_real f l) = (tends_num_real (fun n : nat => f (S n)) l).
Axiom thm_SEQ_ABS : forall f : nat -> R, (tends_num_real (fun n : nat => normr (f n)) (R_of_nat (NUMERAL O))) = (tends_num_real f (R_of_nat (NUMERAL O))).
Axiom thm_SEQ_ABS_IMP : forall f : nat -> R, forall l : R, (tends_num_real f l) -> tends_num_real (fun n : nat => normr (f n)) (normr l).
Axiom thm_SEQ_INV0 : forall f : nat -> R, (forall y : R, exists N' : nat, forall n : nat, (geqn n N') -> gtr (f n) y) -> tends_num_real (fun n : nat => invr (f n)) (R_of_nat (NUMERAL O)).
Axiom thm_SEQ_POWER_ABS : forall c : R, (ltr (normr c) (R_of_nat (NUMERAL (BIT1 O)))) -> tends_num_real (fun n : nat => expr (normr c) n) (R_of_nat (NUMERAL O)).
Axiom thm_SEQ_POWER : forall c : R, (ltr (normr c) (R_of_nat (NUMERAL (BIT1 O)))) -> tends_num_real (fun n : nat => expr c n) (R_of_nat (NUMERAL O)).
Axiom thm_SEQ_HARMONIC : forall a : R, tends_num_real (fun n : nat => divr a (R_of_nat n)) (R_of_nat (NUMERAL O)).
Axiom thm_SEQ_SUBSEQ : forall f : nat -> R, forall l : R, (tends_num_real f l) -> forall a : nat, forall b : nat, (~ (a = (NUMERAL O))) -> tends_num_real (fun n : nat => f (addn (muln a n) b)) l.
Axiom thm_SEQ_POW : forall f : nat -> R, forall l : R, (tends_num_real f l) -> forall n : nat, tends_num_real (fun i : nat => expr (f i) n) (expr l n).
Axiom thm_NEST_LEMMA : forall f : nat -> R, forall g : nat -> R, ((forall n : nat, ger (f (S n)) (f n)) /\ ((forall n : nat, ler (g (S n)) (g n)) /\ (forall n : nat, ler (f n) (g n)))) -> exists l : R, exists m : R, (ler l m) /\ (((forall n : nat, ler (f n) l) /\ (tends_num_real f l)) /\ ((forall n : nat, ler m (g n)) /\ (tends_num_real g m))).
Axiom thm_NEST_LEMMA_UNIQ : forall f : nat -> R, forall g : nat -> R, ((forall n : nat, ger (f (S n)) (f n)) /\ ((forall n : nat, ler (g (S n)) (g n)) /\ ((forall n : nat, ler (f n) (g n)) /\ (tends_num_real (fun n : nat => subr (f n) (g n)) (R_of_nat (NUMERAL O)))))) -> exists l : R, ((forall n : nat, ler (f n) l) /\ (tends_num_real f l)) /\ ((forall n : nat, ler l (g n)) /\ (tends_num_real g l)).
Axiom thm_BOLZANO_LEMMA : forall P : (prod R R) -> Prop, ((forall a : R, forall b : R, forall c : R, ((ler a b) /\ ((ler b c) /\ ((P (@pair R R a b)) /\ (P (@pair R R b c))))) -> P (@pair R R a c)) /\ (forall x : R, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall a : R, forall b : R, ((ler a x) /\ ((ler x b) /\ (ltr (subr b a) d))) -> P (@pair R R a b)))) -> forall a : R, forall b : R, (ler a b) -> P (@pair R R a b).
Axiom thm_BOLZANO_LEMMA_ALT : forall P : R -> R -> Prop, ((forall a : R, forall b : R, forall c : R, ((ler a b) /\ ((ler b c) /\ ((P a b) /\ (P b c)))) -> P a c) /\ (forall x : R, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall a : R, forall b : R, ((ler a x) /\ ((ler x b) /\ (ltr (subr b a) d))) -> P a b))) -> forall a : R, forall b : R, (ler a b) -> P a b.
Axiom thm_sums : forall f : nat -> R, forall s : R, (sums f s) = (tends_num_real (fun n : nat => psum (@pair nat nat (NUMERAL O) n) f) s).
Axiom thm_summable : forall f : nat -> R, (summable f) = (exists s : R, sums f s).
Axiom thm_suminf : forall f : nat -> R, (suminf f) = (@ε R (fun s : R => sums f s)).
Axiom thm_SUM_SUMMABLE : forall f : nat -> R, forall l : R, (sums f l) -> summable f.
Axiom thm_SUMMABLE_SUM : forall f : nat -> R, (summable f) -> sums f (suminf f).
Axiom thm_SUM_UNIQ : forall f : nat -> R, forall x : R, (sums f x) -> x = (suminf f).
Axiom thm_SER_UNIQ : forall f : nat -> R, forall x : R, forall y : R, ((sums f x) /\ (sums f y)) -> x = y.
Axiom thm_SER_0 : forall f : nat -> R, forall n : nat, (forall m : nat, (leqn n m) -> (f m) = (R_of_nat (NUMERAL O))) -> sums f (psum (@pair nat nat (NUMERAL O) n) f).
Axiom thm_SER_POS_LE : forall f : nat -> R, forall n : nat, ((summable f) /\ (forall m : nat, (leqn n m) -> ler (R_of_nat (NUMERAL O)) (f m))) -> ler (psum (@pair nat nat (NUMERAL O) n) f) (suminf f).
Axiom thm_SER_POS_LT : forall f : nat -> R, forall n : nat, ((summable f) /\ (forall m : nat, (leqn n m) -> ltr (R_of_nat (NUMERAL O)) (f m))) -> ltr (psum (@pair nat nat (NUMERAL O) n) f) (suminf f).
Axiom thm_SER_GROUP : forall f : nat -> R, forall k : nat, ((summable f) /\ (ltn (NUMERAL O) k)) -> sums (fun n : nat => psum (@pair nat nat (muln n k) k) f) (suminf f).
Axiom thm_SER_PAIR : forall f : nat -> R, (summable f) -> sums (fun n : nat => psum (@pair nat nat (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT0 (BIT1 O)))) f) (suminf f).
Axiom thm_SER_OFFSET : forall f : nat -> R, (summable f) -> forall k : nat, sums (fun n : nat => f (addn n k)) (subr (suminf f) (psum (@pair nat nat (NUMERAL O) k) f)).
Axiom thm_SER_OFFSET_REV : forall f : nat -> R, forall k : nat, (summable (fun n : nat => f (addn n k))) -> sums f (addr (psum (@pair nat nat (NUMERAL O) k) f) (suminf (fun n : nat => f (addn n k)))).
Axiom thm_SER_POS_LT_PAIR : forall f : nat -> R, forall n : nat, ((summable f) /\ (forall d : nat, ltr (R_of_nat (NUMERAL O)) (addr (f (addn n (muln (NUMERAL (BIT0 (BIT1 O))) d))) (f (addn n (addn (muln (NUMERAL (BIT0 (BIT1 O))) d) (NUMERAL (BIT1 O)))))))) -> ltr (psum (@pair nat nat (NUMERAL O) n) f) (suminf f).
Axiom thm_SER_ADD : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((sums x x0) /\ (sums y y0)) -> sums (fun n : nat => addr (x n) (y n)) (addr x0 y0).
Axiom thm_SER_CMUL : forall x : nat -> R, forall x0 : R, forall c : R, (sums x x0) -> sums (fun n : nat => mulr c (x n)) (mulr c x0).
Axiom thm_SER_NEG : forall x : nat -> R, forall x0 : R, (sums x x0) -> sums (fun n : nat => oppr (x n)) (oppr x0).
Axiom thm_SER_SUB : forall x : nat -> R, forall x0 : R, forall y : nat -> R, forall y0 : R, ((sums x x0) /\ (sums y y0)) -> sums (fun n : nat => subr (x n) (y n)) (subr x0 y0).
Axiom thm_SER_CDIV : forall x : nat -> R, forall x0 : R, forall c : R, (sums x x0) -> sums (fun n : nat => divr (x n) c) (divr x0 c).
Axiom thm_SER_CAUCHY : forall f : nat -> R, (summable f) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall m : nat, forall n : nat, (geqn m N') -> ltr (normr (psum (@pair nat nat m n) f)) e).
Axiom thm_SER_ZERO : forall f : nat -> R, (summable f) -> tends_num_real f (R_of_nat (NUMERAL O)).
Axiom thm_SER_COMPAR : forall f : nat -> R, forall g : nat -> R, ((exists N' : nat, forall n : nat, (geqn n N') -> ler (normr (f n)) (g n)) /\ (summable g)) -> summable f.
Axiom thm_SER_COMPARA : forall f : nat -> R, forall g : nat -> R, ((exists N' : nat, forall n : nat, (geqn n N') -> ler (normr (f n)) (g n)) /\ (summable g)) -> summable (fun k : nat => normr (f k)).
Axiom thm_SER_LE : forall f : nat -> R, forall g : nat -> R, ((forall n : nat, ler (f n) (g n)) /\ ((summable f) /\ (summable g))) -> ler (suminf f) (suminf g).
Axiom thm_SER_LE2 : forall f : nat -> R, forall g : nat -> R, ((forall n : nat, ler (normr (f n)) (g n)) /\ (summable g)) -> (summable f) /\ (ler (suminf f) (suminf g)).
Axiom thm_SER_ACONV : forall f : nat -> R, (summable (fun n : nat => normr (f n))) -> summable f.
Axiom thm_SER_ABS : forall f : nat -> R, (summable (fun n : nat => normr (f n))) -> ler (normr (suminf f)) (suminf (fun n : nat => normr (f n))).
Axiom thm_GP_FINITE : forall x : R, (~ (x = (R_of_nat (NUMERAL (BIT1 O))))) -> forall n : nat, (psum (@pair nat nat (NUMERAL O) n) (fun n' : nat => expr x n')) = (divr (subr (expr x n) (R_of_nat (NUMERAL (BIT1 O)))) (subr x (R_of_nat (NUMERAL (BIT1 O))))).
Axiom thm_GP : forall x : R, (ltr (normr x) (R_of_nat (NUMERAL (BIT1 O)))) -> sums (fun n : nat => expr x n) (invr (subr (R_of_nat (NUMERAL (BIT1 O))) x)).
Axiom thm_ABS_NEG_LEMMA : forall c : R, forall x : R, forall y : R, (ler c (R_of_nat (NUMERAL O))) -> (ler (normr x) (mulr c (normr y))) -> x = (R_of_nat (NUMERAL O)).
Axiom thm_SER_RATIO : forall f : nat -> R, forall c : R, forall N' : nat, ((ltr c (R_of_nat (NUMERAL (BIT1 O)))) /\ (forall n : nat, (geqn n N') -> ler (normr (f (S n))) (mulr c (normr (f n))))) -> summable f.
Axiom thm_SEQ_TRUNCATION : forall f : nat -> R, forall l : R, forall n : nat, forall b : R, ((sums f l) /\ (forall m : nat, ler (normr (psum (@pair nat nat n m) f)) b)) -> ler (normr (subr l (psum (@pair nat nat (NUMERAL O) n) f))) b.
Axiom thm_tends_real_real : forall f : R -> R, forall l : R, forall x0 : R, (tends_real_real f l x0) = (@tends R R f l (@pair (Topology R) (R -> R -> Prop) (@mtop R mr1) (@tendsto R (@pair (Metric R) R mr1 x0)))).
Axiom thm_LIM : forall f : R -> R, forall y0 : R, forall x0 : R, (tends_real_real f y0 x0) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, ((ltr (R_of_nat (NUMERAL O)) (normr (subr x x0))) /\ (ltr (normr (subr x x0)) d)) -> ltr (normr (subr (f x) y0)) e)).
Axiom thm_LIM_CONST : forall k : R, forall x : R, tends_real_real (fun x' : R => k) k x.
Axiom thm_LIM_ADD : forall (x : R), forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, ((tends_real_real f l x) /\ (tends_real_real g m x)) -> tends_real_real (fun x' : R => addr (f x') (g x')) (addr l m) x.
Axiom thm_LIM_MUL : forall (x : R), forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, ((tends_real_real f l x) /\ (tends_real_real g m x)) -> tends_real_real (fun x' : R => mulr (f x') (g x')) (mulr l m) x.
Axiom thm_LIM_NEG : forall (x : R), forall f : R -> R, forall l : R, (tends_real_real f l x) = (tends_real_real (fun x' : R => oppr (f x')) (oppr l) x).
Axiom thm_LIM_INV : forall (x : R), forall f : R -> R, forall l : R, ((tends_real_real f l x) /\ (~ (l = (R_of_nat (NUMERAL O))))) -> tends_real_real (fun x' : R => invr (f x')) (invr l) x.
Axiom thm_LIM_SUB : forall (x : R), forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, ((tends_real_real f l x) /\ (tends_real_real g m x)) -> tends_real_real (fun x' : R => subr (f x') (g x')) (subr l m) x.
Axiom thm_LIM_DIV : forall (x : R), forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, ((tends_real_real f l x) /\ ((tends_real_real g m x) /\ (~ (m = (R_of_nat (NUMERAL O)))))) -> tends_real_real (fun x' : R => divr (f x') (g x')) (divr l m) x.
Axiom thm_LIM_NULL : forall f : R -> R, forall l : R, forall x : R, (tends_real_real f l x) = (tends_real_real (fun x' : R => subr (f x') l) (R_of_nat (NUMERAL O)) x).
Axiom thm_LIM_SUM : forall f : nat -> R -> R, forall l : nat -> R, forall m : nat, forall n : nat, forall x : R, (forall r : nat, ((leqn m r) /\ (ltn r (addn m n))) -> tends_real_real (f r) (l r) x) -> tends_real_real (fun x' : R => psum (@pair nat nat m n) (fun r : nat => f r x')) (psum (@pair nat nat m n) l) x.
Axiom thm_LIM_X : forall x0 : R, tends_real_real (fun x : R => x) x0 x0.
Axiom thm_LIM_UNIQ : forall f : R -> R, forall l : R, forall m : R, forall x : R, ((tends_real_real f l x) /\ (tends_real_real f m x)) -> l = m.
Axiom thm_LIM_EQUAL : forall f : R -> R, forall g : R -> R, forall l : R, forall x0 : R, (forall x : R, (~ (x = x0)) -> (f x) = (g x)) -> (tends_real_real f l x0) = (tends_real_real g l x0).
Axiom thm_LIM_TRANSFORM : forall f : R -> R, forall g : R -> R, forall x0 : R, forall l : R, ((tends_real_real (fun x : R => subr (f x) (g x)) (R_of_nat (NUMERAL O)) x0) /\ (tends_real_real g l x0)) -> tends_real_real f l x0.
Axiom thm_diffl : forall f : R -> R, forall x : R, forall l : R, (diffl f l x) = (tends_real_real (fun h : R => divr (subr (f (addr x h)) (f x)) h) l (R_of_nat (NUMERAL O))).
Axiom thm_contl : forall f : R -> R, forall x : R, (contl f x) = (tends_real_real (fun h : R => f (addr x h)) (f x) (R_of_nat (NUMERAL O))).
Axiom thm_differentiable : forall f : R -> R, forall x : R, (differentiable f x) = (exists l : R, diffl f l x).
Axiom thm_DIFF_UNIQ : forall f : R -> R, forall l : R, forall m : R, forall x : R, ((diffl f l x) /\ (diffl f m x)) -> l = m.
Axiom thm_DIFF_CONT : forall f : R -> R, forall l : R, forall x : R, (diffl f l x) -> contl f x.
Axiom thm_CONTL_LIM : forall f : R -> R, forall x : R, (contl f x) = (tends_real_real f (f x) x).
Axiom thm_CONT_X : forall x : R, contl (fun x' : R => x') x.
Axiom thm_CONT_CONST : forall (k : R), forall x : R, contl (fun x' : R => k) x.
Axiom thm_CONT_ADD : forall (f : R -> R) (g : R -> R), forall x : R, ((contl f x) /\ (contl g x)) -> contl (fun x' : R => addr (f x') (g x')) x.
Axiom thm_CONT_MUL : forall (f : R -> R) (g : R -> R), forall x : R, ((contl f x) /\ (contl g x)) -> contl (fun x' : R => mulr (f x') (g x')) x.
Axiom thm_CONT_NEG : forall (f : R -> R), forall x : R, (contl f x) -> contl (fun x' : R => oppr (f x')) x.
Axiom thm_CONT_INV : forall (f : R -> R), forall x : R, ((contl f x) /\ (~ ((f x) = (R_of_nat (NUMERAL O))))) -> contl (fun x' : R => invr (f x')) x.
Axiom thm_CONT_SUB : forall (f : R -> R) (g : R -> R), forall x : R, ((contl f x) /\ (contl g x)) -> contl (fun x' : R => subr (f x') (g x')) x.
Axiom thm_CONT_DIV : forall (f : R -> R) (g : R -> R), forall x : R, ((contl f x) /\ ((contl g x) /\ (~ ((g x) = (R_of_nat (NUMERAL O)))))) -> contl (fun x' : R => divr (f x') (g x')) x.
Axiom thm_CONT_ABS : forall f : R -> R, forall x : R, (contl f x) -> contl (fun x' : R => normr (f x')) x.
Axiom thm_CONT_COMPOSE : forall f : R -> R, forall g : R -> R, forall x : R, ((contl f x) /\ (contl g (f x))) -> contl (fun x' : R => g (f x')) x.
Axiom thm_IVT : forall f : R -> R, forall a : R, forall b : R, forall y : R, ((ler a b) /\ (((ler (f a) y) /\ (ler y (f b))) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x))) -> exists x : R, (ler a x) /\ ((ler x b) /\ ((f x) = y)).
Axiom thm_IVT2 : forall f : R -> R, forall a : R, forall b : R, forall y : R, ((ler a b) /\ (((ler (f b) y) /\ (ler y (f a))) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x))) -> exists x : R, (ler a x) /\ ((ler x b) /\ ((f x) = y)).
Axiom thm_DIFF_CONST : forall k : R, forall x : R, diffl (fun x' : R => k) (R_of_nat (NUMERAL O)) x.
Axiom thm_DIFF_ADD : forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, forall x : R, ((diffl f l x) /\ (diffl g m x)) -> diffl (fun x' : R => addr (f x') (g x')) (addr l m) x.
Axiom thm_DIFF_MUL : forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, forall x : R, ((diffl f l x) /\ (diffl g m x)) -> diffl (fun x' : R => mulr (f x') (g x')) (addr (mulr l (g x)) (mulr m (f x))) x.
Axiom thm_DIFF_CMUL : forall f : R -> R, forall c : R, forall l : R, forall x : R, (diffl f l x) -> diffl (fun x' : R => mulr c (f x')) (mulr c l) x.
Axiom thm_DIFF_NEG : forall f : R -> R, forall l : R, forall x : R, (diffl f l x) -> diffl (fun x' : R => oppr (f x')) (oppr l) x.
Axiom thm_DIFF_SUB : forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, forall x : R, ((diffl f l x) /\ (diffl g m x)) -> diffl (fun x' : R => subr (f x') (g x')) (subr l m) x.
Axiom thm_DIFF_CARAT : forall f : R -> R, forall l : R, forall x : R, (diffl f l x) = (exists g : R -> R, (forall z : R, (subr (f z) (f x)) = (mulr (g z) (subr z x))) /\ ((contl g x) /\ ((g x) = l))).
Axiom thm_DIFF_CHAIN : forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, forall x : R, ((diffl f l (g x)) /\ (diffl g m x)) -> diffl (fun x' : R => f (g x')) (mulr l m) x.
Axiom thm_DIFF_X : forall x : R, diffl (fun x' : R => x') (R_of_nat (NUMERAL (BIT1 O))) x.
Axiom thm_DIFF_POW : forall n : nat, forall x : R, diffl (fun x' : R => expr x' n) (mulr (R_of_nat n) (expr x (subn n (NUMERAL (BIT1 O))))) x.
Axiom thm_DIFF_XM1 : forall x : R, (~ (x = (R_of_nat (NUMERAL O)))) -> diffl (fun x' : R => invr x') (oppr (expr (invr x) (NUMERAL (BIT0 (BIT1 O))))) x.
Axiom thm_DIFF_INV : forall f : R -> R, forall l : R, forall x : R, ((diffl f l x) /\ (~ ((f x) = (R_of_nat (NUMERAL O))))) -> diffl (fun x' : R => invr (f x')) (oppr (divr l (expr (f x) (NUMERAL (BIT0 (BIT1 O)))))) x.
Axiom thm_DIFF_DIV : forall (x : R), forall f : R -> R, forall g : R -> R, forall l : R, forall m : R, ((diffl f l x) /\ ((diffl g m x) /\ (~ ((g x) = (R_of_nat (NUMERAL O)))))) -> diffl (fun x' : R => divr (f x') (g x')) (divr (subr (mulr l (g x)) (mulr m (f x))) (expr (g x) (NUMERAL (BIT0 (BIT1 O))))) x.
Axiom thm_DIFF_SUM : forall f : nat -> R -> R, forall f' : nat -> R -> R, forall m : nat, forall n : nat, forall x : R, (forall r : nat, ((leqn m r) /\ (ltn r (addn m n))) -> diffl (fun x' : R => f r x') (f' r x) x) -> diffl (fun x' : R => psum (@pair nat nat m n) (fun n' : nat => f n' x')) (psum (@pair nat nat m n) (fun r : nat => f' r x)) x.
Axiom thm_CONT_BOUNDED : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> exists M : R, forall x : R, ((ler a x) /\ (ler x b)) -> ler (f x) M.
Axiom thm_CONT_BOUNDED_ABS : forall f : R -> R, forall a : R, forall b : R, (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) -> exists M : R, forall x : R, ((ler a x) /\ (ler x b)) -> ler (normr (f x)) M.
Axiom thm_CONT_HASSUP : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> exists M : R, (forall x : R, ((ler a x) /\ (ler x b)) -> ler (f x) M) /\ (forall N' : R, (ltr N' M) -> exists x : R, (ler a x) /\ ((ler x b) /\ (ltr N' (f x)))).
Axiom thm_CONT_ATTAINS : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> exists M : R, (forall x : R, ((ler a x) /\ (ler x b)) -> ler (f x) M) /\ (exists x : R, (ler a x) /\ ((ler x b) /\ ((f x) = M))).
Axiom thm_CONT_ATTAINS2 : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> exists M : R, (forall x : R, ((ler a x) /\ (ler x b)) -> ler M (f x)) /\ (exists x : R, (ler a x) /\ ((ler x b) /\ ((f x) = M))).
Axiom thm_CONT_ATTAINS_ALL : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> exists L : R, exists M : R, (forall x : R, ((ler a x) /\ (ler x b)) -> (ler L (f x)) /\ (ler (f x) M)) /\ (forall y : R, ((ler L y) /\ (ler y M)) -> exists x : R, (ler a x) /\ ((ler x b) /\ ((f x) = y))).
Axiom thm_DIFF_LINC : forall f : R -> R, forall x : R, forall l : R, ((diffl f l x) /\ (ltr (R_of_nat (NUMERAL O)) l)) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall h : R, ((ltr (R_of_nat (NUMERAL O)) h) /\ (ltr h d)) -> ltr (f x) (f (addr x h))).
Axiom thm_DIFF_LDEC : forall f : R -> R, forall x : R, forall l : R, ((diffl f l x) /\ (ltr l (R_of_nat (NUMERAL O)))) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall h : R, ((ltr (R_of_nat (NUMERAL O)) h) /\ (ltr h d)) -> ltr (f x) (f (subr x h))).
Axiom thm_DIFF_LMAX : forall f : R -> R, forall x : R, forall l : R, ((diffl f l x) /\ (exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall y : R, (ltr (normr (subr x y)) d) -> ler (f y) (f x)))) -> l = (R_of_nat (NUMERAL O)).
Axiom thm_DIFF_LMIN : forall f : R -> R, forall x : R, forall l : R, ((diffl f l x) /\ (exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall y : R, (ltr (normr (subr x y)) d) -> ler (f x) (f y)))) -> l = (R_of_nat (NUMERAL O)).
Axiom thm_DIFF_LCONST : forall f : R -> R, forall x : R, forall l : R, ((diffl f l x) /\ (exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall y : R, (ltr (normr (subr x y)) d) -> (f y) = (f x)))) -> l = (R_of_nat (NUMERAL O)).
Axiom thm_INTERVAL_LEMMA_LT : forall a : R, forall b : R, forall x : R, ((ltr a x) /\ (ltr x b)) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall y : R, (ltr (normr (subr x y)) d) -> (ltr a y) /\ (ltr y b)).
Axiom thm_INTERVAL_LEMMA : forall a : R, forall b : R, forall x : R, ((ltr a x) /\ (ltr x b)) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall y : R, (ltr (normr (subr x y)) d) -> (ler a y) /\ (ler y b)).
Axiom thm_ROLLE : forall f : R -> R, forall a : R, forall b : R, ((ltr a b) /\ (((f a) = (f b)) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) /\ (forall x : R, ((ltr a x) /\ (ltr x b)) -> differentiable f x)))) -> exists z : R, (ltr a z) /\ ((ltr z b) /\ (diffl f (R_of_nat (NUMERAL O)) z)).
Axiom thm_MVT_LEMMA : forall f : R -> R, forall a : R, forall b : R, ((fun x : R => subr (f x) (mulr (divr (subr (f b) (f a)) (subr b a)) x)) a) = ((fun x : R => subr (f x) (mulr (divr (subr (f b) (f a)) (subr b a)) x)) b).
Axiom thm_MVT : forall f : R -> R, forall a : R, forall b : R, ((ltr a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) /\ (forall x : R, ((ltr a x) /\ (ltr x b)) -> differentiable f x))) -> exists l : R, exists z : R, (ltr a z) /\ ((ltr z b) /\ ((diffl f l z) /\ ((subr (f b) (f a)) = (mulr (subr b a) l)))).
Axiom thm_MVT_ALT : forall f : R -> R, forall f' : R -> R, forall a : R, forall b : R, ((ltr a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> diffl f (f' x) x)) -> exists z : R, (ltr a z) /\ ((ltr z b) /\ ((subr (f b) (f a)) = (mulr (subr b a) (f' z)))).
Axiom thm_DIFF_ISCONST_END : forall f : R -> R, forall a : R, forall b : R, ((ltr a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) /\ (forall x : R, ((ltr a x) /\ (ltr x b)) -> diffl f (R_of_nat (NUMERAL O)) x))) -> (f b) = (f a).
Axiom thm_DIFF_ISCONST : forall f : R -> R, forall a : R, forall b : R, ((ltr a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) /\ (forall x : R, ((ltr a x) /\ (ltr x b)) -> diffl f (R_of_nat (NUMERAL O)) x))) -> forall x : R, ((ler a x) /\ (ler x b)) -> (f x) = (f a).
Axiom thm_DIFF_ISCONST_END_SIMPLE : forall f : R -> R, forall a : R, forall b : R, ((ltr a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> diffl f (R_of_nat (NUMERAL O)) x)) -> (f b) = (f a).
Axiom thm_DIFF_ISCONST_ALL : forall f : R -> R, forall x : R, forall y : R, (forall x' : R, diffl f (R_of_nat (NUMERAL O)) x') -> (f x) = (f y).
Axiom thm_CONT_INJ_LEMMA : forall f : R -> R, forall g : R -> R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ler (normr (subr z x)) d) -> (g (f z)) = z) /\ (forall z : R, (ler (normr (subr z x)) d) -> contl f z))) -> ~ (forall z : R, (ler (normr (subr z x)) d) -> ler (f z) (f x)).
Axiom thm_CONT_INJ_LEMMA2 : forall f : R -> R, forall g : R -> R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ler (normr (subr z x)) d) -> (g (f z)) = z) /\ (forall z : R, (ler (normr (subr z x)) d) -> contl f z))) -> ~ (forall z : R, (ler (normr (subr z x)) d) -> ler (f x) (f z)).
Axiom thm_CONT_INJ_RANGE : forall f : R -> R, forall g : R -> R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ler (normr (subr z x)) d) -> (g (f z)) = z) /\ (forall z : R, (ler (normr (subr z x)) d) -> contl f z))) -> exists e : R, (ltr (R_of_nat (NUMERAL O)) e) /\ (forall y : R, (ler (normr (subr y (f x))) e) -> exists z : R, (ler (normr (subr z x)) d) /\ ((f z) = y)).
Axiom thm_CONT_INVERSE : forall f : R -> R, forall g : R -> R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ler (normr (subr z x)) d) -> (g (f z)) = z) /\ (forall z : R, (ler (normr (subr z x)) d) -> contl f z))) -> contl g (f x).
Axiom thm_DIFF_INVERSE : forall f : R -> R, forall g : R -> R, forall l : R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ler (normr (subr z x)) d) -> (g (f z)) = z) /\ ((forall z : R, (ler (normr (subr z x)) d) -> contl f z) /\ ((diffl f l x) /\ (~ (l = (R_of_nat (NUMERAL O)))))))) -> diffl g (invr l) (f x).
Axiom thm_DIFF_INVERSE_LT : forall f : R -> R, forall g : R -> R, forall l : R, forall x : R, forall d : R, ((ltr (R_of_nat (NUMERAL O)) d) /\ ((forall z : R, (ltr (normr (subr z x)) d) -> (g (f z)) = z) /\ ((forall z : R, (ltr (normr (subr z x)) d) -> contl f z) /\ ((diffl f l x) /\ (~ (l = (R_of_nat (NUMERAL O)))))))) -> diffl g (invr l) (f x).
Axiom thm_IVT_DERIVATIVE_0 : forall f : R -> R, forall f' : R -> R, forall a : R, forall b : R, ((ler a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> diffl f (f' x) x) /\ ((gtr (f' a) (R_of_nat (NUMERAL O))) /\ (ltr (f' b) (R_of_nat (NUMERAL O)))))) -> exists z : R, (ltr a z) /\ ((ltr z b) /\ ((f' z) = (R_of_nat (NUMERAL O)))).
Axiom thm_IVT_DERIVATIVE_POS : forall f : R -> R, forall f' : R -> R, forall a : R, forall b : R, forall y : R, ((ler a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> diffl f (f' x) x) /\ ((gtr (f' a) y) /\ (ltr (f' b) y)))) -> exists z : R, (ltr a z) /\ ((ltr z b) /\ ((f' z) = y)).
Axiom thm_IVT_DERIVATIVE_NEG : forall f : R -> R, forall f' : R -> R, forall a : R, forall b : R, forall y : R, ((ler a b) /\ ((forall x : R, ((ler a x) /\ (ler x b)) -> diffl f (f' x) x) /\ ((ltr (f' a) y) /\ (gtr (f' b) y)))) -> exists z : R, (ltr a z) /\ ((ltr z b) /\ ((f' z) = y)).
Axiom thm_SEQ_CONT_UNIFORM : forall s : nat -> R -> R, forall f : R -> R, forall x0 : R, ((forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall n : nat, ((ltr (normr (subr x x0)) d) /\ (geqn n N')) -> ltr (normr (subr (s n x) (f x))) e)) /\ (exists N' : nat, forall n : nat, (geqn n N') -> contl (s n) x0)) -> contl f x0.
Axiom thm_SER_COMPARA_UNIFORM : forall s : R -> nat -> R, forall x0 : R, forall g : nat -> R, ((exists N' : nat, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall n : nat, forall x : R, ((ltr (normr (subr x x0)) d) /\ (geqn n N')) -> ler (normr (s x n)) (g n))) /\ (summable g)) -> exists f : R -> R, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall x : R, forall n : nat, ((ltr (normr (subr x x0)) d) /\ (geqn n N')) -> ltr (normr (subr (psum (@pair nat nat (NUMERAL O) n) (s x)) (f x))) e).
Axiom thm_SER_COMPARA_UNIFORM_WEAK : forall s : R -> nat -> R, forall x0 : R, forall g : nat -> R, ((exists N' : nat, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall n : nat, forall x : R, ((ltr (normr (subr x x0)) d) /\ (geqn n N')) -> ler (normr (s x n)) (g n))) /\ (summable g)) -> exists f : R -> R, forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall n : nat, ((ltr (normr (subr x x0)) d) /\ (geqn n N')) -> ltr (normr (subr (psum (@pair nat nat (NUMERAL O) n) (s x)) (f x))) e).
Axiom thm_CONTL : forall f : R -> R, forall x : R, (contl f x) = (forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x' : R, (ltr (normr (subr x' x)) d) -> ltr (normr (subr (f x') (f x))) e)).
Axiom thm_CONTL_SEQ : forall f : R -> R, forall x : nat -> R, forall l : R, ((contl f l) /\ (tends_num_real x l)) -> tends_num_real (fun n : nat => f (x n)) (f l).
Axiom thm_SUP_INTERVAL : forall P : R -> Prop, forall a : R, forall b : R, (exists x : R, (ler a x) /\ ((ler x b) /\ (P x))) -> exists s : R, (ler a s) /\ ((ler s b) /\ (forall y : R, (ltr y s) = (exists x : R, (ler a x) /\ ((ler x b) /\ ((P x) /\ (ltr y x)))))).
Axiom thm_CONT_UNIFORM : forall f : R -> R, forall a : R, forall b : R, ((ler a b) /\ (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x)) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall y : R, ((ler a x) /\ ((ler x b) /\ ((ler a y) /\ ((ler y b) /\ (ltr (normr (subr x y)) d))))) -> ltr (normr (subr (f x) (f y))) e).
Axiom thm_CONT_UNIFORM_STRONG : forall f : R -> R, forall a : R, forall b : R, (forall x : R, ((ler a x) /\ (ler x b)) -> contl f x) -> forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists d : R, (ltr (R_of_nat (NUMERAL O)) d) /\ (forall x : R, forall y : R, ((((ler a x) /\ (ler x b)) \/ ((ler a y) /\ (ler y b))) /\ (ltr (normr (subr x y)) d)) -> ltr (normr (subr (f x) (f y))) e).
Axiom thm_SUBSET_PRED : forall {_169226 : Type'}, forall P : _169226 -> Prop, forall Q : _169226 -> Prop, (@subset _169226 P Q) = (forall x : _169226, (P x) -> Q x).
Axiom thm_UNIONS_PRED : forall {_169242 : Type'} (P : (_169242 -> Prop) -> Prop), (@UNIONS _169242 P) = (fun x : _169242 => exists p : _169242 -> Prop, (P p) /\ (p x)).
Axiom thm_IN_FLD : forall {A : Type'}, forall l : A -> A -> Prop, forall x : A, (@IN A x (@fld A l)) = (exists y : A, (l x y) \/ (l y x)).
Axiom thm_FLD_EQ_EMPTY : forall {A : Type'}, forall R' : A -> A -> Prop, ((@fld A R') = (@set0 A)) = (R' = (fun x : A => fun y : A => False)).
Axiom thm_FLD_SUBSET : forall {_169347 : Type'}, forall l : _169347 -> _169347 -> Prop, forall r : _169347 -> _169347 -> Prop, (forall x : _169347, forall y : _169347, (l x y) -> r x y) -> @subset _169347 (@fld _169347 l) (@fld _169347 r).
Axiom thm_FINITE_FLD : forall {A : Type'}, forall l : A -> A -> Prop, (@finite_set A (@fld A l)) = (@finite_set (prod A A) (@GSPEC (prod A A) (fun GEN_PVAR_378 : prod A A => exists x : A, exists y : A, @SETSPEC (prod A A) GEN_PVAR_378 (l x y) (@pair A A x y)))).
Axiom thm_qoset : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) = ((forall x : A, (@IN A x (@fld A l)) -> l x x) /\ (forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z)).
Axiom thm_poset : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) = ((forall x : A, (@IN A x (@fld A l)) -> l x x) /\ ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ (forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y))).
Axiom thm_toset : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) = ((forall x : A, (@IN A x (@fld A l)) -> l x x) /\ ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ ((forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A l)) /\ (@IN A y (@fld A l))) -> (l x y) \/ (l y x))))).
Axiom thm_woset : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((forall x : A, (@IN A x (@fld A l)) -> l x x) /\ ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ ((forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A l)) /\ (@IN A y (@fld A l))) -> (l x y) \/ (l y x)) /\ (forall s : A -> Prop, ((@subset A s (@fld A l)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> l x y)))))).
Axiom thm_wqoset : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((forall x : A, (@IN A x (@fld A l)) -> l x x) /\ ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ (forall s : A -> Prop, (@subset A s (@fld A l)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (l x y)))))).
Axiom thm_chain : forall {A : Type'}, forall s : A -> Prop, forall l : A -> A -> Prop, (@chain A l s) = (forall x : A, forall y : A, ((@IN A x s) /\ (@IN A y s)) -> (l x y) \/ (l y x)).
Axiom thm_antichain : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, (@antichain A l s) = ((@subset A s (@fld A l)) /\ (@pairwise A (fun x : A => fun y : A => ~ (l x y)) s)).
Axiom thm_CHAIN : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, (@chain A l s) = ((@subset A s (@fld A l)) /\ (forall x : A, forall y : A, ((@IN A x s) /\ (@IN A y s)) -> (l x y) \/ (l y x))).
Axiom thm_ANTICHAIN : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, (@antichain A l s) = ((@subset A s (@fld A l)) /\ (forall x : A, forall y : A, ((@IN A x s) /\ ((@IN A y s) /\ (~ (x = y)))) -> ~ (l x y))).
Axiom thm_CHAIN_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@chain A l s) /\ (@subset A t s)) -> @chain A l t.
Axiom thm_ANTICHAIN_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, forall t : A -> Prop, ((@antichain A l s) /\ (@subset A t s)) -> @antichain A l t.
Axiom thm_QOSET_REFL : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) -> forall x : A, (@fld A l x) -> l x x.
Axiom thm_QOSET_TRANS : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) -> forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z.
Axiom thm_QOSET_REFL_EQ : forall {A : Type'}, forall l : A -> A -> Prop, forall x : A, (@qoset A l) -> (l x x) = (@IN A x (@fld A l)).
Axiom thm_QOSET_FLDEQ : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) -> forall x : A, (@fld A l x) = (l x x).
Axiom thm_QOSET_FLD : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) -> (@fld A l) = (@GSPEC A (fun GEN_PVAR_379 : A => exists x : A, @SETSPEC A GEN_PVAR_379 (l x x) x)).
Axiom thm_WOSET_IMP_TOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> @toset A l.
Axiom thm_WOSET_IMP_POSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> @poset A l.
Axiom thm_WOSET_IMP_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> @qoset A l.
Axiom thm_TOSET_IMP_POSET : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) -> @poset A l.
Axiom thm_TOSET_IMP_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) -> @qoset A l.
Axiom thm_POSET_IMP_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> @qoset A l.
Axiom thm_WQOSET_IMP_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) -> @qoset A l.
Axiom thm_strictly : forall {A : Type'}, forall R' : A -> A -> Prop, (@strictly A R') = (fun x : A => fun y : A => (R' x y) /\ (~ (R' y x))).
Axiom thm_properly : forall {A : Type'}, forall R' : A -> A -> Prop, (@properly A R') = (fun x : A => fun y : A => (R' x y) /\ (~ (x = y))).
Axiom thm_PROPERLY_EQ_STRICTLY : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> (@properly A l) = (@strictly A l).
Axiom thm_STRICTLY_EQ_PROPERLY : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> (@strictly A l) = (@properly A l).
Axiom thm_STRICTLY_IMP_PROPERLY : forall {A : Type'}, forall l : A -> A -> Prop, forall x : A, forall y : A, ((@qoset A l) /\ (@strictly A l x y)) -> @properly A l x y.
Axiom thm_STRICTLY_STRICTLY : forall {A : Type'}, forall R' : A -> A -> Prop, (@strictly A (@strictly A R')) = (@strictly A R').
Axiom thm_PROPERLY_PROPERLY : forall {A : Type'}, forall R' : A -> A -> Prop, (@properly A (@properly A R')) = (@properly A R').
Axiom thm_STRICTLY_PROPERLY : forall {A : Type'}, forall R' : A -> A -> Prop, (@strictly A (@properly A R')) = (@strictly A R').
Axiom thm_PROPERLY_STRICTLY : forall {A : Type'}, forall R' : A -> A -> Prop, (@properly A (@strictly A R')) = (@strictly A R').
Axiom thm_PROPERLY_MONO : forall {_170368 : Type'}, forall R' : _170368 -> _170368 -> Prop, forall S' : _170368 -> _170368 -> Prop, (forall x : _170368, forall y : _170368, (R' x y) -> S' x y) -> forall x : _170368, forall y : _170368, (@properly _170368 R' x y) -> @properly _170368 S' x y.
Axiom thm_POSET_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) = ((@qoset A l) /\ (forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y)).
Axiom thm_TOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) = ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ ((forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A l)) /\ (@IN A y (@fld A l))) -> (l x y) \/ (l y x)))).
Axiom thm_TOSET_POSET : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) = ((@poset A l) /\ (forall x : A, forall y : A, ((@IN A x (@fld A l)) /\ (@IN A y (@fld A l))) -> (l x y) \/ (l y x))).
Axiom thm_WOSET_TOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((@toset A l) /\ (forall s : A -> Prop, ((@subset A s (@fld A l)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> l x y))).
Axiom thm_WQOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z) /\ (forall s : A -> Prop, (@subset A s (@fld A l)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (l x y))))).
Axiom thm_WQOSET_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((@qoset A l) /\ (forall s : A -> Prop, (@subset A s (@fld A l)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (l x y))))).
Axiom thm_WOSET_POSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((@poset A l) /\ (forall s : A -> Prop, ((@subset A s (@fld A l)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> l x y))).
Axiom thm_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y) /\ (forall s : A -> Prop, ((@subset A s (@fld A l)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> l x y))).
Axiom thm_WOSET_WF : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((forall x : A, forall y : A, ((@IN A x (@fld A l)) /\ (@IN A y (@fld A l))) -> (l x y) \/ (l y x)) /\ (@well_founded A (@properly A l))).
Axiom thm_WOSET_IMP_WQOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> @wqoset A l.
Axiom thm_WQOSET_SUPERSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@wqoset A l) /\ ((@qoset A m) /\ ((@subset A (@fld A m) (@fld A l)) /\ (forall x : A, forall y : A, (l x y) -> m x y)))) -> @wqoset A m.
Axiom thm_WQOSET_NOBAD : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((@qoset A l) /\ (forall x : nat -> A, (forall n : nat, @IN A (x n) (@fld A l)) -> exists i : nat, exists j : nat, (ltn i j) /\ (l (x i) (x j)))).
Axiom thm_WQOSET_ANTICHAIN : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((@qoset A l) /\ ((@well_founded A (@strictly A l)) /\ (forall s : A -> Prop, (@antichain A l s) -> @finite_set A s))).
Axiom thm_WQOSET_NOBAD_SUBSEQ : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((@qoset A l) /\ (forall x : nat -> A, (forall n : nat, @IN A (x n) (@fld A l)) -> exists r : nat -> nat, (forall m : nat, forall n : nat, (ltn m n) -> ltn (r m) (r n)) /\ (forall i : nat, forall j : nat, (leqn i j) -> l (x (r i)) (x (r j))))).
Axiom thm_WQOSET_IMP_WF : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) -> @well_founded A (@strictly A l).
Axiom thm_WQOSET_WF_SUPERSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@wqoset A l) /\ ((@qoset A m) /\ ((@subset A (@fld A m) (@fld A l)) /\ (forall x : A, forall y : A, (l x y) -> m x y)))) -> @well_founded A (@strictly A m).
Axiom thm_WQOSET_WF_SUPERSET_EQ : forall {A : Type'}, forall l : A -> A -> Prop, (@wqoset A l) = ((@qoset A l) /\ (forall m : A -> A -> Prop, ((@qoset A m) /\ (((@fld A m) = (@fld A l)) /\ (forall x : A, forall y : A, (l x y) -> m x y))) -> @well_founded A (@strictly A m))).
Axiom thm_WOSET_WQOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) = ((@toset A l) /\ (@wqoset A l)).
Axiom thm_FLD_RESTRICT_QOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@qoset A l) -> (@fld A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y)))) = (@GSPEC A (fun GEN_PVAR_389 : A => exists x : A, @SETSPEC A GEN_PVAR_389 ((@IN A x (@fld A l)) /\ (P x)) x)).
Axiom thm_FLD_RESTRICT_POSET : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@poset A l) -> (@fld A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y)))) = (@GSPEC A (fun GEN_PVAR_390 : A => exists x : A, @SETSPEC A GEN_PVAR_390 ((@IN A x (@fld A l)) /\ (P x)) x)).
Axiom thm_FLD_RESTRICT_TOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@toset A l) -> (@fld A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y)))) = (@GSPEC A (fun GEN_PVAR_391 : A => exists x : A, @SETSPEC A GEN_PVAR_391 ((@IN A x (@fld A l)) /\ (P x)) x)).
Axiom thm_FLD_RESTRICT_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@woset A l) -> (@fld A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y)))) = (@GSPEC A (fun GEN_PVAR_392 : A => exists x : A, @SETSPEC A GEN_PVAR_392 ((@IN A x (@fld A l)) /\ (P x)) x)).
Axiom thm_FLD_RESTRICT_WQOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@wqoset A l) -> (@fld A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y)))) = (@GSPEC A (fun GEN_PVAR_393 : A => exists x : A, @SETSPEC A GEN_PVAR_393 ((@IN A x (@fld A l)) /\ (P x)) x)).
Axiom thm_QOSET_RESTRICT : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@qoset A l) -> @qoset A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y))).
Axiom thm_POSET_RESTRICT : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@poset A l) -> @poset A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y))).
Axiom thm_TOSET_RESTRICT : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@toset A l) -> @toset A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y))).
Axiom thm_WOSET_RESTRICT : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@woset A l) -> @woset A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y))).
Axiom thm_WQOSET_RESTRICT : forall {A : Type'}, forall l : A -> A -> Prop, forall P : A -> Prop, (@wqoset A l) -> @wqoset A (fun x : A => fun y : A => (P x) /\ ((P y) /\ (l x y))).
Axiom thm_QOSET_MAX : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@qoset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> ~ (@strictly A l a x)).
Axiom thm_QOSET_MIN : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@qoset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> ~ (@strictly A l x a)).
Axiom thm_POSET_MAX : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@poset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> ~ (@properly A l a x)).
Axiom thm_POSET_MIN : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@poset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> ~ (@properly A l x a)).
Axiom thm_TOSET_MAX : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@toset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> l x a).
Axiom thm_TOSET_MIN : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@toset A l) /\ ((@finite_set A s) /\ ((~ (s = (@set0 A))) /\ (@subset A s (@fld A l))))) -> exists a : A, (@IN A a s) /\ (forall x : A, (@IN A x s) -> l a x).
Axiom thm_FLD_TRIVIAL : forall {A : Type'}, (@fld A (fun x : A => fun y : A => False)) = (@set0 A).
Axiom thm_WOSET_TRIVIAL : forall {A : Type'}, @woset A (fun x : A => fun y : A => False).
Axiom thm_WQOSET_TRIVIAL : forall {A : Type'}, @wqoset A (fun x : A => fun y : A => False).
Axiom thm_TOSET_TRIVIAL : forall {A : Type'}, @toset A (fun x : A => fun y : A => False).
Axiom thm_POSET_TRIVIAL : forall {A : Type'}, @poset A (fun x : A => fun y : A => False).
Axiom thm_QOSET_TRIVIAL : forall {A : Type'}, @qoset A (fun x : A => fun y : A => False).
Axiom thm_FLD_num : (@fld nat leqn) = (@setT nat).
Axiom thm_WOSET_num : @woset nat leqn.
Axiom thm_WQOSET_num : @wqoset nat leqn.
Axiom thm_TOSET_num : @toset nat leqn.
Axiom thm_POSET_num : @poset nat leqn.
Axiom thm_QOSET_num : @qoset nat leqn.
Axiom thm_QOSET_POINTWISE : forall {A K : Type'}, forall l : A -> A -> Prop, forall s : K -> Prop, (@qoset (K -> A) (fun x : K -> A => fun y : K -> A => forall i : K, (@IN K i s) -> l (x i) (y i))) = ((s = (@set0 K)) \/ (@qoset A l)).
Axiom thm_FLD_POINTWISE : forall {A K : Type'}, forall l : A -> A -> Prop, forall s : K -> Prop, (@qoset A l) -> (@fld (K -> A) (fun x : K -> A => fun y : K -> A => forall i : K, (@IN K i s) -> l (x i) (y i))) = (@GSPEC (K -> A) (fun GEN_PVAR_394 : K -> A => exists x : K -> A, @SETSPEC (K -> A) GEN_PVAR_394 (forall i : K, (@IN K i s) -> @IN A (x i) (@fld A l)) x)).
Axiom thm_WQOSET_POINTWISE : forall {A K : Type'}, forall l : A -> A -> Prop, forall s : K -> Prop, ((@wqoset A l) /\ (@finite_set K s)) -> @wqoset (K -> A) (fun x : K -> A => fun y : K -> A => forall i : K, (@IN K i s) -> l (x i) (y i)).
Axiom thm_DICKSON : forall n : nat, forall x : nat -> nat -> nat, exists i : nat, exists j : nat, (ltn i j) /\ (forall k : nat, (ltn k n) -> leqn (x i k) (x j k)).
Axiom thm_inseg : forall {A : Type'}, forall m : A -> A -> Prop, forall l : A -> A -> Prop, (@inseg A l m) = (forall x : A, forall y : A, (l x y) = ((m x y) /\ (@fld A l y))).
Axiom thm_INSEG_ANTISYM : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@inseg A l m) /\ (@inseg A m l)) -> l = m.
Axiom thm_INSEG_REFL : forall {A : Type'}, forall l : A -> A -> Prop, @inseg A l l.
Axiom thm_INSEG_TRANS : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, forall n : A -> A -> Prop, ((@inseg A l m) /\ (@inseg A m n)) -> @inseg A l n.
Axiom thm_linseg : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, (@linseg A l a) = (fun x : A => fun y : A => (l x y) /\ (@properly A l y a)).
Axiom thm_ordinal : forall {A : Type'}, forall l : A -> A -> Prop, (@ordinal A l) = ((@woset A l) /\ (forall x : A, (@fld A l x) -> x = (@ε A (fun y : A => ~ (@properly A l y x))))).
Axiom thm_POSET_REFL : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> forall x : A, (@fld A l x) -> l x x.
Axiom thm_POSET_TRANS : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z.
Axiom thm_POSET_ANTISYM : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y.
Axiom thm_POSET_FLDEQ : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> forall x : A, (@fld A l x) = (l x x).
Axiom thm_WOSET_REFL : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, (@fld A l x) -> l x x.
Axiom thm_WOSET_TRANS : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, forall z : A, ((l x y) /\ (l y z)) -> l x z.
Axiom thm_WOSET_ANTISYM : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, ((l x y) /\ (l y x)) -> x = y.
Axiom thm_WOSET_TOTAL : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, ((@fld A l x) /\ (@fld A l y)) -> (l x y) \/ (l y x).
Axiom thm_WOSET_WELL : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall s : A -> Prop, ((forall x : A, (s x) -> @fld A l x) /\ (exists x : A, s x)) -> exists x : A, (s x) /\ (forall y : A, (s y) -> l x y).
Axiom thm_WOSET_FLDEQ : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, (@fld A l x) = (l x x).
Axiom thm_WOSET_TRANS_LESS : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, forall z : A, ((@properly A l x y) /\ (l y z)) -> @properly A l x z.
Axiom thm_PAIRED_EXT : forall {A B C : Type'}, forall l : A -> B -> C, forall m : A -> B -> C, (forall x : A, forall y : B, (l x y) = (m x y)) = (l = m).
Axiom thm_WOSET_TRANS_LE : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, forall z : A, ((l x y) /\ (@properly A l y z)) -> @properly A l x z.
Axiom thm_WOSET_WELL_CONTRAPOS : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall P : A -> Prop, ((forall x : A, (P x) -> @fld A l x) /\ (exists x : A, P x)) -> exists y : A, (P y) /\ (forall z : A, (@properly A l z y) -> ~ (P z)).
Axiom thm_WOSET_TOTAL_LE : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, ((@fld A l x) /\ (@fld A l y)) -> (l x y) \/ (@properly A l y x).
Axiom thm_WOSET_TOTAL_LT : forall {A : Type'}, forall l : A -> A -> Prop, (@woset A l) -> forall x : A, forall y : A, ((@fld A l x) /\ (@fld A l y)) -> (x = y) \/ ((@properly A l x y) \/ (@properly A l y x)).
Axiom thm_ORDINAL_IMP_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@ordinal A l) -> @woset A l.
Axiom thm_WOSET_FINITE_TOSET : forall {A : Type'}, forall l : A -> A -> Prop, ((@toset A l) /\ (@finite_set (prod A A) (@GSPEC (prod A A) (fun GEN_PVAR_396 : prod A A => exists x : A, exists y : A, @SETSPEC (prod A A) GEN_PVAR_396 (l x y) (@pair A A x y))))) -> @woset A l.
Axiom thm_UNION_FLD : forall {A : Type'} (x : A), forall P : (A -> A -> Prop) -> Prop, (@fld A (fun x' : A => fun y : A => exists l : A -> A -> Prop, (P l) /\ (l x' y)) x) = (exists l : A -> A -> Prop, (P l) /\ (@fld A l x)).
Axiom thm_UNION_INSEG : forall {A : Type'}, forall P : (A -> A -> Prop) -> Prop, forall l : A -> A -> Prop, (forall m : A -> A -> Prop, (P m) -> @inseg A m l) -> @inseg A (fun x : A => fun y : A => exists l' : A -> A -> Prop, (P l') /\ (l' x y)) l.
Axiom thm_INSEG_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, (@inseg A m l) -> forall x : A, forall y : A, (m x y) -> l x y.
Axiom thm_INSEG_SUBSET_FLD : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, (@inseg A m l) -> forall x : A, (@fld A m x) -> @fld A l x.
Axiom thm_INSEG_FLD_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, (@inseg A l m) -> @subset A (@fld A l) (@fld A m).
Axiom thm_INSEG_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@inseg A m l) /\ (@woset A l)) -> @woset A m.
Axiom thm_INSEG_ORDINAL : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@inseg A m l) /\ (@ordinal A l)) -> @ordinal A m.
Axiom thm_LINSEG_INSEG : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, (@woset A l) -> @inseg A (@linseg A l a) l.
Axiom thm_LINSEG_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, (@woset A l) -> @woset A (@linseg A l a).
Axiom thm_LINSEG_FLD : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, forall x : A, (@woset A l) -> (@fld A (@linseg A l a) x) = (@properly A l x a).
Axiom thm_INSEG_PROPER_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@inseg A m l) /\ (~ (l = m))) -> exists x : A, exists y : A, (l x y) /\ (~ (m x y)).
Axiom thm_INSEG_PROPER_SUBSET_FLD : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@inseg A m l) /\ (~ (l = m))) -> exists a : A, (@fld A l a) /\ (~ (@fld A m a)).
Axiom thm_INSEG_LINSEG : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, (@woset A l) -> (@inseg A m l) = ((m = l) \/ (exists a : A, (@fld A l a) /\ (m = (@linseg A l a)))).
Axiom thm_EXTEND_FLD : forall {A : Type'} (a : A), forall l : A -> A -> Prop, forall x : A, (@woset A l) -> (@fld A (fun x' : A => fun y : A => (l x' y) /\ (l y a)) x) = (l x a).
Axiom thm_EXTEND_INSEG : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, ((@woset A l) /\ (@fld A l a)) -> @inseg A (fun x : A => fun y : A => (l x y) /\ (l y a)) l.
Axiom thm_EXTEND_LINSEG : forall {A : Type'}, forall l : A -> A -> Prop, forall a : A, ((@woset A l) /\ (@fld A l a)) -> @inseg A (fun x : A => fun y : A => (@linseg A l a x y) \/ ((y = a) /\ ((@fld A (@linseg A l a) x) \/ (x = a)))) l.
Axiom thm_ORDINAL_CHAINED_LEMMA : forall {A : Type'}, forall k : A -> A -> Prop, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@ordinal A l) /\ (@ordinal A m)) -> ((@inseg A k l) /\ (@inseg A k m)) -> (k = l) \/ ((k = m) \/ (exists a : A, (@fld A l a) /\ ((@fld A m a) /\ ((k = (@linseg A l a)) /\ (k = (@linseg A m a)))))).
Axiom thm_ORDINAL_CHAINED : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@ordinal A l) /\ (@ordinal A m)) -> (@inseg A m l) \/ (@inseg A l m).
Axiom thm_ORDINAL_FLD_UNIQUE : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@ordinal A l) /\ ((@ordinal A m) /\ ((@fld A l) = (@fld A m)))) -> l = m.
Axiom thm_ORDINAL_FLD_SUBSET : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@ordinal A l) /\ ((@ordinal A m) /\ (@subset A (@fld A l) (@fld A m)))) -> @inseg A l m.
Axiom thm_ORDINAL_FLD_SUBSET_EQ : forall {A : Type'}, forall l : A -> A -> Prop, forall m : A -> A -> Prop, ((@ordinal A l) /\ (@ordinal A m)) -> (@subset A (@fld A l) (@fld A m)) = (@inseg A l m).
Axiom thm_FLD_SUC : forall {A : Type'} (x : A), forall l : A -> A -> Prop, forall a : A, (@fld A (fun x' : A => fun y : A => (l x' y) \/ ((y = a) /\ ((@fld A l x') \/ (x' = a)))) x) = ((@fld A l x) \/ (x = a)).
Axiom thm_ORDINAL_SUC : forall {A : Type'}, forall l : A -> A -> Prop, ((@ordinal A l) /\ (exists x : A, ~ (@fld A l x))) -> @ordinal A (fun x : A => fun y : A => (l x y) \/ ((y = (@ε A (fun y' : A => ~ (@fld A l y')))) /\ ((@fld A l x) \/ (x = (@ε A (fun y' : A => ~ (@fld A l y'))))))).
Axiom thm_ORDINAL_UNION : forall {A : Type'}, forall P : (A -> A -> Prop) -> Prop, (forall l : A -> A -> Prop, (P l) -> @ordinal A l) -> @ordinal A (fun x : A => fun y : A => exists l : A -> A -> Prop, (P l) /\ (l x y)).
Axiom thm_ORDINAL_UNION_LEMMA : forall {A : Type'}, forall l : A -> A -> Prop, forall x : A, (@ordinal A l) -> (@fld A l x) -> @fld A (fun a : A => fun b : A => exists l' : A -> A -> Prop, (@ordinal A l') /\ (l' a b)) x.
Axiom thm_ORDINAL_UP : forall {A : Type'}, forall l : A -> A -> Prop, (@ordinal A l) -> (forall x : A, @fld A l x) \/ (exists m : A -> A -> Prop, exists x : A, (@ordinal A m) /\ ((@fld A m x) /\ (~ (@fld A l x)))).
Axiom thm_WO_ORDINAL : forall {A : Type'}, exists l : A -> A -> Prop, (@ordinal A l) /\ (forall x : A, @fld A l x).
Axiom thm_FLD_RESTRICT : forall {A : Type'} (x : A), forall l : A -> A -> Prop, (@woset A l) -> forall P : A -> Prop, (@fld A (fun x' : A => fun y : A => (P x') /\ ((P y) /\ (l x' y))) x) = ((P x) /\ (@fld A l x)).
Axiom thm_WO : forall {A : Type'}, forall P : A -> Prop, exists l : A -> A -> Prop, (@woset A l) /\ ((@fld A l) = P).
Axiom thm_WF_INSEG_WOSET : forall {A : Type'}, @well_founded (A -> A -> Prop) (fun x : A -> A -> Prop => fun y : A -> A -> Prop => (@woset A x) /\ ((@woset A y) /\ ((@inseg A x y) /\ (~ (x = y))))).
Axiom thm_WOSET_INSEG_ORDINAL : forall {A : Type'}, @woset (A -> A -> Prop) (fun x : A -> A -> Prop => fun y : A -> A -> Prop => (@ordinal A x) /\ ((@ordinal A y) /\ (@inseg A x y))).
Axiom thm_SUBWOSET_ISO_INSEG : forall {A : Type'}, forall l : A -> A -> Prop, forall s : A -> Prop, ((@woset A l) /\ ((@fld A l) = (@setT A))) -> exists f : A -> A, (forall x : A, forall y : A, ((@IN A x s) /\ (@IN A y s)) -> (l (f x) (f y)) = (l x y)) /\ (forall x : A, forall y : A, ((@IN A y (@IMAGE A A f s)) /\ (l x y)) -> @IN A x (@IMAGE A A f s)).
Axiom thm_HP : forall {A : Type'}, forall l : A -> A -> Prop, (@qoset A l) -> exists P : A -> Prop, (@chain A l P) /\ (forall Q : A -> Prop, ((@chain A l Q) /\ (@subset A P Q)) -> Q = P).
Axiom thm_ZL_STRONG : forall {A : Type'}, forall l : A -> A -> Prop, ((@qoset A l) /\ (forall c : A -> Prop, (@chain A l c) -> exists y : A, (@IN A y (@fld A l)) /\ (forall x : A, (@IN A x c) -> l x y))) -> exists y : A, (@IN A y (@fld A l)) /\ (forall x : A, (l y x) -> l x y).
Axiom thm_ZL : forall {A : Type'}, forall l : A -> A -> Prop, ((@poset A l) /\ (forall P : A -> Prop, (@chain A l P) -> exists y : A, (@fld A l y) /\ (forall x : A, (P x) -> l x y))) -> exists y : A, (@fld A l y) /\ (forall x : A, (l y x) -> y = x).
Axiom thm_KL_POSET_LEMMA : forall {A : Type'} (C : A -> Prop) (l : A -> A -> Prop), @poset (A -> Prop) (fun c1 : A -> Prop => fun c2 : A -> Prop => (@subset A C c1) /\ ((@subset A c1 c2) /\ (@chain A l c2))).
Axiom thm_KL : forall {A : Type'}, forall l : A -> A -> Prop, (@poset A l) -> forall C : A -> Prop, (@chain A l C) -> exists P : A -> Prop, ((@chain A l P) /\ (@subset A C P)) /\ (forall R' : A -> Prop, ((@chain A l R') /\ (@subset A P R')) -> R' = P).
Axiom thm_POSET_RESTRICTED_SUBSET : forall {_176547 : Type'}, forall P : (_176547 -> Prop) -> Prop, @poset (_176547 -> Prop) (fun x : _176547 -> Prop => fun y : _176547 -> Prop => (P x) /\ ((P y) /\ (@subset _176547 x y))).
Axiom thm_FLD_RESTRICTED_SUBSET : forall {_176570 : Type'}, forall P : (_176570 -> Prop) -> Prop, (@fld (_176570 -> Prop) (fun x : _176570 -> Prop => fun y : _176570 -> Prop => (P x) /\ ((P y) /\ (@subset _176570 x y)))) = P.
Axiom thm_ZL_SUBSETS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall c : (A -> Prop) -> Prop, ((forall x : A -> Prop, (@IN (A -> Prop) x c) -> P x) /\ (forall x : A -> Prop, forall y : A -> Prop, ((@IN (A -> Prop) x c) /\ (@IN (A -> Prop) y c)) -> (@subset A x y) \/ (@subset A y x))) -> exists z : A -> Prop, (P z) /\ (forall x : A -> Prop, (@IN (A -> Prop) x c) -> @subset A x z)) -> exists a : A -> Prop, (P a) /\ (forall x : A -> Prop, ((P x) /\ (@subset A a x)) -> a = x).
Axiom thm_ZL_SUBSETS_UNIONS : forall {A : Type'}, forall P : (A -> Prop) -> Prop, (forall c : (A -> Prop) -> Prop, ((forall x : A -> Prop, (@IN (A -> Prop) x c) -> P x) /\ (forall x : A -> Prop, forall y : A -> Prop, ((@IN (A -> Prop) x c) /\ (@IN (A -> Prop) y c)) -> (@subset A x y) \/ (@subset A y x))) -> P (@UNIONS A c)) -> exists a : A -> Prop, (P a) /\ (forall x : A -> Prop, ((P x) /\ (@subset A a x)) -> a = x).
Axiom thm_ZL_SUBSETS_UNIONS_NONEMPTY : forall {A : Type'}, forall P : (A -> Prop) -> Prop, ((exists x : A -> Prop, P x) /\ (forall c : (A -> Prop) -> Prop, ((exists x : A -> Prop, @IN (A -> Prop) x c) /\ ((forall x : A -> Prop, (@IN (A -> Prop) x c) -> P x) /\ (forall x : A -> Prop, forall y : A -> Prop, ((@IN (A -> Prop) x c) /\ (@IN (A -> Prop) y c)) -> (@subset A x y) \/ (@subset A y x)))) -> P (@UNIONS A c))) -> exists a : A -> Prop, (P a) /\ (forall x : A -> Prop, ((P x) /\ (@subset A a x)) -> a = x).
Axiom thm_TUKEY : forall {A : Type'}, forall s : (A -> Prop) -> Prop, ((~ (s = (@set0 (A -> Prop)))) /\ (forall t : A -> Prop, (forall c : A -> Prop, ((@finite_set A c) /\ (@subset A c t)) -> @IN (A -> Prop) c s) = (@IN (A -> Prop) t s))) -> exists u : A -> Prop, (@IN (A -> Prop) u s) /\ (forall v : A -> Prop, ((@IN (A -> Prop) v s) /\ (@subset A u v)) -> u = v).
Axiom thm_OEP : forall {A : Type'}, forall p : A -> A -> Prop, (@poset A p) -> exists t : A -> A -> Prop, (@toset A t) /\ (((@fld A t) = (@fld A p)) /\ (forall x : A, forall y : A, (p x y) -> t x y)).
Axiom thm_TOSET_COFINAL_WOSET : forall {A : Type'}, forall l : A -> A -> Prop, (@toset A l) -> exists w : A -> A -> Prop, (forall x : A, forall y : A, (w x y) -> l x y) /\ ((@woset A w) /\ (forall x : A, (@IN A x (@fld A l)) -> exists y : A, (@IN A y (@fld A w)) /\ (l x y))).
Axiom thm_SYM_ALT : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> R' y x) = (forall x : A, forall y : A, (R' x y) = (R' y x)).
Axiom thm_TRANS_ALT : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, forall U : A -> A -> Prop, (forall x : A, forall z : A, (exists y : A, (R' x y) /\ (S' y z)) -> U x z) = (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (S' y z)) -> U x z).
Axiom thm_RC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall a0 : A, forall a1 : A, (@RC A R' a0 a1) = ((R' a0 a1) \/ (a1 = a0)).
Axiom thm_RC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall RC' : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> RC' x y) /\ (forall x : A, RC' x x)) -> forall a0 : A, forall a1 : A, (@RC A R' a0 a1) -> RC' a0 a1.
Axiom thm_RC_RULES : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> @RC A R' x y) /\ (forall x : A, @RC A R' x x).
Axiom thm_RC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @RC A R' x y.
Axiom thm_RC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, @RC A R' x x.
Axiom thm_RC_EXPLICIT : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RC A R' x y) = ((R' x y) \/ (x = y)).
Axiom thm_RC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@RC A R' x y) -> @RC A S' x y.
Axiom thm_RC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@RC A R') = R') = (forall x : A, R' x x).
Axiom thm_RC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@RC A (@RC A R')) = (@RC A R').
Axiom thm_RC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> R' y x) -> forall x : A, forall y : A, (@RC A R' x y) -> @RC A R' y x.
Axiom thm_RC_TRANS : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z) -> forall x : A, forall y : A, forall z : A, ((@RC A R' x y) /\ (@RC A R' y z)) -> @RC A R' x z.
Axiom thm_SC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall a0 : A, forall a1 : A, (@SC A R' a0 a1) = ((R' a0 a1) \/ (@SC A R' a1 a0)).
Axiom thm_SC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall SC' : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> SC' x y) /\ (forall x : A, forall y : A, (SC' x y) -> SC' y x)) -> forall a0 : A, forall a1 : A, (@SC A R' a0 a1) -> SC' a0 a1.
Axiom thm_SC_RULES : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> @SC A R' x y) /\ (forall x : A, forall y : A, (@SC A R' x y) -> @SC A R' y x).
Axiom thm_SC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @SC A R' x y.
Axiom thm_SC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A R' x y) -> @SC A R' y x.
Axiom thm_SC_EXPLICIT : forall {A : Type'} (y : A) (x : A), forall R' : A -> A -> Prop, (@SC A R' x y) = ((R' x y) \/ (R' y x)).
Axiom thm_SC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@SC A R' x y) -> @SC A S' x y.
Axiom thm_SC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@SC A R') = R') = (forall x : A, forall y : A, (R' x y) -> R' y x).
Axiom thm_SC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@SC A (@SC A R')) = (@SC A R').
Axiom thm_SC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, R' x x) -> forall x : A, @SC A R' x x.
Axiom thm_TC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall a0 : A, forall a1 : A, (@Relation_Operators.clos_trans A R' a0 a1) = ((R' a0 a1) \/ (exists y : A, (@Relation_Operators.clos_trans A R' a0 y) /\ (@Relation_Operators.clos_trans A R' y a1))).
Axiom thm_TC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall TC' : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> TC' x y) /\ (forall x : A, forall y : A, forall z : A, ((TC' x y) /\ (TC' y z)) -> TC' x z)) -> forall a0 : A, forall a1 : A, (@Relation_Operators.clos_trans A R' a0 a1) -> TC' a0 a1.
Axiom thm_TC_RULES : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> @Relation_Operators.clos_trans A R' x y) /\ (forall x : A, forall y : A, forall z : A, ((@Relation_Operators.clos_trans A R' x y) /\ (@Relation_Operators.clos_trans A R' y z)) -> @Relation_Operators.clos_trans A R' x z).
Axiom thm_TC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @Relation_Operators.clos_trans A R' x y.
Axiom thm_TC_TRANS : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@Relation_Operators.clos_trans A R' x y) /\ (@Relation_Operators.clos_trans A R' y z)) -> @Relation_Operators.clos_trans A R' x z.
Axiom thm_TC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> @Relation_Operators.clos_trans A S' x y.
Axiom thm_TC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@Relation_Operators.clos_trans A R') = R') = (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z).
Axiom thm_TC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@Relation_Operators.clos_trans A (@Relation_Operators.clos_trans A R')) = (@Relation_Operators.clos_trans A R').
Axiom thm_TC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, R' x x) -> forall x : A, @Relation_Operators.clos_trans A R' x x.
Axiom thm_TC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> R' y x) -> forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> @Relation_Operators.clos_trans A R' y x.
Axiom thm_RC_SC : forall {A : Type'}, forall R' : A -> A -> Prop, (@RC A (@SC A R')) = (@SC A (@RC A R')).
Axiom thm_SC_RC : forall {A : Type'}, forall R' : A -> A -> Prop, (@SC A (@RC A R')) = (@RC A (@SC A R')).
Axiom thm_RC_TC : forall {A : Type'}, forall R' : A -> A -> Prop, (@RC A (@Relation_Operators.clos_trans A R')) = (@Relation_Operators.clos_trans A (@RC A R')).
Axiom thm_TC_RC : forall {A : Type'}, forall R' : A -> A -> Prop, (@Relation_Operators.clos_trans A (@RC A R')) = (@RC A (@Relation_Operators.clos_trans A R')).
Axiom thm_TC_SC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A (@Relation_Operators.clos_trans A R') x y) -> @Relation_Operators.clos_trans A (@SC A R') x y.
Axiom thm_SC_TC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A (@Relation_Operators.clos_trans A R') x y) -> @Relation_Operators.clos_trans A (@SC A R') x y.
Axiom thm_TC_TRANS_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@Relation_Operators.clos_trans A R' x y) /\ (R' y z)) -> @Relation_Operators.clos_trans A R' x z.
Axiom thm_TC_TRANS_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((R' x y) /\ (@Relation_Operators.clos_trans A R' y z)) -> @Relation_Operators.clos_trans A R' x z.
Axiom thm_TC_CASES_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@Relation_Operators.clos_trans A R' x z) = ((R' x z) \/ (exists y : A, (@Relation_Operators.clos_trans A R' x y) /\ (R' y z))).
Axiom thm_TC_CASES_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@Relation_Operators.clos_trans A R' x z) = ((R' x z) \/ (exists y : A, (R' x y) /\ (@Relation_Operators.clos_trans A R' y z))).
Axiom thm_TC_INDUCT_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ (forall x : A, forall y : A, forall z : A, ((P x y) /\ (R' y z)) -> P x z)) -> forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> P x y.
Axiom thm_TC_INDUCT_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ (forall x : A, forall z : A, (exists y : A, (R' x y) /\ (P y z)) -> P x z)) -> forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> P x y.
Axiom thm_WF_TC : forall {A : Type'}, forall R' : A -> A -> Prop, (@well_founded A (@Relation_Operators.clos_trans A R')) = (@well_founded A R').
Axiom thm_RSC : forall {A : Type'}, forall R' : A -> A -> Prop, (@RSC A R') = (@RC A (@SC A R')).
Axiom thm_RSC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @RSC A R' x y.
Axiom thm_RSC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, @RSC A R' x x.
Axiom thm_RSC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RSC A R' x y) -> @RSC A R' y x.
Axiom thm_RSC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RSC A R' x y) = ((x = y) \/ ((R' x y) \/ (R' y x))).
Axiom thm_RSC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ ((forall x : A, P x x) /\ (forall x : A, forall y : A, (P x y) -> P y x))) -> forall x : A, forall y : A, (@RSC A R' x y) -> P x y.
Axiom thm_RSC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@RSC A R' x y) -> @RSC A S' x y.
Axiom thm_RSC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@RSC A R') = R') = ((forall x : A, R' x x) /\ (forall x : A, forall y : A, (R' x y) -> R' y x)).
Axiom thm_RSC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@RSC A (@RSC A R')) = (@RSC A R').
Axiom thm_RTC : forall {A : Type'}, forall R' : A -> A -> Prop, (@RTC A R') = (@RC A (@Relation_Operators.clos_trans A R')).
Axiom thm_RTC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @RTC A R' x y.
Axiom thm_RTC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, @RTC A R' x x.
Axiom thm_RTC_TRANS : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@RTC A R' x y) /\ (@RTC A R' y z)) -> @RTC A R' x z.
Axiom thm_RTC_RULES : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> @RTC A R' x y) /\ ((forall x : A, @RTC A R' x x) /\ (forall x : A, forall y : A, forall z : A, ((@RTC A R' x y) /\ (@RTC A R' y z)) -> @RTC A R' x z)).
Axiom thm_RTC_TRANS_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@RTC A R' x y) /\ (R' y z)) -> @RTC A R' x z.
Axiom thm_RTC_TRANS_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((R' x y) /\ (@RTC A R' y z)) -> @RTC A R' x z.
Axiom thm_RTC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RTC A R' x z) = ((x = z) \/ (exists y : A, (@RTC A R' x y) /\ (@RTC A R' y z))).
Axiom thm_RTC_CASES_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RTC A R' x z) = ((x = z) \/ (exists y : A, (@RTC A R' x y) /\ (R' y z))).
Axiom thm_RTC_CASES_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RTC A R' x z) = ((x = z) \/ (exists y : A, (R' x y) /\ (@RTC A R' y z))).
Axiom thm_RTC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ ((forall x : A, P x x) /\ (forall x : A, forall y : A, forall z : A, ((P x y) /\ (P y z)) -> P x z))) -> forall x : A, forall y : A, (@RTC A R' x y) -> P x y.
Axiom thm_RTC_INDUCT_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, P x x) /\ (forall x : A, forall y : A, forall z : A, ((P x y) /\ (R' y z)) -> P x z)) -> forall x : A, forall y : A, (@RTC A R' x y) -> P x y.
Axiom thm_RTC_INDUCT_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, P x x) /\ (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (P y z)) -> P x z)) -> forall x : A, forall y : A, (@RTC A R' x y) -> P x y.
Axiom thm_RTC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@RTC A R' x y) -> @RTC A S' x y.
Axiom thm_RTC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@RTC A R') = R') = ((forall x : A, R' x x) /\ (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z)).
Axiom thm_RTC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@RTC A (@RTC A R')) = (@RTC A R').
Axiom thm_RTC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> R' y x) -> forall x : A, forall y : A, (@RTC A R' x y) -> @RTC A R' y x.
Axiom thm_RTC_STUTTER : forall {_180072 : Type'} (R' : _180072 -> _180072 -> Prop), (@RTC _180072 R') = (@RTC _180072 (fun x : _180072 => fun y : _180072 => (R' x y) /\ (~ (x = y)))).
Axiom thm_TC_RTC_CASES_L : forall {_180092 : Type'} (x : _180092) (R' : _180092 -> _180092 -> Prop) (z : _180092), (@Relation_Operators.clos_trans _180092 R' x z) = (exists y : _180092, (@RTC _180092 R' x y) /\ (R' y z)).
Axiom thm_TC_RTC_CASES_R : forall {_180119 : Type'}, forall R' : _180119 -> _180119 -> Prop, forall x : _180119, forall z : _180119, (@Relation_Operators.clos_trans _180119 R' x z) = (exists y : _180119, (R' x y) /\ (@RTC _180119 R' y z)).
Axiom thm_TC_TC_RTC_CASES : forall {_180140 : Type'}, forall R' : _180140 -> _180140 -> Prop, forall x : _180140, forall z : _180140, (@Relation_Operators.clos_trans _180140 R' x z) = (exists y : _180140, (@Relation_Operators.clos_trans _180140 R' x y) /\ (@RTC _180140 R' y z)).
Axiom thm_TC_RTC_TC_CASES : forall {_180173 : Type'}, forall R' : _180173 -> _180173 -> Prop, forall x : _180173, forall z : _180173, (@Relation_Operators.clos_trans _180173 R' x z) = (exists y : _180173, (@RTC _180173 R' x y) /\ (@Relation_Operators.clos_trans _180173 R' y z)).
Axiom thm_RTC_NE_IMP_TC : forall {_180213 : Type'}, forall R' : _180213 -> _180213 -> Prop, forall x : _180213, forall y : _180213, ((@RTC _180213 R' x y) /\ (~ (x = y))) -> @Relation_Operators.clos_trans _180213 R' x y.
Axiom thm_STC : forall {A : Type'}, forall R' : A -> A -> Prop, (@STC A R') = (@Relation_Operators.clos_trans A (@SC A R')).
Axiom thm_STC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @STC A R' x y.
Axiom thm_STC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@STC A R' x y) -> @STC A R' y x.
Axiom thm_STC_TRANS : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@STC A R' x y) /\ (@STC A R' y z)) -> @STC A R' x z.
Axiom thm_STC_TRANS_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@STC A R' x y) /\ (R' y z)) -> @STC A R' x z.
Axiom thm_STC_TRANS_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((R' x y) /\ (@STC A R' y z)) -> @STC A R' x z.
Axiom thm_STC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@STC A R' x z) = ((R' x z) \/ ((@STC A R' z x) \/ (exists y : A, (@STC A R' x y) /\ (@STC A R' y z)))).
Axiom thm_STC_CASES_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@STC A R' x z) = ((R' x z) \/ ((@STC A R' z x) \/ (exists y : A, (@STC A R' x y) /\ (R' y z)))).
Axiom thm_STC_CASES_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@STC A R' x z) = ((R' x z) \/ ((@STC A R' z x) \/ (exists y : A, (R' x y) /\ (@STC A R' y z)))).
Axiom thm_STC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ ((forall x : A, forall y : A, (P x y) -> P y x) /\ (forall x : A, forall y : A, forall z : A, ((P x y) /\ (P y z)) -> P x z))) -> forall x : A, forall y : A, (@STC A R' x y) -> P x y.
Axiom thm_STC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@STC A R' x y) -> @STC A S' x y.
Axiom thm_STC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@STC A R') = R') = ((forall x : A, forall y : A, (R' x y) -> R' y x) /\ (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z)).
Axiom thm_STC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@STC A (@STC A R')) = (@STC A R').
Axiom thm_STC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, R' x x) -> forall x : A, @STC A R' x x.
Axiom thm_RSTC : forall {A : Type'}, forall R' : A -> A -> Prop, (@RSTC A R') = (@RC A (@Relation_Operators.clos_trans A (@SC A R'))).
Axiom thm_RSTC_INC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_REFL : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, @RSTC A R' x x.
Axiom thm_RSTC_SYM : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RSTC A R' x y) -> @RSTC A R' y x.
Axiom thm_RSTC_TRANS : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@RSTC A R' x y) /\ (@RSTC A R' y z)) -> @RSTC A R' x z.
Axiom thm_RSTC_RULES : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> @RSTC A R' x y) /\ ((forall x : A, @RSTC A R' x x) /\ ((forall x : A, forall y : A, (@RSTC A R' x y) -> @RSTC A R' y x) /\ (forall x : A, forall y : A, forall z : A, ((@RSTC A R' x y) /\ (@RSTC A R' y z)) -> @RSTC A R' x z))).
Axiom thm_RSTC_TRANS_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((@RSTC A R' x y) /\ (R' y z)) -> @RSTC A R' x z.
Axiom thm_RSTC_TRANS_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, forall z : A, ((R' x y) /\ (@RSTC A R' y z)) -> @RSTC A R' x z.
Axiom thm_RSTC_CASES : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RSTC A R' x z) = ((x = z) \/ ((R' x z) \/ ((@RSTC A R' z x) \/ (exists y : A, (@RSTC A R' x y) /\ (@RSTC A R' y z))))).
Axiom thm_RSTC_CASES_L : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RSTC A R' x z) = ((x = z) \/ ((R' x z) \/ ((@RSTC A R' z x) \/ (exists y : A, (@RSTC A R' x y) /\ (R' y z))))).
Axiom thm_RSTC_CASES_R : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall z : A, (@RSTC A R' x z) = ((x = z) \/ ((R' x z) \/ ((@RSTC A R' z x) \/ (exists y : A, (R' x y) /\ (@RSTC A R' y z))))).
Axiom thm_RSTC_INDUCT : forall {A : Type'}, forall R' : A -> A -> Prop, forall P : A -> A -> Prop, ((forall x : A, forall y : A, (R' x y) -> P x y) /\ ((forall x : A, P x x) /\ ((forall x : A, forall y : A, (P x y) -> P y x) /\ (forall x : A, forall y : A, forall z : A, ((P x y) /\ (P y z)) -> P x z)))) -> forall x : A, forall y : A, (@RSTC A R' x y) -> P x y.
Axiom thm_RSTC_MONO : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y : A, (R' x y) -> S' x y) -> forall x : A, forall y : A, (@RSTC A R' x y) -> @RSTC A S' x y.
Axiom thm_RSTC_CLOSED : forall {A : Type'}, forall R' : A -> A -> Prop, ((@RSTC A R') = R') = ((forall x : A, R' x x) /\ ((forall x : A, forall y : A, (R' x y) -> R' y x) /\ (forall x : A, forall y : A, forall z : A, ((R' x y) /\ (R' y z)) -> R' x z))).
Axiom thm_RSTC_IDEMP : forall {A : Type'}, forall R' : A -> A -> Prop, (@RSTC A (@RSTC A R')) = (@RSTC A R').
Axiom thm_RSC_INC_RC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RC A R' x y) -> @RSC A R' x y.
Axiom thm_RSC_INC_SC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A R' x y) -> @RSC A R' x y.
Axiom thm_RTC_INC_RC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RC A R' x y) -> @RTC A R' x y.
Axiom thm_RTC_INC_TC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> @RTC A R' x y.
Axiom thm_STC_INC_SC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A R' x y) -> @STC A R' x y.
Axiom thm_STC_INC_TC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> @STC A R' x y.
Axiom thm_RSTC_INC_RC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RC A R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_INC_SC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@SC A R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_INC_TC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_INC_RSC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RSC A R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_INC_RTC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RTC A R' x y) -> @RSTC A R' x y.
Axiom thm_RSTC_INC_STC : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@STC A R' x y) -> @RSTC A R' x y.
Axiom thm_INV : forall {A B : Type'}, forall R' : B -> A -> Prop, forall y : B, forall x : A, (@INV A B R' x y) = (R' y x).
Axiom thm_RC_INV : forall {_181587 : Type'} (R' : _181587 -> _181587 -> Prop), (@RC _181587 (@INV _181587 _181587 R')) = (@INV _181587 _181587 (@RC _181587 R')).
Axiom thm_SC_INV : forall {_181601 : Type'} (R' : _181601 -> _181601 -> Prop), (@SC _181601 (@INV _181601 _181601 R')) = (@INV _181601 _181601 (@SC _181601 R')).
Axiom thm_SC_INV_STRONG : forall {_181612 : Type'} (R' : _181612 -> _181612 -> Prop), (@SC _181612 (@INV _181612 _181612 R')) = (@SC _181612 R').
Axiom thm_TC_INV : forall {_181626 : Type'} (R' : _181626 -> _181626 -> Prop), (@Relation_Operators.clos_trans _181626 (@INV _181626 _181626 R')) = (@INV _181626 _181626 (@Relation_Operators.clos_trans _181626 R')).
Axiom thm_RSC_INV : forall {_181640 : Type'} (R' : _181640 -> _181640 -> Prop), (@RSC _181640 (@INV _181640 _181640 R')) = (@INV _181640 _181640 (@RSC _181640 R')).
Axiom thm_RTC_INV : forall {_181654 : Type'} (R' : _181654 -> _181654 -> Prop), (@RTC _181654 (@INV _181654 _181654 R')) = (@INV _181654 _181654 (@RTC _181654 R')).
Axiom thm_STC_INV : forall {_181668 : Type'} (R' : _181668 -> _181668 -> Prop), (@STC _181668 (@INV _181668 _181668 R')) = (@INV _181668 _181668 (@STC _181668 R')).
Axiom thm_RSTC_INV : forall {_181682 : Type'} (R' : _181682 -> _181682 -> Prop), (@RSTC _181682 (@INV _181682 _181682 R')) = (@INV _181682 _181682 (@RSTC _181682 R')).
Axiom thm_RELPOW : forall {A : Type'} (n : nat) (x : A) (R' : A -> A -> Prop) (y : A), ((@RELPOW A (NUMERAL O) R' x y) = (x = y)) /\ ((@RELPOW A (S n) R' x y) = (exists z : A, (@RELPOW A n R' x z) /\ (R' z y))).
Axiom thm_RELPOW_R : forall {A : Type'} (x : A) (n : nat) (R' : A -> A -> Prop) (y : A), ((@RELPOW A (NUMERAL O) R' x y) = (x = y)) /\ ((@RELPOW A (S n) R' x y) = (exists z : A, (R' x z) /\ (@RELPOW A n R' z y))).
Axiom thm_RELPOW_M : forall {A : Type'} (R' : A -> A -> Prop), forall m : nat, forall n : nat, forall x : A, forall y : A, (@RELPOW A (addn m n) R' x y) = (exists z : A, (@RELPOW A m R' x z) /\ (@RELPOW A n R' z y)).
Axiom thm_RTC_RELPOW : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@RTC A R' x y) = (exists n : nat, @RELPOW A n R' x y).
Axiom thm_TC_RELPOW : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, forall y : A, (@Relation_Operators.clos_trans A R' x y) = (exists n : nat, @RELPOW A (S n) R' x y).
Axiom thm_RELPOW_SEQUENCE : forall {A : Type'}, forall R' : A -> A -> Prop, forall n : nat, forall x : A, forall y : A, (@RELPOW A n R' x y) = (exists f : nat -> A, ((f (NUMERAL O)) = x) /\ (((f n) = y) /\ (forall i : nat, (ltn i n) -> R' (f i) (f (S i))))).
Axiom thm_fld : forall {_181981 : Type'}, forall R' : _181981 -> _181981 -> Prop, (@fld _181981 R') = (@GSPEC _181981 (fun GEN_PVAR_406 : _181981 => exists x : _181981, @SETSPEC _181981 GEN_PVAR_406 (exists y : _181981, (R' x y) \/ (R' y x)) x)).
Axiom thm_NORMAL : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, (@NORMAL A R' x) = (~ (exists y : A, R' x y)).
Axiom thm_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A R') = (forall x : A, forall y1 : A, forall y2 : A, ((R' x y1) /\ (R' x y2)) -> exists z : A, (R' y1 z) /\ (R' y2 z)).
Axiom thm_WCR : forall {A : Type'}, forall R' : A -> A -> Prop, (@WCR A R') = (forall x : A, forall y1 : A, forall y2 : A, ((R' x y1) /\ (R' x y2)) -> exists z : A, (@RTC A R' y1 z) /\ (@RTC A R' y2 z)).
Axiom thm_WN : forall {A : Type'}, forall R' : A -> A -> Prop, (@WN A R') = (forall x : A, exists y : A, (@RTC A R' x y) /\ (@NORMAL A R' y)).
Axiom thm_SN : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') = (~ (exists seq : nat -> A, forall n : nat, R' (seq n) (seq (S n)))).
Axiom thm_TREE : forall {A : Type'}, forall R' : A -> A -> Prop, (@TREE A R') = ((forall y : A, ~ (@Relation_Operators.clos_trans A R' y y)) /\ (exists a : A, (@IN A a (@fld A R')) /\ (forall y : A, (@IN A y (@fld A R')) -> (y = a) \/ ((@Relation_Operators.clos_trans A R' a y) /\ (@ex1 A (fun x : A => R' x y)))))).
Axiom thm_LF : forall {A : Type'}, forall R' : A -> A -> Prop, (@LF A R') = (forall x : A, @finite_set A (@GSPEC A (fun GEN_PVAR_407 : A => exists y : A, @SETSPEC A GEN_PVAR_407 (R' x y) y))).
Axiom thm_SN_WF : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') = (@well_founded A (@INV A A R')).
Axiom thm_SN_PRESERVE : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') = (forall P : A -> Prop, (forall x : A, (P x) -> exists y : A, (P y) /\ (R' x y)) -> ~ (exists x : A, P x)).
Axiom thm_SN_NOETHERIAN : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') = (forall P : A -> Prop, (forall x : A, (forall y : A, (R' x y) -> P y) -> P x) -> forall x : A, P x).
Axiom thm_NORMAL_TC : forall {A : Type'} (x : A), forall R' : A -> A -> Prop, (@NORMAL A (@Relation_Operators.clos_trans A R') x) = (@NORMAL A R' x).
Axiom thm_NORMAL_RTC : forall {A : Type'} (x : A), forall R' : A -> A -> Prop, (@NORMAL A R' x) -> forall y : A, (@RTC A R' x y) = (x = y).
Axiom thm_WN_TC : forall {A : Type'}, forall R' : A -> A -> Prop, (@WN A (@Relation_Operators.clos_trans A R')) = (@WN A R').
Axiom thm_SN_TC : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A (@Relation_Operators.clos_trans A R')) = (@SN A R').
Axiom thm_SN_WN : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') -> @WN A R'.
Axiom thm_RC_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A R') -> @CR A (@RC A R').
Axiom thm_STRIP_LEMMA : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, (forall x : A, forall y1 : A, forall y2 : A, ((R' x y1) /\ (S' x y2)) -> exists z : A, (S' y1 z) /\ (R' y2 z)) -> forall x : A, forall y1 : A, forall y2 : A, ((@Relation_Operators.clos_trans A R' x y1) /\ (S' x y2)) -> exists z : A, (S' y1 z) /\ (@Relation_Operators.clos_trans A R' y2 z).
Axiom thm_TC_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A R') -> @CR A (@Relation_Operators.clos_trans A R').
Axiom thm_RTC_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A R') -> @CR A (@RTC A R').
Axiom thm_STC_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A (@RTC A R')) = (forall x : A, forall y : A, (@RSTC A R' x y) -> exists z : A, (@RTC A R' x z) /\ (@RTC A R' y z)).
Axiom thm_NORM_CR : forall {A : Type'}, forall R' : A -> A -> Prop, (@WN A R') -> (@CR A (@RTC A R')) = (forall x : A, forall y1 : A, forall y2 : A, ((@RTC A R' x y1) /\ ((@NORMAL A R' y1) /\ ((@RTC A R' x y2) /\ (@NORMAL A R' y2)))) -> y1 = y2).
Axiom thm_CR_NORM : forall {A : Type'}, forall R' : A -> A -> Prop, ((@WN A R') /\ (@CR A (@RTC A R'))) = (forall x : A, @ex1 A (fun y : A => (@RTC A R' x y) /\ (@NORMAL A R' y))).
Axiom thm_NEWMAN_LEMMA : forall {A : Type'}, forall R' : A -> A -> Prop, ((@SN A R') /\ (@WCR A R')) -> @CR A (@RTC A R').
Axiom thm_LF_TC_FINITE : forall {A : Type'}, forall R' : A -> A -> Prop, ((@LF A R') /\ (@SN A R')) -> forall x : A, @finite_set A (@GSPEC A (fun GEN_PVAR_414 : A => exists y : A, @SETSPEC A GEN_PVAR_414 (@Relation_Operators.clos_trans A R' x y) y)).
Axiom thm_SN_NOLOOP : forall {A : Type'}, forall R' : A -> A -> Prop, (@SN A R') -> forall z : A, ~ (@Relation_Operators.clos_trans A R' z z).
Axiom thm_RELPOW_RTC : forall {A : Type'}, forall R' : A -> A -> Prop, forall n : nat, forall x : A, forall y : A, (@RELPOW A n R' x y) -> @RTC A R' x y.
Axiom thm_RTC_TC_LEMMA : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, (@GSPEC A (fun GEN_PVAR_415 : A => exists y : A, @SETSPEC A GEN_PVAR_415 (@RTC A R' x y) y)) = (@INSERT A x (@GSPEC A (fun GEN_PVAR_416 : A => exists y : A, @SETSPEC A GEN_PVAR_416 (@Relation_Operators.clos_trans A R' x y) y))).
Axiom thm_HAS_SIZE_SUBSET : forall {A : Type'}, forall s : A -> Prop, forall t : A -> Prop, forall m : nat, forall n : nat, ((@HAS_SIZE A s m) /\ ((@HAS_SIZE A t n) /\ (@subset A s t))) -> leqn m n.
Axiom thm_FC_FINITE_BOUND_LEMMA : forall {A : Type'} (x : A), forall R' : A -> A -> Prop, (forall z : A, ~ (@Relation_Operators.clos_trans A R' z z)) -> forall n : nat, (@HAS_SIZE A (@GSPEC A (fun GEN_PVAR_426 : A => exists y : A, @SETSPEC A GEN_PVAR_426 (@RTC A R' x y) y)) n) -> forall m : nat, forall y : A, (@RELPOW A m R' x y) -> leqn m n.
Axiom thm_FC_FINITE_BOUND : forall {A : Type'}, forall R' : A -> A -> Prop, forall x : A, ((@finite_set A (@GSPEC A (fun GEN_PVAR_428 : A => exists y : A, @SETSPEC A GEN_PVAR_428 (@RTC A R' x y) y))) /\ (forall z : A, ~ (@Relation_Operators.clos_trans A R' z z))) -> exists N' : nat, forall n : nat, forall y : A, (@RELPOW A n R' x y) -> leqn n N'.
Axiom thm_BOUND_SN : forall {A : Type'}, forall R' : A -> A -> Prop, (forall x : A, exists N' : nat, forall n : nat, forall y : A, (@RELPOW A n R' x y) -> leqn n N') -> @SN A R'.
Axiom thm_LF_SN_BOUND : forall {A : Type'}, forall R' : A -> A -> Prop, (@LF A R') -> (@SN A R') = (forall x : A, exists N' : nat, forall n : nat, forall y : A, (@RELPOW A n R' x y) -> leqn n N').
Axiom thm_TREE_FLD : forall {A : Type'}, forall R' : A -> A -> Prop, (@TREE A R') -> exists a : A, (@fld A R') = (@GSPEC A (fun GEN_PVAR_429 : A => exists y : A, @SETSPEC A GEN_PVAR_429 (@RTC A R' a y) y)).
Axiom thm_KOENIG_LEMMA : forall {A : Type'}, forall R' : A -> A -> Prop, ((@TREE A R') /\ ((@LF A R') /\ (@SN A R'))) -> @finite_set A (@fld A R').
Axiom thm_JOINABLE : forall {_183549 : Type'}, forall s : _183549, forall R' : _183549 -> _183549 -> Prop, forall t : _183549, (@JOINABLE _183549 R' s t) = (exists u : _183549, (@RTC _183549 R' s u) /\ (@RTC _183549 R' t u)).
Axiom thm_JOINABLE_REFL : forall {_183566 : Type'}, forall R' : _183566 -> _183566 -> Prop, forall t : _183566, @JOINABLE _183566 R' t t.
Axiom thm_JOINABLE_SYM : forall {_183585 : Type'}, forall R' : _183585 -> _183585 -> Prop, forall s : _183585, forall t : _183585, (@JOINABLE _183585 R' s t) = (@JOINABLE _183585 R' t s).
Axiom thm_JOINABLE_TRANS_R : forall {_183614 : Type'}, forall R' : _183614 -> _183614 -> Prop, forall s : _183614, forall t : _183614, forall u : _183614, ((R' s t) /\ (@JOINABLE _183614 R' t u)) -> @JOINABLE _183614 R' s u.
Axiom thm_CR_RSTC_JOINABLE : forall {A : Type'}, forall R' : A -> A -> Prop, (@CR A (@RTC A R')) -> forall x : A, forall y : A, (@RSTC A R' x y) = (@JOINABLE A R' x y).
Axiom thm_JOINABLE_TRANS : forall {_183663 : Type'}, forall R' : _183663 -> _183663 -> Prop, (@CR _183663 (@RTC _183663 R')) = (forall x : _183663, forall y : _183663, forall z : _183663, ((@JOINABLE _183663 R' x y) /\ (@JOINABLE _183663 R' y z)) -> @JOINABLE _183663 R' x z).
Axiom thm_EMPTY_IS_FINITE : forall {_183702 : Type'}, forall s : _183702 -> Prop, (s = (@set0 _183702)) -> @finite_set _183702 s.
Axiom thm_SING_IS_FINITE : forall {_183722 : Type'}, forall s : _183722 -> Prop, forall a : _183722, (s = (@INSERT _183722 a (@set0 _183722))) -> @finite_set _183722 s.
Axiom thm_UNION_NONZERO : forall {_183786 : Type'} (f : _183786 -> nat) (g : _183786 -> nat), (@GSPEC _183786 (fun GEN_PVAR_430 : _183786 => exists a : _183786, @SETSPEC _183786 GEN_PVAR_430 (~ ((addn (f a) (g a)) = (NUMERAL O))) a)) = (@setU _183786 (@GSPEC _183786 (fun GEN_PVAR_431 : _183786 => exists a : _183786, @SETSPEC _183786 GEN_PVAR_431 (~ ((f a) = (NUMERAL O))) a)) (@GSPEC _183786 (fun GEN_PVAR_432 : _183786 => exists a : _183786, @SETSPEC _183786 GEN_PVAR_432 (~ ((g a) = (NUMERAL O))) a))).
Axiom thm_multiset_tybij_th : forall {A : Type'}, exists f : A -> nat, @finite_set A (@GSPEC A (fun GEN_PVAR_433 : A => exists a : A, @SETSPEC A GEN_PVAR_433 (~ ((f a) = (NUMERAL O))) a)).
Axiom thm_mempty : forall {_183821 : Type'}, (@mempty _183821) = (@multiset _183821 (fun b : _183821 => NUMERAL O)).
Axiom thm_mmember : forall {_183831 : Type'}, forall M : Multiset _183831, forall a : _183831, (@mmember _183831 a M) = (~ ((@multiplicity _183831 M a) = (NUMERAL O))).
Axiom thm_msing : forall {_183847 : Type'}, forall a : _183847, (@msing _183847 a) = (@multiset _183847 (fun b : _183847 => @COND nat (b = a) (NUMERAL (BIT1 O)) (NUMERAL O))).
Axiom thm_munion : forall {_183866 : Type'}, forall M : Multiset _183866, forall N' : Multiset _183866, (@munion _183866 M N') = (@multiset _183866 (fun b : _183866 => addn (@multiplicity _183866 M b) (@multiplicity _183866 N' b))).
Axiom thm_mdiff : forall {_183885 : Type'}, forall M : Multiset _183885, forall N' : Multiset _183885, (@mdiff _183885 M N') = (@multiset _183885 (fun b : _183885 => subn (@multiplicity _183885 M b) (@multiplicity _183885 N' b))).
Axiom thm_MEXTENSION : forall {_183902 : Type'} (M : Multiset _183902) (N' : Multiset _183902), (M = N') = (forall a : _183902, (@multiplicity _183902 M a) = (@multiplicity _183902 N' a)).
Axiom thm_MULTIPLICITY_MULTISET : forall {_183935 : Type'} (f : _183935 -> nat) (a : _183935) (y : nat), ((@finite_set _183935 (@GSPEC _183935 (fun GEN_PVAR_434 : _183935 => exists a' : _183935, @SETSPEC _183935 GEN_PVAR_434 (~ ((f a') = (NUMERAL O))) a'))) /\ ((f a) = y)) -> (@multiplicity _183935 (@multiset _183935 f) a) = y.
Axiom thm_MEMPTY : forall {_183951 : Type'} (a : _183951), (@multiplicity _183951 (@mempty _183951) a) = (NUMERAL O).
Axiom thm_MSING : forall {A : Type'} (b : A) (a : A), (@multiplicity A (@msing A a) b) = (@COND nat (b = a) (NUMERAL (BIT1 O)) (NUMERAL O)).
Axiom thm_MUNION : forall {_183978 : Type'} (M : Multiset _183978) (N' : Multiset _183978) (a : _183978), (@multiplicity _183978 (@munion _183978 M N') a) = (addn (@multiplicity _183978 M a) (@multiplicity _183978 N' a)).
Axiom thm_MDIFF : forall {A : Type'} (M : Multiset A) (N' : Multiset A) (a : A), (@multiplicity A (@mdiff A M N') a) = (subn (@multiplicity A M a) (@multiplicity A N' a)).
Axiom thm_MUNION_MEMPTY : forall {A : Type'} (M : Multiset A) (a : A), ~ ((@munion A M (@msing A a)) = (@mempty A)).
Axiom thm_MMEMBER_MUNION : forall {_184054 : Type'} (M : Multiset _184054) (x : _184054) (N' : Multiset _184054), (@mmember _184054 x (@munion _184054 M N')) = ((@mmember _184054 x M) \/ (@mmember _184054 x N')).
Axiom thm_MMEMBER_MSING : forall {_184064 : Type'} (x : _184064) (a : _184064), (@mmember _184064 x (@msing _184064 a)) = (x = a).
Axiom thm_MUNION_EMPTY : forall {_184074 : Type'} (M : Multiset _184074), (@munion _184074 M (@mempty _184074)) = M.
Axiom thm_MUNION_ASSOC : forall {_184090 : Type'} (M1 : Multiset _184090) (M2 : Multiset _184090) (M3 : Multiset _184090), (@munion _184090 M1 (@munion _184090 M2 M3)) = (@munion _184090 (@munion _184090 M1 M2) M3).
Axiom thm_MUNION_AC : forall {_184134 : Type'} (M2 : Multiset _184134) (M1 : Multiset _184134) (M3 : Multiset _184134), ((@munion _184134 M1 M2) = (@munion _184134 M2 M1)) /\ (((@munion _184134 (@munion _184134 M1 M2) M3) = (@munion _184134 M1 (@munion _184134 M2 M3))) /\ ((@munion _184134 M1 (@munion _184134 M2 M3)) = (@munion _184134 M2 (@munion _184134 M1 M3)))).
Axiom thm_MUNION_11 : forall {_184146 : Type'} (N' : Multiset _184146) (M1 : Multiset _184146) (M2 : Multiset _184146), ((@munion _184146 M1 N') = (@munion _184146 M2 N')) = (M1 = M2).
Axiom thm_MUNION_INUNION : forall {_184168 : Type'} (b : _184168) (a : _184168) (M : Multiset _184168), ((@mmember _184168 a (@munion _184168 M (@msing _184168 b))) /\ (~ (b = a))) -> @mmember _184168 a M.
Axiom thm_MMEMBER_MDIFF : forall {A : Type'} (M : Multiset A) (a : A), (@mmember A a M) -> M = (@munion A (@mdiff A M (@msing A a)) (@msing A a)).
Axiom thm_MULTISET_INDUCT_LEMMA1 : forall {A : Type'} (a : A) (s : A -> Prop) (P : (Multiset A) -> Prop), ((forall M : Multiset A, (@subset A (@GSPEC A (fun GEN_PVAR_439 : A => exists a' : A, @SETSPEC A GEN_PVAR_439 (~ ((@multiplicity A M a') = (NUMERAL O))) a')) s) -> P M) /\ (forall a' : A, forall M : Multiset A, (P M) -> P (@munion A M (@msing A a')))) -> forall n : nat, forall M : Multiset A, (((@multiplicity A M a) = n) /\ (@subset A (@GSPEC A (fun GEN_PVAR_440 : A => exists a' : A, @SETSPEC A GEN_PVAR_440 (~ ((@multiplicity A M a') = (NUMERAL O))) a')) (@INSERT A a s))) -> P M.
Axiom thm_MULTISET_INDUCT_LEMMA2 : forall {A : Type'} (P : (Multiset A) -> Prop), ((P (@mempty A)) /\ (forall a : A, forall M : Multiset A, (P M) -> P (@munion A M (@msing A a)))) -> forall s : A -> Prop, (@finite_set A s) -> forall M : Multiset A, (@subset A (@GSPEC A (fun GEN_PVAR_441 : A => exists a : A, @SETSPEC A GEN_PVAR_441 (~ ((@multiplicity A M a) = (NUMERAL O))) a)) s) -> P M.
Axiom thm_MULTISET_INDUCT : forall {A : Type'} (P : (Multiset A) -> Prop), ((P (@mempty A)) /\ (forall a : A, forall M : Multiset A, (P M) -> P (@munion A M (@msing A a)))) -> forall M : Multiset A, P M.
Axiom thm_WFP_CASES : forall {_184552 : Type'}, forall lt2' : _184552 -> _184552 -> Prop, forall a : _184552, (@Acc _184552 lt2' a) = (forall y : _184552, (lt2' y a) -> @Acc _184552 lt2' y).
Axiom thm_WFP_INDUCT : forall {_184552 : Type'}, forall lt2' : _184552 -> _184552 -> Prop, forall WFP' : _184552 -> Prop, (forall x : _184552, (forall y : _184552, (lt2' y x) -> WFP' y) -> WFP' x) -> forall a : _184552, (@Acc _184552 lt2' a) -> WFP' a.
Axiom thm_WFP_RULES : forall {_184552 : Type'}, forall lt2' : _184552 -> _184552 -> Prop, forall x : _184552, (forall y : _184552, (lt2' y x) -> @Acc _184552 lt2' y) -> @Acc _184552 lt2' x.
Axiom thm_WFP_PART_INDUCT : forall {A : Type'} (lt2' : A -> A -> Prop), forall P : A -> Prop, (forall x : A, ((@IN A x (@Acc A lt2')) /\ (forall y : A, (lt2' y x) -> P y)) -> P x) -> forall x : A, (@IN A x (@Acc A lt2')) -> P x.
Axiom thm_WFP_WF : forall {A : Type'} (lt2' : A -> A -> Prop), (@well_founded A lt2') = ((@Acc A lt2') = (@setT A)).
Axiom thm_WFP_DCHAIN : forall {A : Type'}, forall lt2' : A -> A -> Prop, (@Acc A lt2') = (@GSPEC A (fun GEN_PVAR_443 : A => exists a : A, @SETSPEC A GEN_PVAR_443 (forall x : nat -> A, (forall n : nat, lt2' (x (S n)) (x n)) -> ~ ((x (NUMERAL O)) = a)) a)).
Axiom thm_morder : forall {_184734 : Type'}, forall M : Multiset _184734, forall N' : Multiset _184734, forall lt2' : _184734 -> _184734 -> Prop, (@morder _184734 lt2' N' M) = (exists M0 : Multiset _184734, exists a : _184734, exists K : Multiset _184734, (M = (@munion _184734 M0 (@msing _184734 a))) /\ ((N' = (@munion _184734 M0 K)) /\ (forall b : _184734, (@mmember _184734 b K) -> lt2' b a))).
Axiom thm_LEMMA_2_0 : forall {A : Type'} (N' : Multiset A) (M0 : Multiset A) (lt2' : A -> A -> Prop) (a : A), (@morder A lt2' N' (@munion A M0 (@msing A a))) -> (exists M : Multiset A, (@morder A lt2' M M0) /\ (N' = (@munion A M (@msing A a)))) \/ (exists K : Multiset A, (N' = (@munion A M0 K)) /\ (forall b : A, (@mmember A b K) -> lt2' b a)).
Axiom thm_LEMMA_2_1 : forall {A : Type'} (M0 : Multiset A) (a : A) (lt2' : A -> A -> Prop), ((forall M : Multiset A, forall b : A, ((lt2' b a) /\ (@IN (Multiset A) M (@Acc (Multiset A) (@morder A lt2')))) -> @IN (Multiset A) (@munion A M (@msing A b)) (@Acc (Multiset A) (@morder A lt2'))) /\ ((@IN (Multiset A) M0 (@Acc (Multiset A) (@morder A lt2'))) /\ (forall M : Multiset A, (@morder A lt2' M M0) -> @IN (Multiset A) (@munion A M (@msing A a)) (@Acc (Multiset A) (@morder A lt2'))))) -> @IN (Multiset A) (@munion A M0 (@msing A a)) (@Acc (Multiset A) (@morder A lt2')).
Axiom thm_LEMMA_2_2 : forall {_185002 : Type'} (a : _185002) (lt2' : _185002 -> _185002 -> Prop), (forall M : Multiset _185002, forall b : _185002, ((lt2' b a) /\ (@IN (Multiset _185002) M (@Acc (Multiset _185002) (@morder _185002 lt2')))) -> @IN (Multiset _185002) (@munion _185002 M (@msing _185002 b)) (@Acc (Multiset _185002) (@morder _185002 lt2'))) -> forall M : Multiset _185002, (@IN (Multiset _185002) M (@Acc (Multiset _185002) (@morder _185002 lt2'))) -> @IN (Multiset _185002) (@munion _185002 M (@msing _185002 a)) (@Acc (Multiset _185002) (@morder _185002 lt2')).
Axiom thm_LEMMA_2_3 : forall {_185036 : Type'} (lt2' : _185036 -> _185036 -> Prop), (@well_founded _185036 lt2') -> forall a : _185036, forall M : Multiset _185036, (@IN (Multiset _185036) M (@Acc (Multiset _185036) (@morder _185036 lt2'))) -> @IN (Multiset _185036) (@munion _185036 M (@msing _185036 a)) (@Acc (Multiset _185036) (@morder _185036 lt2')).
Axiom thm_LEMMA_2_4 : forall {_185041 : Type'} (lt2' : _185041 -> _185041 -> Prop), (@well_founded _185041 lt2') -> forall M : Multiset _185041, @IN (Multiset _185041) M (@Acc (Multiset _185041) (@morder _185041 lt2')).
Axiom thm_MORDER_WF : forall {_185057 : Type'} (lt2' : _185057 -> _185057 -> Prop), (@well_founded _185057 lt2') -> @well_founded (Multiset _185057) (@morder _185057 lt2').
Axiom thm_LIST_UNION : forall {_185080 : Type'} (h : _185080 -> Prop) (t : seq (_185080 -> Prop)), ((@list_Union _185080 (@nil (_185080 -> Prop))) = (@set0 _185080)) /\ ((@list_Union _185080 (@cons (_185080 -> Prop) h t)) = (@setU _185080 h (@list_Union _185080 t))).
Axiom thm_LIST_UNION_FINITE : forall {_185096 : Type'}, forall l : seq (_185096 -> Prop), (@ALL (_185096 -> Prop) (@finite_set _185096) l) -> @finite_set _185096 (@list_Union _185096 l).
Axiom thm_IN_LIST_UNION : forall {_185119 : Type'}, forall x : _185119, forall l : seq (_185119 -> Prop), (@IN _185119 x (@list_Union _185119 l)) = (@EX (_185119 -> Prop) (fun s : _185119 -> Prop => @IN _185119 x s) l).
Axiom thm_LIST_UNION_APPEND : forall {_185144 : Type'}, forall l1 : seq (_185144 -> Prop), forall l2 : seq (_185144 -> Prop), (@list_Union _185144 (@cat (_185144 -> Prop) l1 l2)) = (@setU _185144 (@list_Union _185144 l1) (@list_Union _185144 l2)).
Axiom thm_term_raw_INDUCT : forall P0 : term -> Prop, forall P1 : (seq term) -> Prop, ((forall a : nat, P0 (V a)) /\ ((forall a0 : nat, forall a1 : seq term, (P1 a1) -> P0 (Fn a0 a1)) /\ ((P1 (@nil term)) /\ (forall a0 : term, forall a1 : seq term, ((P0 a0) /\ (P1 a1)) -> P1 (@cons term a0 a1))))) -> (forall x0 : term, P0 x0) /\ (forall x1 : seq term, P1 x1).
Axiom thm_term_raw_RECURSION : forall {Z0 Z1 : Type'}, forall f0 : nat -> Z1, forall f1 : nat -> (seq term) -> Z0 -> Z1, forall f2 : Z0, forall f3 : term -> (seq term) -> Z1 -> Z0 -> Z0, exists fn0 : (seq term) -> Z0, exists fn1 : term -> Z1, (forall a : nat, (fn1 (V a)) = (f0 a)) /\ ((forall a0 : nat, forall a1 : seq term, (fn1 (Fn a0 a1)) = (f1 a0 a1 (fn0 a1))) /\ (((fn0 (@nil term)) = f2) /\ (forall a0 : term, forall a1 : seq term, (fn0 (@cons term a0 a1)) = (f3 a0 a1 (fn1 a0) (fn0 a1))))).
Axiom thm_term_INDUCT : forall P : term -> Prop, ((forall v : nat, P (V v)) /\ (forall s : nat, forall l : seq term, (@ALL term P l) -> P (Fn s l))) -> forall t : term, P t.
Axiom thm_term_RECURSION : forall {Z' : Type'}, forall f : nat -> Z', forall h : nat -> (seq term) -> (seq Z') -> Z', exists fn : term -> Z', (forall v : nat, (fn (V v)) = (f v)) /\ (forall s : nat, forall l : seq term, (fn (Fn s l)) = (h s l (@map term Z' fn l))).
Axiom thm_term_INJ : (forall v : nat, forall v' : nat, ((V v) = (V v')) = (v = v')) /\ (forall s : nat, forall l : seq term, forall s' : nat, forall l' : seq term, ((Fn s l) = (Fn s' l')) = ((s = s') /\ (l = l'))).
Axiom thm_term_DISTINCT : forall v : nat, forall s' : nat, forall l' : seq term, ~ ((V v) = (Fn s' l')).
Axiom thm_term_CASES : forall t : term, (exists v : nat, t = (V v)) \/ (exists s : nat, exists l : seq term, t = (Fn s l)).
Axiom thm_form_INDUCTION : forall P : form -> Prop, ((P FFalse) /\ ((forall a0 : nat, forall a1 : seq term, P (Atom a0 a1)) /\ ((forall a0 : form, forall a1 : form, ((P a0) /\ (P a1)) -> P (FImp a0 a1)) /\ (forall a0 : nat, forall a1 : form, (P a1) -> P (FAll a0 a1))))) -> forall x : form, P x.
Axiom thm_form_RECURSION : forall {Z' : Type'}, forall f0 : Z', forall f1 : nat -> (seq term) -> Z', forall f2 : form -> form -> Z' -> Z' -> Z', forall f3 : nat -> form -> Z' -> Z', exists fn : form -> Z', ((fn FFalse) = f0) /\ ((forall a0 : nat, forall a1 : seq term, (fn (Atom a0 a1)) = (f1 a0 a1)) /\ ((forall a0 : form, forall a1 : form, (fn (FImp a0 a1)) = (f2 a0 a1 (fn a0) (fn a1))) /\ (forall a0 : nat, forall a1 : form, (fn (FAll a0 a1)) = (f3 a0 a1 (fn a1))))).
Axiom thm_form_INJ : (forall a0 : nat, forall a1 : seq term, forall a0' : nat, forall a1' : seq term, ((Atom a0 a1) = (Atom a0' a1')) = ((a0 = a0') /\ (a1 = a1'))) /\ ((forall a0 : form, forall a1 : form, forall a0' : form, forall a1' : form, ((FImp a0 a1) = (FImp a0' a1')) = ((a0 = a0') /\ (a1 = a1'))) /\ (forall a0 : nat, forall a1 : form, forall a0' : nat, forall a1' : form, ((FAll a0 a1) = (FAll a0' a1')) = ((a0 = a0') /\ (a1 = a1')))).
Axiom thm_form_DISTINCT : (forall a0' : nat, forall a1' : seq term, ~ (FFalse = (Atom a0' a1'))) /\ ((forall a0' : form, forall a1' : form, ~ (FFalse = (FImp a0' a1'))) /\ ((forall a0' : nat, forall a1' : form, ~ (FFalse = (FAll a0' a1'))) /\ ((forall a0 : nat, forall a1 : seq term, forall a0' : form, forall a1' : form, ~ ((Atom a0 a1) = (FImp a0' a1'))) /\ ((forall a0 : nat, forall a1 : seq term, forall a0' : nat, forall a1' : form, ~ ((Atom a0 a1) = (FAll a0' a1'))) /\ (forall a0 : form, forall a1 : form, forall a0' : nat, forall a1' : form, ~ ((FImp a0 a1) = (FAll a0' a1'))))))).
Axiom thm_form_CASES : forall x : form, (x = FFalse) \/ ((exists a0 : nat, exists a1 : seq term, x = (Atom a0 a1)) \/ ((exists a0 : form, exists a1 : form, x = (FImp a0 a1)) \/ (exists a0 : nat, exists a1 : form, x = (FAll a0 a1)))).
Axiom thm_Not_DEF : forall p : form, (Not p) = (FImp p FFalse).
Axiom thm_True_DEF : FTrue = (Not FFalse).
Axiom thm_Or_DEF : forall p : form, forall q : form, (FOr p q) = (FImp (FImp p q) q).
Axiom thm_And_DEF : forall p : form, forall q : form, (FAnd p q) = (Not (FOr (Not p) (Not q))).
Axiom thm_Iff_DEF : forall q : form, forall p : form, (FEquiv p q) = (FAnd (FImp p q) (FImp q p)).
Axiom thm_Exists_DEF : forall x : nat, forall p : form, (FEx x p) = (Not (FAll x (Not p))).
Axiom thm_functions_term : (forall v : nat, (functions_term (V v)) = (@set0 (prod nat nat))) /\ (forall f : nat, forall l : seq term, (functions_term (Fn f l)) = (@INSERT (prod nat nat) (@pair nat nat f (@size term l)) (@list_Union (prod nat nat) (@map term ((prod nat nat) -> Prop) functions_term l)))).
Axiom thm_functions_form : forall (a : nat) (l : seq term) (q : form) (x : nat) (p : form), ((functions_form FFalse) = (@set0 (prod nat nat))) /\ (((functions_form (Atom a l)) = (@list_Union (prod nat nat) (@map term ((prod nat nat) -> Prop) functions_term l))) /\ (((functions_form (FImp p q)) = (@setU (prod nat nat) (functions_form p) (functions_form q))) /\ ((functions_form (FAll x p)) = (functions_form p)))).
Axiom thm_predicates_form : forall (a : nat) (l : seq term) (q : form) (x : nat) (p : form), ((predicates_form FFalse) = (@set0 (prod nat nat))) /\ (((predicates_form (Atom a l)) = (@INSERT (prod nat nat) (@pair nat nat a (@size term l)) (@set0 (prod nat nat)))) /\ (((predicates_form (FImp p q)) = (@setU (prod nat nat) (predicates_form p) (predicates_form q))) /\ ((predicates_form (FAll x p)) = (predicates_form p)))).
Axiom thm_functions : forall fms : form -> Prop, (functions fms) = (@UNIONS (prod nat nat) (@GSPEC ((prod nat nat) -> Prop) (fun GEN_PVAR_444 : (prod nat nat) -> Prop => exists f : form, @SETSPEC ((prod nat nat) -> Prop) GEN_PVAR_444 (@IN form f fms) (functions_form f)))).
Axiom thm_predicates : forall fms : form -> Prop, (predicates fms) = (@UNIONS (prod nat nat) (@GSPEC ((prod nat nat) -> Prop) (fun GEN_PVAR_445 : (prod nat nat) -> Prop => exists f : form, @SETSPEC ((prod nat nat) -> Prop) GEN_PVAR_445 (@IN form f fms) (predicates_form f)))).
Axiom thm_language : forall fms : form -> Prop, (language fms) = (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (functions fms) (predicates fms)).
Axiom thm_FUNCTIONS_SING : forall (p : form), (functions (@INSERT form p (@set0 form))) = (functions_form p).
Axiom thm_LANGUAGE_1 : forall (p : form), (language (@INSERT form p (@set0 form))) = (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (functions_form p) (predicates_form p)).
Axiom thm_Dom_DEF : forall {A : Type'}, forall Funs : nat -> (seq A) -> A, forall Preds : nat -> (seq A) -> Prop, forall D : A -> Prop, (@Dom A (@pair (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)) D (@pair (nat -> (seq A) -> A) (nat -> (seq A) -> Prop) Funs Preds))) = D.
Axiom thm_Fun_DEF : forall {A : Type'}, forall D : A -> Prop, forall Preds : nat -> (seq A) -> Prop, forall Funs : nat -> (seq A) -> A, (@Fun A (@pair (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)) D (@pair (nat -> (seq A) -> A) (nat -> (seq A) -> Prop) Funs Preds))) = Funs.
Axiom thm_Pred_DEF : forall {A : Type'}, forall D : A -> Prop, forall Funs : nat -> (seq A) -> A, forall Preds : nat -> (seq A) -> Prop, (@Pred A (@pair (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)) D (@pair (nat -> (seq A) -> A) (nat -> (seq A) -> Prop) Funs Preds))) = Preds.
Axiom thm_MODEL_EQ : forall {_185616 : Type'} (M : prod (_185616 -> Prop) (prod (nat -> (seq _185616) -> _185616) (nat -> (seq _185616) -> Prop))) (M' : prod (_185616 -> Prop) (prod (nat -> (seq _185616) -> _185616) (nat -> (seq _185616) -> Prop))), (M = M') = (((@Dom _185616 M) = (@Dom _185616 M')) /\ (((@Fun _185616 M) = (@Fun _185616 M')) /\ ((@Pred _185616 M) = (@Pred _185616 M')))).
Axiom thm_MODEL_DECOMP : forall {_185634 : Type'} (M : prod (_185634 -> Prop) (prod (nat -> (seq _185634) -> _185634) (nat -> (seq _185634) -> Prop))), M = (@pair (_185634 -> Prop) (prod (nat -> (seq _185634) -> _185634) (nat -> (seq _185634) -> Prop)) (@Dom _185634 M) (@pair (nat -> (seq _185634) -> _185634) (nat -> (seq _185634) -> Prop) (@Fun _185634 M) (@Pred _185634 M))).
Axiom thm_FVT : (forall x : nat, (free_variables_term (V x)) = (@INSERT nat x (@set0 nat))) /\ (forall f : nat, forall l : seq term, (free_variables_term (Fn f l)) = (@list_Union nat (@map term (nat -> Prop) free_variables_term l))).
Axiom thm_FV : ((free_variables FFalse) = (@set0 nat)) /\ ((forall a : nat, forall l : seq term, (free_variables (Atom a l)) = (@list_Union nat (@map term (nat -> Prop) free_variables_term l))) /\ ((forall p : form, forall q : form, (free_variables (FImp p q)) = (@setU nat (free_variables p) (free_variables q))) /\ (forall x : nat, forall p : form, (free_variables (FAll x p)) = (@DELETE nat (free_variables p) x)))).
Axiom thm_BV : ((bound_variables FFalse) = (@set0 nat)) /\ ((forall a : nat, forall l : seq term, (bound_variables (Atom a l)) = (@set0 nat)) /\ ((forall p : form, forall q : form, (bound_variables (FImp p q)) = (@setU nat (bound_variables p) (bound_variables q))) /\ (forall x : nat, forall p : form, (bound_variables (FAll x p)) = (@INSERT nat x (bound_variables p))))).
Axiom thm_FVT_FINITE : forall t : term, @finite_set nat (free_variables_term t).
Axiom thm_FV_FINITE : forall p : form, @finite_set nat (free_variables p).
Axiom thm_BV_FINITE : forall p : form, @finite_set nat (bound_variables p).
Axiom thm_FV_EXISTS : forall (p : form) (x : nat), (free_variables (FEx x p)) = (@DELETE nat (free_variables p) x).
Axiom thm_valmod : forall {_185849 _185858 : Type'}, forall x : _185858, forall a : _185849, forall v : _185858 -> _185849, (@valmod _185849 _185858 (@pair _185858 _185849 x a) v) = (fun y : _185858 => @COND _185849 (y = x) a (v y)).
Axiom thm_VALMOD_CLAUSES : forall {_185882 _185883 _185916 _185920 : Type'}, (forall v : _185883 -> _185882, forall a : _185882, forall k : _185883, (@valmod _185882 _185883 (@pair _185883 _185882 k a) v k) = a) /\ (forall v : _185920 -> _185916, forall a : _185916, forall k : _185920, forall x : _185920, (~ (x = k)) -> (@valmod _185916 _185920 (@pair _185920 _185916 k a) v x) = (v x)).
Axiom thm_VALMOD_TRIV : forall {_185937 _185941 : Type'}, forall v : _185941 -> _185937, forall x : _185941, (@valmod _185937 _185941 (@pair _185941 _185937 x (v x)) v) = v.
Axiom thm_VALMOD_VALMOD : forall {_185982 _185983 : Type'}, forall v : _185983 -> _185982, forall a : _185982, forall x : _185983, forall b : _185982, (@valmod _185982 _185983 (@pair _185983 _185982 x a) (@valmod _185982 _185983 (@pair _185983 _185982 x b) v)) = (@valmod _185982 _185983 (@pair _185983 _185982 x a) v).
Axiom thm_valuation : forall {_186000 : Type'}, forall v : nat -> _186000, forall M : prod (_186000 -> Prop) (prod (nat -> (seq _186000) -> _186000) (nat -> (seq _186000) -> Prop)), (@valuation _186000 M v) = (forall x : nat, @IN _186000 (v x) (@Dom _186000 M)).
Axiom thm_VALUATION_VALMOD : forall {_186033 : Type'} (x : nat), forall M : prod (_186033 -> Prop) (prod (nat -> (seq _186033) -> _186033) (nat -> (seq _186033) -> Prop)), forall a : _186033, forall v : nat -> _186033, ((@valuation _186033 M v) /\ (@IN _186033 a (@Dom _186033 M))) -> @valuation _186033 M (@valmod _186033 nat (@pair nat _186033 x a) v).
Axiom thm_VALUATION_IS_VALMOD : forall {_186053 _186057 : Type'}, forall v : _186057 -> _186053, forall x : _186057, (@valmod _186053 _186057 (@pair _186057 _186053 x (v x)) v) = v.
Axiom thm_holds : forall {_186193 : Type'} (M : prod (_186193 -> Prop) (prod (nat -> (seq _186193) -> _186193) (nat -> (seq _186193) -> Prop))) (v : nat -> _186193), ((@holds _186193 M v FFalse) = False) /\ ((forall a : nat, forall l : seq term, (@holds _186193 M v (Atom a l)) = (@Pred _186193 M a (@map term _186193 (@termval _186193 M v) l))) /\ ((forall p : form, forall q : form, (@holds _186193 M v (FImp p q)) = ((@holds _186193 M v p) -> @holds _186193 M v q)) /\ (forall x : nat, forall p : form, (@holds _186193 M v (FAll x p)) = (forall a : _186193, (@IN _186193 a (@Dom _186193 M)) -> @holds _186193 M (@valmod _186193 nat (@pair nat _186193 x a) v) p)))).
Axiom thm_hold : forall {_186215 : Type'}, forall fms : form -> Prop, forall M : prod (_186215 -> Prop) (prod (nat -> (seq _186215) -> _186215) (nat -> (seq _186215) -> Prop)), forall v : nat -> _186215, (@hold _186215 M v fms) = (forall p : form, (@IN form p fms) -> @holds _186215 M v p).
Axiom thm_satisfies : forall {_186235 : Type'}, forall fms : form -> Prop, forall M : prod (_186235 -> Prop) (prod (nat -> (seq _186235) -> _186235) (nat -> (seq _186235) -> Prop)), (@satisfies _186235 M fms) = (forall v : nat -> _186235, forall p : form, ((@valuation _186235 M v) /\ (@IN form p fms)) -> @holds _186235 M v p).
Axiom thm_SATISFIES_1 : forall {_186248 : Type'} (M : prod (_186248 -> Prop) (prod (nat -> (seq _186248) -> _186248) (nat -> (seq _186248) -> Prop))) (p : form), (@satisfies _186248 M (@INSERT form p (@set0 form))) = (forall v : nat -> _186248, (@valuation _186248 M v) -> @holds _186248 M v p).
Axiom thm_HOLDS : forall {_186519 : Type'} (M : prod (_186519 -> Prop) (prod (nat -> (seq _186519) -> _186519) (nat -> (seq _186519) -> Prop))) (v : nat -> _186519), ((@holds _186519 M v FFalse) = False) /\ (((@holds _186519 M v FTrue) = True) /\ ((forall a : nat, forall l : seq term, (@holds _186519 M v (Atom a l)) = (@Pred _186519 M a (@map term _186519 (@termval _186519 M v) l))) /\ ((forall p : form, (@holds _186519 M v (Not p)) = (~ (@holds _186519 M v p))) /\ ((forall p : form, forall q : form, (@holds _186519 M v (FOr p q)) = ((@holds _186519 M v p) \/ (@holds _186519 M v q))) /\ ((forall p : form, forall q : form, (@holds _186519 M v (FAnd p q)) = ((@holds _186519 M v p) /\ (@holds _186519 M v q))) /\ ((forall p : form, forall q : form, (@holds _186519 M v (FImp p q)) = ((@holds _186519 M v p) -> @holds _186519 M v q)) /\ ((forall p : form, forall q : form, (@holds _186519 M v (FEquiv p q)) = ((@holds _186519 M v p) = (@holds _186519 M v q))) /\ ((forall x : nat, forall p : form, (@holds _186519 M v (FAll x p)) = (forall a : _186519, (@IN _186519 a (@Dom _186519 M)) -> @holds _186519 M (@valmod _186519 nat (@pair nat _186519 x a) v) p)) /\ (forall x : nat, forall p : form, (@holds _186519 M v (FEx x p)) = (exists a : _186519, (@IN _186519 a (@Dom _186519 M)) /\ (@holds _186519 M (@valmod _186519 nat (@pair nat _186519 x a) v) p))))))))))).
Axiom thm_TERMVAL_VALUATION : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall t : term, forall v : nat -> A, forall v' : nat -> A, (forall x : nat, (@IN nat x (free_variables_term t)) -> (v' x) = (v x)) -> (@termval A M v' t) = (@termval A M v t).
Axiom thm_HOLDS_VALUATION : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall p : form, forall v : nat -> A, forall v' : nat -> A, (forall x : nat, (@IN nat x (free_variables p)) -> (v' x) = (v x)) -> (@holds A M v' p) = (@holds A M v p).
Axiom thm_satisfiable : forall {A : Type'}, forall U : A -> Prop, forall fms : form -> Prop, (@satisfiable A U fms) = (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M fms)).
Axiom thm_valid : forall {A : Type'}, forall U : A -> Prop, forall fms : form -> Prop, (@valid A U fms) = (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), @satisfies A M fms).
Axiom thm_entails : forall {A : Type'}, forall U : A -> Prop, forall A' : form -> Prop, forall p : form, (@entails A U A' p) = (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (@hold A M v A') -> @holds A M v p).
Axiom thm_equivalent : forall {A : Type'}, forall U : A -> Prop, forall p : form, forall q : form, (@equivalent A U p q) = (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (@holds A M v p) = (@holds A M v q)).
Axiom thm_interpretation : forall {_186822 : Type'}, forall preds : (prod nat nat) -> Prop, forall fns : (prod nat nat) -> Prop, forall M : prod (_186822 -> Prop) (prod (nat -> (seq _186822) -> _186822) (nat -> (seq _186822) -> Prop)), (@interpretation _186822 (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) fns preds) M) = (forall f : nat, forall l : seq _186822, ((@IN (prod nat nat) (@pair nat nat f (@size _186822 l)) fns) /\ (@ALL _186822 (fun x : _186822 => @IN _186822 x (@Dom _186822 M)) l)) -> @IN _186822 (@Fun _186822 M f l) (@Dom _186822 M)).
Axiom thm_INTERPRETATION_TERMVAL : forall {_186869 : Type'}, forall any : (prod nat nat) -> Prop, forall M : prod (_186869 -> Prop) (prod (nat -> (seq _186869) -> _186869) (nat -> (seq _186869) -> Prop)), forall v : nat -> _186869, forall t : term, ((@interpretation _186869 (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (functions_term t) any) M) /\ (@valuation _186869 M v)) -> @IN _186869 (@termval _186869 M v t) (@Dom _186869 M).
Axiom thm_INTERPRETATION_SUBLANGUAGE : forall {_186900 : Type'}, forall M : prod (_186900 -> Prop) (prod (nat -> (seq _186900) -> _186900) (nat -> (seq _186900) -> Prop)), forall funs1 : (prod nat nat) -> Prop, forall funs2 : (prod nat nat) -> Prop, forall preds1 : (prod nat nat) -> Prop, forall preds2 : (prod nat nat) -> Prop, (@subset (prod nat nat) funs2 funs1) -> (@interpretation _186900 (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) funs1 preds1) M) -> @interpretation _186900 (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) funs2 preds2) M.
Axiom thm_TERMSUBST_TERMVAL : forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), ((@Fun term M) = Fn) -> forall v : nat -> term, forall t : term, (termsubst v t) = (@termval term M v t).
Axiom thm_TERMVAL_TRIV : forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), ((@Fun term M) = Fn) -> forall t : term, (@termval term M V t) = t.
Axiom thm_TERMVAL_TERMSUBST : forall {_187037 : Type'}, forall M : prod (_187037 -> Prop) (prod (nat -> (seq _187037) -> _187037) (nat -> (seq _187037) -> Prop)), forall v : nat -> _187037, forall i : nat -> term, forall t : term, (@termval _187037 M v (termsubst i t)) = (@termval _187037 M (@o nat term _187037 (@termval _187037 M v) i) t).
Axiom thm_TERMSUBST_TERMSUBST : forall i : nat -> term, forall j : nat -> term, forall t : term, (termsubst j (termsubst i t)) = (termsubst (@o nat term term (termsubst j) i) t).
Axiom thm_TERMSUBST_TRIV : forall t : term, (termsubst V t) = t.
Axiom thm_TERMSUBST_VALUATION : forall t : term, forall v : nat -> term, forall v' : nat -> term, (forall x : nat, (@IN nat x (free_variables_term t)) -> (v' x) = (v x)) -> (termsubst v' t) = (termsubst v t).
Axiom thm_TERMSUBST_FVT : forall t : term, forall i : nat -> term, (free_variables_term (termsubst i t)) = (@GSPEC nat (fun GEN_PVAR_449 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_449 (exists y : nat, (@IN nat y (free_variables_term t)) /\ (@IN nat x (free_variables_term (i y)))) x)).
Axiom thm_MAX_SYM : forall x : nat, forall y : nat, (maxn x y) = (maxn y x).
Axiom thm_MAX_ASSOC : forall x : nat, forall y : nat, forall z : nat, (maxn x (maxn y z)) = (maxn (maxn x y) z).
Axiom thm_SETMAX : forall s : nat -> Prop, (SETMAX s) = (@fold_set nat nat maxn s (NUMERAL O)).
Axiom thm_VARIANT : forall s : nat -> Prop, (VARIANT s) = (addn (SETMAX s) (NUMERAL (BIT1 O))).
Axiom thm_SETMAX_LEMMA : ((SETMAX (@set0 nat)) = (NUMERAL O)) /\ (forall x : nat, forall s : nat -> Prop, (@finite_set nat s) -> (SETMAX (@INSERT nat x s)) = (@COND nat (@IN nat x s) (SETMAX s) (maxn x (SETMAX s)))).
Axiom thm_SETMAX_MEMBER : forall s : nat -> Prop, (@finite_set nat s) -> forall x : nat, (@IN nat x s) -> leqn x (SETMAX s).
Axiom thm_SETMAX_THM : ((SETMAX (@set0 nat)) = (NUMERAL O)) /\ (forall x : nat, forall s : nat -> Prop, (@finite_set nat s) -> (SETMAX (@INSERT nat x s)) = (maxn x (SETMAX s))).
Axiom thm_SETMAX_UNION : forall s : nat -> Prop, forall t : nat -> Prop, (@finite_set nat (@setU nat s t)) -> (SETMAX (@setU nat s t)) = (maxn (SETMAX s) (SETMAX t)).
Axiom thm_VARIANT_FINITE : forall s : nat -> Prop, (@finite_set nat s) -> ~ (@IN nat (VARIANT s) s).
Axiom thm_VARIANT_THM : forall p : form, ~ (@IN nat (VARIANT (free_variables p)) (free_variables p)).
Axiom thm_formsubst : forall (p : nat) (l : seq term) (r : form) (q : form) (x : nat) (v : nat -> term), ((formsubst v FFalse) = FFalse) /\ (((formsubst v (Atom p l)) = (Atom p (@map term term (termsubst v) l))) /\ (((formsubst v (FImp q r)) = (FImp (formsubst v q) (formsubst v r))) /\ ((formsubst v (FAll x q)) = (@LET (nat -> term) form (fun v' : nat -> term => @LET_END form (@LET nat form (fun z : nat => @LET_END form (FAll z (formsubst (@valmod term nat (@pair nat term x (V z)) v) q))) (@COND nat (exists y : nat, (@IN nat y (free_variables (FAll x q))) /\ (@IN nat x (free_variables_term (v' y)))) (VARIANT (free_variables (formsubst v' q))) x))) (@valmod term nat (@pair nat term x (V x)) v))))).
Axiom thm_FORMSUBST_TRIV : forall p : form, (formsubst V p) = p.
Axiom thm_FORMSUBST_VALUATION : forall p : form, forall v : nat -> term, forall v' : nat -> term, (forall x : nat, (@IN nat x (free_variables p)) -> (v' x) = (v x)) -> (formsubst v' p) = (formsubst v p).
Axiom thm_FORMSUBST_FV : forall p : form, forall i : nat -> term, (free_variables (formsubst i p)) = (@GSPEC nat (fun GEN_PVAR_453 : nat => exists x : nat, @SETSPEC nat GEN_PVAR_453 (exists y : nat, (@IN nat y (free_variables p)) /\ (@IN nat x (free_variables_term (i y)))) x)).
Axiom thm_HOLDS_FORMSUBST : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall p : form, forall i : nat -> term, forall v : nat -> A, (@holds A M v (formsubst i p)) = (@holds A M (@o nat term A (@termval A M v) i) p).
Axiom thm_HOLDS_FORMSUBST1 : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall x : nat, forall t : term, forall p : form, forall v : nat -> A, (@holds A M v (formsubst (@valmod term nat (@pair nat term x t) V) p)) = (@holds A M (@valmod A nat (@pair nat A x (@termval A M v t)) v) p).
Axiom thm_HOLDS_RENAME : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall x : nat, forall y : nat, forall p : form, forall v : nat -> A, (@holds A M v (formsubst (@valmod term nat (@pair nat term x (V y)) V) p)) = (@holds A M (@valmod A nat (@pair nat A x (v y)) v) p).
Axiom thm_HOLDS_ALPHA_FORALL : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall x : nat, forall y : nat, forall p : form, forall v : nat -> A, (~ (@IN nat y (free_variables (FAll x p)))) -> (@holds A M v (FAll y (formsubst (@valmod term nat (@pair nat term x (V y)) V) p))) = (@holds A M v (FAll x p)).
Axiom thm_HOLDS_ALPHA_EXISTS : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall x : nat, forall y : nat, forall p : form, forall v : nat -> A, (~ (@IN nat y (free_variables (FEx x p)))) -> (@holds A M v (FEx y (formsubst (@valmod term nat (@pair nat term x (V y)) V) p))) = (@holds A M v (FEx x p)).
Axiom thm_FORMSUBST_RENAME : forall p : form, forall x : nat, forall y : nat, (@DELETE nat (free_variables (formsubst (@valmod term nat (@pair nat term x (V y)) V) p)) y) = (@DELETE nat (@DELETE nat (free_variables p) x) y).
Axiom thm_TERMSUBST_FUNCTIONS_TERM : forall t : term, forall i : nat -> term, (functions_term (termsubst i t)) = (@setU (prod nat nat) (functions_term t) (@GSPEC (prod nat nat) (fun GEN_PVAR_459 : prod nat nat => exists x : prod nat nat, @SETSPEC (prod nat nat) GEN_PVAR_459 (exists y : nat, (@IN nat y (free_variables_term t)) /\ (@IN (prod nat nat) x (functions_term (i y)))) x))).
Axiom thm_FORMSUBST_FUNCTIONS_FORM : forall p : form, forall i : nat -> term, (functions_form (formsubst i p)) = (@setU (prod nat nat) (functions_form p) (@GSPEC (prod nat nat) (fun GEN_PVAR_463 : prod nat nat => exists x : prod nat nat, @SETSPEC (prod nat nat) GEN_PVAR_463 (exists y : nat, (@IN nat y (free_variables p)) /\ (@IN (prod nat nat) x (functions_term (i y)))) x))).
Axiom thm_FORMSUBST_FUNCTIONS_FORM_1 : forall x : nat, forall t : term, forall p : form, (@IN nat x (free_variables p)) -> (functions_form (formsubst (@valmod term nat (@pair nat term x t) V) p)) = (@setU (prod nat nat) (functions_form p) (functions_term t)).
Axiom thm_FORMSUBST_PREDICATES : forall p : form, forall i : nat -> term, (predicates_form (formsubst i p)) = (predicates_form p).
Axiom thm_FORMSUBST_LANGUAGE_RENAME : forall (x : nat) (y : nat) (p : form), (language (@INSERT form (formsubst (@valmod term nat (@pair nat term x (V y)) V) p) (@set0 form))) = (language (@INSERT form p (@set0 form))).
Axiom thm_TERMVAL_FUNCTIONS : forall {A : Type'} (M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall t : term, (forall f : nat, forall zs : seq A, (@IN (prod nat nat) (@pair nat nat f (@size A zs)) (functions_term t)) -> (@Fun A M f zs) = (@Fun A M' f zs)) -> forall v : nat -> A, (@termval A M v t) = (@termval A M' v t).
Axiom thm_HOLDS_FUNCTIONS : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall p : form, (((@Dom A M) = (@Dom A M')) /\ ((forall P : nat, forall zs : seq A, (@Pred A M P zs) = (@Pred A M' P zs)) /\ (forall f : nat, forall zs : seq A, (@IN (prod nat nat) (@pair nat nat f (@size A zs)) (functions_form p)) -> (@Fun A M f zs) = (@Fun A M' f zs)))) -> forall v : nat -> A, (@holds A M v p) = (@holds A M' v p).
Axiom thm_HOLDS_PREDICATES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall p : form, (((@Dom A M) = (@Dom A M')) /\ ((forall f : nat, forall zs : seq A, (@Fun A M f zs) = (@Fun A M' f zs)) /\ (forall P : nat, forall zs : seq A, (@IN (prod nat nat) (@pair nat nat P (@size A zs)) (predicates_form p)) -> (@Pred A M P zs) = (@Pred A M' P zs)))) -> forall v : nat -> A, (@holds A M v p) = (@holds A M' v p).
Axiom thm_HOLDS_UCLOSE : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall x : nat, forall p : form, (forall v : nat -> A, (@valuation A M v) -> @holds A M v (FAll x p)) = (((@Dom A M) = (@set0 A)) \/ (forall v : nat -> A, (@valuation A M v) -> @holds A M v p)).
Axiom thm_MODEL_DUPLICATE : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall fns : (prod nat nat) -> Prop, forall preds : (prod nat nat) -> Prop, forall D : A -> Prop, ((@interpretation A (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) fns preds) M) /\ ((@subset A (@Dom A M) D) /\ (~ ((@Dom A M) = (@set0 A))))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) fns preds) M') /\ (((@Dom A M') = D) /\ (forall s : form -> Prop, ((@subset (prod nat nat) (functions s) fns) /\ (@subset (prod nat nat) (predicates s) preds)) -> (@satisfies A M' s) = (@satisfies A M s))).
Axiom thm_qfree : forall (n : nat) (l : seq term) (q : form) (x : nat) (p : form), ((qfree FFalse) = True) /\ (((qfree (Atom n l)) = True) /\ (((qfree (FImp p q)) = ((qfree p) /\ (qfree q))) /\ ((qfree (FAll x p)) = False))).
Axiom thm_QFREE : ((qfree FFalse) = True) /\ (((qfree FTrue) = True) /\ ((forall a : nat, forall l : seq term, (qfree (Atom a l)) = True) /\ ((forall p : form, (qfree (Not p)) = (qfree p)) /\ ((forall p : form, forall q : form, (qfree (FOr p q)) = ((qfree p) /\ (qfree q))) /\ ((forall p : form, forall q : form, (qfree (FAnd p q)) = ((qfree p) /\ (qfree q))) /\ ((forall p : form, forall q : form, (qfree (FImp p q)) = ((qfree p) /\ (qfree q))) /\ ((forall p : form, forall q : form, (qfree (FEquiv p q)) = ((qfree p) /\ (qfree q))) /\ ((forall x : nat, forall p : form, (qfree (FAll x p)) = False) /\ (forall x : nat, forall p : form, (qfree (FEx x p)) = False))))))))).
Axiom thm_QFREE_FORMSUBST : forall p : form, forall v : nat -> term, (qfree (formsubst v p)) = (qfree p).
Axiom thm_QFREE_BV_EMPTY : forall p : form, (qfree p) = ((bound_variables p) = (@set0 nat)).
Axiom thm_prenex_RULES : (forall p : form, (qfree p) -> prenex p) /\ ((forall x : nat, forall p : form, (prenex p) -> prenex (FAll x p)) /\ (forall x : nat, forall p : form, (prenex p) -> prenex (FEx x p))).
Axiom thm_prenex_CASES : forall a : form, (prenex a) = ((qfree a) \/ ((exists x : nat, exists p : form, (a = (FAll x p)) /\ (prenex p)) \/ (exists x : nat, exists p : form, (a = (FEx x p)) /\ (prenex p)))).
Axiom thm_prenex_INDUCT : forall prenex' : form -> Prop, ((forall p : form, (qfree p) -> prenex' p) /\ ((forall x : nat, forall p : form, (prenex' p) -> prenex' (FAll x p)) /\ (forall x : nat, forall p : form, (prenex' p) -> prenex' (FEx x p)))) -> forall a : form, (prenex a) -> prenex' a.
Axiom thm_universal_RULES : (forall p : form, (qfree p) -> universal p) /\ (forall x : nat, forall p : form, (universal p) -> universal (FAll x p)).
Axiom thm_universal_CASES : forall a : form, (universal a) = ((qfree a) \/ (exists x : nat, exists p : form, (a = (FAll x p)) /\ (universal p))).
Axiom thm_universal_INDUCT : forall universal' : form -> Prop, ((forall p : form, (qfree p) -> universal' p) /\ (forall x : nat, forall p : form, (universal' p) -> universal' (FAll x p))) -> forall a : form, (universal a) -> universal' a.
Axiom thm_prenex_INDUCT_NOT : forall {_189887 : Type'}, forall P : form -> Prop, ((forall p : form, (qfree p) -> P p) /\ ((forall x : nat, forall p : form, (P p) -> P (FAll x p)) /\ (forall x : _189887, forall p : form, (P p) -> P (Not p)))) -> forall a : form, (prenex a) -> P a.
Axiom thm_PRENEX : ((prenex FFalse) = True) /\ (((prenex FTrue) = True) /\ ((forall a : nat, forall l : seq term, (prenex (Atom a l)) = True) /\ ((forall p : form, (prenex (Not p)) = ((qfree p) \/ (exists q : form, exists x : nat, ((Not p) = (FEx x q)) /\ (prenex q)))) /\ ((forall p : form, forall q : form, (prenex (FOr p q)) = ((qfree p) /\ (qfree q))) /\ ((forall p : form, forall q : form, (prenex (FAnd p q)) = ((qfree p) /\ (qfree q))) /\ ((forall p : form, forall q : form, (prenex (FImp p q)) = (((qfree p) /\ (qfree q)) \/ (exists r : form, exists x : nat, ((FImp p q) = (FEx x r)) /\ (prenex r)))) /\ ((forall p : form, forall q : form, (prenex (FEquiv p q)) = ((qfree p) /\ (qfree q))) /\ ((forall x : nat, forall p : form, (prenex (FAll x p)) = (prenex p)) /\ (forall x : nat, forall p : form, (prenex (FEx x p)) = (prenex p)))))))))).
Axiom thm_FORMSUBST_STRUCTURE_LEMMA : forall p : form, forall i : nat -> term, (((formsubst i p) = FFalse) = (p = FFalse)) /\ (((exists a : nat, exists l : seq term, (formsubst i p) = (Atom a l)) = (exists a : nat, exists l : seq term, p = (Atom a l))) /\ (((exists q : form, exists r : form, (formsubst i p) = (FImp q r)) = (exists q : form, exists r : form, p = (FImp q r))) /\ ((exists x : nat, exists q : form, (formsubst i p) = (FAll x q)) = (exists x : nat, exists q : form, p = (FAll x q))))).
Axiom thm_FORMSUBST_STRUCTURE_NOT : forall p : form, forall i : nat -> term, (exists q : form, (formsubst i p) = (Not q)) = (exists q : form, p = (Not q)).
Axiom thm_FORMSUBST_STRUCTURE_EXISTS : forall p : form, forall i : nat -> term, (exists x : nat, exists q : form, (formsubst i p) = (FEx x q)) = (exists x : nat, exists q : form, p = (FEx x q)).
Axiom thm_PRENEX_FORMSUBST_LEMMA : forall p : form, (prenex p) -> forall i : nat -> term, forall q : form, (p = (formsubst i q)) -> prenex q.
Axiom thm_PRENEX_FORMSUBST : forall p : form, forall i : nat -> term, (prenex (formsubst i p)) = (prenex p).
Axiom thm_size : forall (p : nat) (l : seq term) (r : form) (x : nat) (q : form), ((form_size FFalse) = (NUMERAL (BIT1 O))) /\ (((form_size (Atom p l)) = (NUMERAL (BIT1 O))) /\ (((form_size (FImp q r)) = (addn (form_size q) (form_size r))) /\ ((form_size (FAll x q)) = (addn (NUMERAL (BIT1 O)) (form_size q))))).
Axiom thm_SIZE : ((form_size FFalse) = (NUMERAL (BIT1 O))) /\ (((form_size FTrue) = (NUMERAL (BIT0 (BIT1 O)))) /\ ((forall a : nat, forall l : seq term, (form_size (Atom a l)) = (NUMERAL (BIT1 O))) /\ ((forall p : form, (form_size (Not p)) = (addn (NUMERAL (BIT1 O)) (form_size p))) /\ ((forall p : form, forall q : form, (form_size (FOr p q)) = (addn (form_size p) (muln (NUMERAL (BIT0 (BIT1 O))) (form_size q)))) /\ ((forall p : form, forall q : form, (form_size (FAnd p q)) = (addn (form_size p) (addn (muln (NUMERAL (BIT0 (BIT1 O))) (form_size q)) (NUMERAL (BIT0 (BIT0 (BIT1 O))))))) /\ ((forall p : form, forall q : form, (form_size (FImp p q)) = (addn (form_size p) (form_size q))) /\ ((forall p : form, forall q : form, (form_size (FEquiv p q)) = (addn (muln (NUMERAL (BIT1 (BIT1 O))) (form_size p)) (addn (muln (NUMERAL (BIT1 (BIT1 O))) (form_size q)) (NUMERAL (BIT0 (BIT0 (BIT1 O))))))) /\ ((forall x : nat, forall p : form, (form_size (FAll x p)) = (addn (NUMERAL (BIT1 O)) (form_size p))) /\ (forall x : nat, forall p : form, (form_size (FEx x p)) = (addn (NUMERAL (BIT1 (BIT1 O))) (form_size p))))))))))).
Axiom thm_SIZE_FORMSUBST : forall p : form, forall i : nat -> term, (form_size (formsubst i p)) = (form_size p).
Axiom thm_PPAT_DEF : forall {_190599 : Type'}, forall A : nat -> form -> _190599, forall B : nat -> form -> _190599, forall C : form -> _190599, forall r : form, (@PPAT _190599 A B C r) = (@COND _190599 (exists x : nat, exists p : form, r = (FAll x p)) (A (@ε nat (fun x : nat => exists p : form, r = (FAll x p))) (@ε form (fun p : form => r = (FAll (@ε nat (fun x : nat => exists p' : form, r = (FAll x p'))) p)))) (@COND _190599 (exists x : nat, exists p : form, r = (FEx x p)) (B (@ε nat (fun x : nat => exists p : form, r = (FEx x p))) (@ε form (fun p : form => r = (FEx (@ε nat (fun x : nat => exists p' : form, r = (FEx x p'))) p)))) (C r))).
Axiom thm_PRENEX_DISTINCT : forall x : nat, forall y : nat, forall p : form, forall q : form, (((FAll x p) = (FAll y q)) = ((x = y) /\ (p = q))) /\ ((((FEx x p) = (FEx y q)) = ((x = y) /\ (p = q))) /\ (~ ((FAll x p) = (FEx y q)))).
Axiom thm_PPAT : forall {A : Type'}, forall A' : nat -> form -> A, forall B : nat -> form -> A, forall C : form -> A, (forall x : nat, forall p : form, (@PPAT A A' B C (FAll x p)) = (A' x p)) /\ ((forall x : nat, forall p : form, (@PPAT A A' B C (FEx x p)) = (B x p)) /\ (forall r : form, ((~ (exists x : nat, exists p : form, r = (FAll x p))) /\ (~ (exists x : nat, exists p : form, r = (FEx x p)))) -> (@PPAT A A' B C r) = (C r))).
Axiom thm_SIZE_REC : forall {_190932 : Type'}, forall H : (form -> _190932) -> form -> _190932, (forall f : form -> _190932, forall g : form -> _190932, forall x : form, (forall z : form, (ltn (form_size z) (form_size x)) -> (f z) = (g z)) -> (H f x) = (H g x)) -> exists f : form -> _190932, forall x : form, (f x) = (H f x).
Axiom thm_PRENEX_RIGHT_EXISTENCE : exists Prenex_right' : form -> form -> form, (forall p : form, forall x : nat, forall q : form, (Prenex_right' p (FAll x q)) = (@LET nat form (fun y : nat => @LET_END form (FAll y (Prenex_right' p (formsubst (@valmod term nat (@pair nat term x (V y)) V) q)))) (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))))) /\ ((forall p : form, forall x : nat, forall q : form, (Prenex_right' p (FEx x q)) = (@LET nat form (fun y : nat => @LET_END form (FEx y (Prenex_right' p (formsubst (@valmod term nat (@pair nat term x (V y)) V) q)))) (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))))) /\ (forall p : form, forall q : form, (qfree q) -> (Prenex_right' p q) = (FImp p q))).
Axiom thm_PRENEX_LEFT_EXISTENCE : exists Prenex_left' : form -> form -> form, (forall p : form, forall x : nat, forall q : form, (Prenex_left' (FAll x q) p) = (@LET nat form (fun y : nat => @LET_END form (FEx y (Prenex_left' (formsubst (@valmod term nat (@pair nat term x (V y)) V) q) p))) (VARIANT (@setU nat (free_variables (FAll x q)) (free_variables p))))) /\ ((forall p : form, forall x : nat, forall q : form, (Prenex_left' (FEx x q) p) = (@LET nat form (fun y : nat => @LET_END form (FAll y (Prenex_left' (formsubst (@valmod term nat (@pair nat term x (V y)) V) q) p))) (VARIANT (@setU nat (free_variables (FEx x q)) (free_variables p))))) /\ (forall p : form, forall q : form, (qfree q) -> (Prenex_left' q p) = (Prenex_right q p))).
Axiom thm_Prenex_DEF : forall (a : nat) (l : seq term) (q : form) (x : nat) (p : form), ((Prenex FFalse) = FFalse) /\ (((Prenex (Atom a l)) = (Atom a l)) /\ (((Prenex (FImp p q)) = (Prenex_left (Prenex p) (Prenex q))) /\ ((Prenex (FAll x p)) = (FAll x (Prenex p))))).
Axiom thm_PRENEX_RIGHT_FORALL : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (v : nat -> A) (p : form) (x : nat) (q : form), (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FImp p (FAll x q))) = (@holds A M v (FAll (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))))) V) q)))).
Axiom thm_PRENEX_RIGHT_EXISTS : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (v : nat -> A) (p : form) (x : nat) (q : form), (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FImp p (FEx x q))) = (@holds A M v (FEx (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))))) V) q)))).
Axiom thm_PRENEX_DUALITY_LEMMAS : forall {_191808 : Type'} (M : prod (_191808 -> Prop) (prod (nat -> (seq _191808) -> _191808) (nat -> (seq _191808) -> Prop))) (v : nat -> _191808) (q : form) (x : nat) (p : form), ((@holds _191808 M v (FImp (FEx x p) q)) = (@holds _191808 M v (FImp (Not q) (FAll x (Not p))))) /\ ((@holds _191808 M v (FImp (FAll x p) q)) = (@holds _191808 M v (FImp (Not q) (FEx x (Not p))))).
Axiom thm_PRENEX_LEFT_FORALL : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (v : nat -> A) (x : nat) (p : form) (q : form), (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FImp (FAll x p) q)) = (@holds A M v (FEx (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))))) V) p) q))).
Axiom thm_PRENEX_LEFT_EXISTS : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (v : nat -> A) (x : nat) (p : form) (q : form), (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FImp (FEx x p) q)) = (@holds A M v (FAll (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))))) V) p) q))).
Axiom thm_PRENEX_RIGHT_FORALL_FV : forall (p : form) (x : nat) (q : form), (free_variables (FImp p (FAll x q))) = (free_variables (FAll (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))))) V) q)))).
Axiom thm_PRENEX_RIGHT_EXISTS_FV : forall (p : form) (x : nat) (q : form), (free_variables (FImp p (FEx x q))) = (free_variables (FEx (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))))) V) q)))).
Axiom thm_PRENEX_LEFT_FORALL_FV : forall (x : nat) (p : form) (q : form), (free_variables (FImp (FAll x p) q)) = (free_variables (FEx (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))))) V) p) q))).
Axiom thm_PRENEX_LEFT_EXISTS_FV : forall (x : nat) (p : form) (q : form), (free_variables (FImp (FEx x p) q)) = (free_variables (FAll (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))))) V) p) q))).
Axiom thm_PRENEX_RIGHT_FORALL_LANGUAGE : forall (p : form) (x : nat) (q : form), (language (@INSERT form (FImp p (FAll x q)) (@set0 form))) = (language (@INSERT form (FAll (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FAll x q)))))) V) q))) (@set0 form))).
Axiom thm_PRENEX_RIGHT_EXISTS_LANGUAGE : forall (p : form) (x : nat) (q : form), (language (@INSERT form (FImp p (FEx x q)) (@set0 form))) = (language (@INSERT form (FEx (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))) (FImp p (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables p) (free_variables (FEx x q)))))) V) q))) (@set0 form))).
Axiom thm_PRENEX_LEFT_FORALL_LANGUAGE : forall (x : nat) (p : form) (q : form), (language (@INSERT form (FImp (FAll x p) q) (@set0 form))) = (language (@INSERT form (FEx (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FAll x p)) (free_variables q))))) V) p) q)) (@set0 form))).
Axiom thm_PRENEX_LEFT_EXISTS_LANGUAGE : forall (x : nat) (p : form) (q : form), (language (@INSERT form (FImp (FEx x p) q) (@set0 form))) = (language (@INSERT form (FAll (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))) (FImp (formsubst (@valmod term nat (@pair nat term x (V (VARIANT (@setU nat (free_variables (FEx x p)) (free_variables q))))) V) p) q)) (@set0 form))).
Axiom thm_PRENEX_LEMMA_FORALL : forall {A : Type'} (P : Prop) (r1 : form) (z : nat) (r2 : form) (p : form) (x : nat) (q : form), (P /\ (((free_variables r1) = (free_variables r2)) /\ (((language (@INSERT form r1 (@set0 form))) = (language (@INSERT form r2 (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v p) = (@holds A M v q))))) -> P /\ (((free_variables (FAll z r1)) = (free_variables (FAll z r2))) /\ (((language (@INSERT form (FAll z r1) (@set0 form))) = (language (@INSERT form (FAll z r2) (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FAll x p)) = (@holds A M v (FAll x q))))).
Axiom thm_PRENEX_LEMMA_EXISTS : forall {A : Type'} (P : Prop) (r1 : form) (z : nat) (r2 : form) (p : form) (x : nat) (q : form), (P /\ (((free_variables r1) = (free_variables r2)) /\ (((language (@INSERT form r1 (@set0 form))) = (language (@INSERT form r2 (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v p) = (@holds A M v q))))) -> P /\ (((free_variables (FEx z r1)) = (free_variables (FEx z r2))) /\ (((language (@INSERT form (FEx z r1) (@set0 form))) = (language (@INSERT form (FEx z r2) (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (FEx x p)) = (@holds A M v (FEx x q))))).
Axiom thm_PRENEX_RIGHT_THM : forall {A : Type'}, forall p : form, forall q : form, ((qfree p) /\ (prenex q)) -> (prenex (Prenex_right p q)) /\ (((free_variables (Prenex_right p q)) = (free_variables (FImp p q))) /\ (((language (@INSERT form (Prenex_right p q) (@set0 form))) = (language (@INSERT form (FImp p q) (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (Prenex_right p q)) = (@holds A M v (FImp p q))))).
Axiom thm_PRENEX_LEFT_THM : forall {A : Type'}, forall p : form, forall q : form, ((prenex p) /\ (prenex q)) -> (prenex (Prenex_left p q)) /\ (((free_variables (Prenex_left p q)) = (free_variables (FImp p q))) /\ (((language (@INSERT form (Prenex_left p q) (@set0 form))) = (language (@INSERT form (FImp p q) (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (Prenex_left p q)) = (@holds A M v (FImp p q))))).
Axiom thm_PRENEX_THM : forall {A : Type'}, forall p : form, (prenex (Prenex p)) /\ (((free_variables (Prenex p)) = (free_variables p)) /\ (((language (@INSERT form (Prenex p) (@set0 form))) = (language (@INSERT form p (@set0 form)))) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (~ ((@Dom A M) = (@set0 A))) -> (@holds A M v (Prenex p)) = (@holds A M v p)))).
Axiom thm_HOLDS_EXISTS_LEMMA : forall {A : Type'}, forall p : form, forall t : term, forall x : nat, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, forall preds : (prod nat nat) -> Prop, ((@interpretation A (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (functions_term t) preds) M) /\ ((@valuation A M v) /\ (@holds A M v (formsubst (@valmod term nat (@pair nat term x t) V) p)))) -> @holds A M v (FEx x p).
Axiom thm_Skolem1_DEF : forall f : nat, forall x : nat, forall p : form, (Skolem1 f x p) = (formsubst (@valmod term nat (@pair nat term x (Fn f (@map nat term V (@list_of_set nat (free_variables (FEx x p)))))) V) p).
Axiom thm_HOLDS_SKOLEM1 : forall {A : Type'}, forall f : nat, forall x : nat, forall p : form, ((prenex (FEx x p)) /\ (~ (@IN (prod nat nat) (@pair nat nat f (@CARD nat (free_variables (FEx x p)))) (functions_form (FEx x p))))) -> (prenex (Skolem1 f x p)) /\ (((free_variables (Skolem1 f x p)) = (free_variables (FEx x p))) /\ ((ltn (form_size (Skolem1 f x p)) (form_size (FEx x p))) /\ (((predicates_form (Skolem1 f x p)) = (predicates_form (FEx x p))) /\ ((@subset (prod nat nat) (functions_form (FEx x p)) (functions_form (Skolem1 f x p))) /\ ((@subset (prod nat nat) (functions_form (Skolem1 f x p)) (@INSERT (prod nat nat) (@pair nat nat f (@CARD nat (free_variables (FEx x p)))) (functions_form (FEx x p)))) /\ ((forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (FEx x p)))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((forall g : nat, forall zs : seq A, ((~ (g = f)) \/ (~ ((@size A zs) = (@CARD nat (free_variables (FEx x p)))))) -> (@Fun A M' g zs) = (@Fun A M g zs)) /\ ((@interpretation A (language (@INSERT form (Skolem1 f x p) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (Skolem1 f x p)))))) /\ (forall N' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (Skolem1 f x p) (@set0 form))) N') /\ (~ ((@Dom A N') = (@set0 A)))) -> forall v : nat -> A, ((@valuation A N' v) /\ (@holds A N' v (Skolem1 f x p))) -> @holds A N' v (FEx x p)))))))).
Axiom thm_Skolems_EXISTENCE : forall J : nat, exists Skolems' : form -> nat -> form, forall r : form, (Skolems' r) = (fun k : nat => @PPAT form (fun x : nat => fun q : form => FAll x (Skolems' q k)) (fun x : nat => fun q : form => Skolems' (Skolem1 (NUMPAIR J k) x q) (S k)) (fun p : form => p) r).
Axiom thm_Skolems_SPECIFICATION : exists Skolems' : nat -> form -> nat -> form, forall J : nat, forall r : form, forall k : nat, (Skolems' J r k) = (@PPAT form (fun x : nat => fun q : form => FAll x (Skolems' J q k)) (fun x : nat => fun q : form => Skolems' J (Skolem1 (NUMPAIR J k) x q) (S k)) (fun p : form => p) r).
Axiom thm_HOLDS_SKOLEMS_INDUCTION : forall {A : Type'}, forall n : nat, forall J : nat, forall k : nat, forall p : form, (((form_size p) = n) /\ ((prenex p) /\ (forall l : nat, forall m : nat, (@IN (prod nat nat) (@pair nat nat (NUMPAIR J l) m) (functions_form p)) -> ltn l k))) -> (universal (Skolems J p k)) /\ (((free_variables (Skolems J p k)) = (free_variables p)) /\ (((predicates_form (Skolems J p k)) = (predicates_form p)) /\ ((@subset (prod nat nat) (functions_form p) (functions_form (Skolems J p k))) /\ ((@subset (prod nat nat) (functions_form (Skolems J p k)) (@setU (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_467 : prod nat nat => exists j : nat, exists l : nat, exists m : nat, @SETSPEC (prod nat nat) GEN_PVAR_467 ((j = J) /\ (leqn k l)) (@pair nat nat (NUMPAIR j l) m))) (functions_form p))) /\ ((forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (forall v : nat -> A, (@valuation A M v) -> @holds A M v p))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((forall g : nat, forall zs : seq A, (~ ((@Fun A M' g zs) = (@Fun A M g zs))) -> exists l : nat, (leqn k l) /\ (g = (NUMPAIR J l))) /\ ((@interpretation A (language (@INSERT form (Skolems J p k) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (Skolems J p k)))))) /\ (forall N' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (Skolems J p k) (@set0 form))) N') /\ (~ ((@Dom A N') = (@set0 A)))) -> forall v : nat -> A, ((@valuation A N' v) /\ (@holds A N' v (Skolems J p k))) -> @holds A N' v p)))))).
Axiom thm_HOLDS_SKOLEMS_PRENEX : forall {A : Type'}, forall p : form, (prenex p) -> forall K : nat, (forall l : nat, forall m : nat, ~ (@IN (prod nat nat) (@pair nat nat (NUMPAIR K l) m) (functions_form p))) -> (universal (Skolems K p (NUMERAL O))) /\ (((free_variables (Skolems K p (NUMERAL O))) = (free_variables p)) /\ (((predicates_form (Skolems K p (NUMERAL O))) = (predicates_form p)) /\ ((@subset (prod nat nat) (functions_form p) (functions_form (Skolems K p (NUMERAL O)))) /\ ((@subset (prod nat nat) (functions_form (Skolems K p (NUMERAL O))) (@setU (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_468 : prod nat nat => exists k : nat, exists l : nat, exists m : nat, @SETSPEC (prod nat nat) GEN_PVAR_468 (k = K) (@pair nat nat (NUMPAIR k l) m))) (functions_form p))) /\ ((forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (forall v : nat -> A, (@valuation A M v) -> @holds A M v p))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((forall g : nat, forall zs : seq A, (~ ((@Fun A M' g zs) = (@Fun A M g zs))) -> exists l : nat, g = (NUMPAIR K l)) /\ ((@interpretation A (language (@INSERT form (Skolems K p (NUMERAL O)) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (Skolems K p (NUMERAL O))))))) /\ (forall N' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (Skolems K p (NUMERAL O)) (@set0 form))) N') /\ (~ ((@Dom A N') = (@set0 A)))) -> forall v : nat -> A, ((@valuation A N' v) /\ (@holds A N' v (Skolems K p (NUMERAL O)))) -> @holds A N' v p)))))).
Axiom thm_Skopre_DEF : forall K : nat, forall p : form, (Skopre K p) = (Skolems K (Prenex p) (NUMERAL O)).
Axiom thm_SKOPRE : forall {A : Type'}, forall p : form, forall K : nat, (forall l : nat, forall m : nat, ~ (@IN (prod nat nat) (@pair nat nat (NUMPAIR K l) m) (functions_form p))) -> (universal (Skopre K p)) /\ (((free_variables (Skopre K p)) = (free_variables p)) /\ (((predicates_form (Skopre K p)) = (predicates_form p)) /\ ((@subset (prod nat nat) (functions_form p) (functions_form (Skopre K p))) /\ ((@subset (prod nat nat) (functions_form (Skopre K p)) (@setU (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_469 : prod nat nat => exists k : nat, exists l : nat, exists m : nat, @SETSPEC (prod nat nat) GEN_PVAR_469 (k = K) (@pair nat nat (NUMPAIR k l) m))) (functions_form p))) /\ ((forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (forall v : nat -> A, (@valuation A M v) -> @holds A M v p))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((forall g : nat, forall zs : seq A, (~ ((@Fun A M' g zs) = (@Fun A M g zs))) -> exists l : nat, g = (NUMPAIR K l)) /\ ((@interpretation A (language (@INSERT form (Skopre K p) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (Skopre K p)))))) /\ (forall N' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (Skopre K p) (@set0 form))) N') /\ (~ ((@Dom A N') = (@set0 A)))) -> forall v : nat -> A, ((@valuation A N' v) /\ (@holds A N' v (Skopre K p))) -> @holds A N' v p)))))).
Axiom thm_bumpmod : forall {_195789 : Type'}, forall M : prod (_195789 -> Prop) (prod (nat -> (seq _195789) -> _195789) (nat -> (seq _195789) -> Prop)), (@bumpmod _195789 M) = (@pair (_195789 -> Prop) (prod (nat -> (seq _195789) -> _195789) (nat -> (seq _195789) -> Prop)) (@Dom _195789 M) (@pair (nat -> (seq _195789) -> _195789) (nat -> (seq _195789) -> Prop) (fun k : nat => fun zs : seq _195789 => @Fun _195789 M (NUMSND k) zs) (@Pred _195789 M))).
Axiom thm_bumpterm : forall (x : nat) (k : nat) (l : seq term), ((bumpterm (V x)) = (V x)) /\ ((bumpterm (Fn k l)) = (Fn (NUMPAIR (NUMERAL O) k) (@map term term bumpterm l))).
Axiom thm_bumpform : forall (p : nat) (l : seq term) (q : form) (x : nat) (r : form), ((bumpform FFalse) = FFalse) /\ (((bumpform (Atom p l)) = (Atom p (@map term term bumpterm l))) /\ (((bumpform (FImp q r)) = (FImp (bumpform q) (bumpform r))) /\ ((bumpform (FAll x r)) = (FAll x (bumpform r))))).
Axiom thm_BUMPTERM : forall {_195895 : Type'}, forall M : prod (_195895 -> Prop) (prod (nat -> (seq _195895) -> _195895) (nat -> (seq _195895) -> Prop)), forall v : nat -> _195895, forall t : term, (@termval _195895 M v t) = (@termval _195895 (@bumpmod _195895 M) v (bumpterm t)).
Axiom thm_BUMPFORM : forall {_195916 : Type'}, forall M : prod (_195916 -> Prop) (prod (nat -> (seq _195916) -> _195916) (nat -> (seq _195916) -> Prop)), forall p : form, forall v : nat -> _195916, (@holds _195916 M v p) = (@holds _195916 (@bumpmod _195916 M) v (bumpform p)).
Axiom thm_FUNCTIONS_FORM_BUMPFORM : forall p : form, forall f : nat, forall m : nat, (@IN (prod nat nat) (@pair nat nat f m) (functions_form (bumpform p))) -> exists k : nat, (f = (NUMPAIR (NUMERAL O) k)) /\ (@IN (prod nat nat) (@pair nat nat k m) (functions_form p)).
Axiom thm_BUMPFORM_INTERPRETATION : forall {_196002 : Type'} (p : form) (M : prod (_196002 -> Prop) (prod (nat -> (seq _196002) -> _196002) (nat -> (seq _196002) -> Prop))), (@interpretation _196002 (language (@INSERT form p (@set0 form))) M) -> @interpretation _196002 (language (@INSERT form (bumpform p) (@set0 form))) (@bumpmod _196002 M).
Axiom thm_unbumpterm : forall (x : nat) (k : nat) (l : seq term), ((unbumpterm (V x)) = (V x)) /\ ((unbumpterm (Fn k l)) = (Fn (NUMSND k) (@map term term unbumpterm l))).
Axiom thm_unbumpform : forall (p : nat) (l : seq term) (q : form) (x : nat) (r : form), ((unbumpform FFalse) = FFalse) /\ (((unbumpform (Atom p l)) = (Atom p (@map term term unbumpterm l))) /\ (((unbumpform (FImp q r)) = (FImp (unbumpform q) (unbumpform r))) /\ ((unbumpform (FAll x r)) = (FAll x (unbumpform r))))).
Axiom thm_UNBUMPTERM : forall t : term, (unbumpterm (bumpterm t)) = t.
Axiom thm_UNBUMPFORM : forall p : form, (unbumpform (bumpform p)) = p.
Axiom thm_unbumpmod : forall {_196113 : Type'}, forall M : prod (_196113 -> Prop) (prod (nat -> (seq _196113) -> _196113) (nat -> (seq _196113) -> Prop)), (@unbumpmod _196113 M) = (@pair (_196113 -> Prop) (prod (nat -> (seq _196113) -> _196113) (nat -> (seq _196113) -> Prop)) (@Dom _196113 M) (@pair (nat -> (seq _196113) -> _196113) (nat -> (seq _196113) -> Prop) (fun k : nat => fun zs : seq _196113 => @Fun _196113 M (NUMPAIR (NUMERAL O) k) zs) (@Pred _196113 M))).
Axiom thm_UNBUMPMOD_TERM : forall {_196156 : Type'}, forall M : prod (_196156 -> Prop) (prod (nat -> (seq _196156) -> _196156) (nat -> (seq _196156) -> Prop)), forall v : nat -> _196156, forall t : term, (@termval _196156 M v (bumpterm t)) = (@termval _196156 (@unbumpmod _196156 M) v t).
Axiom thm_UNBUMPMOD : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall p : form, forall v : nat -> A, (@holds A M v (bumpform p)) = (@holds A (@unbumpmod A M) v p).
Axiom thm_NUMLIST : forall (h : nat) (t : seq nat), ((NUMLIST (@nil nat)) = (NUMERAL O)) /\ ((NUMLIST (@cons nat h t)) = (addn (NUMPAIR h (NUMLIST t)) (NUMERAL (BIT1 O)))).
Axiom thm_NUMLIST_INJ : forall l1 : seq nat, forall l2 : seq nat, ((NUMLIST l1) = (NUMLIST l2)) = (l1 = l2).
Axiom thm_NUM_OF_TERM_INJ : forall s : term, forall t : term, ((num_of_term s) = (num_of_term t)) = (s = t).
Axiom thm_num_of_form : forall (p : nat) (l : seq term) (r : form) (x : nat) (q : form), ((num_of_form FFalse) = (NUMPAIR (NUMERAL O) (NUMERAL O))) /\ (((num_of_form (Atom p l)) = (NUMPAIR (NUMERAL (BIT1 O)) (NUMPAIR p (NUMLIST (@map term nat num_of_term l))))) /\ (((num_of_form (FImp q r)) = (NUMPAIR (NUMERAL (BIT0 (BIT1 O))) (NUMPAIR (num_of_form q) (num_of_form r)))) /\ ((num_of_form (FAll x q)) = (NUMPAIR (NUMERAL (BIT1 (BIT1 O))) (NUMPAIR x (num_of_form q)))))).
Axiom thm_NUMLIST_NUM_OF_TERM : forall l1 : seq term, forall l2 : seq term, ((NUMLIST (@map term nat num_of_term l1)) = (NUMLIST (@map term nat num_of_term l2))) = (l1 = l2).
Axiom thm_NUM_OF_FORM_INJ : forall q : form, forall r : form, ((num_of_form q) = (num_of_form r)) = (q = r).
Axiom thm_form_of_num : forall x : nat, (form_of_num x) = (@ε form (fun p : form => (num_of_form p) = x)).
Axiom thm_FORM_OF_NUM : forall (p : form), (form_of_num (num_of_form p)) = p.
Axiom thm_SKOLEMIZE : forall p : form, (SKOLEMIZE p) = (Skopre (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O))) (bumpform p)).
Axiom thm_SKOLEMIZE_WORKS : forall {A : Type'}, forall p : form, (universal (SKOLEMIZE p)) /\ (((free_variables (SKOLEMIZE p)) = (free_variables (bumpform p))) /\ (((predicates_form (SKOLEMIZE p)) = (predicates_form (bumpform p))) /\ ((@subset (prod nat nat) (functions_form (bumpform p)) (functions_form (SKOLEMIZE p))) /\ ((@subset (prod nat nat) (functions_form (SKOLEMIZE p)) (@setU (prod nat nat) (@GSPEC (prod nat nat) (fun GEN_PVAR_470 : prod nat nat => exists k : nat, exists l : nat, exists m : nat, @SETSPEC (prod nat nat) GEN_PVAR_470 (k = (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O)))) (@pair nat nat (NUMPAIR k l) m))) (functions_form (bumpform p)))) /\ ((forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (bumpform p) (@set0 form))) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (bumpform p)))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((forall g : nat, forall zs : seq A, (~ ((@Fun A M' g zs) = (@Fun A M g zs))) -> exists l : nat, g = (NUMPAIR (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O))) l)) /\ ((@interpretation A (language (@INSERT form (SKOLEMIZE p) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (SKOLEMIZE p)))))) /\ (forall N' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@INSERT form (SKOLEMIZE p) (@set0 form))) N') /\ (~ ((@Dom A N') = (@set0 A)))) -> forall v : nat -> A, ((@valuation A N' v) /\ (@holds A N' v (SKOLEMIZE p))) -> @holds A N' v (bumpform p))))))).
Axiom thm_FUNCTIONS_FORM_SKOLEMIZE : forall p : form, forall f : nat, forall m : nat, (@IN (prod nat nat) (@pair nat nat f m) (functions_form (SKOLEMIZE p))) -> (exists k : nat, (f = (NUMPAIR (NUMERAL O) k)) /\ (@IN (prod nat nat) (@pair nat nat k m) (functions_form p))) \/ (exists l : nat, f = (NUMPAIR (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O))) l)).
Axiom thm_SKOMOD1 : forall {A : Type'}, forall p : form, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@SKOMOD1 A p M) = (@COND (prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (forall v : nat -> A, (@valuation A M v) -> @holds A M v p) (@ε (prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (fun M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)) => ((@Dom A M') = (@Dom A (@bumpmod A M))) /\ (((@Pred A M') = (@Pred A (@bumpmod A M))) /\ ((forall g : nat, forall zs : seq A, (~ ((@Fun A M' g zs) = (@Fun A (@bumpmod A M) g zs))) -> exists l : nat, g = (NUMPAIR (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O))) l)) /\ ((@interpretation A (language (@INSERT form (SKOLEMIZE p) (@set0 form))) M') /\ (forall v : nat -> A, (@valuation A M' v) -> @holds A M' v (SKOLEMIZE p))))))) (@pair (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)) (@Dom A M) (@pair (nat -> (seq A) -> A) (nat -> (seq A) -> Prop) (fun g : nat => fun zs : seq A => @ε A (fun a : A => @IN A a (@Dom A M))) (@Pred A M)))).
Axiom thm_SKOMOD1_WORKS : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall p : form, ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ (~ ((@Dom A M) = (@set0 A)))) -> ((@Dom A (@SKOMOD1 A p M)) = (@Dom A (@bumpmod A M))) /\ (((@Pred A (@SKOMOD1 A p M)) = (@Pred A (@bumpmod A M))) /\ ((@interpretation A (language (@INSERT form (SKOLEMIZE p) (@set0 form))) (@SKOMOD1 A p M)) /\ ((forall v : nat -> A, (@valuation A M v) -> @holds A M v p) -> (forall g : nat, forall zs : seq A, (~ ((@Fun A (@SKOMOD1 A p M) g zs) = (@Fun A (@bumpmod A M) g zs))) -> exists l : nat, g = (NUMPAIR (addn (num_of_form (bumpform p)) (NUMERAL (BIT1 O))) l)) /\ (forall v : nat -> A, (@valuation A (@SKOMOD1 A p M) v) -> @holds A (@SKOMOD1 A p M) v (SKOLEMIZE p))))).
Axiom thm_SKOMOD : forall {_197166 : Type'}, forall M : prod (_197166 -> Prop) (prod (nat -> (seq _197166) -> _197166) (nat -> (seq _197166) -> Prop)), (@SKOMOD _197166 M) = (@pair (_197166 -> Prop) (prod (nat -> (seq _197166) -> _197166) (nat -> (seq _197166) -> Prop)) (@Dom _197166 M) (@pair (nat -> (seq _197166) -> _197166) (nat -> (seq _197166) -> Prop) (fun g : nat => fun zs : seq _197166 => @COND _197166 ((NUMFST g) = (NUMERAL O)) (@Fun _197166 M (NUMSND g) zs) (@Fun _197166 (@SKOMOD1 _197166 (unbumpform (form_of_num (predn (NUMFST g)))) M) g zs)) (@Pred _197166 M))).
Axiom thm_SKOMOD_INTERPRETATION : forall {A : Type'} (p : form) (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ (~ ((@Dom A M) = (@set0 A)))) -> @interpretation A (language (@INSERT form (SKOLEMIZE p) (@set0 form))) (@SKOMOD A M).
Axiom thm_SKOMOD_WORKS : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (p : form), ((@interpretation A (language (@INSERT form p (@set0 form))) M) /\ (~ ((@Dom A M) = (@set0 A)))) -> (forall v : nat -> A, (@valuation A M v) -> @holds A M v p) = (forall v : nat -> A, (@valuation A (@SKOMOD A M) v) -> @holds A (@SKOMOD A M) v (SKOLEMIZE p)).
Axiom thm_SKOLEMIZE_SATISFIABLE : forall {A : Type'} (s : form -> Prop), (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) /\ ((@interpretation A (language s) M) /\ (@satisfies A M s))) = (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) /\ ((@interpretation A (language (@GSPEC form (fun GEN_PVAR_472 : form => exists p : form, @SETSPEC form GEN_PVAR_472 (@IN form p s) (SKOLEMIZE p)))) M) /\ (@satisfies A M (@GSPEC form (fun GEN_PVAR_473 : form => exists p : form, @SETSPEC form GEN_PVAR_473 (@IN form p s) (SKOLEMIZE p)))))).
Axiom thm_specialize : forall (p : nat) (l : seq term) (q : form) (x : nat) (r : form), ((specialize FFalse) = FFalse) /\ (((specialize (Atom p l)) = (Atom p l)) /\ (((specialize (FImp q r)) = (FImp q r)) /\ ((specialize (FAll x r)) = (specialize r)))).
Axiom thm_SPECIALIZE_SATISFIES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall s : form -> Prop, (~ ((@Dom A M) = (@set0 A))) -> (@satisfies A M s) = (@satisfies A M (@GSPEC form (fun GEN_PVAR_474 : form => exists p : form, @SETSPEC form GEN_PVAR_474 (@IN form p s) (specialize p)))).
Axiom thm_SPECIALIZE_QFREE : forall p : form, (universal p) -> qfree (specialize p).
Axiom thm_SPECIALIZE_LANGUAGE : forall s : form -> Prop, (language (@GSPEC form (fun GEN_PVAR_475 : form => exists p : form, @SETSPEC form GEN_PVAR_475 (@IN form p s) (specialize p)))) = (language s).
Axiom thm_SKOLEM : forall p : form, (SKOLEM p) = (specialize (SKOLEMIZE p)).
Axiom thm_SKOLEM_QFREE : forall p : form, qfree (SKOLEM p).
Axiom thm_SKOLEM_SATISFIABLE : forall {A : Type'} (s : form -> Prop), (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) /\ ((@interpretation A (language s) M) /\ (@satisfies A M s))) = (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) /\ ((@interpretation A (language (@GSPEC form (fun GEN_PVAR_476 : form => exists p : form, @SETSPEC form GEN_PVAR_476 (@IN form p s) (SKOLEM p)))) M) /\ (@satisfies A M (@GSPEC form (fun GEN_PVAR_477 : form => exists p : form, @SETSPEC form GEN_PVAR_477 (@IN form p s) (SKOLEM p)))))).
Axiom thm_pholds : forall (p : nat) (l : seq term) (r : form) (v : form -> Prop) (x : nat) (q : form), ((pholds v FFalse) = False) /\ (((pholds v (Atom p l)) = (v (Atom p l))) /\ (((pholds v (FImp q r)) = ((pholds v q) -> pholds v r)) /\ ((pholds v (FAll x q)) = (v (FAll x q))))).
Axiom thm_PHOLDS : forall (p : nat) (l : seq term) (q : form) (v : form -> Prop) (r : form), ((pholds v FFalse) = False) /\ (((pholds v FTrue) = True) /\ (((pholds v (Atom p l)) = (v (Atom p l))) /\ (((pholds v (Not q)) = (~ (pholds v q))) /\ (((pholds v (FOr q r)) = ((pholds v q) \/ (pholds v r))) /\ (((pholds v (FAnd q r)) = ((pholds v q) /\ (pholds v r))) /\ (((pholds v (FImp q r)) = ((pholds v q) -> pholds v r)) /\ ((pholds v (FEquiv q r)) = ((pholds v q) = (pholds v r))))))))).
Axiom thm_psatisfies : forall s : form -> Prop, forall v : form -> Prop, (psatisfies v s) = (forall p : form, (@IN form p s) -> pholds v p).
Axiom thm_psatisfiable : forall s : form -> Prop, (psatisfiable s) = (exists v : form -> Prop, forall p : form, (@IN form p s) -> pholds v p).
Axiom thm_PSATISFIABLE_MONO : forall A : form -> Prop, forall B : form -> Prop, ((psatisfiable A) /\ (@subset form B A)) -> psatisfiable B.
Axiom thm_finsat : forall A : form -> Prop, (finsat A) = (forall B : form -> Prop, ((@subset form B A) /\ (@finite_set form B)) -> psatisfiable B).
Axiom thm_FINSAT_MONO : forall A : form -> Prop, forall B : form -> Prop, ((finsat A) /\ (@subset form B A)) -> finsat B.
Axiom thm_SATISFIABLE_MONO : forall A : form -> Prop, forall B : form -> Prop, ((psatisfiable A) /\ (@subset form B A)) -> psatisfiable B.
Axiom thm_FINSAT_SATISFIABLE : forall (B : form -> Prop), (psatisfiable B) -> finsat B.
Axiom thm_FINSAT_MAX : forall A : form -> Prop, (finsat A) -> exists B : form -> Prop, (@subset form A B) /\ ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)).
Axiom thm_FINSAT_EXTEND : forall (p : form) (B : form -> Prop), (finsat B) -> (finsat (@INSERT form p B)) \/ (finsat (@INSERT form (Not p) B)).
Axiom thm_FINSAT_MAX_COMPLETE : forall (B : form -> Prop), ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)) -> forall p : form, (@IN form p B) \/ (@IN form (Not p) B).
Axiom thm_FINSAT_MAX_COMPLETE_STRONG : forall (B : form -> Prop), ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)) -> forall p : form, (@IN form (Not p) B) = (~ (@IN form p B)).
Axiom thm_FINSAT_DEDUCTION : forall (B : form -> Prop), ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)) -> forall p : form, (@IN form p B) = (exists A : form -> Prop, (@finite_set form A) /\ ((@subset form A B) /\ (forall v : form -> Prop, (forall q : form, (@IN form q A) -> pholds v q) -> pholds v p))).
Axiom thm_FINSAT_MAX_CONSISTENT : forall (B : form -> Prop), ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)) -> ~ (@IN form FFalse B).
Axiom thm_FINSAT_MAX_HOMO : forall (B : form -> Prop), ((finsat B) /\ (forall C : form -> Prop, ((@subset form B C) /\ (finsat C)) -> C = B)) -> forall p : form, forall q : form, (@IN form (FImp p q) B) = ((@IN form p B) -> @IN form q B).
Axiom thm_COMPACT_PROP : forall (A : form -> Prop), (forall B : form -> Prop, ((@finite_set form B) /\ (@subset form B A)) -> exists d : form -> Prop, forall r : form, (@IN form r B) -> pholds d r) -> exists d : form -> Prop, forall r : form, (@IN form r A) -> pholds d r.
Axiom thm_COMPACT_PROP_ALT : forall A : form -> Prop, (forall d : form -> Prop, exists p : form, (@IN form p A) /\ (pholds d p)) -> exists B : form -> Prop, (@finite_set form B) /\ ((@subset form B A) /\ (forall d : form -> Prop, exists p : form, (@IN form p B) /\ (pholds d p))).
Axiom thm_FINITE_DISJ_LEMMA : forall A : form -> Prop, (@finite_set form A) -> exists ps : seq form, (@ALL form (fun p : form => @IN form p A) ps) /\ (forall d : form -> Prop, (pholds d (@ITLIST form form FOr ps FFalse)) = (exists p : form, (@IN form p A) /\ (pholds d p))).
Axiom thm_COMPACT_DISJ : forall A : form -> Prop, (forall d : form -> Prop, exists p : form, (@IN form p A) /\ (pholds d p)) -> exists ps : seq form, (@ALL form (fun p : form => @IN form p A) ps) /\ (forall d : form -> Prop, pholds d (@ITLIST form form FOr ps FFalse)).
Axiom thm_terms_CASES : forall fns : (prod nat nat) -> Prop, forall a : term, (terms fns a) = ((exists x : nat, a = (V x)) \/ (exists f : nat, exists l : seq term, (a = (Fn f l)) /\ ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term (terms fns) l)))).
Axiom thm_terms_INDUCT : forall fns : (prod nat nat) -> Prop, forall terms' : term -> Prop, ((forall x : nat, terms' (V x)) /\ (forall f : nat, forall l : seq term, ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term terms' l)) -> terms' (Fn f l))) -> forall a : term, (terms fns a) -> terms' a.
Axiom thm_terms_RULES : forall fns : (prod nat nat) -> Prop, (forall x : nat, terms fns (V x)) /\ (forall f : nat, forall l : seq term, ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term (terms fns) l)) -> terms fns (Fn f l)).
Axiom thm_STUPID_CANONDOM_LEMMA : forall {_199173 : Type'} (L : prod ((prod nat nat) -> Prop) _199173), forall t : term, (@IN term t (terms (@fst ((prod nat nat) -> Prop) _199173 L))) -> @subset (prod nat nat) (functions_term t) (@fst ((prod nat nat) -> Prop) _199173 L).
Axiom thm_FINITE_SUBSET_INSTANCE : forall (s : form -> Prop) (P : (nat -> term) -> Prop), forall t' : form -> Prop, (@finite_set form t') -> (@subset form t' (@GSPEC form (fun GEN_PVAR_483 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_483 ((P v) /\ (@IN form p s)) (formsubst v p)))) -> exists t : form -> Prop, (@finite_set form t) /\ ((@subset form t s) /\ (@subset form t' (@GSPEC form (fun GEN_PVAR_484 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_484 ((P v) /\ (@IN form p t)) (formsubst v p))))).
Axiom thm_FINITE_SUBSET_SKOLEM : forall s : form -> Prop, forall u : form -> Prop, (@finite_set form u) -> (@subset form u (@GSPEC form (fun GEN_PVAR_487 : form => exists p : form, @SETSPEC form GEN_PVAR_487 (@IN form p s) (SKOLEM p)))) -> exists t : form -> Prop, (@finite_set form t) /\ ((@subset form t s) /\ (u = (@GSPEC form (fun GEN_PVAR_488 : form => exists p : form, @SETSPEC form GEN_PVAR_488 (@IN form p t) (SKOLEM p))))).
Axiom thm_VALUATION_EXISTS : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) -> exists v : nat -> A, @valuation A M v.
Axiom thm_HOLDS_ITLIST_EXISTS : forall {A : Type'} (p : form), forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall xs : seq nat, forall v : nat -> A, (@holds A M v (@ITLIST nat form FEx xs p)) = (exists _as : seq A, ((@size A _as) = (@size nat xs)) /\ ((@ALL A (@Dom A M) _as) /\ (@holds A M (@ITLIST (prod nat A) (nat -> A) (@valmod A nat) (@rev (prod nat A) (@MAP2 nat A (prod nat A) (fun x : nat => fun a : A => @pair nat A x a) xs _as)) v) p))).
Axiom thm_canonical : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (canonical L M) = (((@Dom term M) = (terms (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L))) /\ (forall f : nat, (@Fun term M f) = (Fn f))).
Axiom thm_prop_of_model : forall {_199671 : Type'}, forall M : prod (_199671 -> Prop) (prod (nat -> (seq _199671) -> _199671) (nat -> (seq _199671) -> Prop)), forall v : nat -> _199671, forall p : nat, forall l : seq term, (@holds _199671 M v (Atom p l)) = (@holds _199671 M v (Atom p l)).
Axiom thm_canon_of_prop : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall d : form -> Prop, (canon_of_prop L d) = (@pair (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)) (terms (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (@pair (nat -> (seq term) -> term) (nat -> (seq term) -> Prop) Fn (fun p : nat => fun l : seq term => d (Atom p l)))).
Axiom thm_PHOLDS_PROP_OF_MODEL : forall {_199713 : Type'} (M : prod (_199713 -> Prop) (prod (nat -> (seq _199713) -> _199713) (nat -> (seq _199713) -> Prop))) (v : nat -> _199713), forall p : form, (qfree p) -> (pholds (@holds _199713 M v) p) = (@holds _199713 M v p).
Axiom thm_PROP_OF_CANON_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop), forall p : nat, forall l : seq term, (@holds term (canon_of_prop L d) V (Atom p l)) = (d (Atom p l)).
Axiom thm_HOLDS_CANON_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop), forall p : form, (qfree p) -> (@holds term (canon_of_prop L d) V p) = (pholds d p).
Axiom thm_HOLDS_CANON_OF_PROP_GENERAL : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop) (v : nat -> term) (p : form), (qfree p) -> (@holds term (canon_of_prop L d) v p) = (pholds d (formsubst v p)).
Axiom thm_CANONICAL_CANON_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)), forall d : form -> Prop, canonical L (canon_of_prop L d).
Axiom thm_INTERPRETATION_CANON_OF_PROP : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall d : form -> Prop, @interpretation term L (canon_of_prop L d).
Axiom thm_PROP_VALID_IMP_FOL_VALID : forall {_199833 : Type'}, forall p : form, ((qfree p) /\ (forall d : form -> Prop, pholds d p)) -> forall M : prod (_199833 -> Prop) (prod (nat -> (seq _199833) -> _199833) (nat -> (seq _199833) -> Prop)), forall v : nat -> _199833, @holds _199833 M v p.
Axiom thm_FOL_VALID_IMP_PROP_VALID : forall p : form, ((qfree p) /\ (forall C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), forall v : nat -> term, (canonical (language (@INSERT form p (@set0 form))) C) -> @holds term C v p)) -> forall d : form -> Prop, pholds d p.
Axiom thm_SATISFIES_PSATISFIES : forall {_199890 : Type'} (M : prod (_199890 -> Prop) (prod (nat -> (seq _199890) -> _199890) (nat -> (seq _199890) -> Prop))) (v : nat -> _199890) (s : form -> Prop), ((forall p : form, (@IN form p s) -> qfree p) /\ ((@satisfies _199890 M s) /\ (@valuation _199890 M v))) -> psatisfies (@holds _199890 M v) s.
Axiom thm_PSATISFIES_INSTANCES : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop) (s : form -> Prop), ((forall p : form, (@IN form p s) -> qfree p) /\ (psatisfies d (@GSPEC form (fun GEN_PVAR_489 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_489 ((forall x : nat, @IN term (v x) (terms (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L))) /\ (@IN form p s)) (formsubst v p))))) -> @satisfies term (canon_of_prop L d) s.
Axiom thm_SATISFIES_INSTANCES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall s : form -> Prop, forall t : form -> Prop, (@interpretation A (language t) M) -> (@satisfies A M (@GSPEC form (fun GEN_PVAR_490 : form => exists i : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_490 ((@IN form p s) /\ (forall x : nat, @IN term (i x) (terms (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (language t))))) (formsubst i p)))) = (@satisfies A M s).
Axiom thm_COMPACT_CANON_QFREE : forall {A : Type'} (ss : form -> Prop) (s : form -> Prop), ((forall p : form, (@IN form p s) -> qfree p) /\ (forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t s)) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language ss) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t)))) -> exists C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language ss) C) /\ ((canonical (language ss) C) /\ (@satisfies term C s)).
Axiom thm_INTERPRETATION_RESTRICTLANGUAGE : forall {_200332 : Type'}, forall M : prod (_200332 -> Prop) (prod (nat -> (seq _200332) -> _200332) (nat -> (seq _200332) -> Prop)), forall s : form -> Prop, forall t : form -> Prop, ((@subset form t s) /\ (@interpretation _200332 (language s) M)) -> @interpretation _200332 (language t) M.
Axiom thm_INTERPRETATION_EXTENDLANGUAGE : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall s : form -> Prop, forall t : form -> Prop, ((@interpretation A (language t) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t))) -> exists M' : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@Dom A M') = (@Dom A M)) /\ (((@Pred A M') = (@Pred A M)) /\ ((@interpretation A (language s) M') /\ (@satisfies A M' t))).
Axiom thm_COMPACT_LS : forall {A : Type'} (s : form -> Prop), (forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t s)) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t))) -> exists C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language s) C) /\ ((~ ((@Dom term C) = (@set0 term))) /\ (@satisfies term C s)).
Axiom thm_CANON : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall s : form -> Prop, ((@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((forall p : form, (@IN form p s) -> qfree p) /\ (@satisfies A M s)))) -> exists C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language s) C) /\ ((~ ((@Dom term C) = (@set0 term))) /\ (@satisfies term C s)).
Axiom thm_term_of_num : forall n : nat, (term_of_num n) = (@ε term (fun t : term => (num_of_term t) = n)).
Axiom thm_TERM_OF_NUM : forall (t : term), (term_of_num (num_of_term t)) = t.
Axiom thm_LOWMOD : forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (LOWMOD M) = (@pair (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)) (@GSPEC nat (fun GEN_PVAR_501 : nat => exists t : term, @SETSPEC nat GEN_PVAR_501 (@IN term t (@Dom term M)) (num_of_term t))) (@pair (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop) (fun g : nat => fun zs : seq nat => num_of_term (@Fun term M g (@map nat term term_of_num zs))) (fun p : nat => fun zs : seq nat => @Pred term M p (@map nat term term_of_num zs)))).
Axiom thm_LOWMOD_DOM_EMPTY : forall (M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop))), ((@Dom nat (LOWMOD M)) = (@set0 nat)) = ((@Dom term M) = (@set0 term)).
Axiom thm_LOWMOD_TERMVAL : forall (M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop))), forall v : nat -> nat, (@valuation nat (LOWMOD M) v) -> forall t : term, (@termval nat (LOWMOD M) v t) = (num_of_term (@termval term M (@o nat nat term term_of_num v) t)).
Axiom thm_LOWMOD_HOLDS : forall (M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop))), forall p : form, forall v : nat -> nat, (@valuation nat (LOWMOD M) v) -> (@holds nat (LOWMOD M) v p) = (@holds term M (@o nat nat term term_of_num v) p).
Axiom thm_LOWMOD_INTERPRETATION : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation nat L (LOWMOD M)) = (@interpretation term L M).
Axiom thm_LS : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall s : form -> Prop, ((@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((forall p : form, (@IN form p s) -> qfree p) /\ (@satisfies A M s)))) -> exists N' : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), (@interpretation nat (language s) N') /\ ((~ ((@Dom nat N') = (@set0 nat))) /\ (@satisfies nat N' s)).
Axiom thm_UNIFORMITY : forall (xs : seq nat) (p : form), ((qfree p) /\ (forall C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), forall v : nat -> term, ((~ ((@Dom term C) = (@set0 term))) /\ (@valuation term C v)) -> @holds term C v (@ITLIST nat form FEx xs p))) -> exists is : seq (nat -> term), (forall i : nat -> term, forall x : nat, (@MEM (nat -> term) i is) -> terms (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (language (@INSERT form p (@set0 form)))) (i x)) /\ (forall d : form -> Prop, pholds d (@ITLIST form form FOr (@map (nat -> term) form (fun i : nat -> term => formsubst i p) is) FFalse)).
Axiom thm_herbase_CASES : forall fns : (prod nat nat) -> Prop, forall a : term, (herbase fns a) = (((a = (V (NUMERAL O))) /\ (~ (exists c : nat, @IN (prod nat nat) (@pair nat nat c (NUMERAL O)) fns))) \/ (exists f : nat, exists l : seq term, (a = (Fn f l)) /\ ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term (herbase fns) l)))).
Axiom thm_herbase_INDUCT : forall fns : (prod nat nat) -> Prop, forall herbase' : term -> Prop, (((~ (exists c : nat, @IN (prod nat nat) (@pair nat nat c (NUMERAL O)) fns)) -> herbase' (V (NUMERAL O))) /\ (forall f : nat, forall l : seq term, ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term herbase' l)) -> herbase' (Fn f l))) -> forall a : term, (herbase fns a) -> herbase' a.
Axiom thm_herbase_RULES : forall fns : (prod nat nat) -> Prop, ((~ (exists c : nat, @IN (prod nat nat) (@pair nat nat c (NUMERAL O)) fns)) -> herbase fns (V (NUMERAL O))) /\ (forall f : nat, forall l : seq term, ((@IN (prod nat nat) (@pair nat nat f (@size term l)) fns) /\ (@ALL term (herbase fns) l)) -> herbase fns (Fn f l)).
Axiom thm_herbrand : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (herbrand L M) = (((@Dom term M) = (herbase (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L))) /\ (forall f : nat, (@Fun term M f) = (Fn f))).
Axiom thm_HERBRAND_INTERPRETATION : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (herbrand L M) -> @interpretation term L M.
Axiom thm_HERBASE_FUNCTIONS : forall fns : (prod nat nat) -> Prop, forall t : term, (@IN term t (herbase fns)) -> @subset (prod nat nat) (functions_term t) fns.
Axiom thm_HERBASE_NONEMPTY : forall fns : (prod nat nat) -> Prop, exists t : term, @IN term t (herbase fns).
Axiom thm_HERBRAND_NONEMPTY : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (herbrand L M) -> ~ ((@Dom term M) = (@set0 term)).
Axiom thm_herbrand_of_prop : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall d : form -> Prop, (herbrand_of_prop L d) = (@pair (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)) (herbase (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (@pair (nat -> (seq term) -> term) (nat -> (seq term) -> Prop) Fn (fun p : nat => fun l : seq term => d (Atom p l)))).
Axiom thm_PROP_OF_HERBRAND_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop), forall p : nat, forall l : seq term, (@holds term (herbrand_of_prop L d) V (Atom p l)) = (d (Atom p l)).
Axiom thm_HOLDS_HERBRAND_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop), forall p : form, (qfree p) -> (@holds term (herbrand_of_prop L d) V p) = (pholds d p).
Axiom thm_HOLDS_HERBRAND_OF_PROP_GENERAL : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop) (v : nat -> term) (p : form), (qfree p) -> (@holds term (herbrand_of_prop L d) v p) = (pholds d (formsubst v p)).
Axiom thm_HERBRAND_HERBRAND_OF_PROP : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)), forall d : form -> Prop, herbrand L (herbrand_of_prop L d).
Axiom thm_INTERPRETATION_HERBRAND_OF_PROP : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall d : form -> Prop, @interpretation term L (herbrand_of_prop L d).
Axiom thm_PSATISFIES_HERBRAND_INSTANCES : forall (L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop)) (d : form -> Prop) (s : form -> Prop), ((forall p : form, (@IN form p s) -> qfree p) /\ (psatisfies d (@GSPEC form (fun GEN_PVAR_506 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_506 ((forall x : nat, @IN term (v x) (herbase (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L))) /\ (@IN form p s)) (formsubst v p))))) -> @satisfies term (herbrand_of_prop L d) s.
Axiom thm_SATISFIES_SUBSET : forall {_201883 : Type'}, forall M : prod (_201883 -> Prop) (prod (nat -> (seq _201883) -> _201883) (nat -> (seq _201883) -> Prop)), forall s : form -> Prop, forall t : form -> Prop, ((@subset form s t) /\ (@satisfies _201883 M t)) -> @satisfies _201883 M s.
Axiom thm_HERBASE_SUBSET_TERMS : forall (fns : (prod nat nat) -> Prop), forall t : term, (@IN term t (herbase fns)) -> @IN term t (terms fns).
Axiom thm_HERBRAND_THEOREM : forall s : form -> Prop, (forall p : form, (@IN form p s) -> qfree p) -> (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language s) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M s))) = (exists d : form -> Prop, psatisfies d (@GSPEC form (fun GEN_PVAR_507 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_507 ((forall x : nat, @IN term (v x) (herbase (functions s))) /\ (@IN form p s)) (formsubst v p)))).
Axiom thm_Equal_DEF : forall s : term, forall t : term, (FEq s t) = (Atom (NUMERAL O) (@cons term s (@cons term t (@nil term)))).
Axiom thm_uclose : forall p : form, (uclose p) = (@ITLIST nat form FAll (@list_of_set nat (free_variables p)) p).
Axiom thm_normal : forall {_202043 : Type'}, forall fns : (prod nat nat) -> Prop, forall M : prod (_202043 -> Prop) (prod (nat -> (seq _202043) -> _202043) (nat -> (seq _202043) -> Prop)), (@normal _202043 fns M) = (forall s : term, forall t : term, forall v : nat -> _202043, ((@valuation _202043 M v) /\ ((@IN term s (terms fns)) /\ (@IN term t (terms fns)))) -> (@holds _202043 M v (FEq s t)) = ((@termval _202043 M v s) = (@termval _202043 M v t))).
Axiom thm_Varpairs_DEF : forall (n : nat), ((Varpairs (NUMERAL O)) = (@nil (prod term term))) /\ ((Varpairs (S n)) = (@cons (prod term term) (@pair term term (V (muln (NUMERAL (BIT0 (BIT1 O))) n)) (V (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O))))) (Varpairs n))).
Axiom thm_Eqaxiom_Func : forall f : nat, forall n : nat, (Eqaxiom_Func (@pair nat nat f n)) = (uclose (FImp (@ITLIST form form FAnd (@map (prod term term) form (@ε ((prod term term) -> form) (fun f' : (prod term term) -> form => forall s : term, forall t : term, @eq form (f' (@pair term term s t)) (FEq s t))) (Varpairs n)) FTrue) (FEq (Fn f (@map (prod term term) term (@fst term term) (Varpairs n))) (Fn f (@map (prod term term) term (@snd term term) (Varpairs n)))))).
Axiom thm_Eqaxiom_Pred : forall p : nat, forall n : nat, (Eqaxiom_Pred (@pair nat nat p n)) = (uclose (FImp (@ITLIST form form FAnd (@map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (FEq s t))) (Varpairs n)) FTrue) (FEquiv (Atom p (@map (prod term term) term (@fst term term) (Varpairs n))) (Atom p (@map (prod term term) term (@snd term term) (Varpairs n)))))).
Axiom thm_Eqaxioms_DEF : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), (Eqaxioms L) = (@setU form (@INSERT form (FAll (NUMERAL O) (FEq (V (NUMERAL O)) (V (NUMERAL O)))) (@set0 form)) (@setU form (@INSERT form (FAll (NUMERAL O) (FAll (NUMERAL (BIT1 O)) (FAll (NUMERAL (BIT0 (BIT1 O))) (FImp (FEq (V (NUMERAL O)) (V (NUMERAL (BIT1 O)))) (FImp (FEq (V (NUMERAL (BIT0 (BIT1 O)))) (V (NUMERAL (BIT1 O)))) (FEq (V (NUMERAL O)) (V (NUMERAL (BIT0 (BIT1 O)))))))))) (@set0 form)) (@setU form (@GSPEC form (fun GEN_PVAR_508 : form => exists fa : prod nat nat, @SETSPEC form GEN_PVAR_508 (@IN (prod nat nat) fa (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (Eqaxiom_Func fa))) (@GSPEC form (fun GEN_PVAR_509 : form => exists pa : prod nat nat, @SETSPEC form GEN_PVAR_509 (@IN (prod nat nat) pa (@snd ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (Eqaxiom_Pred pa)))))).
Axiom thm_DOWNFROM : forall (n : nat), ((DOWNFROM (NUMERAL O)) = (@nil nat)) /\ ((DOWNFROM (S n)) = (@cons nat n (DOWNFROM n))).
Axiom thm_SATISFIES_UNION : forall {_202327 : Type'}, forall M : prod (_202327 -> Prop) (prod (nat -> (seq _202327) -> _202327) (nat -> (seq _202327) -> Prop)), forall s : form -> Prop, forall t : form -> Prop, (@satisfies _202327 M (@setU form s t)) = ((@satisfies _202327 M s) /\ (@satisfies _202327 M t)).
Axiom thm_HOLDS_UCLOSE_ALL : forall {_202352 A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall x : _202352, forall p : form, (forall v : nat -> A, (@valuation A M v) -> @holds A M v p) -> forall v : nat -> A, (@valuation A M v) -> @holds A M v (uclose p).
Axiom thm_HOLDS_UCLOSE_ALL_EQ : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (~ ((@Dom A M) = (@set0 A))) -> forall p : form, (forall v : nat -> A, (@valuation A M v) -> @holds A M v (uclose p)) = (forall v : nat -> A, (@valuation A M v) -> @holds A M v p).
Axiom thm_UCLOSE_FV_LEMMA : forall l : seq nat, forall p : form, (free_variables (@ITLIST nat form FAll l p)) = (@setD nat (free_variables p) (@set_of_list nat l)).
Axiom thm_UCLOSE_CLOSED : forall p : form, (free_variables (uclose p)) = (@set0 nat).
Axiom thm_HOLDS_UCLOSE_ANY : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, forall p : form, (@holds A M v (uclose p)) -> (~ ((@Dom A M) = (@set0 A))) -> forall w : nat -> A, (@valuation A M w) -> @holds A M w p.
Axiom thm_SATISFIES_NOT : forall {A : Type'} (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (p : form) (E : form -> Prop), (~ ((@Dom A M) = (@set0 A))) -> ((@satisfies A M E) /\ (~ (@satisfies A M (@INSERT form p (@set0 form))))) = (@satisfies A M (@INSERT form (Not (uclose p)) E)).
Axiom thm_PREDICATES_FORM_UCLOSE : forall (p : form), (predicates_form (uclose p)) = (predicates_form p).
Axiom thm_HOLDS_ANDS : forall {_202627 : Type'} (M : prod (_202627 -> Prop) (prod (nat -> (seq _202627) -> _202627) (nat -> (seq _202627) -> Prop))) (v : nat -> _202627), forall l : seq form, (@holds _202627 M v (@ITLIST form form FAnd l FTrue)) = (@ALL form (@holds _202627 M v) l).
Axiom thm_LENGTH_VARPAIRS : forall n : nat, (@size (prod term term) (Varpairs n)) = n.
Axiom thm_MAP_FST_VARPAIRS : forall n : nat, (@map (prod term term) term (@fst term term) (Varpairs n)) = (@map nat term (fun n' : nat => V (muln (NUMERAL (BIT0 (BIT1 O))) n')) (DOWNFROM n)).
Axiom thm_MAP_SND_VARPAIRS : forall n : nat, (@map (prod term term) term (@snd term term) (Varpairs n)) = (@map nat term (fun n' : nat => V (addn (muln (NUMERAL (BIT0 (BIT1 O))) n') (NUMERAL (BIT1 O)))) (DOWNFROM n)).
Axiom thm_MULT_DIV_LEMMA : (forall n : nat, (divn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT0 (BIT1 O)))) = n) /\ (forall n : nat, (divn (addn (muln (NUMERAL (BIT0 (BIT1 O))) n) (NUMERAL (BIT1 O))) (NUMERAL (BIT0 (BIT1 O)))) = n).
Axiom thm_PAIR_LEMMA : forall {_202741 _202751 _202752 : Type'} (P : _202752 -> _202751 -> _202741), forall z : prod _202752 _202751, (@ε ((prod _202752 _202751) -> _202741) (fun f : (prod _202752 _202751) -> _202741 => forall x : _202752, forall y : _202751, @eq _202741 (f (@pair _202752 _202751 x y)) (P x y)) z) = (P (@fst _202752 _202751 z) (@snd _202752 _202751 z)).
Axiom thm_FORALL_VARPAIRS : forall (P : (prod term term) -> Prop), forall n : nat, (@ALL (prod term term) P (Varpairs n)) = (@ALL nat (fun n' : nat => P (@pair term term (V (muln (NUMERAL (BIT0 (BIT1 O))) n')) (V (addn (muln (NUMERAL (BIT0 (BIT1 O))) n') (NUMERAL (BIT1 O)))))) (DOWNFROM n)).
Axiom thm_FORALL2_VARPAIRS : forall {_202870 : Type'} (a : nat) (M : prod (_202870 -> Prop) (prod (nat -> (seq _202870) -> _202870) (nat -> (seq _202870) -> Prop))) (v : nat -> _202870), forall n : nat, (@ALL (prod term term) (fun p : prod term term => @Pred _202870 M a (@cons _202870 (@termval _202870 M v (@fst term term p)) (@cons _202870 (@termval _202870 M v (@snd term term p)) (@nil _202870)))) (Varpairs n)) = (@ALL2 _202870 _202870 (fun x : _202870 => fun y : _202870 => @Pred _202870 M a (@cons _202870 x (@cons _202870 y (@nil _202870)))) (@map term _202870 (@termval _202870 M v) (@map (prod term term) term (@fst term term) (Varpairs n))) (@map term _202870 (@termval _202870 M v) (@map (prod term term) term (@snd term term) (Varpairs n)))).
Axiom thm_FORALL2_FORALL : forall {_202909 _202910 _202912 : Type'} (P : _202910 -> _202909 -> Prop) (f : _202912 -> _202910) (g : _202912 -> _202909), forall l : seq _202912, (@ALL2 _202910 _202909 (fun x : _202910 => fun y : _202909 => P x y) (@map _202912 _202910 f l) (@map _202912 _202909 g l)) = (@ALL _202912 (fun x : _202912 => P (f x) (g x)) l).
Axiom thm_FORALL_DOWNFROM : forall (P : nat -> Prop), forall n : nat, (@ALL nat P (DOWNFROM n)) = (forall k : nat, (ltn k n) -> P k).
Axiom thm_MAP_INDEXED : forall {A : Type'}, forall l : seq A, (@map nat A (fun n : nat => @EL A (subn (subn (@size A l) (NUMERAL (BIT1 O))) n) l) (DOWNFROM (@size A l))) = l.
Axiom thm_RECONSTRUCT_TERMVAL : forall {_203233 _203259 : Type'} (l : seq _203233), forall M : prod (_203259 -> Prop) (prod (nat -> (seq _203259) -> _203259) (nat -> (seq _203259) -> Prop)), forall a : _203259, forall f1 : _203233 -> _203259, forall f2 : _203233 -> _203259, ((@map term _203259 (@termval _203259 M (fun n : nat => @COND _203259 (leqn (muln (NUMERAL (BIT0 (BIT1 O))) (@size _203233 l)) n) a (@COND _203259 (even n) (f1 (@EL _203233 (subn (subn (@size _203233 l) (NUMERAL (BIT1 O))) (divn n (NUMERAL (BIT0 (BIT1 O))))) l)) (f2 (@EL _203233 (subn (subn (@size _203233 l) (NUMERAL (BIT1 O))) (divn n (NUMERAL (BIT0 (BIT1 O))))) l))))) (@map (prod term term) term (@fst term term) (Varpairs (@size _203233 l)))) = (@map _203233 _203259 f1 l)) /\ ((@map term _203259 (@termval _203259 M (fun n : nat => @COND _203259 (leqn (muln (NUMERAL (BIT0 (BIT1 O))) (@size _203233 l)) n) a (@COND _203259 (even n) (f1 (@EL _203233 (subn (subn (@size _203233 l) (NUMERAL (BIT1 O))) (divn n (NUMERAL (BIT0 (BIT1 O))))) l)) (f2 (@EL _203233 (subn (subn (@size _203233 l) (NUMERAL (BIT1 O))) (divn n (NUMERAL (BIT0 (BIT1 O))))) l))))) (@map (prod term term) term (@snd term term) (Varpairs (@size _203233 l)))) = (@map _203233 _203259 f2 l)).
Axiom thm_FORALL_TERMS_STRONG : forall s : form -> Prop, forall t : term, (terms (functions s) t) = (@subset (prod nat nat) (functions_term t) (functions s)).
Axiom thm_FORALL_TERMS_RAW : forall s : form -> Prop, forall t : term, (terms (functions s) t) -> @subset (prod nat nat) (functions_term t) (functions s).
Axiom thm_FORALL_TERMS_INDEXED : forall (s : form -> Prop), forall l : seq term, forall n : nat, ((@ALL term (terms (functions s)) l) /\ (ltn n (@size term l))) -> @subset (prod nat nat) (functions_term (@EL term n l)) (functions s).
Axiom thm_NORMAL_THM : forall {A : Type'} (s : form -> Prop), (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((@normal A (functions s) M) /\ (@satisfies A M s)))) = (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M (@setU form s (Eqaxioms (language s)))))).
Axiom thm_FUNCTIONS_SUBSET : forall s : form -> Prop, forall t : form -> Prop, (@subset form t s) -> @subset (prod nat nat) (functions t) (functions s).
Axiom thm_INTERPRETATION_MODIFY_LANGUAGE : forall {A : Type'}, forall s : form -> Prop, forall s' : form -> Prop, forall t : form -> Prop, ((@subset form t s) /\ (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t)))) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s') M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t)).
Axiom thm_INTERPRETATION_RESTRICT_LANGUAGE : forall {A : Type'}, forall s : form -> Prop, forall s' : form -> Prop, forall t : form -> Prop, ((@subset form s' s) /\ (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t)))) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s') M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M t)).
Axiom thm_FUNCTIONS_INSERT : forall (p : form) (s : form -> Prop), (functions (@INSERT form p s)) = (@setU (prod nat nat) (functions_form p) (functions s)).
Axiom thm_FUNCTIONS_UNION : forall (s : form -> Prop) (t : form -> Prop), (functions (@setU form s t)) = (@setU (prod nat nat) (functions s) (functions t)).
Axiom thm_PREDICATES_UNION : forall (s : form -> Prop) (t : form -> Prop), (predicates (@setU form s t)) = (@setU (prod nat nat) (predicates s) (predicates t)).
Axiom thm_FUNCTIONS_FORM_UCLOSE : forall (p : form), (functions_form (uclose p)) = (functions_form p).
Axiom thm_FUNCTIONS_TERM_FNV1 : forall (p : nat) (n : nat), (functions_term (Fn p (@map (prod term term) term (@fst term term) (Varpairs n)))) = (@INSERT (prod nat nat) (@pair nat nat p n) (@set0 (prod nat nat))).
Axiom thm_FUNCTIONS_FORM_FNV1 : forall n : nat, (@list_Union (prod nat nat) (@map term ((prod nat nat) -> Prop) functions_term (@map (prod term term) term (@fst term term) (Varpairs n)))) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_FORM_FNV2 : forall n : nat, (@list_Union (prod nat nat) (@map term ((prod nat nat) -> Prop) functions_term (@map (prod term term) term (@snd term term) (Varpairs n)))) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_TERM_FNV2 : forall (p : nat) (n : nat), (functions_term (Fn p (@map (prod term term) term (@snd term term) (Varpairs n)))) = (@INSERT (prod nat nat) (@pair nat nat p n) (@set0 (prod nat nat))).
Axiom thm_FUNCTIONS_EQCONJ : forall n : nat, (functions_form (@ITLIST form form FAnd (@map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Atom (NUMERAL O) (@cons term s (@cons term t (@nil term)))))) (Varpairs n)) FTrue)) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_EQAXIOM_FUNC : forall fa : prod nat nat, (functions_form (Eqaxiom_Func fa)) = (@INSERT (prod nat nat) fa (@set0 (prod nat nat))).
Axiom thm_FUNCTIONS_EQAXIOM_PRED : forall pa : prod nat nat, (functions_form (Eqaxiom_Pred pa)) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_EQAXIOM : forall (s : form -> Prop), (functions (Eqaxioms (language s))) = (functions s).
Axiom thm_INTERPRETATION_EQAXIOMS : forall {_205336 : Type'} (s : form -> Prop) (M : prod (_205336 -> Prop) (prod (nat -> (seq _205336) -> _205336) (nat -> (seq _205336) -> Prop))), (@interpretation _205336 (language s) M) = (@interpretation _205336 (language (@setU form s (Eqaxioms (language s)))) M).
Axiom thm_TERMS_SUBSET : forall f1 : (prod nat nat) -> Prop, forall f2 : (prod nat nat) -> Prop, (@subset (prod nat nat) f1 f2) -> @subset term (terms f1) (terms f2).
Axiom thm_EQAXIOMS_UNION : forall (s : form -> Prop) (t : form -> Prop), (Eqaxioms (language (@setU form s t))) = (@setU form (Eqaxioms (language s)) (Eqaxioms (language t))).
Axiom thm_EQAXIOMS_SUBSET : forall (s : form -> Prop) (t : form -> Prop), (@subset form s t) -> @subset form (Eqaxioms (language s)) (Eqaxioms (language t)).
Axiom thm_IN_EQAXIOMS : forall (s : form -> Prop) (p : form), (@IN form p (Eqaxioms (language s))) -> (s = (@set0 form)) \/ (exists q : form, (@IN form q s) /\ (@IN form p (Eqaxioms (language (@INSERT form q (@set0 form)))))).
Axiom thm_COMPACT_LS_NORM_LEMMA1 : forall {A : Type'} (s : form -> Prop), (forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t s)) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((@normal A (functions s) M) /\ (@satisfies A M t)))) -> forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t s)) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language t) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((@normal A (functions t) M) /\ (@satisfies A M t))).
Axiom thm_COMPACT_LS_NORM_LEMMA2a : forall (s : form -> Prop) (t : form -> Prop), ((@finite_set form t) /\ (@subset form t (Eqaxioms (language s)))) -> exists s0 : form -> Prop, (@finite_set form s0) /\ ((@subset form s0 s) /\ (@subset form t (Eqaxioms (language s0)))).
Axiom thm_COMPACT_LS_NORM_LEMMA2 : forall (s : form -> Prop), forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t (@setU form s (Eqaxioms (language s))))) -> exists u : form -> Prop, (@subset form t (@setU form u (Eqaxioms (language u)))) /\ ((@finite_set form u) /\ (@subset form u s)).
Axiom thm_COMPACT_LS_NORM : forall {A : Type'} (s : form -> Prop), (forall t : form -> Prop, ((@finite_set form t) /\ (@subset form t s)) -> exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language s) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ ((@normal A (functions s) M) /\ (@satisfies A M t)))) -> exists C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language s) C) /\ ((~ ((@Dom term C) = (@set0 term))) /\ ((@normal term (functions s) C) /\ (@satisfies term C s))).
Axiom thm_LEFT_AND_EX_THM : forall {_205870 : Type'}, forall P : _205870 -> Prop, forall Q : Prop, forall l : seq _205870, ((@EX _205870 P l) /\ Q) = (@EX _205870 (fun x : _205870 => (P x) /\ Q) l).
Axiom thm_EX_ADHOC : forall {_205889 : Type'} (P : _205889 -> Prop) (Q : _205889 -> Prop) (R' : _205889 -> Prop), forall l : seq _205889, (forall x : _205889, (~ (P x)) -> (Q x) = (R' x)) -> (~ (@EX _205889 P l)) -> (@EX _205889 Q l) = (@EX _205889 R' l).
Axiom thm_ALL_ADHOC : forall {_205920 : Type'} (f : _205920 -> Prop) (g : _205920 -> Prop), forall l : seq _205920, (@ALL _205920 (fun x : _205920 => (f x) = (g x)) l) -> (@EX _205920 f l) = (@EX _205920 g l).
Axiom thm_WF_FINITE_LEMMA : forall {A : Type'}, forall lt2' : A -> A -> Prop, forall s : A -> Prop, ((@finite_set A s) /\ ((forall x : A, ~ (@Relation_Operators.clos_trans A lt2' x x)) /\ (forall x : A, forall y : A, (lt2' x y) -> @IN A y s))) -> @well_founded A lt2'.
Axiom thm_TC_REV : forall {A : Type'} (R' : A -> A -> Prop), forall x : A, forall y : A, (@Relation_Operators.clos_trans A (fun u : A => fun v : A => R' v u) x y) = (@Relation_Operators.clos_trans A R' y x).
Axiom thm_WF_DISJ : forall {A : Type'} (R' : A -> A -> Prop) (S' : A -> A -> Prop), ((@well_founded A R') /\ (@well_founded A (fun x : A => fun y : A => exists z : A, (S' x z) /\ (@RTC A R' z y)))) -> @well_founded A (fun x : A => fun y : A => (R' x y) \/ (S' x y)).
Axiom thm_WF_ALTERNATION : forall {A : Type'} (S' : A -> A -> Prop) (R' : A -> A -> Prop) (P : A -> A -> Prop), ((@well_founded A (fun x : A => fun y : A => (R' x y) \/ (S' x y))) /\ (forall x : A, forall y : A, forall z : A, ~ ((P x y) /\ (P y z)))) -> @well_founded (prod A A) (@ε ((prod A A) -> (prod A A) -> Prop) (fun f : (prod A A) -> (prod A A) -> Prop => forall x1 : A, forall y1 : A, @eq ((prod A A) -> Prop) (f (@pair A A x1 y1)) (@ε ((prod A A) -> Prop) (fun f' : (prod A A) -> Prop => forall x2 : A, forall y2 : A, @eq Prop (f' (@pair A A x2 y2)) (((S' x1 x2) /\ (S' y1 y2)) \/ (((R' x1 x2) /\ (y1 = y2)) \/ ((P x2 y2) /\ ((x1 = y2) /\ (x2 = y1))))))))).
Axiom thm_MULTISET_FILTEREQ : forall {A : Type'} (a : A) (l : seq A), (@multiplicity A (@multiset A (fun x : A => @size A (@FILTER A (@eq A x) l))) a) = (@size A (@FILTER A (@eq A a) l)).
Axiom thm_WF_MULTIZIP : forall {A : Type'} (R' : A -> A -> Prop), (@well_founded A R') -> @well_founded (seq A) (fun l1 : seq A => fun l2 : seq A => exists h : A, exists t : seq A, exists l0 : seq A, (l2 = (@cons A h t)) /\ ((l1 = (@cat A l0 t)) /\ (forall k : A, (@MEM A k l0) -> R' k h))).
Axiom thm_WF_MEASURE_OR_NONINC : forall {A : Type'}, forall R' : A -> A -> Prop, forall m : A -> nat, ((@well_founded A R') /\ (forall x : A, forall y : A, (R' x y) -> leqn (m x) (m y))) -> @well_founded A (fun x : A => fun y : A => (@MEASURE A m x y) \/ (R' x y)).
Axiom thm_WF_PROJ_EQ : forall {A B : Type'} (P : A -> Prop) (R' : A -> B -> B -> Prop), (forall x : A, (P x) -> @well_founded B (R' x)) -> @well_founded (prod A B) (@ε ((prod A B) -> (prod A B) -> Prop) (fun f : (prod A B) -> (prod A B) -> Prop => forall x' : A, forall y' : B, @eq ((prod A B) -> Prop) (f (@pair A B x' y')) (@ε ((prod A B) -> Prop) (fun f' : (prod A B) -> Prop => forall x : A, forall y : B, @eq Prop (f' (@pair A B x y)) ((P x) /\ ((x' = x) /\ (R' x y' y))))))).
Axiom thm_OCC : forall x : nat, forall env : seq (prod nat term), forall y : nat, (OCC env x y) = (exists t : term, (@MEM (prod nat term) (@pair nat term x t) env) /\ (@IN nat y (free_variables_term t))).
Axiom thm_LOOPFREE : forall env : seq (prod nat term), (LOOPFREE env) = (forall z : nat, ~ (@Relation_Operators.clos_trans nat (OCC env) z z)).
Axiom thm_LOOP_BREAK : forall env : seq (prod nat term), forall x : nat, forall t : term, forall u : nat, forall v : nat, ((@Relation_Operators.clos_trans nat (OCC (@cons (prod nat term) (@pair nat term x t) env)) u v) /\ (~ (@Relation_Operators.clos_trans nat (OCC env) u v))) -> exists y : nat, (@RTC nat (OCC env) u x) /\ ((@IN nat y (free_variables_term t)) /\ (@RTC nat (OCC env) y v)).
Axiom thm_LOOPFREE_PRESERVE : forall (x : nat) (t : term) (env : seq (prod nat term)), ((LOOPFREE env) /\ (~ (exists y : nat, (@IN nat y (free_variables_term t)) /\ (@RTC nat (OCC env) y x)))) -> LOOPFREE (@cons (prod nat term) (@pair nat term x t) env).
Axiom thm_LOOPFREE_PRESERVE_EQ : forall (t : term) (env : seq (prod nat term)) (x : nat), (LOOPFREE env) -> (LOOPFREE (@cons (prod nat term) (@pair nat term x t) env)) = (~ (exists y : nat, (@IN nat y (free_variables_term t)) /\ (@RTC nat (OCC env) y x))).
Axiom thm_LOOPFREE_WF : forall env : seq (prod nat term), (LOOPFREE env) -> @well_founded nat (fun x : nat => fun y : nat => OCC env y x).
Axiom thm_LOOPFREE_WF_TERM : forall env : seq (prod nat term), (LOOPFREE env) -> @well_founded term (fun s : term => fun t : term => exists y : nat, (@IN nat y (free_variables_term t)) /\ (@MEM (prod nat term) (@pair nat term y s) env)).
Axiom thm_LOOPCHECK_EXISTS : forall env : seq (prod nat term), forall x : nat, (LOOPFREE env) -> exists loopcheck' : term -> Prop, forall t : term, (loopcheck' t) = (exists y : nat, (@IN nat y (free_variables_term t)) /\ ((y = x) \/ (exists s : term, (@MEM (prod nat term) (@pair nat term y s) env) /\ (loopcheck' s)))).
Axiom thm_loopcheck : forall env : seq (prod nat term), forall x : nat, (LOOPFREE env) -> (forall x' : nat, forall y : nat, (loopcheck env x' (V y)) = ((y = x') \/ (exists s : term, (@MEM (prod nat term) (@pair nat term y s) env) /\ (loopcheck env x' s)))) /\ (forall f : nat, forall args : seq term, (loopcheck env x (Fn f args)) = (@EX term (loopcheck env x) args)).
Axiom thm_LOOPCHECK : forall env : seq (prod nat term), forall x : nat, forall t : term, (LOOPFREE env) -> (loopcheck env x t) = (~ (LOOPFREE (@cons (prod nat term) (@pair nat term x t) env))).
Axiom thm_rightsubst : forall y : nat, forall x : nat, forall t : term, forall s : term, (rightsubst (@pair nat term x t) (@pair nat term y s)) = (@pair nat term y (termsubst (fun z : nat => @COND term (z = x) t (V z)) s)).
Axiom thm_SOLVE_EXISTS : exists SOLVE' : (prod (seq (prod nat term)) (seq (prod nat term))) -> seq (prod nat term), forall pr : prod (seq (prod nat term)) (seq (prod nat term)), (SOLVE' pr) = (@COND (seq (prod nat term)) ((@snd (seq (prod nat term)) (seq (prod nat term)) pr) = (@nil (prod nat term))) (@fst (seq (prod nat term)) (seq (prod nat term)) pr) (SOLVE' (@pair (seq (prod nat term)) (seq (prod nat term)) (@cons (prod nat term) (@HD (prod nat term) (@snd (seq (prod nat term)) (seq (prod nat term)) pr)) (@map (prod nat term) (prod nat term) (rightsubst (@HD (prod nat term) (@snd (seq (prod nat term)) (seq (prod nat term)) pr))) (@fst (seq (prod nat term)) (seq (prod nat term)) pr))) (@map (prod nat term) (prod nat term) (rightsubst (@HD (prod nat term) (@snd (seq (prod nat term)) (seq (prod nat term)) pr))) (@TL (prod nat term) (@snd (seq (prod nat term)) (seq (prod nat term)) pr)))))).
Axiom thm_SOLVE : (forall sol : seq (prod nat term), (SOLVE sol (@nil (prod nat term))) = sol) /\ (forall sol : seq (prod nat term), forall p : prod nat term, forall oth : seq (prod nat term), (SOLVE sol (@cons (prod nat term) p oth)) = (SOLVE (@cons (prod nat term) p (@map (prod nat term) (prod nat term) (rightsubst p) sol)) (@map (prod nat term) (prod nat term) (rightsubst p) oth))).
Axiom thm_CONFLICTFREE : forall l : seq (prod nat term), (CONFLICTFREE l) = (forall x : nat, leqn (@size (prod nat term) (@FILTER (prod nat term) (@ε ((prod nat term) -> Prop) (fun f : (prod nat term) -> Prop => forall y : nat, forall s : term, @eq Prop (f (@pair nat term y s)) (y = x))) l)) (NUMERAL (BIT1 O))).
Axiom thm_SOLVE_PRESERVES_LOOPFREE_LEMMA : forall p : prod nat term, forall oth : seq (prod nat term), forall x : nat, forall y : nat, (@Relation_Operators.clos_trans nat (OCC (@map (prod nat term) (prod nat term) (rightsubst p) oth)) x y) -> @Relation_Operators.clos_trans nat (OCC (@cons (prod nat term) p oth)) x y.
Axiom thm_SOLVE_PRESERVES_LOOPFREE : forall p : prod nat term, forall oth : seq (prod nat term), (LOOPFREE (@cons (prod nat term) p oth)) -> LOOPFREE (@map (prod nat term) (prod nat term) (rightsubst p) oth).
Axiom thm_SOLVE_PRESERVES_CONFLICTFREE_LEMMA : forall p : prod nat term, forall x : nat, (@o (prod nat term) (prod nat term) Prop (@ε ((prod nat term) -> Prop) (fun f : (prod nat term) -> Prop => forall y : nat, forall s : term, @eq Prop (f (@pair nat term y s)) (y = x))) (rightsubst p)) = (@ε ((prod nat term) -> Prop) (fun f : (prod nat term) -> Prop => forall y : nat, forall s : term, @eq Prop (f (@pair nat term y s)) (y = x))).
Axiom thm_SOLVE_PRESERVES_CONFLICTFREE : forall (sol : seq (prod nat term)) (p : prod nat term) (oth : seq (prod nat term)), (CONFLICTFREE (@cat (prod nat term) sol (@cons (prod nat term) p oth))) -> CONFLICTFREE (@cat (prod nat term) (@cons (prod nat term) p (@map (prod nat term) (prod nat term) (rightsubst p) sol)) (@map (prod nat term) (prod nat term) (rightsubst p) oth)).
Axiom thm_SOLVE_PRESERVES_DEFREE : forall (sol : seq (prod nat term)) (p : prod nat term) (oth : seq (prod nat term)), ((LOOPFREE (@cons (prod nat term) p oth)) /\ (forall x : nat, forall y : nat, forall s : term, forall t : term, ((@MEM (prod nat term) (@pair nat term x t) sol) /\ (@MEM (prod nat term) (@pair nat term y s) (@cat (prod nat term) sol (@cons (prod nat term) p oth)))) -> ~ (@IN nat x (free_variables_term s)))) -> forall x : nat, forall y : nat, forall s : term, forall t : term, ((@MEM (prod nat term) (@pair nat term x t) (@cons (prod nat term) p (@map (prod nat term) (prod nat term) (rightsubst p) sol))) /\ (@MEM (prod nat term) (@pair nat term y s) (@cat (prod nat term) (@cons (prod nat term) p (@map (prod nat term) (prod nat term) (rightsubst p) sol)) (@map (prod nat term) (prod nat term) (rightsubst p) oth)))) -> ~ (@IN nat x (free_variables_term s)).
Axiom thm_SOLVE_PRESERVES_UNIFIERS : forall (sol : seq (prod nat term)) (p : prod nat term) (oth : seq (prod nat term)) (i : nat -> term), (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) (@cat (prod nat term) sol (@cons (prod nat term) p oth))) -> (i x) = (termsubst i t)) = (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) (@cat (prod nat term) (@cons (prod nat term) p (@map (prod nat term) (prod nat term) (rightsubst p) sol)) (@map (prod nat term) (prod nat term) (rightsubst p) oth))) -> (i x) = (termsubst i t)).
Axiom thm_SOLVE_WORKS_GENERAL : forall n : nat, forall env : seq (prod nat term), forall sol : seq (prod nat term), (((@size (prod nat term) env) = n) /\ ((LOOPFREE env) /\ ((CONFLICTFREE (@cat (prod nat term) sol env)) /\ (forall x : nat, forall y : nat, forall s : term, forall t : term, ((@MEM (prod nat term) (@pair nat term x t) sol) /\ (@MEM (prod nat term) (@pair nat term y s) (@cat (prod nat term) sol env))) -> ~ (@IN nat x (free_variables_term s)))))) -> (CONFLICTFREE (SOLVE sol env)) /\ ((forall i : nat -> term, (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) (@cat (prod nat term) sol env)) -> (i x) = (termsubst i t)) = (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) (SOLVE sol env)) -> (i x) = (termsubst i t))) /\ (forall x : nat, forall y : nat, forall s : term, forall t : term, ((@MEM (prod nat term) (@pair nat term x t) (SOLVE sol env)) /\ (@MEM (prod nat term) (@pair nat term y s) (SOLVE sol env))) -> ~ (@IN nat x (free_variables_term s)))).
Axiom thm_SOLVE_WORKS : forall env : seq (prod nat term), ((LOOPFREE env) /\ (CONFLICTFREE env)) -> (CONFLICTFREE (SOLVE (@nil (prod nat term)) env)) /\ ((forall i : nat -> term, (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) env) -> (i x) = (termsubst i t)) = (forall x : nat, forall t : term, (@MEM (prod nat term) (@pair nat term x t) (SOLVE (@nil (prod nat term)) env)) -> (i x) = (termsubst i t))) /\ (forall x : nat, forall y : nat, forall s : term, forall t : term, ((@MEM (prod nat term) (@pair nat term x t) (SOLVE (@nil (prod nat term)) env)) /\ (@MEM (prod nat term) (@pair nat term y s) (SOLVE (@nil (prod nat term)) env))) -> ~ (@IN nat x (free_variables_term s)))).
Axiom thm_retval_INDUCT : forall P : retval -> Prop, ((P TT) /\ ((P FF) /\ (P Exception))) -> forall x : retval, P x.
Axiom thm_retval_RECURSION : forall {Z' : Type'}, forall f0 : Z', forall f1 : Z', forall f2 : Z', exists fn : retval -> Z', ((fn TT) = f0) /\ (((fn FF) = f1) /\ ((fn Exception) = f2)).
Axiom thm_retval_DISTINCT : (~ (TT = FF)) /\ ((~ (TT = Exception)) /\ (~ (FF = Exception))).
Axiom thm_ISTRIV_EXISTS : forall env : seq (prod nat term), forall x : nat, ((LOOPFREE env) /\ (CONFLICTFREE env)) -> exists istriv' : term -> retval, forall t : term, (istriv' t) = (@COND retval (t = (V x)) TT (@COND retval (exists y : nat, (t = (V y)) /\ (@MEM nat y (@map (prod nat term) nat (@fst nat term) env))) (istriv' (@ASSOC nat term (@ε nat (fun y : nat => (t = (V y)) /\ (@MEM nat y (@map (prod nat term) nat (@fst nat term) env)))) env)) (@COND retval (@IN nat x (free_variables_term t)) Exception (@COND retval (exists y : nat, exists s : term, (@IN nat y (free_variables_term t)) /\ ((@MEM (prod nat term) (@pair nat term y s) env) /\ (~ ((istriv' s) = FF)))) Exception FF)))).
Axiom thm_istriv : forall env : seq (prod nat term), forall x : nat, ((LOOPFREE env) /\ (CONFLICTFREE env)) -> (forall x' : nat, forall y : nat, (istriv env x' (V y)) = (@COND retval (y = x') TT (@COND retval (@MEM nat y (@map (prod nat term) nat (@fst nat term) env)) (istriv env x' (@ASSOC nat term y env)) FF))) /\ (forall f : nat, forall args : seq term, (istriv env x (Fn f args)) = (@COND retval (@EX term (fun a : term => ~ ((istriv env x a) = FF)) args) Exception FF)).
Axiom thm_EQV : forall {_208846 : Type'}, forall x : _208846, forall y : nat, forall env : seq (prod _208846 term), (@EQV _208846 env x y) = (@MEM (prod _208846 term) (@pair _208846 term x (V y)) env).
Axiom thm_EQV_IMP_OCC : forall env : seq (prod nat term), forall x : nat, forall y : nat, (@EQV nat env x y) -> OCC env x y.
Axiom thm_ISTRIV_WORKS : forall env : seq (prod nat term), forall x : nat, forall t : term, ((LOOPFREE env) /\ (CONFLICTFREE env)) -> (istriv env x t) = (@COND retval (exists y : nat, (t = (V y)) /\ (@RTC nat (@EQV nat env) y x)) TT (@COND retval (exists y : nat, (@IN nat y (free_variables_term t)) /\ (@RTC nat (OCC env) y x)) Exception FF)).
Axiom thm_SUB1 : forall t : term, forall s : term, (SUB1 s t) = (exists f : nat, exists args : seq term, (t = (Fn f args)) /\ (@MEM term s args)).
Axiom thm_WF_SUB1 : @well_founded term SUB1.
Axiom thm_RTC_SUB1 : forall x : nat, forall t : term, (@RTC term SUB1 (V x) t) = (@IN nat x (free_variables_term t)).
Axiom thm_WF_SUBCOMPONENT : forall (env : seq (prod nat term)), (LOOPFREE env) -> @well_founded term (fun s : term => fun t : term => exists x : nat, (@MEM (prod nat term) (@pair nat term x s) env) /\ (@RTC term SUB1 (V x) t)).
Axiom thm_WF_DESCENT : forall (env : seq (prod nat term)), (LOOPFREE env) -> @well_founded term (fun s : term => fun t : term => (exists x : nat, (t = (V x)) /\ (@MEM (prod nat term) (@pair nat term x s) env)) \/ (exists f : nat, exists args : seq term, (t = (Fn f args)) /\ (@MEM term s args))).
Axiom thm_termcases : forall {_209366 : Type'} (v : nat) (cv : nat -> _209366) (cf : nat -> (seq term) -> _209366) (f : nat) (args : seq term), ((@termcases _209366 cv cf (V v)) = (cv v)) /\ ((@termcases _209366 cv cf (Fn f args)) = (cf f args)).
Axiom thm_tpcases_def : forall {_209426 : Type'}, forall c2 : nat -> term -> _209426, forall c3 : nat -> (seq term) -> nat -> _209426, forall c1 : nat -> (seq term) -> nat -> (seq term) -> _209426, forall t2 : term, forall t1 : term, (@tpcases _209426 c1 c2 c3 (@pair term term t1 t2)) = (@termcases _209426 (fun v1 : nat => @termcases _209426 (fun v2 : nat => c2 v1 (V v2)) (fun f2 : nat => fun args2 : seq term => c2 v1 (Fn f2 args2)) t2) (fun f1 : nat => fun args1 : seq term => @termcases _209426 (fun v2 : nat => c3 f1 args1 v2) (fun f2 : nat => fun args2 : seq term => c1 f1 args1 f2 args2) t2) t1).
Axiom thm_tpcases : forall {_209437 : Type'} (f2 : nat) (args2 : seq term) (v1 : nat) (t2 : term) (c1 : nat -> (seq term) -> nat -> (seq term) -> _209437) (c2 : nat -> term -> _209437) (c3 : nat -> (seq term) -> nat -> _209437) (f1 : nat) (args1 : seq term) (v2 : nat), ((@tpcases _209437 c1 c2 c3 (@pair term term (Fn f1 args1) (Fn f2 args2))) = (c1 f1 args1 f2 args2)) /\ (((@tpcases _209437 c1 c2 c3 (@pair term term (V v1) t2)) = (c2 v1 t2)) /\ ((@tpcases _209437 c1 c2 c3 (@pair term term (Fn f1 args1) (V v2))) = (c3 f1 args1 v2))).
Axiom thm_MLEFT : forall eqs : seq (prod term term), forall env : seq (prod nat term), (MLEFT (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) = (subn (@CARD nat (@setU nat (free_variables_term (Fn (NUMERAL O) (@map (prod term term) term (@fst term term) eqs))) (@setU nat (free_variables_term (Fn (NUMERAL O) (@map (prod term term) term (@snd term term) eqs))) (@setU nat (free_variables_term (Fn (NUMERAL O) (@map (prod nat term) term (@snd nat term) env))) (free_variables_term (Fn (NUMERAL O) (@map (prod nat term) term (@o (prod nat term) nat term V (@fst nat term)) env))))))) (@CARD nat (free_variables_term (Fn (NUMERAL O) (@map (prod nat term) term (@o (prod nat term) nat term V (@fst nat term)) env))))).
Axiom thm_CRIGHT : forall env' : seq (prod nat term), forall env : seq (prod nat term), forall eqs : seq (prod term term), forall eqs' : seq (prod term term), (CRIGHT (@pair (seq (prod nat term)) (seq (prod term term)) env' eqs') (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) = ((LOOPFREE env) /\ ((env' = env) /\ ((exists f : nat, exists args1 : seq term, exists args2 : seq term, exists oth : seq (prod term term), ((@size term args1) = (@size term args2)) /\ ((eqs = (@cons (prod term term) (@pair term term (Fn f args1) (Fn f args2)) oth)) /\ (eqs' = (@cat (prod term term) (@ZIP term term args1 args2) oth)))) \/ ((exists x : nat, exists t : term, exists oth : seq (prod term term), (eqs = (@cons (prod term term) (@pair term term (V x) t) oth)) /\ (((@MEM nat x (@map (prod nat term) nat (@fst nat term) env)) /\ (eqs' = (@cons (prod term term) (@pair term term (@ASSOC nat term x env) t) oth))) \/ ((~ (@MEM nat x (@map (prod nat term) nat (@fst nat term) env))) /\ (((istriv env x t) = TT) /\ (eqs' = oth))))) \/ (exists x : nat, exists f : nat, exists args : seq term, exists oth : seq (prod term term), (eqs = (@cons (prod term term) (@pair term term (Fn f args) (V x)) oth)) /\ (eqs' = (@cons (prod term term) (@pair term term (V x) (Fn f args)) oth))))))).
Axiom thm_CALLORDER : forall env' : seq (prod nat term), forall eqs' : seq (prod term term), forall env : seq (prod nat term), forall eqs : seq (prod term term), (CALLORDER (@pair (seq (prod nat term)) (seq (prod term term)) env' eqs') (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) = ((@MEASURE (prod (seq (prod nat term)) (seq (prod term term))) MLEFT (@pair (seq (prod nat term)) (seq (prod term term)) env' eqs') (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) \/ (CRIGHT (@pair (seq (prod nat term)) (seq (prod term term)) env' eqs') (@pair (seq (prod nat term)) (seq (prod term term)) env eqs))).
Axiom thm_PAIRED_ETA_THM : forall {A B C : Type'}, forall g : (prod A B) -> C, (@ε ((prod A B) -> C) (fun f : (prod A B) -> C => forall p1 : A, forall p2 : B, @eq C (f (@pair A B p1 p2)) (g (@pair A B p1 p2)))) = g.
Axiom thm_WF_CRIGHT : @well_founded (prod (seq (prod nat term)) (seq (prod term term))) CRIGHT.
Axiom thm_WF_CALLORDER : @well_founded (prod (seq (prod nat term)) (seq (prod term term))) CALLORDER.
Axiom thm_UNIFY_EXISTS_RAW : exists unify' : (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term)), forall pr : prod (seq (prod nat term)) (seq (prod term term)), (unify' pr) = (@COND (option (seq (prod nat term))) (~ (LOOPFREE (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((@snd (seq (prod nat term)) (seq (prod term term)) pr) = (@nil (prod term term))) (@Some (seq (prod nat term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@tpcases (option (seq (prod nat term))) (fun f : nat => fun fargs : seq term => fun g : nat => fun gargs : seq term => @COND (option (seq (prod nat term))) ((f = g) /\ ((@size term fargs) = (@size term gargs))) (unify' (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cat (prod term term) (@ZIP term term fargs gargs) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@None (seq (prod nat term)))) (fun x : nat => fun t : term => @COND (option (seq (prod nat term))) (@MEM nat x (@map (prod nat term) nat (@fst nat term) (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (unify' (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (@ASSOC nat term x (@fst (seq (prod nat term)) (seq (prod term term)) pr)) t) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@COND (option (seq (prod nat term))) ((istriv (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = Exception) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((istriv (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = TT) (unify' (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))) (unify' (@pair (seq (prod nat term)) (seq (prod term term)) (@cons (prod nat term) (@pair nat term x t) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))))) (fun f : nat => fun args : seq term => fun x : nat => unify' (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (V x) (Fn f args)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@HD (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))).
Axiom thm_unify : forall (g : nat) (gargs : seq term) (t : term) (env : seq (prod nat term)) (x : nat) (f : nat) (fargs : seq term) (oth : seq (prod term term)), (LOOPFREE env) -> ((unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cons (prod term term) (@pair term term (Fn f fargs) (Fn g gargs)) oth))) = (@COND (option (seq (prod nat term))) ((f = g) /\ ((@size term fargs) = (@size term gargs))) (unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cat (prod term term) (@ZIP term term fargs gargs) oth))) (@None (seq (prod nat term))))) /\ (((unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cons (prod term term) (@pair term term (V x) t) oth))) = (@COND (option (seq (prod nat term))) (@MEM nat x (@map (prod nat term) nat (@fst nat term) env)) (unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cons (prod term term) (@pair term term (@ASSOC nat term x env) t) oth))) (@COND (option (seq (prod nat term))) ((istriv env x t) = Exception) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((istriv env x t) = TT) (unify (@pair (seq (prod nat term)) (seq (prod term term)) env oth)) (unify (@pair (seq (prod nat term)) (seq (prod term term)) (@cons (prod nat term) (@pair nat term x t) env) oth)))))) /\ ((unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cons (prod term term) (@pair term term (Fn f fargs) (V x)) oth))) = (unify (@pair (seq (prod nat term)) (seq (prod term term)) env (@cons (prod term term) (@pair term term (V x) (Fn f fargs)) oth))))).
Axiom thm_unifies : forall i : nat -> term, forall l : seq (prod term term), (unifies i l) = (@ALL (prod term term) (@ε ((prod term term) -> Prop) (fun f : (prod term term) -> Prop => forall s : term, forall t : term, @eq Prop (f (@pair term term s t)) ((termsubst i s) = (termsubst i t)))) l).
Axiom thm_OPTION_DISTINCT : forall {A : Type'}, forall a' : A, ~ ((@None A) = (@Some A a')).
Axiom thm_OPTION_INJ : forall {A : Type'}, forall a : A, forall a' : A, ((@Some A a) = (@Some A a')) = (a = a').
Axiom thm_TC_SUB1_IRREFL : forall s : term, forall t : term, (@Relation_Operators.clos_trans term SUB1 s t) -> ~ (s = t).
Axiom thm_UNIFY_OCCURS : forall env : seq (prod nat term), forall i : nat -> term, (@ALL (prod nat term) (@ε ((prod nat term) -> Prop) (fun f : (prod nat term) -> Prop => forall x : nat, forall t : term, @eq Prop (f (@pair nat term x t)) ((i x) = (termsubst i t)))) env) -> forall x : nat, forall y : nat, (@RTC nat (OCC env) x y) -> @RTC term SUB1 (i y) (i x).
Axiom thm_UNIFY_OCCURS_PROPER : forall env : seq (prod nat term), forall i : nat -> term, (@ALL (prod nat term) (@ε ((prod nat term) -> Prop) (fun f : (prod nat term) -> Prop => forall x : nat, forall t : term, @eq Prop (f (@pair nat term x t)) ((i x) = (termsubst i t)))) env) -> forall x : nat, forall y : nat, (@RTC nat (OCC env) x y) -> (@RTC nat (@EQV nat env) x y) \/ (@Relation_Operators.clos_trans term SUB1 (i y) (i x)).
Axiom thm_GOODLOOP_UNIFIABLE : forall env : seq (prod nat term), forall x : nat, forall t : term, ((LOOPFREE env) /\ ((CONFLICTFREE env) /\ ((istriv env x t) = TT))) -> forall i : nat -> term, (unifies i (@cons (prod term term) (@pair term term (V x) t) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x' : nat, forall t' : term, @eq (prod term term) (f (@pair nat term x' t')) (@pair term term (V x') t'))) env))) = (unifies i (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x' : nat, forall t' : term, @eq (prod term term) (f (@pair nat term x' t')) (@pair term term (V x') t'))) env)).
Axiom thm_BADLOOP_UNUNIFIABLE : forall env : seq (prod nat term), forall x : nat, forall t : term, ((LOOPFREE env) /\ ((CONFLICTFREE env) /\ ((istriv env x t) = Exception))) -> forall i : nat -> term, ~ (unifies i (@cons (prod term term) (@pair term term (V x) t) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x' : nat, forall t' : term, @eq (prod term term) (f (@pair nat term x' t')) (@pair term term (V x') t'))) env))).
Axiom thm_UNIFY_WORKS_RAW : forall pr : prod (seq (prod nat term)) (seq (prod term term)), ((LOOPFREE (@fst (seq (prod nat term)) (seq (prod term term)) pr)) /\ (CONFLICTFREE (@fst (seq (prod nat term)) (seq (prod term term)) pr))) -> (((unify pr) = (@None (seq (prod nat term)))) -> forall i : nat -> term, ~ (unifies i (@cat (prod term term) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))) /\ (forall ans : seq (prod nat term), ((unify pr) = (@Some (seq (prod nat term)) ans)) -> (LOOPFREE ans) /\ ((CONFLICTFREE ans) /\ (forall i : nat -> term, (unifies i (@cat (prod term term) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@snd (seq (prod nat term)) (seq (prod term term)) pr))) = (unifies i (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) ans))))).
Axiom thm_THE : forall {_212257 : Type'} (x : _212257), (@the _212257 (@Some _212257 x)) = x.
Axiom thm_unifier : forall env : seq (prod nat term), (unifier env) = (@LET (seq (prod nat term)) (nat -> term) (fun sol : seq (prod nat term) => @LET_END (nat -> term) (@ITLIST (prod nat term) (nat -> term) (@valmod term nat) sol V)) (SOLVE (@nil (prod nat term)) env)).
Axiom thm_ITLIST_VALMOD_LEMMA : forall env : seq (prod nat term), forall x : nat, (CONFLICTFREE env) -> forall t : term, ((@ITLIST (prod nat term) (nat -> term) (@valmod term nat) env V x) = t) = ((@MEM (prod nat term) (@pair nat term x t) env) \/ ((t = (V x)) /\ (~ (@MEM nat x (@map (prod nat term) nat (@fst nat term) env))))).
Axiom thm_UNIFIER_WORKS : forall env : seq (prod nat term), ((LOOPFREE env) /\ (CONFLICTFREE env)) -> unifies (unifier env) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) env).
Axiom thm_UNIFIER_MGU : forall env : seq (prod nat term), ((LOOPFREE env) /\ (CONFLICTFREE env)) -> forall i : nat -> term, (unifies i (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) env)) -> (termsubst i) = (@o term term term (termsubst i) (termsubst (@ITLIST (prod nat term) (nat -> term) (@valmod term nat) env V))).
Axiom thm_UNIFY_WORKS : forall (ans : seq (prod nat term)), forall env : seq (prod nat term), forall eqs : seq (prod term term), ((LOOPFREE env) /\ (CONFLICTFREE env)) -> (((unify (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) = (@None (seq (prod nat term)))) -> forall i : nat -> term, ~ (unifies i (@cat (prod term term) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) env) eqs))) /\ (((unify (@pair (seq (prod nat term)) (seq (prod term term)) env eqs)) = (@Some (seq (prod nat term)) ans)) -> (LOOPFREE ans) /\ ((CONFLICTFREE ans) /\ ((unifies (unifier ans) (@cat (prod term term) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) env) eqs)) /\ (forall i : nat -> term, (unifies i (@cat (prod term term) (@map (prod nat term) (prod term term) (@ε ((prod nat term) -> prod term term) (fun f : (prod nat term) -> prod term term => forall x : nat, forall t : term, @eq (prod term term) (f (@pair nat term x t)) (@pair term term (V x) t))) env) eqs)) -> (termsubst i) = (@o term term term (termsubst i) (termsubst (unifier ans))))))).
Axiom thm_UNIFY_WORKS_SIMPLE : forall (ans : seq (prod nat term)), forall eqs : seq (prod term term), (((unify (@pair (seq (prod nat term)) (seq (prod term term)) (@nil (prod nat term)) eqs)) = (@None (seq (prod nat term)))) -> forall i : nat -> term, ~ (unifies i eqs)) /\ (((unify (@pair (seq (prod nat term)) (seq (prod term term)) (@nil (prod nat term)) eqs)) = (@Some (seq (prod nat term)) ans)) -> (LOOPFREE ans) /\ ((CONFLICTFREE ans) /\ ((unifies (unifier ans) eqs) /\ (forall i : nat -> term, (unifies i eqs) -> (termsubst i) = (@o term term term (termsubst i) (termsubst (unifier ans))))))).
Axiom thm_Unifies_DEF : forall s : form -> Prop, forall i : nat -> term, (Unifies i s) = (forall p : form, forall q : form, ((@IN form p s) /\ (@IN form q s)) -> (formsubst i p) = (formsubst i q)).
Axiom thm_UNIFIES : forall (s : form -> Prop) (i : nat -> term), (Unifies i s) = (exists q : form, forall p : form, (@IN form p s) -> (formsubst i p) = q).
Axiom thm_UNIFIER_FORMPAIR_TERMLIST : forall p : form, forall q : form, ((qfree p) /\ (qfree q)) -> exists l : seq (prod term term), forall i : nat -> term, ((formsubst i p) = (formsubst i q)) = (unifies i l).
Axiom thm_UNIFIER_SUBTERMS : forall A : form -> Prop, ((@finite_set form A) /\ (forall p : form, (@IN form p A) -> qfree p)) -> exists l : seq (prod term term), forall i : nat -> term, (Unifies i A) = (unifies i l).
Axiom thm_MGU_EXISTS : forall (s : form -> Prop), ((@finite_set form s) /\ (forall p : form, (@IN form p s) -> qfree p)) -> (exists i : nat -> term, Unifies i s) = (exists i : nat -> term, (Unifies i s) /\ (forall j : nat -> term, (Unifies j s) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p)))).
Axiom thm_mgu : forall s : form -> Prop, (mgu s) = (@ε (nat -> term) (fun i : nat -> term => (Unifies i s) /\ (forall j : nat -> term, (Unifies j s) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p))))).
Axiom thm_MGU : forall s : form -> Prop, ((@finite_set form s) /\ ((forall p : form, (@IN form p s) -> qfree p) /\ (exists i : nat -> term, Unifies i s))) -> (Unifies (mgu s) s) /\ (forall i : nat -> term, (Unifies i s) -> forall p : form, (qfree p) -> (formsubst i p) = (formsubst i (formsubst (mgu s) p))).
Axiom thm_FORMSUBST_TERMSUBST_LEMMA : forall (i : nat -> term) (j : nat -> term) (k : nat -> term), (forall p : form, (qfree p) -> (formsubst i p) = (formsubst j (formsubst k p))) = ((termsubst i) = (@o term term term (termsubst j) (termsubst k))).
Axiom thm_ismgu : forall s : form -> Prop, forall i : nat -> term, (ismgu s i) = ((Unifies i s) /\ (forall j : nat -> term, (Unifies j s) -> exists k : nat -> term, (termsubst j) = (@o term term term (termsubst k) (termsubst i)))).
Axiom thm_ISMGU : forall (s : form -> Prop) (i : nat -> term), (ismgu s i) = ((Unifies i s) /\ (forall j : nat -> term, (Unifies j s) -> exists k : nat -> term, forall p : form, (qfree p) -> (formsubst j p) = (formsubst k (formsubst i p)))).
Axiom thm_ISMGU_MGU : forall s : form -> Prop, ((@finite_set form s) /\ ((forall p : form, (@IN form p s) -> qfree p) /\ (exists i : nat -> term, Unifies i s))) -> ismgu s (mgu s).
Axiom thm_renaming : forall i : nat -> term, (renaming i) = (exists j : nat -> term, ((@o term term term (termsubst j) (termsubst i)) = (@I term)) /\ ((@o term term term (termsubst i) (termsubst j)) = (@I term))).
Axiom thm_RENAMING : forall (i : nat -> term), (renaming i) -> (forall x : nat, exists y : nat, (i x) = (V y)) /\ (forall x : nat, forall x' : nat, ((i x') = (i x)) -> x' = x).
Axiom thm_atom : forall (p : nat) (l : seq term) (r : form) (x : nat) (q : form), ((atom FFalse) = False) /\ (((atom (Atom p l)) = True) /\ (((atom (FImp q r)) = False) /\ ((atom (FAll x q)) = False))).
Axiom thm_literal : forall p : form, (literal p) = ((atom p) \/ (exists q : form, (atom q) /\ (p = (Not q)))).
Axiom thm_clause : forall cl : form -> Prop, (clause cl) = ((@finite_set form cl) /\ (forall p : form, (@IN form p cl) -> literal p)).
Axiom thm_LITERAL : forall (r : nat) (args : seq term), (literal (Atom r args)) /\ (literal (Not (Atom r args))).
Axiom thm_ATOM : forall (p : form), (atom p) = (exists q : nat, exists l : seq term, p = (Atom q l)).
Axiom thm_negative : forall p : form, (negative p) = (exists q : form, p = (Not q)).
Axiom thm_positive : forall p : form, (positive p) = (~ (negative p)).
Axiom thm_negate : forall p : form, (FNot p) = (@COND form (negative p) (@ε form (fun q : form => (Not q) = p)) (Not p)).
Axiom thm_PHOLDS_NEGATE : forall (d : form -> Prop) (p : form), (pholds d (FNot p)) = (~ (pholds d p)).
Axiom thm_HOLDS_NEGATE : forall {_213655 : Type'} (M : prod (_213655 -> Prop) (prod (nat -> (seq _213655) -> _213655) (nat -> (seq _213655) -> Prop))) (v : nat -> _213655) (p : form), (@holds _213655 M v (FNot p)) = (~ (@holds _213655 M v p)).
Axiom thm_NEGATE_NEG : forall (p : form), (FNot (Not p)) = p.
Axiom thm_NEGATE_ATOM : forall p : form, (atom p) -> (FNot p) = (Not p).
Axiom thm_NEGATE_REFL : forall p : form, ~ ((FNot p) = p).
Axiom thm_NEGATE_NEGATE : forall p : form, (literal p) -> (FNot (FNot p)) = p.
Axiom thm_resolve : forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall p : form, (resolve p cl1 cl2) = (@setU form (@DELETE form cl1 p) (@DELETE form cl2 (FNot p))).
Axiom thm_presproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (presproof hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a = (resolve p cl1 cl2)) /\ ((presproof hyps' cl1) /\ ((presproof hyps' cl2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))))).
Axiom thm_presproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall presproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> presproof' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((presproof' cl1) /\ ((presproof' cl2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))) -> presproof' (resolve p cl1 cl2))) -> forall a : form -> Prop, (presproof hyps' a) -> presproof' a.
Axiom thm_presproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> presproof hyps' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((presproof hyps' cl1) /\ ((presproof hyps' cl2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))) -> presproof hyps' (resolve p cl1 cl2)).
Axiom thm_interp : forall cl : form -> Prop, (interp cl) = (@ITLIST form form FOr (@list_of_set form cl) FFalse).
Axiom thm_UNPSATISFIABLE_FINITE_SUBSET : forall s : form -> Prop, (~ (psatisfiable s)) -> exists t : form -> Prop, (@finite_set form t) /\ ((@subset form t s) /\ (~ (psatisfiable t))).
Axiom thm_PRESPROOF_MONO : forall hyps1' : (form -> Prop) -> Prop, forall hyps2' : (form -> Prop) -> Prop, forall c : form -> Prop, ((presproof hyps1' c) /\ (@subset (form -> Prop) hyps1' hyps2')) -> presproof hyps2' c.
Axiom thm_PRESPROOF_TRANS : forall hyps' : (form -> Prop) -> Prop, forall hyps'' : (form -> Prop) -> Prop, forall c : form -> Prop, ((forall c' : form -> Prop, (@IN (form -> Prop) c' hyps'') -> presproof hyps' c') /\ (presproof hyps'' c)) -> presproof hyps' c.
Axiom thm_IMAGE_CLAUSE : forall (hyps' : (form -> Prop) -> Prop), (@GSPEC form (fun GEN_PVAR_519 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_519 (@IN (form -> Prop) cl hyps') (interp cl))) = (@IMAGE (form -> Prop) form interp hyps').
Axiom thm_PHOLDS_INTERP : forall cl : form -> Prop, forall d : form -> Prop, (@finite_set form cl) -> (pholds d (interp cl)) = (exists p : form, (@IN form p cl) /\ (pholds d p)).
Axiom thm_HOLDS_INTERP : forall {_213964 : Type'}, forall cl : form -> Prop, forall M : prod (_213964 -> Prop) (prod (nat -> (seq _213964) -> _213964) (nat -> (seq _213964) -> Prop)), forall v : nat -> _213964, (@finite_set form cl) -> (@holds _213964 M v (interp cl)) = (exists p : form, (@IN form p cl) /\ (@holds _213964 M v p)).
Axiom thm_PRESPROOF_REFUTATION_COMPLETE_FINITE : forall (hyps' : (form -> Prop) -> Prop), ((@finite_set (form -> Prop) hyps') /\ ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (psatisfiable (@GSPEC form (fun GEN_PVAR_523 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_523 (@IN (form -> Prop) cl hyps') (interp cl))))))) -> presproof hyps' (@set0 form).
Axiom thm_PRESPROOF_REFUTATION_COMPLETE : forall (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (psatisfiable (@GSPEC form (fun GEN_PVAR_526 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_526 (@IN (form -> Prop) cl hyps') (interp cl)))))) -> presproof hyps' (@set0 form).
Axiom thm_instance_of : forall cl1 : form -> Prop, forall cl2 : form -> Prop, (instance_of cl1 cl2) = (exists i : nat -> term, cl1 = (@IMAGE form form (formsubst i) cl2)).
Axiom thm_FVS : forall cl : form -> Prop, (FVS cl) = (@UNIONS nat (@GSPEC (nat -> Prop) (fun GEN_PVAR_527 : nat -> Prop => exists p : form, @SETSPEC (nat -> Prop) GEN_PVAR_527 (@IN form p cl) (free_variables p)))).
Axiom thm_NEGATIVE_FORMSUBST : forall (i : nat -> term), forall p : form, (negative (formsubst i p)) = (negative p).
Axiom thm_FORMSUBST_NEGATE : forall p : form, forall i : nat -> term, (formsubst i (FNot p)) = (FNot (formsubst i p)).
Axiom thm_FORMSUBST_ATOM : forall p : form, forall i : nat -> term, (atom (formsubst i p)) = (atom p).
Axiom thm_FORMSUBST_NOT : forall i : nat -> term, forall p : form, (formsubst i (Not p)) = (Not (formsubst i p)).
Axiom thm_NOT_NOT_ATOM : forall p : form, ~ (atom (Not p)).
Axiom thm_FORMSUBST_LITERAL : forall p : form, forall i : nat -> term, (literal (formsubst i p)) = (literal p).
Axiom thm_QFREE_NOT : forall p : form, (qfree (Not p)) = (qfree p).
Axiom thm_QFREE_ATOM : forall p : form, (atom p) -> qfree p.
Axiom thm_QFREE_LITERAL : forall p : form, (literal p) -> qfree p.
Axiom thm_QFREE_NEGATE : forall p : form, (qfree (FNot p)) = (qfree p).
Axiom thm_LIFTING_LEMMA : forall A : form -> Prop, forall B : form -> Prop, forall A' : form -> Prop, forall B' : form -> Prop, forall C' : form -> Prop, forall p : form, ((clause A) /\ ((clause B) /\ (((@setI nat (FVS A) (FVS B)) = (@set0 nat)) /\ ((instance_of A' A) /\ ((instance_of B' B) /\ ((@IN form p A') /\ ((@IN form (FNot p) B') /\ (C' = (resolve p A' B'))))))))) -> exists A1 : form -> Prop, exists B1 : form -> Prop, (@subset form A1 A) /\ ((@subset form B1 B) /\ ((~ (A1 = (@set0 form))) /\ ((~ (B1 = (@set0 form))) /\ ((exists i : nat -> term, Unifies i (@setU form A1 (@GSPEC form (fun GEN_PVAR_531 : form => exists l : form, @SETSPEC form GEN_PVAR_531 (@IN form l B1) (FNot l))))) /\ (forall j : nat -> term, (ismgu (@setU form A1 (@GSPEC form (fun GEN_PVAR_532 : form => exists l : form, @SETSPEC form GEN_PVAR_532 (@IN form l B1) (FNot l)))) j) -> instance_of C' (@IMAGE form form (formsubst j) (@setU form (@setD form A A1) (@setD form B B1)))))))).
Axiom thm_FVS_CLAUSE_FINITE : forall cl : form -> Prop, (clause cl) -> @finite_set nat (FVS cl).
Axiom thm_RENAME_AWAY : forall cl : form -> Prop, forall s : nat -> Prop, ((@finite_set nat s) /\ (clause cl)) -> exists i : nat -> term, (renaming i) /\ ((@setI nat (FVS (@IMAGE form form (formsubst i) cl)) s) = (@set0 nat)).
Axiom thm_resproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (resproof hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : nat -> term, (a = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))) /\ ((resproof hyps' cl1) /\ ((resproof hyps' cl2) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_533 : form => exists p : form, @SETSPEC form GEN_PVAR_533 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_534 : form => exists p : form, @SETSPEC form GEN_PVAR_534 (@IN form p ps2) (FNot p))))) = i))))))))))).
Axiom thm_resproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall resproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> resproof' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((resproof' cl1) /\ ((resproof' cl2) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_533 : form => exists p : form, @SETSPEC form GEN_PVAR_533 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_534 : form => exists p : form, @SETSPEC form GEN_PVAR_534 (@IN form p ps2) (FNot p))))) = i))))))))) -> resproof' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) -> forall a : form -> Prop, (resproof hyps' a) -> resproof' a.
Axiom thm_resproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> resproof hyps' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((resproof hyps' cl1) /\ ((resproof hyps' cl2) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_533 : form => exists p : form, @SETSPEC form GEN_PVAR_533 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_534 : form => exists p : form, @SETSPEC form GEN_PVAR_534 (@IN form p ps2) (FNot p))))) = i))))))))) -> resproof hyps' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))).
Axiom thm_PHOLDS_FORMSUBST : forall p : form, forall i : nat -> term, forall d : form -> Prop, (qfree p) -> (pholds d (formsubst i p)) = (pholds (@o form form Prop d (formsubst i)) p).
Axiom thm_QFREE_INTERP : forall cl : form -> Prop, (clause cl) -> qfree (interp cl).
Axiom thm_PHOLDS_INTERP_IMAGE : forall cl : form -> Prop, forall v : nat -> term, forall d : form -> Prop, (clause cl) -> (pholds d (interp (@IMAGE form form (formsubst v) cl))) = (pholds d (formsubst v (interp cl))).
Axiom thm_IMAGE_FORMSUBST_CLAUSE : forall v : nat -> term, forall cl : form -> Prop, (clause cl) -> clause (@IMAGE form form (formsubst v) cl).
Axiom thm_INSTANCE_OF_EMPTY : forall cl : form -> Prop, (instance_of (@set0 form) cl) -> cl = (@set0 form).
Axiom thm_RESPROOF_CLAUSE : forall (hyps' : (form -> Prop) -> Prop), (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) -> forall cl : form -> Prop, (resproof hyps' cl) -> clause cl.
Axiom thm_RESOLUTION_COMPLETE : forall (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M (@IMAGE (form -> Prop) form interp hyps')))))) -> resproof hyps' (@set0 form).
Axiom thm_isaresolvent : forall cl : form -> Prop, forall cl1 : form -> Prop, forall cl2 : form -> Prop, (isaresolvent cl (@pair (form -> Prop) (form -> Prop) cl1 cl2)) = (@LET (form -> Prop) Prop (fun cl2' : form -> Prop => @LET_END Prop (exists ps1 : form -> Prop, exists ps2 : form -> Prop, (@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i : nat -> term, Unifies i (@setU form ps1 (@GSPEC form (fun GEN_PVAR_540 : form => exists p : form, @SETSPEC form GEN_PVAR_540 (@IN form p ps2) (FNot p))))) /\ (@LET (nat -> term) Prop (fun i : nat -> term => @LET_END Prop (cl = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) (mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_541 : form => exists p : form, @SETSPEC form GEN_PVAR_541 (@IN form p ps2) (FNot p)))))))))))) (@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2)).
Axiom thm_RESPROOF_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> resproof hyps' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl : form -> Prop, ((resproof hyps' cl1) /\ ((resproof hyps' cl2) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) cl1 cl2)))) -> resproof hyps' cl).
Axiom thm_FIRSTN : forall {_216522 : Type'} (n : nat) (l : seq _216522), ((@take _216522 (NUMERAL O) l) = (@nil _216522)) /\ ((@take _216522 (S n) l) = (@COND (seq _216522) (l = (@nil _216522)) (@nil _216522) (@cons _216522 (@HD _216522 l) (@take _216522 n (@TL _216522 l))))).
Axiom thm_FIRSTN_TRIVIAL : forall {_216548 : Type'}, forall n : nat, forall l : seq _216548, (leqn (@size _216548 l) n) -> (@take _216548 n l) = l.
Axiom thm_FIRSTN_EMPTY : forall {_216567 : Type'}, forall n : nat, (@take _216567 n (@nil _216567)) = (@nil _216567).
Axiom thm_FIRSTN_SUBLIST : forall {_216590 : Type'}, forall x : _216590, forall n : nat, forall l : seq _216590, (@MEM _216590 x (@take _216590 n l)) -> @MEM _216590 x l.
Axiom thm_FIRSTN_SUC : forall {_216629 : Type'}, forall x : _216629, forall n : nat, forall l : seq _216629, (@MEM _216629 x (@take _216629 (S n) l)) -> @MEM _216629 x (@cat _216629 (@take _216629 n l) (@cons _216629 (@EL _216629 n l) (@nil _216629))).
Axiom thm_FIRSTN_SHORT : forall {_216665 : Type'}, forall n : nat, forall l : seq _216665, (leqn (@size _216665 l) n) -> (@take _216665 (S n) l) = (@take _216665 n l).
Axiom thm_tautologous : forall cl : form -> Prop, (tautologous cl) = (exists p : form, (@IN form p cl) /\ (@IN form (FNot p) cl)).
Axiom thm_subsumes : forall cl : form -> Prop, forall cl' : form -> Prop, (subsumes cl cl') = (exists i : nat -> term, @subset form (@IMAGE form form (formsubst i) cl) cl').
Axiom thm_subsumes_REFL : forall cl : form -> Prop, subsumes cl cl.
Axiom thm_subsumes_TRANS : forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl3 : form -> Prop, ((clause cl1) /\ ((subsumes cl1 cl2) /\ (subsumes cl2 cl3))) -> subsumes cl1 cl3.
Axiom thm_SUBSUMES : forall s' : (form -> Prop) -> Prop, forall s : (form -> Prop) -> Prop, (SUBSUMES s s') = (forall cl' : form -> Prop, (@IN (form -> Prop) cl' s') -> exists cl : form -> Prop, (@IN (form -> Prop) cl s) /\ (subsumes cl cl')).
Axiom thm_SUBSUMES_REFL : forall s : (form -> Prop) -> Prop, SUBSUMES s s.
Axiom thm_SUBSUMES_UNION : forall (s : (form -> Prop) -> Prop) (t : (form -> Prop) -> Prop) (s' : (form -> Prop) -> Prop) (t' : (form -> Prop) -> Prop), ((SUBSUMES s s') /\ (SUBSUMES t t')) -> SUBSUMES (@setU (form -> Prop) s t) (@setU (form -> Prop) s' t').
Axiom thm_SUBSUMES_TRANS : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((SUBSUMES s t) /\ (SUBSUMES t u))) -> SUBSUMES s u.
Axiom thm_SUBSUMES_SUBSET : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((SUBSUMES s t) /\ (@subset (form -> Prop) s u)) -> SUBSUMES u t.
Axiom thm_SUBSUMES_CLAUSES : forall (x : form -> Prop) (t : (form -> Prop) -> Prop), (forall s : (form -> Prop) -> Prop, SUBSUMES s (@set0 (form -> Prop))) /\ (forall s : (form -> Prop) -> Prop, (SUBSUMES s (@INSERT (form -> Prop) x t)) = ((SUBSUMES s (@INSERT (form -> Prop) x (@set0 (form -> Prop)))) /\ (SUBSUMES s t))).
Axiom thm_SUBSUMES_SUBSET_REFL : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, (@subset (form -> Prop) s t) -> SUBSUMES t s.
Axiom thm_allresolvents : forall s1 : (form -> Prop) -> Prop, forall s2 : (form -> Prop) -> Prop, (allresolvents s1 s2) = (@GSPEC (form -> Prop) (fun GEN_PVAR_542 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_542 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 s1) /\ ((@IN (form -> Prop) c2 s2) /\ (isaresolvent c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c)).
Axiom thm_allntresolvents : forall s1 : (form -> Prop) -> Prop, forall s2 : (form -> Prop) -> Prop, (allntresolvents s1 s2) = (@GSPEC (form -> Prop) (fun GEN_PVAR_543 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_543 ((@IN (form -> Prop) r (allresolvents s1 s2)) /\ (~ (tautologous r))) r)).
Axiom thm_TERMSUBST_TERMSUBST_o : forall (j : nat -> term) (i : nat -> term), (termsubst (@o nat term term (termsubst j) i)) = (@o term term term (termsubst j) (termsubst i)).
Axiom thm_FORMSUBST_FORMSUBST : forall p : form, forall i : nat -> term, forall j : nat -> term, (qfree p) -> (formsubst j (formsubst i p)) = (formsubst (@o nat term term (termsubst j) i) p).
Axiom thm_ISARESOLVENT_SYM : forall c1 : form -> Prop, forall c2 : form -> Prop, forall cl : form -> Prop, ((clause c1) /\ ((clause c2) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c2 c1)))) -> exists cl' : form -> Prop, (isaresolvent cl' (@pair (form -> Prop) (form -> Prop) c1 c2)) /\ (subsumes cl' cl).
Axiom thm_ALLRESOLVENTS_SYM : forall (B : (form -> Prop) -> Prop) (A : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c A) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c)) -> SUBSUMES (allresolvents A B) (allresolvents B A).
Axiom thm_ALLRESOLVENTS_UNION : forall (B : (form -> Prop) -> Prop) (A : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((allresolvents (@setU (form -> Prop) A B) C) = (@setU (form -> Prop) (allresolvents A C) (allresolvents B C))) /\ ((allresolvents A (@setU (form -> Prop) B C)) = (@setU (form -> Prop) (allresolvents A B) (allresolvents A C))).
Axiom thm_ALLRESOLVENTS_STEP : forall (A : (form -> Prop) -> Prop) (B : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c C) -> clause c)) -> SUBSUMES (@setU (form -> Prop) (allresolvents B (@setU (form -> Prop) A B)) (allresolvents C (@setU (form -> Prop) A (@setU (form -> Prop) B C)))) (allresolvents (@setU (form -> Prop) B C) (@setU (form -> Prop) A (@setU (form -> Prop) B C))).
Axiom thm_resolvents : forall cl : form -> Prop, forall cls : seq (form -> Prop), (resolvents cl cls) = (@list_of_set (form -> Prop) (allresolvents (@INSERT (form -> Prop) cl (@set0 (form -> Prop))) (@set_of_list (form -> Prop) cls))).
Axiom thm_CLAUSE_UNION : forall c1 : form -> Prop, forall c2 : form -> Prop, (clause (@setU form c1 c2)) = ((clause c1) /\ (clause c2)).
Axiom thm_CLAUSE_SUBSET : forall c1 : form -> Prop, forall c2 : form -> Prop, ((clause c2) /\ (@subset form c1 c2)) -> clause c1.
Axiom thm_CLAUSE_DIFF : forall c1 : form -> Prop, forall c2 : form -> Prop, (clause c1) -> clause (@setD form c1 c2).
Axiom thm_ISARESOLVENT_CLAUSE : forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) p q)))) -> clause r.
Axiom thm_ALLRESOLVENTS_CLAUSE : forall (s : (form -> Prop) -> Prop) (t : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c)) -> forall c : form -> Prop, (@IN (form -> Prop) c (allresolvents s t)) -> clause c.
Axiom thm_ISARESOLVENT_FINITE : forall c1 : form -> Prop, forall c2 : form -> Prop, ((clause c1) /\ (clause c2)) -> @finite_set (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_557 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_557 (isaresolvent c (@pair (form -> Prop) (form -> Prop) c1 c2)) c)).
Axiom thm_ALLRESOLVENTS_FINITE : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, ((@finite_set (form -> Prop) s) /\ ((@finite_set (form -> Prop) t) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c)))) -> @finite_set (form -> Prop) (allresolvents s t).
Axiom thm_replace : forall (c : form -> Prop) (cl : form -> Prop) (cls : seq (form -> Prop)), ((replace cl (@nil (form -> Prop))) = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ ((replace cl (@cons (form -> Prop) c cls)) = (@COND (seq (form -> Prop)) (subsumes cl c) (@cons (form -> Prop) cl cls) (@cons (form -> Prop) c (replace cl cls)))).
Axiom thm_REPLACE : forall cl : form -> Prop, forall lis : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c lis) -> clause c) /\ (clause cl)) -> (forall c : form -> Prop, (@MEM (form -> Prop) c (replace cl lis)) -> clause c) /\ (SUBSUMES (@set_of_list (form -> Prop) (replace cl lis)) (@set_of_list (form -> Prop) (@cons (form -> Prop) cl lis))).
Axiom thm_incorporate : forall gcl : form -> Prop, forall cl : form -> Prop, forall current : seq (form -> Prop), (incorporate gcl cl current) = (@COND (seq (form -> Prop)) ((tautologous cl) \/ (@EX (form -> Prop) (fun c : form -> Prop => subsumes c cl) (@cons (form -> Prop) gcl current))) current (replace cl current)).
Axiom thm_INCORPORATE : forall gcl : form -> Prop, forall cl : form -> Prop, forall current : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c current) -> clause c) /\ ((clause gcl) /\ (clause cl))) -> (forall c : form -> Prop, (@MEM (form -> Prop) c (incorporate gcl cl current)) -> clause c) /\ ((SUBSUMES (@set_of_list (form -> Prop) (incorporate gcl cl current)) (@set_of_list (form -> Prop) current)) /\ ((tautologous cl) \/ (SUBSUMES (@INSERT (form -> Prop) gcl (@set_of_list (form -> Prop) (incorporate gcl cl current))) (@set_of_list (form -> Prop) (@cons (form -> Prop) cl current))))).
Axiom thm_insert_def : forall {_219098 : Type'}, forall x : _219098, forall l : seq _219098, (@insert _219098 x l) = (@COND (seq _219098) (@MEM _219098 x l) l (@cons _219098 x l)).
Axiom thm_step : forall unused : seq (form -> Prop), forall used : seq (form -> Prop), (step (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)) = (@COND (prod (seq (form -> Prop)) (seq (form -> Prop))) (unused = (@nil (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) (@LET (seq (form -> Prop)) (prod (seq (form -> Prop)) (seq (form -> Prop))) (fun new : seq (form -> Prop) => @LET_END (prod (seq (form -> Prop)) (seq (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) (@insert (form -> Prop) (@HD (form -> Prop) unused) used) (@ITLIST (form -> Prop) (seq (form -> Prop)) (incorporate (@HD (form -> Prop) unused)) new (@TL (form -> Prop) unused)))) (resolvents (@HD (form -> Prop) unused) (@cons (form -> Prop) (@HD (form -> Prop) unused) used)))).
Axiom thm_STEP : forall (cls : seq (form -> Prop)) (cl : form -> Prop) (used : seq (form -> Prop)), ((step (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@nil (form -> Prop)))) = (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@nil (form -> Prop)))) /\ ((step (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@cons (form -> Prop) cl cls))) = (@LET (seq (form -> Prop)) (prod (seq (form -> Prop)) (seq (form -> Prop))) (fun new : seq (form -> Prop) => @LET_END (prod (seq (form -> Prop)) (seq (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) (@insert (form -> Prop) cl used) (@ITLIST (form -> Prop) (seq (form -> Prop)) (incorporate cl) new cls))) (resolvents cl (@cons (form -> Prop) cl used)))).
Axiom thm_given : forall (n : nat) (p : prod (seq (form -> Prop)) (seq (form -> Prop))), ((given (NUMERAL O) p) = p) /\ ((given (S n) p) = (step (given n p))).
Axiom thm_Used_DEF : forall n : nat, forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), (Used init n) = (@set_of_list (form -> Prop) (@fst (seq (form -> Prop)) (seq (form -> Prop)) (given n init))).
Axiom thm_Unused_DEF : forall n : nat, forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), (Unused init n) = (@set_of_list (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given n init))).
Axiom thm_Sub_DEF : forall (init : prod (seq (form -> Prop)) (seq (form -> Prop))) (n : nat), ((Sub init (NUMERAL O)) = (@set0 (form -> Prop))) /\ ((Sub init (S n)) = (@COND ((form -> Prop) -> Prop) ((@snd (seq (form -> Prop)) (seq (form -> Prop)) (given n init)) = (@nil (form -> Prop))) (Sub init n) (@INSERT (form -> Prop) (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given n init))) (Sub init n)))).
Axiom thm_TAUTOLOGOUS_INSTANCE : forall i : nat -> term, forall cl : form -> Prop, (tautologous cl) -> tautologous (@IMAGE form form (formsubst i) cl).
Axiom thm_NONTAUTOLOGOUS_SUBSUMES : forall (cl' : form -> Prop) (cl : form -> Prop), ((subsumes cl cl') /\ (~ (tautologous cl'))) -> ~ (tautologous cl).
Axiom thm_ALLNTRESOLVENTS_STEP : forall (A : (form -> Prop) -> Prop) (B : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c C) -> clause c)) -> SUBSUMES (@setU (form -> Prop) (allntresolvents B (@setU (form -> Prop) A B)) (allntresolvents C (@setU (form -> Prop) A (@setU (form -> Prop) B C)))) (allntresolvents (@setU (form -> Prop) B C) (@setU (form -> Prop) A (@setU (form -> Prop) B C))).
Axiom thm_ALLNTRESOLVENTS_UNION : forall (B : (form -> Prop) -> Prop) (A : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((allntresolvents (@setU (form -> Prop) A B) C) = (@setU (form -> Prop) (allntresolvents A C) (allntresolvents B C))) /\ ((allntresolvents A (@setU (form -> Prop) B C)) = (@setU (form -> Prop) (allntresolvents A B) (allntresolvents A C))).
Axiom thm_SET_OF_LIST_INSERT : forall {_219433 : Type'}, forall x : _219433, forall s : seq _219433, (@set_of_list _219433 (@insert _219433 x s)) = (@INSERT _219433 x (@set_of_list _219433 s)).
Axiom thm_SET_OF_LIST_FILTER : forall {_219470 : Type'}, forall P : _219470 -> Prop, forall l : seq _219470, (@set_of_list _219470 (@FILTER _219470 P l)) = (@GSPEC _219470 (fun GEN_PVAR_561 : _219470 => exists x : _219470, @SETSPEC _219470 GEN_PVAR_561 ((@IN _219470 x (@set_of_list _219470 l)) /\ (P x)) x)).
Axiom thm_break : forall (n : nat) (init : prod (seq (form -> Prop)) (seq (form -> Prop))), ((break init (NUMERAL O)) = (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given (NUMERAL O) init)))) /\ ((break init (S n)) = (addn (break init n) (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given (break init n) init))))).
Axiom thm_level : forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall n : nat, (level init n) = (Sub init (break init n)).
Axiom thm_IMAGE_CLAUSE_EQ : forall {_222218 : Type'} (f : form -> _222218) (g : form -> _222218) (p : form -> Prop), ((clause p) /\ (forall q : form, (qfree q) -> (f q) = (g q))) -> (@IMAGE form _222218 f p) = (@IMAGE form _222218 g p).
Axiom thm_FORMSUBST_TERMSUBST_EQ : forall (i : nat -> term) (j : nat -> term), (forall p : form, (qfree p) -> (formsubst i p) = (formsubst j p)) = ((termsubst i) = (termsubst j)).
Axiom thm_ISARESOLVENT_SUBSUME_L : forall p : form -> Prop, forall p' : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause p') /\ ((clause q) /\ ((subsumes p' p) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) p q)))))) -> (subsumes p' r) \/ (exists r' : form -> Prop, (isaresolvent r' (@pair (form -> Prop) (form -> Prop) p' q)) /\ (subsumes r' r)).
Axiom thm_ISARESOLVENT_SUBSUME_R : forall p : form -> Prop, forall q : form -> Prop, forall q' : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((clause q') /\ ((subsumes q' q) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) p q)))))) -> (subsumes q' r) \/ (exists r' : form -> Prop, (isaresolvent r' (@pair (form -> Prop) (form -> Prop) p q')) /\ (subsumes r' r)).
Axiom thm_ISARESOLVENT_SUBSUME : forall p : form -> Prop, forall p' : form -> Prop, forall q : form -> Prop, forall q' : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause p') /\ ((clause q) /\ ((clause q') /\ ((subsumes p' p) /\ ((subsumes q' q) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) p q)))))))) -> (subsumes p' r) \/ ((subsumes q' r) \/ (exists r' : form -> Prop, (isaresolvent r' (@pair (form -> Prop) (form -> Prop) p' q')) /\ (subsumes r' r))).
Axiom thm_ALLRESOLVENTS_SUBSUME_L : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c u) -> clause c) /\ (SUBSUMES s t)))) -> SUBSUMES (@setU (form -> Prop) s (allresolvents s u)) (allresolvents t u).
Axiom thm_ALLRESOLVENTS_SUBSUME_R : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c u) -> clause c) /\ (SUBSUMES t u)))) -> SUBSUMES (@setU (form -> Prop) t (allresolvents s t)) (allresolvents s u).
Axiom thm_ALLRESOLVENTS_SUBSUME : forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall s' : (form -> Prop) -> Prop, forall t' : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c s') -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t') -> clause c) /\ ((SUBSUMES s s') /\ (SUBSUMES t t')))))) -> SUBSUMES (@setU (form -> Prop) s (@setU (form -> Prop) t (allresolvents s t))) (allresolvents s' t').
Axiom thm_ISARESOLVENT_TAUTOLOGY_L : forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((tautologous p) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) p q))))) -> (tautologous r) \/ (subsumes q r).
Axiom thm_ISARESOLVENT_TAUTOLOGY_R : forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((tautologous p) /\ (isaresolvent r (@pair (form -> Prop) (form -> Prop) q p))))) -> (tautologous r) \/ (subsumes q r).
Axiom thm_REPLACE_FROMNEW : forall cl : form -> Prop, forall lis : seq (form -> Prop), forall c : form -> Prop, (@MEM (form -> Prop) c (replace cl lis)) -> (@MEM (form -> Prop) c lis) \/ (c = cl).
Axiom thm_INCORPORATE_FROMNEW : forall gcl : form -> Prop, forall cl : form -> Prop, forall lis : seq (form -> Prop), forall c : form -> Prop, (@MEM (form -> Prop) c (incorporate gcl cl lis)) -> (@MEM (form -> Prop) c lis) \/ (c = cl).
Axiom thm_ITLIST_INCORPORATE_FROMNEW : forall gcl : form -> Prop, forall lis : seq (form -> Prop), forall new : seq (form -> Prop), forall c : form -> Prop, (@MEM (form -> Prop) c (@ITLIST (form -> Prop) (seq (form -> Prop)) (incorporate gcl) new lis)) -> (@MEM (form -> Prop) c new) \/ (@MEM (form -> Prop) c lis).
Axiom thm_ppresproof_RULES : (forall c : form -> Prop, (clause c) -> ppresproof (@INSERT (form -> Prop) c (@set0 (form -> Prop))) c) /\ (forall p : form, forall asm1 : (form -> Prop) -> Prop, forall asm2 : (form -> Prop) -> Prop, forall c1 : form -> Prop, forall c2 : form -> Prop, ((ppresproof asm1 c1) /\ ((ppresproof asm2 c2) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))) -> ppresproof (@setU (form -> Prop) asm1 asm2) (resolve p c1 c2)).
Axiom thm_ppresproof_CASES : forall a0 : (form -> Prop) -> Prop, forall a1 : form -> Prop, (ppresproof a0 a1) = (((a0 = (@INSERT (form -> Prop) a1 (@set0 (form -> Prop)))) /\ (clause a1)) \/ (exists p : form, exists asm1 : (form -> Prop) -> Prop, exists asm2 : (form -> Prop) -> Prop, exists c1 : form -> Prop, exists c2 : form -> Prop, (a0 = (@setU (form -> Prop) asm1 asm2)) /\ ((a1 = (resolve p c1 c2)) /\ ((ppresproof asm1 c1) /\ ((ppresproof asm2 c2) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2))))))).
Axiom thm_ppresproof_INDUCT : forall ppresproof' : ((form -> Prop) -> Prop) -> (form -> Prop) -> Prop, ((forall c : form -> Prop, (clause c) -> ppresproof' (@INSERT (form -> Prop) c (@set0 (form -> Prop))) c) /\ (forall p : form, forall asm1 : (form -> Prop) -> Prop, forall asm2 : (form -> Prop) -> Prop, forall c1 : form -> Prop, forall c2 : form -> Prop, ((ppresproof' asm1 c1) /\ ((ppresproof' asm2 c2) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))) -> ppresproof' (@setU (form -> Prop) asm1 asm2) (resolve p c1 c2))) -> forall a0 : (form -> Prop) -> Prop, forall a1 : form -> Prop, (ppresproof a0 a1) -> ppresproof' a0 a1.
Axiom thm_PPRESPROOF : forall hyps' : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (presproof hyps' c) = (exists asm : (form -> Prop) -> Prop, (@subset (form -> Prop) asm hyps') /\ (ppresproof asm c)).
Axiom thm_PPRESPROOF_CLAUSE : forall asm : (form -> Prop) -> Prop, forall cl : form -> Prop, (ppresproof asm cl) -> (clause cl) /\ (forall c : form -> Prop, (@IN (form -> Prop) c asm) -> clause c).
Axiom thm_PPRESPROOF_CONSEQUENCE : forall asm : (form -> Prop) -> Prop, forall cl : form -> Prop, (ppresproof asm cl) -> forall d : form -> Prop, (psatisfies d (@IMAGE (form -> Prop) form interp asm)) -> pholds d (interp cl).
Axiom thm_PPRESPROOF_SOUND : forall asm : (form -> Prop) -> Prop, (ppresproof asm (@set0 form)) -> ~ (psatisfiable (@IMAGE (form -> Prop) form interp asm)).
Axiom thm_PPRESPROOF_ALLNEGATIVE : forall asm : (form -> Prop) -> Prop, (ppresproof asm (@set0 form)) -> exists c : form -> Prop, (@IN (form -> Prop) c asm) /\ (forall p : form, (@IN form p c) -> negative p).
Axiom thm_lpresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : seq (form -> Prop), (lpresproof hyps' a) = ((exists cl : form -> Prop, (a = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : seq (form -> Prop), exists p : form, (a = (@cons (form -> Prop) (resolve p c1 c2) (@cons (form -> Prop) c1 lis))) /\ ((lpresproof hyps' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))))).
Axiom thm_lpresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall lpresproof' : (seq (form -> Prop)) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> lpresproof' (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall lis : seq (form -> Prop), forall p : form, ((lpresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))) -> lpresproof' (@cons (form -> Prop) (resolve p c1 c2) (@cons (form -> Prop) c1 lis)))) -> forall a : seq (form -> Prop), (lpresproof hyps' a) -> lpresproof' a.
Axiom thm_lpresproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> lpresproof hyps' (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall lis : seq (form -> Prop), forall p : form, ((lpresproof hyps' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ ((@IN form p c1) /\ (@IN form (FNot p) c2)))) -> lpresproof hyps' (@cons (form -> Prop) (resolve p c1 c2) (@cons (form -> Prop) c1 lis))).
Axiom thm_LPRESPROOF_MONO : forall hyps' : (form -> Prop) -> Prop, forall hyps'' : (form -> Prop) -> Prop, forall c : seq (form -> Prop), ((@subset (form -> Prop) hyps' hyps'') /\ (lpresproof hyps' c)) -> lpresproof hyps'' c.
Axiom thm_suffix : forall {_225160 : Type'} (s : _225160) (lis : seq _225160) (cs : seq _225160), ((@suffix _225160 lis (@nil _225160)) = (lis = (@nil _225160))) /\ ((@suffix _225160 lis (@cons _225160 s cs)) = ((lis = (@cons _225160 s cs)) \/ (@suffix _225160 lis cs))).
Axiom thm_SUFFIX_REFL : forall {_225171 : Type'}, forall lis : seq _225171, @suffix _225171 lis lis.
Axiom thm_SUFFIX_BUTLAST : forall {A : Type'}, forall l1 : seq A, forall l2 : seq A, ((@suffix A l1 l2) /\ (~ (l1 = (@nil A)))) -> (@LAST A l1) = (@LAST A l2).
Axiom thm_SUFFIX_TRANS : forall {_225224 : Type'}, forall l1 : seq _225224, forall l2 : seq _225224, forall l3 : seq _225224, ((@suffix _225224 l1 l2) /\ (@suffix _225224 l2 l3)) -> @suffix _225224 l1 l3.
Axiom thm_SUFFIX_MEM : forall {A : Type'}, forall x : A, forall l : seq A, forall lis : seq A, (@suffix A (@cons A x l) lis) -> @MEM A x lis.
Axiom thm_SUFFIX_CONS : forall {_225277 : Type'}, forall x : _225277, forall l1 : seq _225277, forall l2 : seq _225277, (@suffix _225277 l1 l2) -> @suffix _225277 l1 (@cons _225277 x l2).
Axiom thm_SUFFIX_LENGTH : forall {_225302 : Type'}, forall l1 : seq _225302, forall l2 : seq _225302, (@suffix _225302 l1 l2) -> leqn (@size _225302 l1) (@size _225302 l2).
Axiom thm_NOT_SUFFIX_TAIL : forall {_225330 : Type'}, forall x : _225330, forall l : seq _225330, ~ (@suffix _225330 (@cons _225330 x l) l).
Axiom thm_SUFFIX_ANTISYM : forall {_225347 : Type'}, forall l1 : seq _225347, forall l2 : seq _225347, ((@suffix _225347 l1 l2) /\ (@suffix _225347 l2 l1)) -> l1 = l2.
Axiom thm_SYMMETRY_LEMMA_1 : forall {_225538 _225539 : Type'} (Q : form -> (_225538 -> Prop) -> _225539 -> (_225538 -> Prop) -> _225539 -> Prop) (P : form -> (_225538 -> Prop) -> _225539 -> (_225538 -> Prop) -> _225539 -> _225538 -> Prop), ((forall q : form, forall basm : _225538 -> Prop, forall B : _225539, forall casm : _225538 -> Prop, forall C : _225539, forall c : _225538, (literal q) -> (P q basm B casm C c) = (P (FNot q) casm C basm B c)) /\ ((forall q : form, forall basm : _225538 -> Prop, forall B : _225539, forall casm : _225538 -> Prop, forall C : _225539, (literal q) -> (Q q basm B casm C) = (Q (FNot q) casm C basm B)) /\ (forall q : form, forall basm : _225538 -> Prop, forall B : _225539, forall casm : _225538 -> Prop, forall C : _225539, (Q q basm B casm C) -> (literal q) -> forall c : _225538, (@IN _225538 c basm) -> P q basm B casm C c))) -> forall q : form, forall basm : _225538 -> Prop, forall B : _225539, forall casm : _225538 -> Prop, forall C : _225539, (Q q basm B casm C) -> (literal q) -> forall c : _225538, (@IN _225538 c (@setU _225538 basm casm)) -> P q basm B casm C c.
Axiom thm_SYMMETRY_LEMMA_2 : forall {_225715 _225716 _225717 _225719 : Type'} (P : form -> form -> _225719 -> (form -> Prop) -> _225719 -> (form -> Prop) -> _225717 -> _225716 -> _225715 -> Prop), ((forall p : form, forall q : form, forall basm : _225719, forall B : form -> Prop, forall casm : _225719, forall C : form -> Prop, forall main : _225717, forall aasm : _225716, forall A : _225715, (literal q) -> (P p q basm B casm C main aasm A) = (P p (FNot q) casm C basm B main aasm A)) /\ (forall p : form, forall q : form, forall basm : _225719, forall B : form -> Prop, forall casm : _225719, forall C : form -> Prop, forall main : _225717, forall aasm : _225716, forall A : _225715, (@IN form (FNot p) B) -> (literal q) -> P p q basm B casm C main aasm A)) -> forall p : form, forall q : form, forall basm : _225719, forall B : form -> Prop, forall casm : _225719, forall C : form -> Prop, forall main : _225717, forall aasm : _225716, forall A : _225715, ((@IN form (FNot p) B) \/ (@IN form (FNot p) C)) -> (literal q) -> P p q basm B casm C main aasm A.
Axiom thm_LINEARIZATION : forall asm : (form -> Prop) -> Prop, forall cl : form -> Prop, (ppresproof asm cl) -> forall c : form -> Prop, (@IN (form -> Prop) c asm) -> exists cl' : form -> Prop, exists lis : seq (form -> Prop), (lpresproof asm (@cons (form -> Prop) cl' lis)) /\ ((@subset form cl' cl) /\ ((@LAST (form -> Prop) (@cons (form -> Prop) cl' lis)) = c)).
Axiom thm_lresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : seq (form -> Prop), (lresproof hyps' a) = ((exists cl : form -> Prop, (a = (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (@IN (form -> Prop) cl hyps')) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists lis : seq (form -> Prop), exists cl : form -> Prop, (a = (@cons (form -> Prop) cl (@cons (form -> Prop) c1 lis))) /\ ((lresproof hyps' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)))))).
Axiom thm_lresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall lresproof' : (seq (form -> Prop)) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> lresproof' (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall lis : seq (form -> Prop), forall cl : form -> Prop, ((lresproof' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)))) -> lresproof' (@cons (form -> Prop) cl (@cons (form -> Prop) c1 lis)))) -> forall a : seq (form -> Prop), (lresproof hyps' a) -> lresproof' a.
Axiom thm_lresproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> lresproof hyps' (@cons (form -> Prop) cl (@nil (form -> Prop)))) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall lis : seq (form -> Prop), forall cl : form -> Prop, ((lresproof hyps' (@cons (form -> Prop) c1 lis)) /\ (((@IN (form -> Prop) c2 hyps') \/ (@MEM (form -> Prop) c2 lis)) /\ (isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)))) -> lresproof hyps' (@cons (form -> Prop) cl (@cons (form -> Prop) c1 lis))).
Axiom thm_ALL2_BUTLAST : forall {A : Type'}, forall P : A -> A -> Prop, forall l1 : seq A, forall l2 : seq A, ((~ (l1 = (@nil A))) /\ (@ALL2 A A P l1 l2)) -> P (@LAST A l1) (@LAST A l2).
Axiom thm_ALL2_MEM : forall {_226911 _226912 : Type'} (P : _226912 -> _226911 -> Prop) (x : _226912), forall l1 : seq _226912, forall l2 : seq _226911, ((@ALL2 _226912 _226911 P l1 l2) /\ (@MEM _226912 x l1)) -> exists y : _226911, (@MEM _226911 y l2) /\ (P x y).
Axiom thm_LRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall lis : seq (form -> Prop), (lresproof hyps' lis) -> @ALL (form -> Prop) clause lis.
Axiom thm_LINEAR_RESOLUTION_COMPLETE : forall (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M (@IMAGE (form -> Prop) form interp hyps')))))) -> exists lis : seq (form -> Prop), (lresproof hyps' (@cons (form -> Prop) (@set0 form) lis)) /\ (forall p : form, (@IN form p (@LAST (form -> Prop) (@cons (form -> Prop) (@set0 form) lis))) -> negative p).
Axiom thm_NEGATE_LITERAL : forall q : form, (literal q) -> literal (FNot q).
Axiom thm_RESOLVE_CLAUSE : forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((clause c1) /\ (clause c2)) -> clause (resolve p c1 c2).
Axiom thm_PRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall cl : form -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) /\ (presproof hyps' cl)) -> clause cl.
Axiom thm_RESOLVE_MONO : forall c1 : form -> Prop, forall c2 : form -> Prop, forall c1' : form -> Prop, forall c2' : form -> Prop, forall p : form, ((@subset form c1 c1') /\ (@subset form c2 c2')) -> @subset form (resolve p c1 c2) (resolve p c1' c2').
Axiom thm_RESOLVE_SYM : forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, (literal p) -> (resolve (FNot p) c1 c2) = (resolve p c2 c1).
Axiom thm_RESOLVE_TAUT_L : forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((clause c1) /\ (tautologous c1)) -> (tautologous (resolve p c1 c2)) \/ (@subset form c2 (resolve p c1 c2)).
Axiom thm_RESOLVE_TAUT_R : forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((clause c2) /\ ((tautologous c2) /\ (literal p))) -> (tautologous (resolve p c1 c2)) \/ (@subset form c1 (resolve p c1 c2)).
Axiom thm_SUBSET_TAUT : forall c1 : form -> Prop, forall c2 : form -> Prop, ((tautologous c1) /\ (@subset form c1 c2)) -> tautologous c2.
Axiom thm_npresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a0 : form -> Prop, forall a1 : nat, (npresproof hyps' a0 a1) = (((a1 = (NUMERAL (BIT1 O))) /\ (@IN (form -> Prop) a0 hyps')) \/ (exists p : form, exists n1 : nat, exists n2 : nat, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a0 = (resolve p cl1 cl2)) /\ ((a1 = (addn n1 (addn n2 (NUMERAL (BIT1 O))))) /\ ((npresproof hyps' cl1 n1) /\ ((npresproof hyps' cl2 n2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))).
Axiom thm_npresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall npresproof' : (form -> Prop) -> nat -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> npresproof' cl (NUMERAL (BIT1 O))) /\ (forall p : form, forall n1 : nat, forall n2 : nat, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((npresproof' cl1 n1) /\ ((npresproof' cl2 n2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))) -> npresproof' (resolve p cl1 cl2) (addn n1 (addn n2 (NUMERAL (BIT1 O)))))) -> forall a0 : form -> Prop, forall a1 : nat, (npresproof hyps' a0 a1) -> npresproof' a0 a1.
Axiom thm_npresproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> npresproof hyps' cl (NUMERAL (BIT1 O))) /\ (forall p : form, forall n1 : nat, forall n2 : nat, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((npresproof hyps' cl1 n1) /\ ((npresproof hyps' cl2 n2) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2)))) -> npresproof hyps' (resolve p cl1 cl2) (addn n1 (addn n2 (NUMERAL (BIT1 O))))).
Axiom thm_NPRESPROOF : forall hyps' : (form -> Prop) -> Prop, forall cl : form -> Prop, (presproof hyps' cl) = (exists n : nat, npresproof hyps' cl n).
Axiom thm_NPRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall cl : form -> Prop, forall n : nat, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) /\ (npresproof hyps' cl n)) -> clause cl.
Axiom thm_psresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall a0 : Prop, forall a1 : form -> Prop, (psresproof hyps' sos a0 a1) = (((a0 = (@IN (form -> Prop) a1 sos)) /\ ((@IN (form -> Prop) a1 hyps') /\ (~ (tautologous a1)))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists s1 : Prop, exists s2 : Prop, exists p : form, (a0 = True) /\ ((a1 = (resolve p c1 c2)) /\ ((psresproof hyps' sos s1 c1) /\ ((psresproof hyps' sos s2 c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ ((s1 \/ s2) /\ (~ (tautologous (resolve p c1 c2))))))))))).
Axiom thm_psresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall psresproof' : Prop -> (form -> Prop) -> Prop, ((forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ (~ (tautologous c))) -> psresproof' (@IN (form -> Prop) c sos) c) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall s1 : Prop, forall s2 : Prop, forall p : form, ((psresproof' s1 c1) /\ ((psresproof' s2 c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ ((s1 \/ s2) /\ (~ (tautologous (resolve p c1 c2)))))))) -> psresproof' True (resolve p c1 c2))) -> forall a0 : Prop, forall a1 : form -> Prop, (psresproof hyps' sos a0 a1) -> psresproof' a0 a1.
Axiom thm_psresproof_RULES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ (~ (tautologous c))) -> psresproof hyps' sos (@IN (form -> Prop) c sos) c) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall s1 : Prop, forall s2 : Prop, forall p : form, ((psresproof hyps' sos s1 c1) /\ ((psresproof hyps' sos s2 c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ ((s1 \/ s2) /\ (~ (tautologous (resolve p c1 c2)))))))) -> psresproof hyps' sos True (resolve p c1 c2)).
Axiom thm_PSRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall s : Prop, forall cl : form -> Prop, (psresproof hyps' sos s cl) -> clause cl.
Axiom thm_SUPPORT_ASYMMETRIC : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall A : form -> Prop, forall B : form -> Prop, forall C : form -> Prop, forall p : form, forall q : form, forall nb : nat, forall nc : nat, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) /\ ((~ (tautologous (resolve p A (resolve q B C)))) /\ ((psresproof hyps' sos True A) /\ ((npresproof (@setD (form -> Prop) hyps' sos) B nb) /\ ((npresproof (@setD (form -> Prop) hyps' sos) C nc) /\ ((@IN form p A) /\ ((@IN form (FNot p) (resolve q B C)) /\ ((@IN form q B) /\ ((@IN form (FNot q) C) /\ ((@IN form (FNot p) B) /\ ((~ (q = (FNot p))) /\ (forall m : nat, (ltn m (addn nb (addn nc (NUMERAL (BIT1 O))))) -> forall c1 : form -> Prop, forall c2 : form -> Prop, forall p' : form, ((psresproof hyps' sos True c1) /\ ((npresproof (@setD (form -> Prop) hyps' sos) c2 m) /\ ((@IN form p' c1) /\ ((@IN form (FNot p') c2) /\ (~ (tautologous (resolve p' c1 c2))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p' c1 c2)) /\ ((psresproof hyps' sos True cl') \/ (exists m' : nat, (ltn m' m) /\ (npresproof (@setD (form -> Prop) hyps' sos) cl' m'))))))))))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p A (resolve q B C))) /\ ((psresproof hyps' sos True cl') \/ (exists m : nat, (ltn m (addn nb (addn nc (NUMERAL (BIT1 O))))) /\ (npresproof (@setD (form -> Prop) hyps' sos) cl' m))).
Axiom thm_SUPPORT_SYMMETRIC : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall A : form -> Prop, forall B : form -> Prop, forall C : form -> Prop, forall p : form, forall q : form, forall nb : nat, forall nc : nat, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) /\ ((~ (tautologous (resolve p A (resolve q B C)))) /\ ((psresproof hyps' sos True A) /\ ((npresproof (@setD (form -> Prop) hyps' sos) B nb) /\ ((npresproof (@setD (form -> Prop) hyps' sos) C nc) /\ ((@IN form p A) /\ ((@IN form (FNot p) (resolve q B C)) /\ ((@IN form q B) /\ ((@IN form (FNot q) C) /\ (forall m : nat, (ltn m (addn nb (addn nc (NUMERAL (BIT1 O))))) -> forall c1 : form -> Prop, forall c2 : form -> Prop, forall p' : form, ((psresproof hyps' sos True c1) /\ ((npresproof (@setD (form -> Prop) hyps' sos) c2 m) /\ ((@IN form p' c1) /\ ((@IN form (FNot p') c2) /\ (~ (tautologous (resolve p' c1 c2))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p' c1 c2)) /\ ((psresproof hyps' sos True cl') \/ (exists m' : nat, (ltn m' m) /\ (npresproof (@setD (form -> Prop) hyps' sos) cl' m'))))))))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p A (resolve q B C))) /\ ((psresproof hyps' sos True cl') \/ (exists m : nat, (ltn m (addn nb (addn nc (NUMERAL (BIT1 O))))) /\ (npresproof (@setD (form -> Prop) hyps' sos) cl' m))).
Axiom thm_SUPPORT_LEMMA : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) -> forall n : nat, forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((psresproof hyps' sos True c1) /\ ((npresproof (@setD (form -> Prop) hyps' sos) c2 n) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p c1 c2)) /\ ((psresproof hyps' sos True cl') \/ (exists m : nat, (ltn m n) /\ (npresproof (@setD (form -> Prop) hyps' sos) cl' m))).
Axiom thm_SUPPORT_INDUCT_LEMMA : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall p : form, forall c1 : form -> Prop, forall c2 : form -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) /\ ((psresproof hyps' sos True c1) /\ ((presproof (@setD (form -> Prop) hyps' sos) c2) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2)))))))) -> exists cl' : form -> Prop, (@subset form cl' (resolve p c1 c2)) /\ ((presproof (@setD (form -> Prop) hyps' sos) cl') \/ (psresproof hyps' sos True cl')).
Axiom thm_SUPPORT_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) -> forall cl : form -> Prop, (presproof hyps' cl) -> (clause cl) /\ ((~ (tautologous cl)) -> exists cl' : form -> Prop, (@subset form cl' cl) /\ ((presproof (@setD (form -> Prop) hyps' sos) cl') \/ (psresproof hyps' sos True cl'))).
Axiom thm_SUPPORT : forall sos : (form -> Prop) -> Prop, forall hyps' : (form -> Prop) -> Prop, forall cl : form -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) /\ ((presproof hyps' cl) /\ (~ (tautologous cl)))) -> exists cl' : form -> Prop, (@subset form cl' cl) /\ ((presproof (@setD (form -> Prop) hyps' sos) cl') \/ (psresproof hyps' sos True cl')).
Axiom thm_spresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall a : form -> Prop, (spresproof hyps' sos a) = (((@IN (form -> Prop) a hyps') /\ ((@IN (form -> Prop) a sos) /\ (~ (tautologous a)))) \/ (exists c1 : form -> Prop, exists c2 : form -> Prop, exists p : form, (a = (resolve p c1 c2)) /\ ((spresproof hyps' sos c1) /\ (((spresproof hyps' sos c2) \/ (@IN (form -> Prop) c2 hyps')) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))))).
Axiom thm_spresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall spresproof' : (form -> Prop) -> Prop, ((forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ ((@IN (form -> Prop) c sos) /\ (~ (tautologous c)))) -> spresproof' c) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((spresproof' c1) /\ (((spresproof' c2) \/ (@IN (form -> Prop) c2 hyps')) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))) -> spresproof' (resolve p c1 c2))) -> forall a : form -> Prop, (spresproof hyps' sos a) -> spresproof' a.
Axiom thm_spresproof_RULES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ ((@IN (form -> Prop) c sos) /\ (~ (tautologous c)))) -> spresproof hyps' sos c) /\ (forall c1 : form -> Prop, forall c2 : form -> Prop, forall p : form, ((spresproof hyps' sos c1) /\ (((spresproof hyps' sos c2) \/ (@IN (form -> Prop) c2 hyps')) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (tautologous (resolve p c1 c2))))))) -> spresproof hyps' sos (resolve p c1 c2)).
Axiom thm_SPRESPROOF_PSRESPROOF : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) -> forall cl : form -> Prop, (spresproof hyps' sos cl) = (psresproof hyps' sos True cl).
Axiom thm_SPRESPROOF_CLAUSE_NONTAUT : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> (clause c) /\ (~ (tautologous c))) -> forall c : form -> Prop, (spresproof hyps' sos c) -> (clause c) /\ (~ (tautologous c)).
Axiom thm_SPRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (spresproof hyps' sos c) -> clause c.
Axiom thm_SPRESPROOF_MONO : forall hyps1' : (form -> Prop) -> Prop, forall hyps2' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall cl : form -> Prop, ((spresproof hyps1' sos cl) /\ (@subset (form -> Prop) hyps1' hyps2')) -> spresproof hyps2' sos cl.
Axiom thm_SPRESPROOF_MONO_SOS : forall hyps1' : (form -> Prop) -> Prop, forall hyps2' : (form -> Prop) -> Prop, forall sos1 : (form -> Prop) -> Prop, forall sos2 : (form -> Prop) -> Prop, forall cl : form -> Prop, ((spresproof hyps1' sos1 cl) /\ ((@subset (form -> Prop) hyps1' hyps2') /\ (@subset (form -> Prop) sos1 sos2))) -> spresproof hyps2' sos2 cl.
Axiom thm_TAUTOLOGOUS_SATISFIED : forall c : form -> Prop, forall d : form -> Prop, ((clause c) /\ (tautologous c)) -> pholds d (interp c).
Axiom thm_PRESPROOF_SOUND : forall asm : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c asm) -> clause c) /\ (presproof asm (@set0 form))) -> ~ (psatisfiable (@IMAGE (form -> Prop) form interp asm)).
Axiom thm_SPRESPROOF_REFUTATION_COMPLETE : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) /\ ((~ (psatisfiable (@GSPEC form (fun GEN_PVAR_587 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_587 (@IN (form -> Prop) cl hyps') (interp cl))))) /\ (psatisfiable (@GSPEC form (fun GEN_PVAR_588 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_588 (@IN (form -> Prop) cl (@setD (form -> Prop) hyps' sos)) (interp cl)))))) -> spresproof hyps' sos (@set0 form).
Axiom thm_sresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall a : form -> Prop, (sresproof hyps' sos a) = (((@IN (form -> Prop) a hyps') /\ ((@IN (form -> Prop) a sos) /\ (~ (tautologous a)))) \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : nat -> term, (a = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))) /\ ((sresproof hyps' sos cl1) /\ (((sresproof hyps' sos cl2) \/ (@IN (form -> Prop) cl2 hyps')) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_589 : form => exists p : form, @SETSPEC form GEN_PVAR_589 (@IN form p ps2) (FNot p))))) /\ (((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_590 : form => exists p : form, @SETSPEC form GEN_PVAR_590 (@IN form p ps2) (FNot p))))) = i) /\ (~ (tautologous (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))))))))))))))).
Axiom thm_sresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, forall sresproof' : (form -> Prop) -> Prop, ((forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ ((@IN (form -> Prop) c sos) /\ (~ (tautologous c)))) -> sresproof' c) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((sresproof' cl1) /\ (((sresproof' cl2) \/ (@IN (form -> Prop) cl2 hyps')) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_589 : form => exists p : form, @SETSPEC form GEN_PVAR_589 (@IN form p ps2) (FNot p))))) /\ (((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_590 : form => exists p : form, @SETSPEC form GEN_PVAR_590 (@IN form p ps2) (FNot p))))) = i) /\ (~ (tautologous (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))))))))))))) -> sresproof' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) -> forall a : form -> Prop, (sresproof hyps' sos a) -> sresproof' a.
Axiom thm_sresproof_RULES : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, ((@IN (form -> Prop) c hyps') /\ ((@IN (form -> Prop) c sos) /\ (~ (tautologous c)))) -> sresproof hyps' sos c) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((sresproof hyps' sos cl1) /\ (((sresproof hyps' sos cl2) \/ (@IN (form -> Prop) cl2 hyps')) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_589 : form => exists p : form, @SETSPEC form GEN_PVAR_589 (@IN form p ps2) (FNot p))))) /\ (((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_590 : form => exists p : form, @SETSPEC form GEN_PVAR_590 (@IN form p ps2) (FNot p))))) = i) /\ (~ (tautologous (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))))))))))))) -> sresproof hyps' sos (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))).
Axiom thm_SRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall sos : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (sresproof hyps' sos c) -> clause c.
Axiom thm_PSATISFIES_IMAGE_LEMMA : forall (prop : (nat -> term) -> Prop) (s : (form -> Prop) -> Prop), (forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) -> forall d : form -> Prop, (psatisfies d (@GSPEC form (fun GEN_PVAR_591 : form => exists v : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_591 ((prop v) /\ (@IN form p (@IMAGE (form -> Prop) form interp s))) (formsubst v p)))) = (psatisfies d (@GSPEC form (fun GEN_PVAR_593 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_593 (@IN (form -> Prop) cl (@GSPEC (form -> Prop) (fun GEN_PVAR_592 : form -> Prop => exists v : nat -> term, exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_592 ((prop v) /\ (@IN (form -> Prop) c s)) (@IMAGE form form (formsubst v) c)))) (interp cl)))).
Axiom thm_SOS_RESOLUTION_COMPLETE : forall {A : Type'} (hyps' : (form -> Prop) -> Prop) (sos : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ ((@subset (form -> Prop) sos hyps') /\ ((~ (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M (@IMAGE (form -> Prop) form interp hyps'))))) /\ (exists M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), (@interpretation A (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M (@IMAGE (form -> Prop) form interp (@setD (form -> Prop) hyps' sos)))))))) -> sresproof hyps' sos (@set0 form).
Axiom thm_SOS_GIVEN_GENERAL : forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall cl : form -> Prop, ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ ((forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c) /\ (sresproof (@setU (form -> Prop) (@set_of_list (form -> Prop) used) (@set_of_list (form -> Prop) unused)) (@set_of_list (form -> Prop) unused) cl))) -> (clause cl) /\ (exists n : nat, exists cl' : form -> Prop, (subsumes cl' cl) /\ (@IN (form -> Prop) cl' (level (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n))).
Axiom thm_SUBSUMES_EMPTY : forall c : form -> Prop, (subsumes c (@set0 form)) = (c = (@set0 form)).
Axiom thm_SOS_GIVEN : forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ ((forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c) /\ (sresproof (@setU (form -> Prop) (@set_of_list (form -> Prop) used) (@set_of_list (form -> Prop) unused)) (@set_of_list (form -> Prop) unused) (@set0 form)))) -> exists n : nat, @IN (form -> Prop) (@set0 form) (level (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n).
Axiom thm_allpositive : forall cl : form -> Prop, (allpositive cl) = (forall p : form, (@IN form p cl) -> positive p).
Axiom thm_NOT_NEGATIVE_ATOM : forall p : nat, forall a : seq term, ~ (negative (Atom p a)).
Axiom thm_NEGATIVE_NOT : forall p : form, negative (Not p).
Axiom thm_CLAUSE_FINITE : forall c : form -> Prop, (clause c) -> @finite_set form c.
Axiom thm_POSITIVE_LITERAL_ATOM : forall p : form, ((literal p) /\ (positive p)) = (atom p).
Axiom thm_PHOLDS_ATOM : forall v : form -> Prop, forall p : form, (atom p) -> (pholds v p) = (v p).
Axiom thm_PHOLDS_ALLTRUE_POSLIT : forall p : form, ((literal p) /\ (positive p)) -> pholds (fun x : form => True) p.
Axiom thm_PHOLDS_ALLFALSE_NEGLIT : forall p : form, ((literal p) /\ (negative p)) -> pholds (fun x : form => False) p.
Axiom thm_PHOLDS_ALLTRUE_POSCLAUSE : forall c : form -> Prop, ((clause c) /\ ((allpositive c) /\ (~ (c = (@set0 form))))) -> pholds (fun x : form => True) (interp c).
Axiom thm_PHOLDS_ALLFALSE_NONPOSCLAUSE : forall c : form -> Prop, ((clause c) /\ (~ (allpositive c))) -> pholds (fun x : form => False) (interp c).
Axiom thm_PRESOLUTION_LEMMA : forall s : (form -> Prop) -> Prop, ((@finite_set (form -> Prop) s) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((~ (psatisfiable (@IMAGE (form -> Prop) form interp s))) /\ (~ (@IN (form -> Prop) (@set0 form) s))))) -> exists c1 : form -> Prop, exists c2 : form -> Prop, exists p : form, (@IN (form -> Prop) c1 s) /\ ((@IN (form -> Prop) c2 s) /\ (((allpositive c1) \/ (allpositive c2)) /\ ((@IN form p c1) /\ ((@IN form (FNot p) c2) /\ (~ (@IN (form -> Prop) (resolve p c1 c2) s)))))).
Axiom thm_pposresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (pposresproof hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a = (resolve p cl1 cl2)) /\ ((pposresproof hyps' cl1) /\ ((pposresproof hyps' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))).
Axiom thm_pposresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall pposresproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> pposresproof' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((pposresproof' cl1) /\ ((pposresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))) -> pposresproof' (resolve p cl1 cl2))) -> forall a : form -> Prop, (pposresproof hyps' a) -> pposresproof' a.
Axiom thm_pposresproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> pposresproof hyps' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((pposresproof hyps' cl1) /\ ((pposresproof hyps' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))) -> pposresproof hyps' (resolve p cl1 cl2)).
Axiom thm_POSRESPROOF_FINITE : forall hyps' : (form -> Prop) -> Prop, ((@finite_set (form -> Prop) hyps') /\ (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl)) -> @finite_set (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_612 : form -> Prop => exists cl : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_612 (pposresproof hyps' cl) cl)).
Axiom thm_PPOSRESPROOF_REFUTATION_COMPLETE_FINITE : forall (hyps' : (form -> Prop) -> Prop), ((@finite_set (form -> Prop) hyps') /\ ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (psatisfiable (@GSPEC form (fun GEN_PVAR_616 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_616 (@IN (form -> Prop) cl hyps') (interp cl))))))) -> pposresproof hyps' (@set0 form).
Axiom thm_PPOSRESPROOF_MONO : forall hyps1' : (form -> Prop) -> Prop, forall hyps2' : (form -> Prop) -> Prop, forall c : form -> Prop, ((pposresproof hyps1' c) /\ (@subset (form -> Prop) hyps1' hyps2')) -> pposresproof hyps2' c.
Axiom thm_PPOSRESPROOF_REFUTATION_COMPLETE : forall (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (psatisfiable (@GSPEC form (fun GEN_PVAR_619 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_619 (@IN (form -> Prop) cl hyps') (interp cl)))))) -> pposresproof hyps' (@set0 form).
Axiom thm_psemresproof_CASES : forall v : form -> Prop, forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (psemresproof v hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists p : form, exists cl1 : form -> Prop, exists cl2 : form -> Prop, (a = (resolve p cl1 cl2)) /\ ((psemresproof v hyps' cl1) /\ ((psemresproof v hyps' cl2) /\ (((~ (pholds v (interp cl1))) \/ (~ (pholds v (interp cl2)))) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))))).
Axiom thm_psemresproof_INDUCT : forall v : form -> Prop, forall hyps' : (form -> Prop) -> Prop, forall psemresproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> psemresproof' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((psemresproof' cl1) /\ ((psemresproof' cl2) /\ (((~ (pholds v (interp cl1))) \/ (~ (pholds v (interp cl2)))) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))) -> psemresproof' (resolve p cl1 cl2))) -> forall a : form -> Prop, (psemresproof v hyps' a) -> psemresproof' a.
Axiom thm_psemresproof_RULES : forall v : form -> Prop, forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> psemresproof v hyps' cl) /\ (forall p : form, forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((psemresproof v hyps' cl1) /\ ((psemresproof v hyps' cl2) /\ (((~ (pholds v (interp cl1))) \/ (~ (pholds v (interp cl2)))) /\ ((@IN form p cl1) /\ (@IN form (FNot p) cl2))))) -> psemresproof v hyps' (resolve p cl1 cl2)).
Axiom thm_propflip : forall w : form -> Prop, forall p : form, (propflip w p) = (@COND form ((negative p) = (pholds w p)) p (FNot p)).
Axiom thm_PHOLDS_LITERAL_PROPFLIP : forall p : form, forall w : form -> Prop, (literal p) -> (pholds w p) = (pholds (fun x : form => False) (propflip w p)).
Axiom thm_PROPFLIP_INVOLUTE : forall w : form -> Prop, forall p : form, (literal p) -> (propflip w (propflip w p)) = p.
Axiom thm_PROPFLIP_INJ : forall w : form -> Prop, forall p : form, forall q : form, ((literal p) /\ ((literal q) /\ ((propflip w p) = (propflip w q)))) -> p = q.
Axiom thm_PROPFLIP_NEGATE : forall w : form -> Prop, forall p : form, (literal p) -> (propflip w (FNot p)) = (FNot (propflip w p)).
Axiom thm_PROPFLIP_RESOLVE : forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall p : form, forall w : form -> Prop, ((clause cl1) /\ ((clause cl2) /\ (@IN form p cl1))) -> (@IMAGE form form (propflip w) (resolve p cl1 cl2)) = (resolve (propflip w p) (@IMAGE form form (propflip w) cl1) (@IMAGE form form (propflip w) cl2)).
Axiom thm_PPOSRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (pposresproof hyps' c) -> clause c.
Axiom thm_PSEMRESPROOF_CLAUSE : forall hyps' : (form -> Prop) -> Prop, forall w : form -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (psemresproof w hyps' c) -> clause c.
Axiom thm_LITERAL_PROPFLIP : forall p : form, forall w : form -> Prop, (literal p) -> literal (propflip w p).
Axiom thm_CLAUSE_IMAGE_PROPFLIP : forall cl : form -> Prop, forall w : form -> Prop, (clause cl) -> clause (@IMAGE form form (propflip w) cl).
Axiom thm_PHOLDS_LITERAL_PROPFLIP_SAME : forall p : form, forall w : form -> Prop, (literal p) -> (pholds w (propflip w p)) = (~ (positive p)).
Axiom thm_PHOLDS_IMAGE_PROPFLIP_SAME : forall v : form -> Prop, forall cl : form -> Prop, (clause cl) -> (pholds v (interp (@IMAGE form form (propflip v) cl))) = (~ (allpositive cl)).
Axiom thm_PPOSRESPROOF_PSEMRESPROOF : forall hyps' : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall w : form -> Prop, forall cl : form -> Prop, (pposresproof hyps' cl) -> psemresproof w (@IMAGE (form -> Prop) (form -> Prop) (@IMAGE form form (propflip w)) hyps') (@IMAGE form form (propflip w) cl).
Axiom thm_PHOLDS_ATOM_PROPFLIP_DIFF : forall p : form, forall v : form -> Prop, forall w : form -> Prop, (atom p) -> (pholds v (propflip w p)) = (~ ((v p) = (w p))).
Axiom thm_PHOLDS_LITERAL_PROPFLIP_DIFF : forall p : form, forall v : form -> Prop, forall w : form -> Prop, (literal p) -> (pholds v (propflip w p)) = (pholds (fun x : form => ~ ((v x) = (w x))) p).
Axiom thm_PHOLDS_INTERP_IMAGE_PROPFLIP_DIFF : forall (w : form -> Prop), forall v : form -> Prop, forall cl : form -> Prop, (clause cl) -> (pholds v (interp (@IMAGE form form (propflip w) cl))) = (pholds (fun x : form => ~ ((v x) = (w x))) (interp cl)).
Axiom thm_PSATISFIABLE_CLAUSES_PROPFLIP : forall w : form -> Prop, forall s : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) -> (psatisfiable (@IMAGE (form -> Prop) form (@o (form -> Prop) (form -> Prop) form interp (@IMAGE form form (propflip w))) s)) = (psatisfiable (@IMAGE (form -> Prop) form interp s)).
Axiom thm_PSEMRESPROOF_MONO : forall w : form -> Prop, forall hyps1' : (form -> Prop) -> Prop, forall hyps2' : (form -> Prop) -> Prop, forall c : form -> Prop, ((psemresproof w hyps1' c) /\ (@subset (form -> Prop) hyps1' hyps2')) -> psemresproof w hyps2' c.
Axiom thm_PROPFLIP_INVOLUTE_CLAUSE : forall w : form -> Prop, forall cl : form -> Prop, (clause cl) -> (@IMAGE form form (propflip w) (@IMAGE form form (propflip w) cl)) = cl.
Axiom thm_PSEMRESPROOF_REFUTATION_COMPLETE : forall hyps' : (form -> Prop) -> Prop, forall w : form -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (psatisfiable (@GSPEC form (fun GEN_PVAR_621 : form => exists cl : form -> Prop, @SETSPEC form GEN_PVAR_621 (@IN (form -> Prop) cl hyps') (interp cl)))))) -> psemresproof w hyps' (@set0 form).
Axiom thm_posresproof_CASES : forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (posresproof hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : nat -> term, (a = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))) /\ ((posresproof hyps' cl1) /\ ((posresproof hyps' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_622 : form => exists p : form, @SETSPEC form GEN_PVAR_622 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_623 : form => exists p : form, @SETSPEC form GEN_PVAR_623 (@IN form p ps2) (FNot p))))) = i)))))))))))).
Axiom thm_posresproof_INDUCT : forall hyps' : (form -> Prop) -> Prop, forall posresproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> posresproof' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((posresproof' cl1) /\ ((posresproof' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_622 : form => exists p : form, @SETSPEC form GEN_PVAR_622 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_623 : form => exists p : form, @SETSPEC form GEN_PVAR_623 (@IN form p ps2) (FNot p))))) = i)))))))))) -> posresproof' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) -> forall a : form -> Prop, (posresproof hyps' a) -> posresproof' a.
Axiom thm_posresproof_RULES : forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> posresproof hyps' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((posresproof hyps' cl1) /\ ((posresproof hyps' cl2) /\ (((allpositive cl1) \/ (allpositive cl2)) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_622 : form => exists p : form, @SETSPEC form GEN_PVAR_622 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_623 : form => exists p : form, @SETSPEC form GEN_PVAR_623 (@IN form p ps2) (FNot p))))) = i)))))))))) -> posresproof hyps' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))).
Axiom thm_POSRESPROOF_CLAUSE : forall (hyps' : (form -> Prop) -> Prop), (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) -> forall cl : form -> Prop, (posresproof hyps' cl) -> clause cl.
Axiom thm_ALLPOSITIVE_INSTANCE_OF : forall cl1 : form -> Prop, forall cl2 : form -> Prop, ((instance_of cl1 cl2) /\ (allpositive cl1)) -> allpositive cl2.
Axiom thm_POSRESOLUTION_COMPLETE : forall (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M (@IMAGE (form -> Prop) form interp hyps')))))) -> posresproof hyps' (@set0 form).
Axiom thm_semresproof_CASES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (@semresproof A M hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : nat -> term, (a = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))) /\ ((@semresproof A M hyps' cl1) /\ ((@semresproof A M hyps' cl2) /\ (((~ (forall v : nat -> A, @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_629 : form => exists p : form, @SETSPEC form GEN_PVAR_629 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_630 : form => exists p : form, @SETSPEC form GEN_PVAR_630 (@IN form p ps2) (FNot p))))) = i)))))))))))).
Axiom thm_semresproof_INDUCT : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, forall semresproof' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> semresproof' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((semresproof' cl1) /\ ((semresproof' cl2) /\ (((~ (forall v : nat -> A, @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_629 : form => exists p : form, @SETSPEC form GEN_PVAR_629 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_630 : form => exists p : form, @SETSPEC form GEN_PVAR_630 (@IN form p ps2) (FNot p))))) = i)))))))))) -> semresproof' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) -> forall a : form -> Prop, (@semresproof A M hyps' a) -> semresproof' a.
Axiom thm_semresproof_RULES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> @semresproof A M hyps' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((@semresproof A M hyps' cl1) /\ ((@semresproof A M hyps' cl2) /\ (((~ (forall v : nat -> A, @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_629 : form => exists p : form, @SETSPEC form GEN_PVAR_629 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_630 : form => exists p : form, @SETSPEC form GEN_PVAR_630 (@IN form p ps2) (FNot p))))) = i)))))))))) -> @semresproof A M hyps' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))).
Axiom thm_SEMRESPROOF_CLAUSE : forall {_234123 : Type'} (M : prod (_234123 -> Prop) (prod (nat -> (seq _234123) -> _234123) (nat -> (seq _234123) -> Prop))) (hyps' : (form -> Prop) -> Prop), (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (@semresproof _234123 M hyps' c) -> clause c.
Axiom thm_semresproof2_CASES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, forall a : form -> Prop, (@semresproof2 A M hyps' a) = ((@IN (form -> Prop) a hyps') \/ (exists cl1 : form -> Prop, exists cl2 : form -> Prop, exists cl2' : form -> Prop, exists ps1 : form -> Prop, exists ps2 : form -> Prop, exists i : nat -> term, (a = (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))) /\ ((@semresproof2 A M hyps' cl1) /\ ((@semresproof2 A M hyps' cl2) /\ (((~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_636 : form => exists p : form, @SETSPEC form GEN_PVAR_636 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_637 : form => exists p : form, @SETSPEC form GEN_PVAR_637 (@IN form p ps2) (FNot p))))) = i)))))))))))).
Axiom thm_semresproof2_INDUCT : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, forall semresproof2' : (form -> Prop) -> Prop, ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> semresproof2' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((semresproof2' cl1) /\ ((semresproof2' cl2) /\ (((~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_636 : form => exists p : form, @SETSPEC form GEN_PVAR_636 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_637 : form => exists p : form, @SETSPEC form GEN_PVAR_637 (@IN form p ps2) (FNot p))))) = i)))))))))) -> semresproof2' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2))))) -> forall a : form -> Prop, (@semresproof2 A M hyps' a) -> semresproof2' a.
Axiom thm_semresproof2_RULES : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall hyps' : (form -> Prop) -> Prop, (forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> @semresproof2 A M hyps' cl) /\ (forall cl1 : form -> Prop, forall cl2 : form -> Prop, forall cl2' : form -> Prop, forall ps1 : form -> Prop, forall ps2 : form -> Prop, forall i : nat -> term, ((@semresproof2 A M hyps' cl1) /\ ((@semresproof2 A M hyps' cl2) /\ (((~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl1))) \/ (~ (forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp cl2)))) /\ (((@IMAGE form form (formsubst (rename cl2 (FVS cl1))) cl2) = cl2') /\ ((@subset form ps1 cl1) /\ ((@subset form ps2 cl2') /\ ((~ (ps1 = (@set0 form))) /\ ((~ (ps2 = (@set0 form))) /\ ((exists i' : nat -> term, Unifies i' (@setU form ps1 (@GSPEC form (fun GEN_PVAR_636 : form => exists p : form, @SETSPEC form GEN_PVAR_636 (@IN form p ps2) (FNot p))))) /\ ((mgu (@setU form ps1 (@GSPEC form (fun GEN_PVAR_637 : form => exists p : form, @SETSPEC form GEN_PVAR_637 (@IN form p ps2) (FNot p))))) = i)))))))))) -> @semresproof2 A M hyps' (@IMAGE form form (formsubst i) (@setU form (@setD form cl1 ps1) (@setD form cl2' ps2)))).
Axiom thm_SEMRESPROOF2_CLAUSE : forall {_234775 : Type'} (M : prod (_234775 -> Prop) (prod (nat -> (seq _234775) -> _234775) (nat -> (seq _234775) -> Prop))) (hyps' : (form -> Prop) -> Prop), (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (@semresproof2 _234775 M hyps' c) -> clause c.
Axiom thm_QFREE_HOLDS_PHOLDS : forall {_234790 : Type'} (M : prod (_234790 -> Prop) (prod (nat -> (seq _234790) -> _234790) (nat -> (seq _234790) -> Prop))) (v : nat -> _234790), forall p : form, (qfree p) -> (@holds _234790 M v p) = (pholds (@holds _234790 M v) p).
Axiom thm_LIFTING_FALSIFY : forall {_234809 _234875 : Type'} (i : nat -> term), forall p : form, forall M : prod (_234875 -> Prop) (prod (nat -> (seq _234875) -> _234875) (nat -> (seq _234875) -> Prop)), forall w : _234809, ((qfree p) /\ ((forall v : nat -> _234875, (@valuation _234875 M v) -> @holds _234875 M v p) /\ (forall x : nat, forall f : nat, forall l : seq _234875, ((@IN (prod nat nat) (@pair nat nat f (@size _234875 l)) (functions_term (i x))) /\ (@ALL _234875 (fun a : _234875 => @IN _234875 a (@Dom _234875 M)) l)) -> @IN _234875 (@Fun _234875 M f l) (@Dom _234875 M)))) -> forall w' : nat -> _234875, (@valuation _234875 M w') -> pholds (@holds _234875 M w') (formsubst i p).
Axiom thm_LIFTING_FALSITY_CLAUSE : forall {A : Type'} (A' : form -> Prop) (i : nat -> term) (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (A'' : form -> Prop), ((clause A') /\ ((A'' = (@IMAGE form form (formsubst i) A')) /\ ((forall v : nat -> A, (@valuation A M v) -> @holds A M v (interp A')) /\ (forall x : nat, forall f : nat, forall l : seq A, ((@IN (prod nat nat) (@pair nat nat f (@size A l)) (functions_term (i x))) /\ (@ALL A (fun a : A => @IN A a (@Dom A M)) l)) -> @IN A (@Fun A M f l) (@Dom A M))))) -> forall w : nat -> A, (@valuation A M w) -> pholds (@holds A M w) (interp A'').
Axiom thm_FUNCTIONS_FORM_INTERP : forall s : form -> Prop, (@finite_set form s) -> (functions_form (interp s)) = (functions s).
Axiom thm_FUNCTIONS_IMAGE_INTERP : forall s : (form -> Prop) -> Prop, (forall c : form -> Prop, (@IN (form -> Prop) c s) -> @finite_set form c) -> (functions (@IMAGE (form -> Prop) form interp s)) = (@UNIONS (prod nat nat) (@GSPEC ((prod nat nat) -> Prop) (fun GEN_PVAR_638 : (prod nat nat) -> Prop => exists p : form -> Prop, @SETSPEC ((prod nat nat) -> Prop) GEN_PVAR_638 (@IN (form -> Prop) p s) (functions p)))).
Axiom thm_FUNCTIONS_RESOLVE : forall (p : form) (cl1 : form -> Prop) (cl2 : form -> Prop), @subset (prod nat nat) (functions (resolve p cl1 cl2)) (@setU (prod nat nat) (functions cl1) (functions cl2)).
Axiom thm_PSEMRESPROOF_FUNCTIONS : forall (M : form -> Prop) (hyps' : (form -> Prop) -> Prop), (forall c : form -> Prop, (@IN (form -> Prop) c hyps') -> clause c) -> forall c : form -> Prop, (psemresproof M hyps' c) -> @subset (prod nat nat) (functions c) (functions (@IMAGE (form -> Prop) form interp hyps')).
Axiom thm_FUNCTIONS_TERM_NOCONSTANTS : forall t : term, (~ (exists c : nat, @IN (prod nat nat) (@pair nat nat c (NUMERAL O)) (functions_term t))) -> ~ ((free_variables_term t) = (@set0 nat)).
Axiom thm_HERBASE : forall (fns : (prod nat nat) -> Prop), forall t : term, (@IN term t (herbase fns)) = ((@subset (prod nat nat) (functions_term t) fns) /\ ((free_variables_term t) = (@COND (nat -> Prop) (exists c : nat, @IN (prod nat nat) (@pair nat nat c (NUMERAL O)) fns) (@set0 nat) (@INSERT nat (NUMERAL O) (@set0 nat))))).
Axiom thm_HERBASE_LEMMA : forall (fns : (prod nat nat) -> Prop) (x : nat) (j : nat -> term) (p : form) (i : nat -> term) (q : form), ((@subset (prod nat nat) (functions_form q) fns) /\ ((forall v : nat, @IN term (i v) (herbase fns)) /\ ((~ (@IN term (j x) (herbase fns))) /\ (@IN nat x (free_variables p))))) -> ~ ((formsubst j p) = (formsubst i q)).
Axiom thm_SEMRESOLUTION_COMPLETE : forall {A : Type'} (hyps' : (form -> Prop) -> Prop), ((forall cl : form -> Prop, (@IN (form -> Prop) cl hyps') -> clause cl) /\ (~ (exists M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (@interpretation term (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ (@satisfies term M (@IMAGE (form -> Prop) form interp hyps')))))) -> forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@interpretation A (language (@IMAGE (form -> Prop) form interp hyps')) M) /\ (~ ((@Dom A M) = (@set0 A)))) -> @semresproof2 A M hyps' (@set0 form).
Axiom thm_HOLDS_INTERP_SUBSUME : forall {A : Type'} (cl : form -> Prop) (M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop))) (cl' : form -> Prop), ((clause cl) /\ ((clause cl') /\ ((forall v : nat -> A, @holds A M v (interp cl)) /\ (subsumes cl cl')))) -> forall v : nat -> A, @holds A M v (interp cl').
Axiom thm_isaresolvent_sem : forall cl : form -> Prop, forall c1 : form -> Prop, forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall c2 : form -> Prop, (isaresolvent_sem M cl (@pair (form -> Prop) (form -> Prop) c1 c2)) = ((isaresolvent cl (@pair (form -> Prop) (form -> Prop) c1 c2)) /\ ((~ (forall v : nat -> nat, @holds nat M v (interp c1))) \/ (~ (forall v : nat -> nat, @holds nat M v (interp c2))))).
Axiom thm_allresolvents_sem : forall s1 : (form -> Prop) -> Prop, forall s2 : (form -> Prop) -> Prop, forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), (allresolvents_sem M s1 s2) = (@GSPEC (form -> Prop) (fun GEN_PVAR_648 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_648 (exists c1 : form -> Prop, exists c2 : form -> Prop, (@IN (form -> Prop) c1 s1) /\ ((@IN (form -> Prop) c2 s2) /\ (isaresolvent_sem M c (@pair (form -> Prop) (form -> Prop) c1 c2)))) c)).
Axiom thm_allntresolvents_sem : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall s1 : (form -> Prop) -> Prop, forall s2 : (form -> Prop) -> Prop, (allntresolvents_sem M s1 s2) = (@GSPEC (form -> Prop) (fun GEN_PVAR_649 : form -> Prop => exists r : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_649 ((@IN (form -> Prop) r (allresolvents_sem M s1 s2)) /\ (~ (tautologous r))) r)).
Axiom thm_ISARESOLVENT_SEM_SYM : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall c1 : form -> Prop, forall c2 : form -> Prop, forall cl : form -> Prop, ((clause c1) /\ ((clause c2) /\ (isaresolvent_sem M cl (@pair (form -> Prop) (form -> Prop) c2 c1)))) -> exists cl' : form -> Prop, (isaresolvent_sem M cl' (@pair (form -> Prop) (form -> Prop) c1 c2)) /\ (subsumes cl' cl).
Axiom thm_ALLRESOLVENTS_SEM_SYM : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (B : (form -> Prop) -> Prop) (A : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c A) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c)) -> SUBSUMES (allresolvents_sem M A B) (allresolvents_sem M B A).
Axiom thm_ALLRESOLVENTS_SEM_UNION : forall (B : (form -> Prop) -> Prop) (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (A : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((allresolvents_sem M (@setU (form -> Prop) A B) C) = (@setU (form -> Prop) (allresolvents_sem M A C) (allresolvents_sem M B C))) /\ ((allresolvents_sem M A (@setU (form -> Prop) B C)) = (@setU (form -> Prop) (allresolvents_sem M A B) (allresolvents_sem M A C))).
Axiom thm_ALLRESOLVENTS_SEM_STEP : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (A : (form -> Prop) -> Prop) (B : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c C) -> clause c)) -> SUBSUMES (@setU (form -> Prop) (allresolvents_sem M B (@setU (form -> Prop) A B)) (allresolvents_sem M C (@setU (form -> Prop) A (@setU (form -> Prop) B C)))) (allresolvents_sem M (@setU (form -> Prop) B C) (@setU (form -> Prop) A (@setU (form -> Prop) B C))).
Axiom thm_resolvents_sem : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall cl : form -> Prop, forall cls : seq (form -> Prop), (resolvents_sem M cl cls) = (@list_of_set (form -> Prop) (allresolvents_sem M (@INSERT (form -> Prop) cl (@set0 (form -> Prop))) (@set_of_list (form -> Prop) cls))).
Axiom thm_ISARESOLVENT_SEM_CLAUSE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) p q)))) -> clause r.
Axiom thm_ALLRESOLVENTS_SEM_CLAUSE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (s : (form -> Prop) -> Prop) (t : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c)) -> forall c : form -> Prop, (@IN (form -> Prop) c (allresolvents_sem M s t)) -> clause c.
Axiom thm_ISARESOLVENT_SEM_FINITE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall c1 : form -> Prop, forall c2 : form -> Prop, ((clause c1) /\ (clause c2)) -> @finite_set (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_651 : form -> Prop => exists c : form -> Prop, @SETSPEC (form -> Prop) GEN_PVAR_651 (isaresolvent_sem M c (@pair (form -> Prop) (form -> Prop) c1 c2)) c)).
Axiom thm_ALLRESOLVENTS_SEM_FINITE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, ((@finite_set (form -> Prop) s) /\ ((@finite_set (form -> Prop) t) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c)))) -> @finite_set (form -> Prop) (allresolvents_sem M s t).
Axiom thm_step_sem : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall unused : seq (form -> Prop), forall used : seq (form -> Prop), (step_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)) = (@COND (prod (seq (form -> Prop)) (seq (form -> Prop))) (unused = (@nil (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) (@LET (seq (form -> Prop)) (prod (seq (form -> Prop)) (seq (form -> Prop))) (fun new : seq (form -> Prop) => @LET_END (prod (seq (form -> Prop)) (seq (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) (@insert (form -> Prop) (@HD (form -> Prop) unused) used) (@ITLIST (form -> Prop) (seq (form -> Prop)) (incorporate (@HD (form -> Prop) unused)) new (@TL (form -> Prop) unused)))) (resolvents_sem M (@HD (form -> Prop) unused) (@cons (form -> Prop) (@HD (form -> Prop) unused) used)))).
Axiom thm_STEP_SEM : forall (cls : seq (form -> Prop)) (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (cl : form -> Prop) (used : seq (form -> Prop)), ((step_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@nil (form -> Prop)))) = (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@nil (form -> Prop)))) /\ ((step_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used (@cons (form -> Prop) cl cls))) = (@LET (seq (form -> Prop)) (prod (seq (form -> Prop)) (seq (form -> Prop))) (fun new : seq (form -> Prop) => @LET_END (prod (seq (form -> Prop)) (seq (form -> Prop))) (@pair (seq (form -> Prop)) (seq (form -> Prop)) (@insert (form -> Prop) cl used) (@ITLIST (form -> Prop) (seq (form -> Prop)) (incorporate cl) new cls))) (resolvents_sem M cl (@cons (form -> Prop) cl used)))).
Axiom thm_given_sem : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (n : nat) (p : prod (seq (form -> Prop)) (seq (form -> Prop))), ((given_sem M (NUMERAL O) p) = p) /\ ((given_sem M (S n) p) = (step_sem M (given_sem M n p))).
Axiom thm_Used_SEM : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall n : nat, forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), (Used_SEM M init n) = (@set_of_list (form -> Prop) (@fst (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n init))).
Axiom thm_Unused_SEM : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall n : nat, forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), (Unused_SEM M init n) = (@set_of_list (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n init))).
Axiom thm_Sub_SEM : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (init : prod (seq (form -> Prop)) (seq (form -> Prop))) (n : nat), ((Sub_SEM M init (NUMERAL O)) = (@set0 (form -> Prop))) /\ ((Sub_SEM M init (S n)) = (@COND ((form -> Prop) -> Prop) ((@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n init)) = (@nil (form -> Prop))) (Sub_SEM M init n) (@INSERT (form -> Prop) (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n init))) (Sub_SEM M init n)))).
Axiom thm_ALLNTRESOLVENTS_SEM_STEP : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (A : (form -> Prop) -> Prop) (B : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((forall c : form -> Prop, (@IN (form -> Prop) c B) -> clause c) /\ (forall c : form -> Prop, (@IN (form -> Prop) c C) -> clause c)) -> SUBSUMES (@setU (form -> Prop) (allntresolvents_sem M B (@setU (form -> Prop) A B)) (allntresolvents_sem M C (@setU (form -> Prop) A (@setU (form -> Prop) B C)))) (allntresolvents_sem M (@setU (form -> Prop) B C) (@setU (form -> Prop) A (@setU (form -> Prop) B C))).
Axiom thm_ALLNTRESOLVENTS_SEM_UNION : forall (B : (form -> Prop) -> Prop) (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (A : (form -> Prop) -> Prop) (C : (form -> Prop) -> Prop), ((allntresolvents_sem M (@setU (form -> Prop) A B) C) = (@setU (form -> Prop) (allntresolvents_sem M A C) (allntresolvents_sem M B C))) /\ ((allntresolvents_sem M A (@setU (form -> Prop) B C)) = (@setU (form -> Prop) (allntresolvents_sem M A B) (allntresolvents_sem M A C))).
Axiom thm_USED_SUB : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall n : nat, (Used_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) = (@setU (form -> Prop) (@set_of_list (form -> Prop) used) (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)).
Axiom thm_GIVEN_INVARIANT : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall n : nat, (forall c : form -> Prop, (@IN (form -> Prop) c (Used_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c (Unused_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> clause c) /\ (SUBSUMES (@setU (form -> Prop) (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) (Unused_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) (allntresolvents_sem M (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) (@setU (form -> Prop) (@set_of_list (form -> Prop) used) (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)))))).
Axiom thm_SUB_MONO_SUBSET : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall m : nat, forall n : nat, (leqn m n) -> @subset (form -> Prop) (Sub_SEM M init m) (Sub_SEM M init n).
Axiom thm_SUB_MONO : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall m : nat, forall n : nat, (leqn m n) -> SUBSUMES (Sub_SEM M init n) (Sub_SEM M init m).
Axiom thm_LENGTH_REPLACE : forall cl : form -> Prop, forall current : seq (form -> Prop), leqn (@size (form -> Prop) current) (@size (form -> Prop) (replace cl current)).
Axiom thm_LENGTH_INCORPORATE : forall gcl : form -> Prop, forall cl : form -> Prop, forall current : seq (form -> Prop), leqn (@size (form -> Prop) current) (@size (form -> Prop) (incorporate gcl cl current)).
Axiom thm_LENGTH_UNUSED_CHANGE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall m : nat, forall n : nat, leqn (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m init))) (addn (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M (addn m n) init))) n).
Axiom thm_LENGTH_UNUSED_ZERO : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall m : nat, forall n : nat, ((@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused))) = (@nil (form -> Prop))) -> (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M (addn m n) (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused))) = (@nil (form -> Prop)).
Axiom thm_REPLACE_SUBSUMES_SELF : forall cl : form -> Prop, forall current : seq (form -> Prop), forall n : nat, (ltn n (@size (form -> Prop) current)) -> subsumes (@EL (form -> Prop) n (replace cl current)) (@EL (form -> Prop) n current).
Axiom thm_INCORPORATE_SUBSUMES_SELF : forall gcl : form -> Prop, forall cl : form -> Prop, forall current : seq (form -> Prop), forall n : nat, (ltn n (@size (form -> Prop) current)) -> subsumes (@EL (form -> Prop) n (incorporate gcl cl current)) (@EL (form -> Prop) n current).
Axiom thm_REPLACE_CLAUSE : forall cl : form -> Prop, forall current : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c current) -> clause c) /\ (clause cl)) -> forall c : form -> Prop, (@MEM (form -> Prop) c (replace cl current)) -> clause c.
Axiom thm_INCORPORATE_CLAUSE : forall (gcl : form -> Prop) (cl : form -> Prop) (current : seq (form -> Prop)), ((forall c : form -> Prop, (@MEM (form -> Prop) c current) -> clause c) /\ (clause cl)) -> forall c : form -> Prop, (@MEM (form -> Prop) c (incorporate gcl cl current)) -> clause c.
Axiom thm_INCORPORATE_CLAUSE_EL : forall (p : nat) (gcl : form -> Prop) (cl : form -> Prop) (current : seq (form -> Prop)), ((forall c : form -> Prop, (@MEM (form -> Prop) c current) -> clause c) /\ ((clause cl) /\ (ltn p (@size (form -> Prop) current)))) -> clause (@EL (form -> Prop) p (incorporate gcl cl current)).
Axiom thm_UNUSED_SUBSUMES_SELF : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall k : nat, forall m : nat, forall n : nat, (ltn (addn n k) (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused))))) -> subsumes (@EL (form -> Prop) n (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M (addn m k) (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@EL (form -> Prop) (addn n k) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))).
Axiom thm_SUB_SUBSUMES_UNUSED : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (used : seq (form -> Prop)) (unused : seq (form -> Prop)), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall n : nat, SUBSUMES (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) (addn n (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))))) (@setU (form -> Prop) (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) (Unused_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)).
Axiom thm_break_sem : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))) (n : nat) (init : prod (seq (form -> Prop)) (seq (form -> Prop))), ((break_sem M init (NUMERAL O)) = (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M (NUMERAL O) init)))) /\ ((break_sem M init (S n)) = (addn (break_sem M init n) (@size (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M (break_sem M init n) init))))).
Axiom thm_level_sem : forall M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop)), forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall n : nat, (level_sem M init n) = (Sub_SEM M init (break_sem M init n)).
Axiom thm_LEVEL_0 : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> SUBSUMES (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) (NUMERAL O)) (@set_of_list (form -> Prop) unused).
Axiom thm_LEVEL_STEP : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall n : nat, SUBSUMES (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) (S n)) (allntresolvents_sem M (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) (@setU (form -> Prop) (@set_of_list (form -> Prop) used) (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n))).
Axiom thm_level_CLAUSE : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall n : nat, forall c : form -> Prop, (@IN (form -> Prop) c (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> clause c.
Axiom thm_BREAK_MONO : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall init : prod (seq (form -> Prop)) (seq (form -> Prop)), forall m : nat, forall n : nat, (leqn m n) -> leqn (break_sem M init m) (break_sem M init n).
Axiom thm_level_MONO_SUBSET : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall m : nat, forall n : nat, (leqn m n) -> @subset (form -> Prop) (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) m) (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n).
Axiom thm_level_MONO : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), ((forall c : form -> Prop, (@MEM (form -> Prop) c used) -> clause c) /\ (forall c : form -> Prop, (@MEM (form -> Prop) c unused) -> clause c)) -> forall m : nat, forall n : nat, (leqn m n) -> SUBSUMES (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n) (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) m).
Axiom thm_ISARESOLVENT_SEM_SUBSUME_L : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall p' : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause p') /\ ((clause q) /\ ((subsumes p' p) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) p q)))))) -> (subsumes p' r) \/ (exists r' : form -> Prop, (isaresolvent_sem M r' (@pair (form -> Prop) (form -> Prop) p' q)) /\ (subsumes r' r)).
Axiom thm_ISARESOLVENT_SEM_SUBSUME_R : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall q : form -> Prop, forall q' : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((clause q') /\ ((subsumes q' q) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) p q)))))) -> (subsumes q' r) \/ (exists r' : form -> Prop, (isaresolvent_sem M r' (@pair (form -> Prop) (form -> Prop) p q')) /\ (subsumes r' r)).
Axiom thm_ISARESOLVENT_SEM_SUBSUME : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall p' : form -> Prop, forall q : form -> Prop, forall q' : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause p') /\ ((clause q) /\ ((clause q') /\ ((subsumes p' p) /\ ((subsumes q' q) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) p q)))))))) -> (subsumes p' r) \/ ((subsumes q' r) \/ (exists r' : form -> Prop, (isaresolvent_sem M r' (@pair (form -> Prop) (form -> Prop) p' q')) /\ (subsumes r' r))).
Axiom thm_ALLRESOLVENTS_SEM_SUBSUME_L : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c u) -> clause c) /\ (SUBSUMES s t)))) -> SUBSUMES (@setU (form -> Prop) s (allresolvents_sem M s u)) (allresolvents_sem M t u).
Axiom thm_ALLRESOLVENTS_SEM_SUBSUME_R : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall u : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c u) -> clause c) /\ (SUBSUMES t u)))) -> SUBSUMES (@setU (form -> Prop) t (allresolvents_sem M s t)) (allresolvents_sem M s u).
Axiom thm_ALLRESOLVENTS_SEM_SUBSUME : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall s : (form -> Prop) -> Prop, forall t : (form -> Prop) -> Prop, forall s' : (form -> Prop) -> Prop, forall t' : (form -> Prop) -> Prop, ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c s') -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t) -> clause c) /\ ((forall c : form -> Prop, (@IN (form -> Prop) c t') -> clause c) /\ ((SUBSUMES s s') /\ (SUBSUMES t t')))))) -> SUBSUMES (@setU (form -> Prop) s (@setU (form -> Prop) t (allresolvents_sem M s t))) (allresolvents_sem M s' t').
Axiom thm_ISARESOLVENT_SEM_TAUTOLOGY_L : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((tautologous p) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) p q))))) -> (tautologous r) \/ (subsumes q r).
Axiom thm_TAUTOLOGOUS_SUBSUMES : forall p : form -> Prop, forall q : form -> Prop, ((subsumes p q) /\ (tautologous p)) -> tautologous q.
Axiom thm_ISARESOLVENT_SEM_TAUTOLOGY_R : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall p : form -> Prop, forall q : form -> Prop, forall r : form -> Prop, ((clause p) /\ ((clause q) /\ ((tautologous p) /\ (isaresolvent_sem M r (@pair (form -> Prop) (form -> Prop) q p))))) -> (tautologous r) \/ (subsumes q r).
Axiom thm_UNUSED_FROMNEW : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall c : form -> Prop, forall n : nat, (@MEM (form -> Prop) c (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M n (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) -> (@MEM (form -> Prop) c unused) \/ (exists m : nat, (ltn m n) /\ (@MEM (form -> Prop) c (resolvents_sem M (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@cons (form -> Prop) (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@fst (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused))))))).
Axiom thm_SUB_FROMNEW : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall c : form -> Prop, forall n : nat, (@IN (form -> Prop) c (Sub_SEM M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> (@MEM (form -> Prop) c unused) \/ (exists m : nat, (ltn m n) /\ (@MEM (form -> Prop) c (resolvents_sem M (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@cons (form -> Prop) (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@fst (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused))))))).
Axiom thm_LEVEL_FROMNEW : forall (M : prod (nat -> Prop) (prod (nat -> (seq nat) -> nat) (nat -> (seq nat) -> Prop))), forall used : seq (form -> Prop), forall unused : seq (form -> Prop), forall c : form -> Prop, forall n : nat, (@IN (form -> Prop) c (level_sem M (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused) n)) -> (@MEM (form -> Prop) c unused) \/ (exists m : nat, @MEM (form -> Prop) c (resolvents_sem M (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@cons (form -> Prop) (@HD (form -> Prop) (@snd (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))) (@fst (seq (form -> Prop)) (seq (form -> Prop)) (given_sem M m (@pair (seq (form -> Prop)) (seq (form -> Prop)) used unused)))))).
Axiom thm_SATISFIES_IMAGE : forall {_241037 _241064 : Type'} (s : _241064 -> Prop) (M : prod (_241037 -> Prop) (prod (nat -> (seq _241037) -> _241037) (nat -> (seq _241037) -> Prop))) (f : _241064 -> form), (@satisfies _241037 M (@IMAGE _241064 form f s)) = (forall x : _241064, forall v : nat -> _241037, ((@valuation _241037 M v) /\ (@IN _241064 x s)) -> @holds _241037 M v (f x)).
Axiom thm_definite : forall cl : form -> Prop, (definite cl) = ((clause cl) /\ ((@CARD form (@GSPEC form (fun GEN_PVAR_652 : form => exists p : form, @SETSPEC form GEN_PVAR_652 ((@IN form p cl) /\ (positive p)) p))) = (NUMERAL (BIT1 O)))).
Axiom thm_horn : forall cl : form -> Prop, (horn cl) = ((clause cl) /\ (leqn (@CARD form (@GSPEC form (fun GEN_PVAR_653 : form => exists p : form, @SETSPEC form GEN_PVAR_653 ((@IN form p cl) /\ (positive p)) p))) (NUMERAL (BIT1 O)))).
Axiom thm_DEFINITE_IMP_HORN : forall cl : form -> Prop, (definite cl) -> horn cl.
Axiom thm_falsify : forall ff : form, forall cl : form -> Prop, (falsify ff cl) = (@COND (form -> Prop) (definite cl) cl (@INSERT form ff cl)).
Axiom thm_FALSIFY_FINITE : forall (ff : form) (cl : form -> Prop), (@finite_set form cl) -> @finite_set form (falsify ff cl).
Axiom thm_FALSIFY_DEFINITE : forall (P : nat) (args : seq term) (cl : form -> Prop), (horn cl) -> definite (falsify (Atom P args) cl).
Axiom thm_HOLDS_FALSIFY : forall {_241335 : Type'} (M : prod (_241335 -> Prop) (prod (nat -> (seq _241335) -> _241335) (nat -> (seq _241335) -> Prop))) (v : nat -> _241335) (ff : form) (cl : form -> Prop), ((@finite_set form cl) /\ (@holds _241335 M v (interp cl))) -> @holds _241335 M v (interp (falsify ff cl)).
Axiom thm_REDUCE_HORN_DEFINITE : forall {A : Type'} (U : A -> Prop) (s : (form -> Prop) -> Prop) (ff : nat), ((forall c : form -> Prop, (@IN (form -> Prop) c s) -> clause c) /\ ((~ (@IN form (Atom ff (@nil term)) (@UNIONS form s))) /\ (~ (@IN form (Not (Atom ff (@nil term))) (@UNIONS form s))))) -> (~ (@satisfiable A U (@IMAGE (form -> Prop) form interp s))) = (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((~ ((@Dom A M) = (@set0 A))) /\ (@satisfies A M (@IMAGE (form -> Prop) form interp (@IMAGE (form -> Prop) (form -> Prop) (falsify (Atom ff (@nil term))) s)))) -> forall v : nat -> A, (@valuation A M v) -> @holds A M v (Atom ff (@nil term))).
Axiom thm_minmodel : forall s : form -> Prop, (minmodel s) = (@pair (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)) (herbase (functions s)) (@pair (nat -> (seq term) -> term) (nat -> (seq term) -> Prop) Fn (fun p : nat => fun zs : seq term => forall H : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (((@Dom term H) = (herbase (functions s))) /\ (((@Fun term H) = Fn) /\ (@satisfies term H s))) -> @Pred term H p zs))).
Axiom thm_MINMODEL_MINIMAL : forall p : form, forall v : nat -> term, forall s : form -> Prop, (atom p) -> (@holds term (minmodel s) v p) = (forall H : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (((@Dom term H) = (herbase (functions s))) /\ (((@Fun term H) = Fn) /\ (@satisfies term H s))) -> @holds term H v p).
Axiom thm_HOLDS_ITLIST_IMP : forall {_241838 : Type'}, forall M : prod (_241838 -> Prop) (prod (nat -> (seq _241838) -> _241838) (nat -> (seq _241838) -> Prop)), forall v : nat -> _241838, forall asm : seq form, forall c : form, (@holds _241838 M v (@ITLIST form form FImp asm c)) = ((exists p : form, (@MEM form p asm) /\ (~ (@holds _241838 M v p))) \/ (@holds _241838 M v c)).
Axiom thm_breakhorn : forall cl : form -> Prop, (breakhorn cl) = (@COND (prod (seq form) form) (definite cl) (@LET form (prod (seq form) form) (fun p : form => @LET_END (prod (seq form) form) (@pair (seq form) form (@map form form FNot (@list_of_set form (@DELETE form cl p))) p)) (@ε form (fun p : form => (@IN form p cl) /\ (positive p)))) (@pair (seq form) form (@map form form FNot (@list_of_set form cl)) FFalse)).
Axiom thm_hypotheses : forall cl : form -> Prop, (hypotheses cl) = (@fst (seq form) form (breakhorn cl)).
Axiom thm_conclusion : forall cl : form -> Prop, (conclusion cl) = (@snd (seq form) form (breakhorn cl)).
Axiom thm_HOLDS_HORN : forall {A : Type'}, forall cl : form -> Prop, (horn cl) -> (@ALL form atom (hypotheses cl)) /\ ((@COND Prop (definite cl) (atom (conclusion cl)) ((conclusion cl) = FFalse)) /\ (forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall v : nat -> A, (@holds A M v (interp cl)) = (@holds A M v (@ITLIST form form FImp (hypotheses cl) (conclusion cl))))).
Axiom thm_MINMODEL_MODEL : forall (s : (form -> Prop) -> Prop), (forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) -> @satisfies term (minmodel (@IMAGE (form -> Prop) form interp s)) (@IMAGE (form -> Prop) form interp s).
Axiom thm_CONCLUSION_DEFINITE : forall cl : form -> Prop, forall p : form, ((definite cl) /\ ((@IN form p cl) /\ (positive p))) -> (conclusion cl) = p.
Axiom thm_CONCLUSION_DEFINITE_ALT : forall cl : form -> Prop, forall p : form, ((clause cl) /\ ((@IN form p cl) /\ ((positive p) /\ (forall q : form, ((@IN form q cl) /\ (~ (q = p))) -> negative q)))) -> (conclusion cl) = p.
Axiom thm_HYPOTHESES_CONCLUSION : forall cl : form -> Prop, (definite cl) -> (@set_of_list form (hypotheses cl)) = (@IMAGE form form FNot (@DELETE form cl (conclusion cl))).
Axiom thm_gbackchain_CASES : forall s : (form -> Prop) -> Prop, forall a0 : nat, forall a1 : form, (gbackchain s a0 a1) = (exists cl : form -> Prop, exists i : nat -> term, exists ns : seq nat, (a0 = (@ITLIST nat nat addn ns (NUMERAL (BIT1 O)))) /\ ((a1 = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (herbase (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form (gbackchain s) ns (@map form form (formsubst i) (hypotheses cl))))))).
Axiom thm_gbackchain_INDUCT : forall s : (form -> Prop) -> Prop, forall gbackchain' : nat -> form -> Prop, (forall cl : form -> Prop, forall i : nat -> term, forall ns : seq nat, ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (herbase (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form gbackchain' ns (@map form form (formsubst i) (hypotheses cl))))) -> gbackchain' (@ITLIST nat nat addn ns (NUMERAL (BIT1 O))) (formsubst i (conclusion cl))) -> forall a0 : nat, forall a1 : form, (gbackchain s a0 a1) -> gbackchain' a0 a1.
Axiom thm_gbackchain_RULES : forall s : (form -> Prop) -> Prop, forall cl : form -> Prop, forall i : nat -> term, forall ns : seq nat, ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (herbase (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form (gbackchain s) ns (@map form form (formsubst i) (hypotheses cl))))) -> gbackchain s (@ITLIST nat nat addn ns (NUMERAL (BIT1 O))) (formsubst i (conclusion cl)).
Axiom thm_ALL2_TRIV : forall {_242516 _242518 : Type'} (P : _242516 -> Prop), forall l1 : seq _242518, forall l2 : seq _242516, (@ALL2 _242518 _242516 (fun n : _242518 => P) l1 l2) = (((@size _242518 l1) = (@size _242516 l2)) /\ (@ALL _242516 P l2)).
Axiom thm_GBACKCHAIN_SOUND : forall (s : (form -> Prop) -> Prop) (v : nat -> term), ((forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) /\ (@valuation term (minmodel (@IMAGE (form -> Prop) form interp s)) v)) -> forall n : nat, forall p : form, (gbackchain s n p) -> @holds term (minmodel (@IMAGE (form -> Prop) form interp s)) v p.
Axiom thm_GBACKCHAIN_COMPLETE : forall (s : (form -> Prop) -> Prop) (p : form), ((forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) /\ ((atom p) /\ (((free_variables p) = (@set0 nat)) /\ (forall v : nat -> term, @holds term (minmodel (@IMAGE (form -> Prop) form interp s)) v p)))) -> exists n : nat, gbackchain s n p.
Axiom thm_GBACKCHAIN_MINIMAL : forall s : (form -> Prop) -> Prop, forall p : form, ((forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) /\ ((atom p) /\ ((free_variables p) = (@set0 nat)))) -> forall v : nat -> term, (@holds term (minmodel (@IMAGE (form -> Prop) form interp s)) v p) = (exists n : nat, gbackchain s n p).
Axiom thm_iminmodel : forall s : form -> Prop, (iminmodel s) = (@pair (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)) (terms (functions s)) (@pair (nat -> (seq term) -> term) (nat -> (seq term) -> Prop) Fn (fun p : nat => fun zs : seq term => forall C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (((@Dom term C) = (terms (functions s))) /\ (((@Fun term C) = Fn) /\ (forall v : nat -> term, forall p' : form, ((@IN form p' s) /\ (@valuation term C v)) -> @holds term C v p'))) -> @Pred term C p zs))).
Axiom thm_IMINMODEL_MINIMAL : forall p : form, forall v : nat -> term, forall s : form -> Prop, (atom p) -> (@holds term (iminmodel s) v p) = (forall C : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), (((@Dom term C) = (terms (functions s))) /\ (((@Fun term C) = Fn) /\ (forall v' : nat -> term, forall q : form, ((@IN form q s) /\ (@valuation term C v')) -> @holds term C v' q))) -> @holds term C v p).
Axiom thm_IMINMODEL_MODEL : forall (s : (form -> Prop) -> Prop), (forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) -> forall v : nat -> term, forall p : form -> Prop, ((@IN (form -> Prop) p s) /\ (forall x : nat, @IN term (v x) (terms (functions (@IMAGE (form -> Prop) form interp s))))) -> @holds term (iminmodel (@IMAGE (form -> Prop) form interp s)) v (interp p).
Axiom thm_IMINMODEL_INTERPRETATION : forall s : form -> Prop, @interpretation term (language s) (iminmodel s).
Axiom thm_ibackchain_CASES : forall s : (form -> Prop) -> Prop, forall a0 : nat, forall a1 : form, (ibackchain s a0 a1) = (exists cl : form -> Prop, exists i : nat -> term, exists ns : seq nat, (a0 = (@ITLIST nat nat addn ns (NUMERAL (BIT1 O)))) /\ ((a1 = (formsubst i (conclusion cl))) /\ ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form (ibackchain s) ns (@map form form (formsubst i) (hypotheses cl))))))).
Axiom thm_ibackchain_INDUCT : forall s : (form -> Prop) -> Prop, forall ibackchain' : nat -> form -> Prop, (forall cl : form -> Prop, forall i : nat -> term, forall ns : seq nat, ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form ibackchain' ns (@map form form (formsubst i) (hypotheses cl))))) -> ibackchain' (@ITLIST nat nat addn ns (NUMERAL (BIT1 O))) (formsubst i (conclusion cl))) -> forall a0 : nat, forall a1 : form, (ibackchain s a0 a1) -> ibackchain' a0 a1.
Axiom thm_ibackchain_RULES : forall s : (form -> Prop) -> Prop, forall cl : form -> Prop, forall i : nat -> term, forall ns : seq nat, ((@IN (form -> Prop) cl s) /\ ((forall x : nat, @IN term (i x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) /\ (@ALL2 nat form (ibackchain s) ns (@map form form (formsubst i) (hypotheses cl))))) -> ibackchain s (@ITLIST nat nat addn ns (NUMERAL (BIT1 O))) (formsubst i (conclusion cl)).
Axiom thm_IBACKCHAIN_SOUND : forall (s : (form -> Prop) -> Prop), (forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) -> forall v : nat -> term, forall n : nat, forall p : form, ((ibackchain s n p) /\ (forall x : nat, @IN term (v x) (terms (functions (@IMAGE (form -> Prop) form interp s))))) -> @holds term (iminmodel (@IMAGE (form -> Prop) form interp s)) v p.
Axiom thm_IBACKCHAIN_COMPLETE : forall (s : (form -> Prop) -> Prop) (p : form), ((forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) /\ ((atom p) /\ (forall v : nat -> term, (forall x : nat, @IN term (v x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) -> @holds term (iminmodel (@IMAGE (form -> Prop) form interp s)) v p))) -> exists n : nat, ibackchain s n p.
Axiom thm_IBACKCHAIN_MINIMAL : forall s : (form -> Prop) -> Prop, forall p : form, ((forall cl : form -> Prop, (@IN (form -> Prop) cl s) -> definite cl) /\ (atom p)) -> (forall v : nat -> term, (forall x : nat, @IN term (v x) (terms (functions (@IMAGE (form -> Prop) form interp s)))) -> @holds term (iminmodel (@IMAGE (form -> Prop) form interp s)) v p) = (exists n : nat, ibackchain s n p).
Axiom thm_ALL2_SYM : forall {_244062 _244063 : Type'} (P : _244063 -> _244062 -> Prop), forall l1 : seq _244063, forall l2 : seq _244062, (@ALL2 _244063 _244062 P l1 l2) = (@ALL2 _244062 _244063 (fun x : _244062 => fun y : _244063 => P y x) l2 l1).
Axiom thm_MAP_EQ_ALL2 : forall {_244092 _244103 : Type'}, forall f : _244092 -> _244103, forall l1 : seq _244092, forall l2 : seq _244092, (@ALL2 _244092 _244092 (fun x : _244092 => fun y : _244092 => (f x) = (f y)) l1 l2) -> (@map _244092 _244103 f l1) = (@map _244092 _244103 f l2).
Axiom thm_FORMSUBST_EQ : forall i : nat -> term, forall s : term, forall t : term, (formsubst i (FEq s t)) = (FEq (termsubst i s) (termsubst i t)).
Axiom thm_TERMS_UNIV : (terms (@setT (prod nat nat))) = (@setT term).
Axiom thm_FUNCTIONS_UNIV : (functions (@setT form)) = (@setT (prod nat nat)).
Axiom thm_PREDICATES_UNIV : (predicates (@setT form)) = (@setT (prod nat nat)).
Axiom thm_LANGUAGE_UNIV : (language (@setT form)) = (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (@setT (prod nat nat)) (@setT (prod nat nat))).
Axiom thm_EQUAL_INJ : forall s : term, forall t : term, forall u : term, forall v : term, ((FEq s t) = (FEq u v)) = ((s = u) /\ (t = v)).
Axiom thm_EQUAL_INJ_ALT : forall s : term, forall t : term, forall u : term, forall v : term, ((FEq s t) = (FEq u v)) = ((u = s) /\ (v = t)).
Axiom thm_provable_CASES : forall E : form -> Prop, forall a : form, (provable E a) = ((exists s : term, exists t : term, (a = (FEq s t)) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a = (FEq t t)) \/ ((exists s : term, exists t : term, (a = (FEq t s)) /\ (provable E (FEq s t))) \/ ((exists s : term, exists t : term, exists u : term, (a = (FEq s u)) /\ ((provable E (FEq s t)) /\ (provable E (FEq t u)))) \/ ((exists f : nat, exists a' : seq term, exists b : seq term, (a = (FEq (Fn f a') (Fn f b))) /\ (@ALL2 term term (fun l : term => fun r : term => provable E (FEq l r)) a' b)) \/ (exists s : term, exists t : term, exists i : nat -> term, (a = (formsubst i (FEq s t))) /\ (provable E (FEq s t)))))))).
Axiom thm_provable_INDUCT : forall E : form -> Prop, forall vdash' : form -> Prop, ((forall s : term, forall t : term, (@IN form (FEq s t) E) -> vdash' (FEq s t)) /\ ((forall t : term, vdash' (FEq t t)) /\ ((forall s : term, forall t : term, (vdash' (FEq s t)) -> vdash' (FEq t s)) /\ ((forall s : term, forall t : term, forall u : term, ((vdash' (FEq s t)) /\ (vdash' (FEq t u))) -> vdash' (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => vdash' (FEq l r)) a b) -> vdash' (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, forall i : nat -> term, (vdash' (FEq s t)) -> vdash' (formsubst i (FEq s t)))))))) -> forall a : form, (provable E a) -> vdash' a.
Axiom thm_provable_RULES : forall E : form -> Prop, (forall s : term, forall t : term, (@IN form (FEq s t) E) -> provable E (FEq s t)) /\ ((forall t : term, provable E (FEq t t)) /\ ((forall s : term, forall t : term, (provable E (FEq s t)) -> provable E (FEq t s)) /\ ((forall s : term, forall t : term, forall u : term, ((provable E (FEq s t)) /\ (provable E (FEq t u))) -> provable E (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => provable E (FEq l r)) a b) -> provable E (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, forall i : nat -> term, (provable E (FEq s t)) -> provable E (formsubst i (FEq s t))))))).
Axiom thm_wcprovable_CASES : forall E : form -> Prop, forall a : form, (wcprovable E a) = ((exists s : term, exists t : term, exists i : nat -> term, (a = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ ((exists s : term, exists t : term, exists i : nat -> term, (a = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E)) \/ ((exists t : term, a = (FEq t t)) \/ ((exists s : term, exists t : term, exists u : term, (a = (FEq s u)) /\ ((wcprovable E (FEq s t)) /\ (wcprovable E (FEq t u)))) \/ (exists f : nat, exists a' : seq term, exists b : seq term, (a = (FEq (Fn f a') (Fn f b))) /\ (@ALL2 term term (fun l : term => fun r : term => wcprovable E (FEq l r)) a' b)))))).
Axiom thm_wcprovable_INDUCT : forall E : form -> Prop, forall vdash2' : form -> Prop, ((forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> vdash2' (formsubst i (FEq s t))) /\ ((forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> vdash2' (formsubst i (FEq t s))) /\ ((forall t : term, vdash2' (FEq t t)) /\ ((forall s : term, forall t : term, forall u : term, ((vdash2' (FEq s t)) /\ (vdash2' (FEq t u))) -> vdash2' (FEq s u)) /\ (forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => vdash2' (FEq l r)) a b) -> vdash2' (FEq (Fn f a) (Fn f b))))))) -> forall a : form, (wcprovable E a) -> vdash2' a.
Axiom thm_wcprovable_RULES : forall E : form -> Prop, (forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> wcprovable E (formsubst i (FEq s t))) /\ ((forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> wcprovable E (formsubst i (FEq t s))) /\ ((forall t : term, wcprovable E (FEq t t)) /\ ((forall s : term, forall t : term, forall u : term, ((wcprovable E (FEq s t)) /\ (wcprovable E (FEq t u))) -> wcprovable E (FEq s u)) /\ (forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => wcprovable E (FEq l r)) a b) -> wcprovable E (FEq (Fn f a) (Fn f b)))))).
Axiom thm_WCPROVABLE_SYM : forall E : form -> Prop, forall a : form, (wcprovable E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> wcprovable E (FEq t s).
Axiom thm_WCPROVABLE_INST : forall E : form -> Prop, forall a : form, (wcprovable E a) -> forall i : nat -> term, forall s : term, forall t : term, (a = (FEq s t)) -> wcprovable E (formsubst i (FEq s t)).
Axiom thm_WCPROVABLE_PROVABLE : forall E : form -> Prop, forall s : term, forall t : term, (wcprovable E (FEq s t)) = (provable E (FEq s t)).
Axiom thm_aprovable_CASES : forall E : form -> Prop, forall a : form, (aprovable E a) = ((exists s : term, exists t : term, exists i : nat -> term, (a = (formsubst i (FEq s t))) /\ (@IN form (FEq s t) E)) \/ (exists s : term, exists t : term, exists i : nat -> term, (a = (formsubst i (FEq t s))) /\ (@IN form (FEq s t) E))).
Axiom thm_aprovable_INDUCT : forall E : form -> Prop, forall vdash2_axiom' : form -> Prop, ((forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> vdash2_axiom' (formsubst i (FEq s t))) /\ (forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> vdash2_axiom' (formsubst i (FEq t s)))) -> forall a : form, (aprovable E a) -> vdash2_axiom' a.
Axiom thm_aprovable_RULES : forall E : form -> Prop, (forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> aprovable E (formsubst i (FEq s t))) /\ (forall s : term, forall t : term, forall i : nat -> term, (@IN form (FEq s t) E) -> aprovable E (formsubst i (FEq t s))).
Axiom thm_cprovable_CASES : forall E : form -> Prop, (forall a0 : form, (provable_achain E a0) = ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (aprovable E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((aprovable E (FEq s t)) /\ (cprovable E (FEq t u)))))) /\ ((forall a1 : form, (provable_cchain E a1) = ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (provable_cong E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((provable_cong E (FEq s t)) /\ (provable_achain E (FEq t u)))))) /\ ((forall a2 : form, (provable_cong E a2) = (exists f : nat, exists a : seq term, exists b : seq term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@ALL2 term term (fun l : term => fun r : term => cprovable E (FEq l r)) a b))) /\ (forall a3 : form, (cprovable E a3) = (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((provable_achain E (FEq s t)) \/ (provable_cchain E (FEq s t)))))))).
Axiom thm_cprovable_INDUCT : forall E : form -> Prop, forall vdash2_achain' : form -> Prop, forall vdash2_cchain' : form -> Prop, forall vdash2_cong' : form -> Prop, forall vdash3' : form -> Prop, ((forall s : term, forall t : term, (aprovable E (FEq s t)) -> vdash2_achain' (FEq s t)) /\ ((forall s : term, forall t : term, (vdash2_cong' (FEq s t)) -> vdash2_cchain' (FEq s t)) /\ ((forall s : term, forall t : term, forall u : term, ((aprovable E (FEq s t)) /\ (vdash3' (FEq t u))) -> vdash2_achain' (FEq s u)) /\ ((forall s : term, forall t : term, forall u : term, ((vdash2_cong' (FEq s t)) /\ (vdash2_achain' (FEq t u))) -> vdash2_cchain' (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => vdash3' (FEq l r)) a b) -> vdash2_cong' (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, ((s = t) \/ ((vdash2_achain' (FEq s t)) \/ (vdash2_cchain' (FEq s t)))) -> vdash3' (FEq s t))))))) -> (forall a0 : form, (provable_achain E a0) -> vdash2_achain' a0) /\ ((forall a1 : form, (provable_cchain E a1) -> vdash2_cchain' a1) /\ ((forall a2 : form, (provable_cong E a2) -> vdash2_cong' a2) /\ (forall a3 : form, (cprovable E a3) -> vdash3' a3))).
Axiom thm_cprovable_RULES : forall E : form -> Prop, (forall s : term, forall t : term, (aprovable E (FEq s t)) -> provable_achain E (FEq s t)) /\ ((forall s : term, forall t : term, (provable_cong E (FEq s t)) -> provable_cchain E (FEq s t)) /\ ((forall s : term, forall t : term, forall u : term, ((aprovable E (FEq s t)) /\ (cprovable E (FEq t u))) -> provable_achain E (FEq s u)) /\ ((forall s : term, forall t : term, forall u : term, ((provable_cong E (FEq s t)) /\ (provable_achain E (FEq t u))) -> provable_cchain E (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => cprovable E (FEq l r)) a b) -> provable_cong E (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, ((s = t) \/ ((provable_achain E (FEq s t)) \/ (provable_cchain E (FEq s t)))) -> cprovable E (FEq s t)))))).
Axiom thm_CPROVABLE_PROVABLE_LEMMA : forall E : form -> Prop, forall a : form, (wcprovable E a) -> (wcprovable E a) /\ ((cprovable E a) /\ (forall u : term, forall s : term, forall t : term, (a = (FEq s t)) -> (cprovable E (FEq t u)) -> cprovable E (FEq s u))).
Axiom thm_CPROVABLE_PROVABLE : forall E : form -> Prop, forall s : term, forall t : term, (cprovable E (FEq s t)) = (provable E (FEq s t)).
Axiom thm_subterms : forall (x : nat) (f : nat) (args : seq term), ((subterms (V x)) = (@INSERT term (V x) (@set0 term))) /\ ((subterms (Fn f args)) = (@INSERT term (Fn f args) (@list_Union term (@map term (term -> Prop) subterms args)))).
Axiom thm_subtermsa : forall (P : nat) (args : seq term), (subtermsa (Atom P args)) = (@list_Union term (@map term (term -> Prop) subterms args)).
Axiom thm_subtermss : forall E : form -> Prop, (subtermss E) = (@UNIONS term (@GSPEC (term -> Prop) (fun GEN_PVAR_664 : term -> Prop => exists p : form, @SETSPEC (term -> Prop) GEN_PVAR_664 (@IN form p E) (subtermsa p)))).
Axiom thm_SUBTERMS_REFL : forall t : term, @IN term t (subterms t).
Axiom thm_esubterms : forall s : term, forall t : term, forall E : form -> Prop, (esubterms E s t) = (subtermss (@INSERT form (FEq s t) (@GSPEC form (fun GEN_PVAR_665 : form => exists i : nat -> term, exists p : form, @SETSPEC form GEN_PVAR_665 (@IN form p E) (formsubst i p))))).
Axiom thm_scprovable_CASES : forall E : form -> Prop, (forall a0 : form, (provable_sachain E a0) = ((exists s : term, exists t : term, (a0 = (FEq s t)) /\ (aprovable E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a0 = (FEq s u)) /\ ((aprovable E (FEq s t)) /\ ((scprovable E (FEq t u)) /\ (@IN term t (esubterms E s u))))))) /\ ((forall a1 : form, (provable_scchain E a1) = ((exists s : term, exists t : term, (a1 = (FEq s t)) /\ (provable_scong E (FEq s t))) \/ (exists s : term, exists t : term, exists u : term, (a1 = (FEq s u)) /\ ((provable_scong E (FEq s t)) /\ ((provable_sachain E (FEq t u)) /\ (@IN term t (esubterms E s u))))))) /\ ((forall a2 : form, (provable_scong E a2) = (exists f : nat, exists a : seq term, exists b : seq term, (a2 = (FEq (Fn f a) (Fn f b))) /\ (@ALL2 term term (fun l : term => fun r : term => scprovable E (FEq l r)) a b))) /\ (forall a3 : form, (scprovable E a3) = (exists s : term, exists t : term, (a3 = (FEq s t)) /\ ((s = t) \/ ((provable_sachain E (FEq s t)) \/ (provable_scchain E (FEq s t)))))))).
Axiom thm_scprovable_INDUCT : forall E : form -> Prop, forall vdash2_sachain' : form -> Prop, forall vdash2_scchain' : form -> Prop, forall vdash2_scong' : form -> Prop, forall vdash4' : form -> Prop, ((forall s : term, forall t : term, (aprovable E (FEq s t)) -> vdash2_sachain' (FEq s t)) /\ ((forall s : term, forall t : term, (vdash2_scong' (FEq s t)) -> vdash2_scchain' (FEq s t)) /\ ((forall s : term, forall t : term, forall u : term, ((aprovable E (FEq s t)) /\ ((vdash4' (FEq t u)) /\ (@IN term t (esubterms E s u)))) -> vdash2_sachain' (FEq s u)) /\ ((forall s : term, forall t : term, forall u : term, ((vdash2_scong' (FEq s t)) /\ ((vdash2_sachain' (FEq t u)) /\ (@IN term t (esubterms E s u)))) -> vdash2_scchain' (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => vdash4' (FEq l r)) a b) -> vdash2_scong' (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, ((s = t) \/ ((vdash2_sachain' (FEq s t)) \/ (vdash2_scchain' (FEq s t)))) -> vdash4' (FEq s t))))))) -> (forall a0 : form, (provable_sachain E a0) -> vdash2_sachain' a0) /\ ((forall a1 : form, (provable_scchain E a1) -> vdash2_scchain' a1) /\ ((forall a2 : form, (provable_scong E a2) -> vdash2_scong' a2) /\ (forall a3 : form, (scprovable E a3) -> vdash4' a3))).
Axiom thm_scprovable_RULES : forall E : form -> Prop, (forall s : term, forall t : term, (aprovable E (FEq s t)) -> provable_sachain E (FEq s t)) /\ ((forall s : term, forall t : term, (provable_scong E (FEq s t)) -> provable_scchain E (FEq s t)) /\ ((forall s : term, forall t : term, forall u : term, ((aprovable E (FEq s t)) /\ ((scprovable E (FEq t u)) /\ (@IN term t (esubterms E s u)))) -> provable_sachain E (FEq s u)) /\ ((forall s : term, forall t : term, forall u : term, ((provable_scong E (FEq s t)) /\ ((provable_sachain E (FEq t u)) /\ (@IN term t (esubterms E s u)))) -> provable_scchain E (FEq s u)) /\ ((forall f : nat, forall a : seq term, forall b : seq term, (@ALL2 term term (fun l : term => fun r : term => scprovable E (FEq l r)) a b) -> provable_scong E (FEq (Fn f a) (Fn f b))) /\ (forall s : term, forall t : term, ((s = t) \/ ((provable_sachain E (FEq s t)) \/ (provable_scchain E (FEq s t)))) -> scprovable E (FEq s t)))))).
Axiom thm_ESUBTERMS_TRIVIAL_L : forall (E : form -> Prop) (s : term) (t : term), forall u : term, (@IN term u (subterms s)) -> @IN term u (esubterms E s t).
Axiom thm_ESUBTERMS_TRIVIAL_R : forall (E : form -> Prop) (s : term) (t : term), forall u : term, (@IN term u (subterms t)) -> @IN term u (esubterms E s t).
Axiom thm_SCPROVABLE_SUBTERMS : forall (E : form -> Prop), forall a : form, (provable_sachain E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> forall u : term, forall v : term, @IN term s (esubterms E u v).
Axiom thm_SCPROVABLE_CPROVABLE_LEMMA : forall (E : form -> Prop), (forall a : form, (provable_achain E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> provable_sachain E (FEq s t)) /\ ((forall a : form, (provable_cchain E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> provable_scchain E (FEq s t)) /\ ((forall a : form, (provable_cong E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> provable_scong E (FEq s t)) /\ (forall a : form, (cprovable E a) -> forall s : term, forall t : term, (a = (FEq s t)) -> scprovable E (FEq s t)))).
Axiom thm_SCPROVABLE_CPROVABLE : forall E : form -> Prop, forall s : term, forall t : term, (cprovable E (FEq s t)) = (scprovable E (FEq s t)).
Axiom thm_SCPROVABLE_PROVABLE : forall E : form -> Prop, forall s : term, forall t : term, (cprovable E (FEq s t)) = (provable E (FEq s t)).
Axiom thm_Eqclause_Func : forall f : nat, forall n : nat, (Eqclause_Func (@pair nat nat f n)) = (@set_of_list form (@cons form (FEq (Fn f (@map (prod term term) term (@fst term term) (Varpairs n))) (Fn f (@map (prod term term) term (@snd term term) (Varpairs n)))) (@map (prod term term) form (@ε ((prod term term) -> form) (fun f' : (prod term term) -> form => forall s : term, forall t : term, @eq form (f' (@pair term term s t)) (Not (FEq s t)))) (Varpairs n)))).
Axiom thm_Eqclause_Pred : forall p : nat, forall n : nat, (Eqclause_Pred (@pair nat nat p n)) = (@set_of_list form (@cons form (Atom p (@map (prod term term) term (@snd term term) (Varpairs n))) (@cons form (Not (Atom p (@map (prod term term) term (@fst term term) (Varpairs n)))) (@map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs n))))).
Axiom thm_Eqclauses_DEF : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), (Eqclauses L) = (@INSERT (form -> Prop) (@INSERT form (FEq (V (NUMERAL O)) (V (NUMERAL O))) (@set0 form)) (@INSERT (form -> Prop) (@INSERT form (Not (FEq (V (NUMERAL O)) (V (NUMERAL (BIT1 O))))) (@INSERT form (Not (FEq (V (NUMERAL (BIT0 (BIT1 O)))) (V (NUMERAL (BIT1 O))))) (@INSERT form (FEq (V (NUMERAL O)) (V (NUMERAL (BIT0 (BIT1 O))))) (@set0 form)))) (@setU (form -> Prop) (@GSPEC (form -> Prop) (fun GEN_PVAR_666 : form -> Prop => exists fa : prod nat nat, @SETSPEC (form -> Prop) GEN_PVAR_666 (@IN (prod nat nat) fa (@fst ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (Eqclause_Func fa))) (@GSPEC (form -> Prop) (fun GEN_PVAR_667 : form -> Prop => exists pa : prod nat nat, @SETSPEC (form -> Prop) GEN_PVAR_667 (@IN (prod nat nat) pa (@snd ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) L)) (Eqclause_Pred pa)))))).
Axiom thm_EQCLAUSE_EQAXIOM_FUNC : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall f : nat, forall n : nat, (~ ((@Dom A M) = (@set0 A))) -> (@satisfies A M (@INSERT form (interp (Eqclause_Func (@pair nat nat f n))) (@set0 form))) = (@satisfies A M (@INSERT form (Eqaxiom_Func (@pair nat nat f n)) (@set0 form))).
Axiom thm_Eqaxiom_Pred_imp : forall p : nat, forall n : nat, (Eqaxiom_Pred_imp (@pair nat nat p n)) = (uclose (FImp (@ITLIST form form FAnd (@map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (FEq s t))) (Varpairs n)) FTrue) (FImp (Atom p (@map (prod term term) term (@fst term term) (Varpairs n))) (Atom p (@map (prod term term) term (@snd term term) (Varpairs n)))))).
Axiom thm_lemma : forall {_246325 : Type'} (a : _246325) (s : _246325 -> Prop), (@INSERT _246325 a s) = (@setU _246325 (@INSERT _246325 a (@set0 _246325)) s).
Axiom thm_EQCLAUSES_EQAXIOMS : forall {A : Type'}, forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), (~ ((@Dom A M) = (@set0 A))) -> (@satisfies A M (@IMAGE (form -> Prop) form interp (Eqclauses L))) = (@satisfies A M (Eqaxioms L)).
Axiom thm_FUNCTIONS_VAREQLIST : forall n : nat, (functions (@set_of_list form (@map (prod term term) form (@ε ((prod term term) -> form) (fun f : (prod term term) -> form => forall s : term, forall t : term, @eq form (f (@pair term term s t)) (Not (FEq s t)))) (Varpairs n)))) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_TERM_FN_VARPAIRS : (forall f : nat, forall n : nat, (functions_term (Fn f (@map (prod term term) term (@fst term term) (Varpairs n)))) = (@INSERT (prod nat nat) (@pair nat nat f n) (@set0 (prod nat nat)))) /\ (forall f : nat, forall n : nat, (functions_term (Fn f (@map (prod term term) term (@snd term term) (Varpairs n)))) = (@INSERT (prod nat nat) (@pair nat nat f n) (@set0 (prod nat nat)))).
Axiom thm_FUNCTIONS_FORM_PRED_VARPAIRS : (forall p : nat, forall n : nat, (functions_form (Atom p (@map (prod term term) term (@fst term term) (Varpairs n)))) = (@set0 (prod nat nat))) /\ (forall p : nat, forall n : nat, (functions_form (Atom p (@map (prod term term) term (@snd term term) (Varpairs n)))) = (@set0 (prod nat nat))).
Axiom thm_FUNCTIONS_FORM_EQCLAUSE_FUNC : forall fn : prod nat nat, (functions_form (interp (Eqclause_Func fn))) = (@INSERT (prod nat nat) fn (@set0 (prod nat nat))).
Axiom thm_FUNCTIONS_FORM_EQCLAUSE_PRED : forall pn : prod nat nat, (functions_form (interp (Eqclause_Pred pn))) = (@set0 (prod nat nat)).
Axiom thm_FUNCTIONS_EQCLAUSES : forall (s : form -> Prop), (functions (@IMAGE (form -> Prop) form interp (Eqclauses (language s)))) = (functions s).
Axiom thm_FUNCTIONS_FORM_NOT_UCLOSE : forall (p : form), (functions_form (Not (uclose p))) = (functions_form p).
Axiom thm_PREDICATES_FORM_NOT_UCLOSE : forall (p : form), (predicates_form (Not (uclose p))) = (predicates_form p).
Axiom thm_FUNCTIONS_INSERT_NOT_UCLOSE : forall (p : form) (s : form -> Prop), (functions (@INSERT form p s)) = (functions (@INSERT form (Not (uclose p)) s)).
Axiom thm_PREDICATES_INSERT_NOT_UCLOSE : forall (p : form) (s : form -> Prop), (predicates (@INSERT form p s)) = (predicates (@INSERT form (Not (uclose p)) s)).
Axiom thm_LANGUAGE_INSERT_NOT_UCLOSE : forall (p : form) (s : form -> Prop), (language (@INSERT form p s)) = (language (@INSERT form (Not (uclose p)) s)).
Axiom thm_lemma1 : forall {_247121 : Type'} (p : _247121 -> Prop) (q : _247121 -> Prop) (r : _247121 -> Prop) (s : _247121 -> Prop) (t : _247121 -> Prop), (forall m : _247121, ((p m) /\ ((q m) /\ ((r m) /\ (s m)))) -> t m) = (~ (exists m : _247121, (p m) /\ ((q m) /\ ((r m) /\ ((s m) /\ (~ (t m))))))).
Axiom thm_lemma2 : forall {_247137 : Type'} (x : _247137) (s : _247137 -> Prop) (t : _247137 -> Prop), (@setU _247137 (@INSERT _247137 x s) t) = (@INSERT _247137 x (@setU _247137 s t)).
Axiom thm_EQCLAUSES_DEFINITE : forall L : prod ((prod nat nat) -> Prop) ((prod nat nat) -> Prop), forall cl : form -> Prop, (@IN (form -> Prop) cl (Eqclauses L)) -> definite cl.
Axiom thm_EQLOGIC_COMPLETE : forall E : form -> Prop, forall s : term, forall t : term, ((forall e : form, (@IN form e E) -> exists s' : term, exists t' : term, e = (FEq s' t')) /\ (forall M : prod (term -> Prop) (prod (nat -> (seq term) -> term) (nat -> (seq term) -> Prop)), ((@interpretation term (language (@INSERT form (FEq s t) E)) M) /\ ((~ ((@Dom term M) = (@set0 term))) /\ ((@normal term (functions (@INSERT form (FEq s t) E)) M) /\ (@satisfies term M E)))) -> @satisfies term M (@INSERT form (FEq s t) (@set0 form)))) -> provable E (FEq s t).
Axiom thm_EQLOGIC_SOUND : forall {A : Type'}, forall E : form -> Prop, forall s : term, forall t : term, (provable E (FEq s t)) -> forall M : prod (A -> Prop) (prod (nat -> (seq A) -> A) (nat -> (seq A) -> Prop)), ((@normal A (@setT (prod nat nat)) M) /\ ((@interpretation A (@pair ((prod nat nat) -> Prop) ((prod nat nat) -> Prop) (@setT (prod nat nat)) (@setT (prod nat nat))) M) /\ (@satisfies A M E))) -> @satisfies A M (@INSERT form (FEq s t) (@set0 form)).
Axiom thm_TRS_CASES : forall rws : (prod term term) -> Prop, forall a0 : term, forall a1 : term, (TRS rws a0 a1) = ((exists i : nat -> term, exists l : term, exists r : term, (a0 = (termsubst i l)) /\ ((a1 = (termsubst i r)) /\ (@IN (prod term term) (@pair term term l r) rws))) \/ (exists s : term, exists t : term, exists f : nat, exists largs : seq term, exists rargs : seq term, (a0 = (Fn f (@cat term largs (@cons term s rargs)))) /\ ((a1 = (Fn f (@cat term largs (@cons term t rargs)))) /\ (TRS rws s t)))).
Axiom thm_TRS_INDUCT : forall rws : (prod term term) -> Prop, forall TRS' : term -> term -> Prop, ((forall i : nat -> term, forall l : term, forall r : term, (@IN (prod term term) (@pair term term l r) rws) -> TRS' (termsubst i l) (termsubst i r)) /\ (forall s : term, forall t : term, forall f : nat, forall largs : seq term, forall rargs : seq term, (TRS' s t) -> TRS' (Fn f (@cat term largs (@cons term s rargs))) (Fn f (@cat term largs (@cons term t rargs))))) -> forall a0 : term, forall a1 : term, (TRS rws a0 a1) -> TRS' a0 a1.
Axiom thm_TRS_RULES : forall rws : (prod term term) -> Prop, (forall i : nat -> term, forall l : term, forall r : term, (@IN (prod term term) (@pair term term l r) rws) -> TRS rws (termsubst i l) (termsubst i r)) /\ (forall s : term, forall t : term, forall f : nat, forall largs : seq term, forall rargs : seq term, (TRS rws s t) -> TRS rws (Fn f (@cat term largs (@cons term s rargs))) (Fn f (@cat term largs (@cons term t rargs)))).
Axiom thm_CONVERGENT_MODIFY : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, ((@SN A R') /\ ((@CR A (@RTC A R')) /\ ((forall x : A, forall y : A, (S' x y) -> @Relation_Operators.clos_trans A R' x y) /\ (forall x : A, forall y : A, (R' x y) -> exists y' : A, S' x y')))) -> (@SN A S') /\ (@CR A (@RTC A S')).
Axiom thm_EQUIVALENT_JOINABLE_MODIFY : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, ((@SN A R') /\ ((@CR A (@RTC A R')) /\ ((forall x : A, forall y : A, (S' x y) -> @Relation_Operators.clos_trans A R' x y) /\ (forall x : A, forall y : A, (R' x y) -> exists y' : A, S' x y')))) -> forall x : A, forall y : A, (@JOINABLE A S' x y) = (@JOINABLE A R' x y).
Axiom thm_EQUIVALENT_RSTC_MODIFY : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, ((@SN A R') /\ ((@CR A (@RTC A R')) /\ ((forall x : A, forall y : A, (S' x y) -> @Relation_Operators.clos_trans A R' x y) /\ (forall x : A, forall y : A, (R' x y) -> exists y' : A, S' x y')))) -> forall x : A, forall y : A, (@RSTC A S' x y) = (@RSTC A R' x y).
Axiom thm_EQUIVALENT_MODIFY : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, ((@SN A R') /\ ((@CR A (@RTC A R')) /\ ((forall x : A, forall y : A, (S' x y) -> @Relation_Operators.clos_trans A R' x y) /\ (forall x : A, forall y : A, (R' x y) -> exists y' : A, S' x y')))) -> (@SN A S') /\ ((@CR A (@RTC A S')) /\ (forall x : A, forall y : A, (@RSTC A S' x y) = (@RSTC A R' x y))).
Axiom thm_EQUIVALENT_MODIFY_RIGHT : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, forall S'' : A -> A -> Prop, ((@SN A (fun x : A => fun y : A => (R' x y) \/ (S' x y))) /\ ((@CR A (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S' x y)))) /\ ((forall s : A, forall t : A, (S' s t) -> exists t' : A, S'' s t') /\ (forall s : A, forall t : A, (S'' s t) -> exists u : A, (S' s u) /\ (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S' x y)) u t))))) -> (@SN A (fun x : A => fun y : A => (R' x y) \/ (S'' x y))) /\ ((@CR A (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S'' x y)))) /\ (forall x : A, forall y : A, (@RSTC A (fun x' : A => fun y' : A => (R' x' y') \/ (S'' x' y')) x y) = (@RSTC A (fun x' : A => fun y' : A => (R' x' y') \/ (S' x' y')) x y))).
Axiom thm_CONVERGENT_DELETE_LEFT : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, ((@SN A (fun x : A => fun y : A => (R' x y) \/ (S' x y))) /\ ((@CR A (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S' x y)))) /\ (forall x : A, forall y : A, (S' x y) -> exists z : A, R' x z))) -> (@SN A R') /\ ((@CR A (@RTC A R')) /\ (forall x : A, forall y : A, (@RSTC A R' x y) = (@RSTC A (fun x' : A => fun y' : A => (R' x' y') \/ (S' x' y')) x y))).
Axiom thm_CONVERGENT_MODIFY_LEMMA : forall {A : Type'}, forall R' : A -> A -> Prop, forall S' : A -> A -> Prop, forall S'' : A -> A -> Prop, forall t : A, ((@SN A (fun x : A => fun y : A => (R' x y) \/ ((S' x y) \/ (S'' x y)))) /\ ((@CR A (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S' x y)))) /\ ((forall s : A, forall t' : A, (S' s t') -> exists s' : A, exists t'' : A, (@RTC A R' s s') /\ ((@RTC A R' t' t'') /\ ((S'' s' t'') \/ (S'' t'' s')))) /\ (@NORMAL A (fun x : A => fun y : A => (R' x y) \/ (S' x y)) t)))) -> forall s : A, (@RTC A (fun x : A => fun y : A => (R' x y) \/ (S' x y)) s t) -> @RTC A (fun x : A => fun y : A => (R' x y) \/ (S'' x y)) s t.
Axiom thm_ITLIST_ADD_1_POS : forall l : seq nat, ltn (NUMERAL O) (@ITLIST nat nat addn l (NUMERAL (BIT1 O))).
Axiom thm_FVT_FUN_EMPTY : forall f : nat, forall a : term, forall args : seq term, ((@MEM term a args) /\ ((free_variables_term (Fn f args)) = (@set0 nat))) -> (free_variables_term a) = (@set0 nat).
Axiom thm_NONWF : forall {A : Type'}, forall a : A, forall R' : A -> A -> Prop, (@NONWF A R' a) = (exists s : nat -> A, ((s (NUMERAL O)) = a) /\ (forall n : nat, R' (s (S n)) (s n))).
Axiom thm_NONWF_SUCCESSOR : forall {A : Type'}, forall R' : A -> A -> Prop, forall a : A, forall b : A, ((@NONWF A R' b) /\ (R' b a)) -> @NONWF A R' a.
Axiom thm_WF_NONWF : forall {A : Type'} (R' : A -> A -> Prop), @well_founded A (fun x : A => fun y : A => (R' x y) /\ (~ (@NONWF A R' y))).
Axiom thm_NONWF_INDUCT : forall {_249973 : Type'} (R' : _249973 -> _249973 -> Prop) (P : _249973 -> Prop), (forall a : _249973, ((~ (@NONWF _249973 R' a)) /\ (forall b : _249973, (R' b a) -> P b)) -> P a) -> forall x : _249973, (~ (@NONWF _249973 R' x)) -> P x.
Axiom thm_WF_MINIMAL_STEP : forall {A : Type'} (R' : A -> A -> Prop), forall m : A -> nat, forall a : A, (@NONWF A R' a) -> exists b : A, (@NONWF A R' b) /\ ((R' b a) /\ (forall c : A, ((@NONWF A R' c) /\ (R' c a)) -> leqn (m b) (m c))).
Axiom thm_WF_MINIMAL_DCHAIN : forall {A : Type'} (R' : A -> A -> Prop), forall m : A -> nat, (@well_founded A R') = (~ (exists t : nat -> A, (forall n : nat, R' (t (S n)) (t n)) /\ ((forall s : A, (@NONWF A R' s) -> leqn (m (t (NUMERAL O))) (m s)) /\ (forall n : nat, forall s : A, ((@NONWF A R' s) /\ (R' s (t n))) -> leqn (m (t (S n))) (m s))))).
Axiom thm_SEQUENCE_SUBSEQUENCE : forall {A : Type'}, forall P : A -> Prop, forall x : nat -> A, (forall n : nat, exists m : nat, (ltn n m) /\ (P (x m))) -> exists f : nat -> nat, (subseq f) /\ (forall n : nat, P (x (f n))).
Axiom thm_SEQUENCE_PARTITION_LEMMA : forall {A : Type'}, forall x : nat -> A, forall s : A -> Prop, ((@finite_set A s) /\ (forall n : nat, @IN A (x n) s)) -> exists a : A, exists f : nat -> nat, (subseq f) /\ (forall n : nat, (x (f n)) = a).
Axiom thm_termsize_EXISTS : exists termsize' : term -> nat, (forall x : nat, (termsize' (V x)) = (NUMERAL (BIT1 O))) /\ (forall f : nat, forall args : seq term, (termsize' (Fn f args)) = (@ITLIST nat nat addn (@map term nat termsize' args) (NUMERAL (BIT1 O)))).
Axiom thm_LEX_DEF : forall {_250568 : Type'} (h : _250568) (lt2' : _250568 -> _250568 -> Prop) (t : seq _250568) (l : seq _250568), ((@LEX _250568 lt2' (@nil _250568) l) = False) /\ ((@LEX _250568 lt2' (@cons _250568 h t) l) = (@COND Prop (l = (@nil _250568)) False (@COND Prop (lt2' h (@HD _250568 l)) ((@size _250568 t) = (@size _250568 (@TL _250568 l))) ((h = (@HD _250568 l)) /\ (@LEX _250568 lt2' t (@TL _250568 l)))))).
Axiom thm_LEX : forall {_250618 : Type'} (l : seq _250618) (h1' : _250618) (h2' : _250618) (lt2' : _250618 -> _250618 -> Prop) (t1 : seq _250618) (t2 : seq _250618), ((@LEX _250618 lt2' (@nil _250618) l) = False) /\ (((@LEX _250618 lt2' (@cons _250618 h1' t1) (@nil _250618)) = False) /\ ((@LEX _250618 lt2' (@cons _250618 h1' t1) (@cons _250618 h2' t2)) = (@COND Prop (lt2' h1' h2') ((@size _250618 t1) = (@size _250618 t2)) ((h1' = h2') /\ (@LEX _250618 lt2' t1 t2))))).
Axiom thm_LEX_LENGTH : forall {_250643 : Type'}, forall l1 : seq _250643, forall l2 : seq _250643, forall R' : _250643 -> _250643 -> Prop, (@LEX _250643 R' l1 l2) -> (@size _250643 l1) = (@size _250643 l2).
Axiom thm_MONO_LEX : forall {A : Type'} (R' : A -> A -> Prop) (S' : A -> A -> Prop) (x : seq A) (y : seq A), (forall x' : A, forall y' : A, (R' x' y') -> S' x' y') -> (@LEX A R' x y) -> @LEX A S' x y.
Axiom thm_LEX_MAP : forall {_250704 _250716 : Type'} (R' : _250716 -> _250716 -> Prop) (f : _250704 -> _250716), forall l1 : seq _250704, forall l2 : seq _250704, (@LEX _250704 (fun x : _250704 => fun y : _250704 => R' (f x) (f y)) l1 l2) -> @LEX _250716 R' (@map _250704 _250716 f l1) (@map _250704 _250716 f l2).
Axiom thm_LEX_REFL : forall {_250738 : Type'}, forall R' : _250738 -> _250738 -> Prop, forall l : seq _250738, (forall x : _250738, (@MEM _250738 x l) -> ~ (R' x x)) -> ~ (@LEX _250738 R' l l).
Axiom thm_LEX_LENGTH_CHAIN : forall {_250763 : Type'}, forall lis : nat -> seq _250763, forall R' : _250763 -> _250763 -> Prop, (forall n : nat, @LEX _250763 R' (lis (S n)) (lis n)) -> forall n : nat, (@size _250763 (lis n)) = (@size _250763 (lis (NUMERAL O))).
Axiom thm_WF_LEX_STRONG_INDUCT : forall {A : Type'} (R' : A -> A -> Prop), forall n : nat, forall lis : nat -> seq A, ((@size A (lis (NUMERAL O))) = n) -> ~ ((forall n' : nat, forall a : A, (@MEM A a (lis n')) -> ~ (@NONWF A R' a)) /\ (forall n' : nat, @LEX A R' (lis (S n')) (lis n'))).
Axiom thm_WF_LEX_STRONG : forall {A : Type'}, forall R' : A -> A -> Prop, forall lis : nat -> seq A, ~ ((forall n : nat, forall a : A, (@MEM A a (lis n)) -> ~ (@NONWF A R' a)) /\ (forall n : nat, @LEX A R' (lis (S n)) (lis n))).
Axiom thm_LEX_RESTRICT : forall {_251192 : Type'}, forall P : _251192 -> Prop, forall R' : _251192 -> _251192 -> Prop, forall l1 : seq _251192, forall l2 : seq _251192, ((@LEX _251192 R' l1 l2) /\ ((forall a : _251192, (@MEM _251192 a l1) -> P a) /\ (forall a : _251192, (@MEM _251192 a l2) -> P a))) -> @LEX _251192 (fun x : _251192 => fun y : _251192 => (P x) /\ ((P y) /\ (R' x y))) l1 l2.
Axiom thm_subterm_RULES : (forall t : term, subterm t t) /\ (forall s : term, forall a : term, forall f : nat, forall args : seq term, ((subterm s a) /\ (@MEM term a args)) -> subterm s (Fn f args)).
Axiom thm_subterm_CASES : forall a0 : term, forall a1 : term, (subterm a0 a1) = ((a1 = a0) \/ (exists a : term, exists f : nat, exists args : seq term, (a1 = (Fn f args)) /\ ((subterm a0 a) /\ (@MEM term a args)))).
Axiom thm_subterm_INDUCT : forall subterm' : term -> term -> Prop, ((forall t : term, subterm' t t) /\ (forall s : term, forall a : term, forall f : nat, forall args : seq term, ((subterm' s a) /\ (@MEM term a args)) -> subterm' s (Fn f args))) -> forall a0 : term, forall a1 : term, (subterm a0 a1) -> subterm' a0 a1.
Axiom thm_psubterm : forall s : term, forall t : term, (psubterm s t) = ((subterm s t) /\ (~ (s = t))).
Axiom thm_DESCENDANT_SMALLER : forall f : nat, forall args : seq term, forall s : term, (@MEM term s args) -> ltn (termsize s) (termsize (Fn f args)).
Axiom thm_DESCENDANT_DISTINCT : forall f : nat, forall args : seq term, ~ (@MEM term (Fn f args) args).
Axiom thm_SUBTERM_REFL : forall t : term, subterm t t.
Axiom thm_SUBTERM_TRANS : forall s : term, forall t : term, forall u : term, ((subterm s t) /\ (subterm t u)) -> subterm s u.
Axiom thm_SUBTERM_ANTISYM : forall s : term, forall t : term, ((subterm s t) /\ (subterm t s)) -> s = t.
Axiom thm_SUBTERM_FVT : forall x : nat, forall t : term, (@IN nat x (free_variables_term t)) -> subterm (V x) t.
Axiom thm_PSUBTERM_ANTISYM : forall s : term, forall t : term, ~ ((psubterm s t) /\ (psubterm t s)).
Axiom thm_SUBTERM_PSUBTERM_TRANS : forall s : term, forall t : term, forall u : term, ((subterm s t) /\ (psubterm t u)) -> psubterm s u.
Axiom thm_PSUBTERM_CASES : forall s : term, forall t : term, (psubterm s t) = (exists f : nat, exists args : seq term, exists u : term, (t = (Fn f args)) /\ ((@MEM term u args) /\ (subterm s u))).
Axiom thm_SUBTERM_INSTANTIATION : forall i : nat -> term, forall s : term, forall t : term, (subterm s t) -> subterm (termsubst i s) (termsubst i t).
Axiom thm_PSUBTERM_INSTANTIATION : forall i : nat -> term, forall s : term, forall t : term, (psubterm s t) -> psubterm (termsubst i s) (termsubst i t).
Axiom thm_lpo_RULES : (forall x : nat, forall s : term, ((@IN nat x (free_variables_term s)) /\ (~ (s = (V x)))) -> lpo (V x) s) /\ ((forall fs : nat, forall sargs : seq term, forall ft : nat, forall targs : seq term, forall si : term, ((@MEM term si sargs) /\ ((lpo (Fn ft targs) si) \/ (si = (Fn ft targs)))) -> lpo (Fn ft targs) (Fn fs sargs)) /\ ((forall fs : nat, forall ft : nat, forall sargs : seq term, forall targs : seq term, (((gtn fs ft) \/ ((fs = ft) /\ (gtn (@size term sargs) (@size term targs)))) /\ (@ALL term (fun ti : term => lpo ti (Fn fs sargs)) targs)) -> lpo (Fn ft targs) (Fn fs sargs)) /\ (forall f : nat, forall sargs : seq term, forall targs : seq term, ((@ALL term (fun ti : term => lpo ti (Fn f sargs)) targs) /\ (@LEX term lpo targs sargs)) -> lpo (Fn f targs) (Fn f sargs)))).
Axiom thm_lpo_CASES : forall a0 : term, forall a1 : term, (lpo a0 a1) = ((exists x : nat, (a0 = (V x)) /\ ((@IN nat x (free_variables_term a1)) /\ (~ (a1 = (V x))))) \/ ((exists fs : nat, exists sargs : seq term, exists ft : nat, exists targs : seq term, exists si : term, (a0 = (Fn ft targs)) /\ ((a1 = (Fn fs sargs)) /\ ((@MEM term si sargs) /\ ((lpo (Fn ft targs) si) \/ (si = (Fn ft targs)))))) \/ ((exists fs : nat, exists ft : nat, exists sargs : seq term, exists targs : seq term, (a0 = (Fn ft targs)) /\ ((a1 = (Fn fs sargs)) /\ (((gtn fs ft) \/ ((fs = ft) /\ (gtn (@size term sargs) (@size term targs)))) /\ (@ALL term (fun ti : term => lpo ti (Fn fs sargs)) targs)))) \/ (exists f : nat, exists sargs : seq term, exists targs : seq term, (a0 = (Fn f targs)) /\ ((a1 = (Fn f sargs)) /\ ((@ALL term (fun ti : term => lpo ti (Fn f sargs)) targs) /\ (@LEX term lpo targs sargs))))))).
Axiom thm_lpo_INDUCT : forall lt2' : term -> term -> Prop, ((forall x : nat, forall s : term, ((@IN nat x (free_variables_term s)) /\ (~ (s = (V x)))) -> lt2' (V x) s) /\ ((forall fs : nat, forall sargs : seq term, forall ft : nat, forall targs : seq term, forall si : term, ((@MEM term si sargs) /\ ((lt2' (Fn ft targs) si) \/ (si = (Fn ft targs)))) -> lt2' (Fn ft targs) (Fn fs sargs)) /\ ((forall fs : nat, forall ft : nat, forall sargs : seq term, forall targs : seq term, (((gtn fs ft) \/ ((fs = ft) /\ (gtn (@size term sargs) (@size term targs)))) /\ (@ALL term (fun ti : term => lt2' ti (Fn fs sargs)) targs)) -> lt2' (Fn ft targs) (Fn fs sargs)) /\ (forall f : nat, forall sargs : seq term, forall targs : seq term, ((@ALL term (fun ti : term => lt2' ti (Fn f sargs)) targs) /\ (@LEX term lt2' targs sargs)) -> lt2' (Fn f targs) (Fn f sargs))))) -> forall a0 : term, forall a1 : term, (lpo a0 a1) -> lt2' a0 a1.
Axiom thm_LPO_CASES : (forall s : term, forall x : nat, (lpo s (V x)) = False) /\ ((forall x : nat, forall t : term, (lpo (V x) t) = ((@IN nat x (free_variables_term t)) /\ (~ (t = (V x))))) /\ (forall f : nat, forall fargs : seq term, forall g : nat, forall gargs : seq term, (lpo (Fn f fargs) (Fn g gargs)) = ((exists gi : term, (@MEM term gi gargs) /\ ((lpo (Fn f fargs) gi) \/ ((Fn f fargs) = gi))) \/ ((forall fi : term, (@MEM term fi fargs) -> lpo fi (Fn g gargs)) /\ (((ltn f g) \/ ((f = g) /\ (ltn (@size term fargs) (@size term gargs)))) \/ ((f = g) /\ (@LEX term lpo fargs gargs))))))).
Axiom thm_LPO_FVT : forall s : term, forall t : term, (lpo s t) -> @subset nat (free_variables_term s) (free_variables_term t).
Axiom thm_LPO_TRANS_INDUCT : forall n : nat, forall r : term, forall s : term, forall t : term, (((addn (termsize r) (addn (termsize s) (termsize t))) = n) /\ ((lpo t s) /\ (lpo s r))) -> lpo t r.
Axiom thm_LPO_TRANS : forall s : term, forall t : term, forall u : term, ((lpo s t) /\ (lpo t u)) -> lpo s u.
Axiom thm_LPO_SUBTERM_LEMMA : forall f : nat, forall args : seq term, forall a : term, (@MEM term a args) -> lpo a (Fn f args).
Axiom thm_LPO_SUBTERM : forall s : term, forall t : term, (subterm s t) -> (s = t) \/ (lpo s t).
Axiom thm_LPO_PSUBTERM : forall s : term, forall t : term, (psubterm s t) -> lpo s t.
Axiom thm_LPO_INSTANTIATION : forall i : nat -> term, forall s : term, forall t : term, (lpo s t) -> lpo (termsubst i s) (termsubst i t).
Axiom thm_LPO_CONGRUENCE : forall (f : nat) (largs : seq term) (rargs : seq term), forall s : term, forall t : term, (lpo s t) -> lpo (Fn f (@cat term largs (@cons term s rargs))) (Fn f (@cat term largs (@cons term t rargs))).
Axiom thm_LPO_REFL : forall t : term, ~ (lpo t t).
Axiom thm_LPO_WF : forall A : (prod nat nat) -> Prop, (@finite_set (prod nat nat) A) -> @well_founded term (fun s : term => fun t : term => (@subset (prod nat nat) (functions_term s) A) /\ ((@subset (prod nat nat) (functions_term t) A) /\ (lpo s t))).
Axiom thm_LPO_SUBTERM_NOT : forall t : term, forall s : term, (subterm s t) -> ~ (lpo t s).
Axiom thm_LEX_TOTAL : forall fargs : seq term, forall gargs : seq term, (((@size term fargs) = (@size term gargs)) /\ (forall fi : term, forall gi : term, ((@MEM term fi fargs) /\ (@MEM term gi gargs)) -> (lpo fi gi) \/ ((lpo gi fi) \/ (fi = gi)))) -> (@LEX term lpo fargs gargs) \/ ((@LEX term lpo gargs fargs) \/ (fargs = gargs)).
Axiom thm_LPO_GROUND_COMPLETE : forall s : term, forall t : term, (((free_variables_term s) = (@set0 nat)) /\ ((free_variables_term t) = (@set0 nat))) -> (lpo s t) \/ ((lpo t s) \/ (s = t)).
