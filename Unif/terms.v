Require Import Stdlib.Reals.Reals mathcomp.boot.ssrnat mathcomp.boot.div mathcomp.boot.seq mathcomp.algebra.ssralg mathcomp.algebra.ssrint mathcomp.algebra.intdiv mathcomp.classical.classical_sets mathcomp.classical.cardinality mathcomp.analysis_stdlib.Rstruct_topology HOLLight.Unif.mappings.
Definition I {A : Type'} : A -> A := fun x : A => x.
Lemma I_def {A : Type'} : (@I A) = (fun x : A => x).
Proof. exact (REFL (@I A)). Qed.
Definition _SEQPATTERN {A B : Type'} : (A -> B -> Prop) -> (A -> B -> Prop) -> A -> B -> Prop := fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x).
Lemma _SEQPATTERN_def {A B : Type'} : (@_SEQPATTERN A B) = (fun r : A -> B -> Prop => fun s : A -> B -> Prop => fun x : A => @COND (B -> Prop) (exists y : B, r x y) (r x) (s x)).
Proof. exact (REFL (@_SEQPATTERN A B)). Qed.
Definition _GUARDED_PATTERN : Prop -> Prop -> Prop -> Prop := fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r).
Lemma _GUARDED_PATTERN_def : _GUARDED_PATTERN = (fun p : Prop => fun g : Prop => fun r : Prop => p /\ (g /\ r)).
Proof. exact (REFL _GUARDED_PATTERN). Qed.
Definition _MATCH {A B : Type'} : A -> (A -> B -> Prop) -> B := fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False)).
Lemma _MATCH_def {A B : Type'} : (@_MATCH A B) = (fun e : A => fun r : A -> B -> Prop => @COND B (@ex1 B (r e)) (@ε B (r e)) (@ε B (fun z : B => False))).
Proof. exact (REFL (@_MATCH A B)). Qed.
Definition _FUNCTION {A B : Type'} : (A -> B -> Prop) -> A -> B := fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False)).
Lemma _FUNCTION_def {A B : Type'} : (@_FUNCTION A B) = (fun r : A -> B -> Prop => fun x : A => @COND B (@ex1 B (r x)) (@ε B (r x)) (@ε B (fun z : B => False))).
Proof. exact (REFL (@_FUNCTION A B)). Qed.
Definition CURRY {A B C : Type'} : ((prod A B) -> C) -> A -> B -> C := fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285).
Lemma CURRY_def {A B C : Type'} : (@CURRY A B C) = (fun _1283 : (prod A B) -> C => fun _1284 : A => fun _1285 : B => _1283 (@pair A B _1284 _1285)).
Proof. exact (REFL (@CURRY A B C)). Qed.
Definition UNCURRY {A B C : Type'} : (A -> B -> C) -> (prod A B) -> C := fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305).
Lemma UNCURRY_def {A B C : Type'} : (@UNCURRY A B C) = (fun _1304 : A -> B -> C => fun _1305 : prod A B => _1304 (@fst A B _1305) (@snd A B _1305)).
Proof. exact (REFL (@UNCURRY A B C)). Qed.
Definition PASSOC {A B C D : Type'} : ((prod (prod A B) C) -> D) -> (prod A (prod B C)) -> D := fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322))).
Lemma PASSOC_def {A B C D : Type'} : (@PASSOC A B C D) = (fun _1321 : (prod (prod A B) C) -> D => fun _1322 : prod A (prod B C) => _1321 (@pair (prod A B) C (@pair A B (@fst A (prod B C) _1322) (@fst B C (@snd A (prod B C) _1322))) (@snd B C (@snd A (prod B C) _1322)))).
Proof. exact (REFL (@PASSOC A B C D)). Qed.
Definition minimal : (nat -> Prop) -> nat := fun _6536 : nat -> Prop => @ε nat (fun n : nat => (_6536 n) /\ (forall m : nat, (ltn m n) -> ~ (_6536 m))).
Lemma minimal_def : minimal = (fun _6536 : nat -> Prop => @ε nat (fun n : nat => (_6536 n) /\ (forall m : nat, (ltn m n) -> ~ (_6536 m)))).
Proof. exact (REFL minimal). Qed.
Definition FNIL {A : Type'} : nat -> A := fun _17624 : nat => @ε A (fun x : A => True).
Lemma FNIL_def {A : Type'} : (@FNIL A) = (fun _17624 : nat => @ε A (fun x : A => True)).
Proof. exact (REFL (@FNIL A)). Qed.
Definition OUTL {A B : Type'} : (Datatypes.sum A B) -> A := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17649 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O))))))))))).
Lemma OUTL_def {A B : Type'} : (@OUTL A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A) (fun OUTL' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> A => forall _17649 : prod nat (prod nat (prod nat nat)), forall x : A, (OUTL' _17649 (@inl A B x)) = x) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))))))).
Proof. exact (REFL (@OUTL A B)). Qed.
Definition OUTR {A B : Type'} : (Datatypes.sum A B) -> B := @ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17651 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O))))))))))).
Lemma OUTR_def {A B : Type'} : (@OUTR A B) = (@ε ((prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B) (fun OUTR' : (prod nat (prod nat (prod nat nat))) -> (Datatypes.sum A B) -> B => forall _17651 : prod nat (prod nat (prod nat nat)), forall y : B, (OUTR' _17651 (@inr A B y)) = y) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))))))).
Proof. exact (REFL (@OUTR A B)). Qed.
Definition _22943 : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL O) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7).
Lemma _22943_def : _22943 = (fun a0 : Prop => fun a1 : Prop => fun a2 : Prop => fun a3 : Prop => fun a4 : Prop => fun a5 : Prop => fun a6 : Prop => fun a7 : Prop => _mk_char ((fun a0' : Prop => fun a1' : Prop => fun a2' : Prop => fun a3' : Prop => fun a4' : Prop => fun a5' : Prop => fun a6' : Prop => fun a7' : Prop => @CONSTR (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))) (NUMERAL O) (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))))) a0' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))) a1' (@pair Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop)))) a2' (@pair Prop (prod Prop (prod Prop (prod Prop Prop))) a3' (@pair Prop (prod Prop (prod Prop Prop)) a4' (@pair Prop (prod Prop Prop) a5' (@pair Prop Prop a6' a7'))))))) (fun n : nat => @BOTTOM (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop (prod Prop Prop))))))))) a0 a1 a2 a3 a4 a5 a6 a7)).
Proof. exact (REFL _22943). Qed.
Definition ASCII : Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Ascii.ascii := _22943.
Lemma ASCII_def : ASCII = _22943.
Proof. exact (REFL ASCII). Qed.
Definition DECIMAL : nat -> nat -> R := fun _27914 : nat => fun _27915 : nat => divr (R_of_nat _27914) (R_of_nat _27915).
Lemma DECIMAL_def : DECIMAL = (fun _27914 : nat => fun _27915 : nat => divr (R_of_nat _27914) (R_of_nat _27915)).
Proof. exact (REFL DECIMAL). Qed.
Definition eq2 {A : Type'} : A -> A -> (A -> A -> Prop) -> Prop := fun _29688 : A => fun _29689 : A => fun _29690 : A -> A -> Prop => _29690 _29688 _29689.
Lemma eq2_def {A : Type'} : (@eq2 A) = (fun _29688 : A => fun _29689 : A => fun _29690 : A -> A -> Prop => _29690 _29688 _29689).
Proof. exact (REFL (@eq2 A)). Qed.
Definition int_mod : int -> int -> int -> Prop := fun _29750 : int => fun _29751 : int => fun _29752 : int => dividez _29750 (subz _29751 _29752).
Lemma int_mod_def : int_mod = (fun _29750 : int => fun _29751 : int => fun _29752 : int => dividez _29750 (subz _29751 _29752)).
Proof. exact (REFL int_mod). Qed.
Definition num_of_int : int -> nat := fun _31320 : int => @ε nat (fun n : nat => (int_of_nat n) = _31320).
Lemma num_of_int_def : num_of_int = (fun _31320 : int => @ε nat (fun n : nat => (int_of_nat n) = _31320)).
Proof. exact (REFL num_of_int). Qed.
Definition num_divides : nat -> nat -> Prop := fun _31352 : nat => fun _31353 : nat => dividez (int_of_nat _31352) (int_of_nat _31353).
Lemma num_divides_def : num_divides = (fun _31352 : nat => fun _31353 : nat => dividez (int_of_nat _31352) (int_of_nat _31353)).
Proof. exact (REFL num_divides). Qed.
Definition num_mod : nat -> nat -> nat -> Prop := fun _31364 : nat => fun _31365 : nat => fun _31366 : nat => int_mod (int_of_nat _31364) (int_of_nat _31365) (int_of_nat _31366).
Lemma num_mod_def : num_mod = (fun _31364 : nat => fun _31365 : nat => fun _31366 : nat => int_mod (int_of_nat _31364) (int_of_nat _31365) (int_of_nat _31366)).
Proof. exact (REFL num_mod). Qed.
Definition num_coprime : (prod nat nat) -> Prop := fun _31385 : prod nat nat => pair_coprimez (@pair int int (int_of_nat (@fst nat nat _31385)) (int_of_nat (@snd nat nat _31385))).
Lemma num_coprime_def : num_coprime = (fun _31385 : prod nat nat => pair_coprimez (@pair int int (int_of_nat (@fst nat nat _31385)) (int_of_nat (@snd nat nat _31385)))).
Proof. exact (REFL num_coprime). Qed.
Definition num_gcd : (prod nat nat) -> nat := fun _31394 : prod nat nat => num_of_int (pair_gcdz (@pair int int (int_of_nat (@fst nat nat _31394)) (int_of_nat (@snd nat nat _31394)))).
Lemma num_gcd_def : num_gcd = (fun _31394 : prod nat nat => num_of_int (pair_gcdz (@pair int int (int_of_nat (@fst nat nat _31394)) (int_of_nat (@snd nat nat _31394))))).
Proof. exact (REFL num_gcd). Qed.
Definition num_lcm : (prod nat nat) -> nat := fun _31403 : prod nat nat => num_of_int (pair_lcmz (@pair int int (int_of_nat (@fst nat nat _31403)) (int_of_nat (@snd nat nat _31403)))).
Lemma num_lcm_def : num_lcm = (fun _31403 : prod nat nat => num_of_int (pair_lcmz (@pair int int (int_of_nat (@fst nat nat _31403)) (int_of_nat (@snd nat nat _31403))))).
Proof. exact (REFL num_lcm). Qed.
Definition prime : nat -> Prop := fun _32188 : nat => (~ (_32188 = (NUMERAL (BIT1 O)))) /\ (forall x : nat, (num_divides x _32188) -> (x = (NUMERAL (BIT1 O))) \/ (x = _32188)).
Lemma prime_def : prime = (fun _32188 : nat => (~ (_32188 = (NUMERAL (BIT1 O)))) /\ (forall x : nat, (num_divides x _32188) -> (x = (NUMERAL (BIT1 O))) \/ (x = _32188))).
Proof. exact (REFL prime). Qed.
Definition real_zpow : R -> int -> R := fun _32346 : R => fun _32347 : int => @COND R (lez (int_of_nat (NUMERAL O)) _32347) (expr _32346 (num_of_int _32347)) (invr (expr _32346 (num_of_int (oppz _32347)))).
Lemma real_zpow_def : real_zpow = (fun _32346 : R => fun _32347 : int => @COND R (lez (int_of_nat (NUMERAL O)) _32347) (expr _32346 (num_of_int _32347)) (invr (expr _32346 (num_of_int (oppz _32347))))).
Proof. exact (REFL real_zpow). Qed.
Definition INFINITE {A : Type'} : (A -> Prop) -> Prop := fun _32574 : A -> Prop => ~ (@finite_set A _32574).
Lemma INFINITE_def {A : Type'} : (@INFINITE A) = (fun _32574 : A -> Prop => ~ (@finite_set A _32574)).
Proof. exact (REFL (@INFINITE A)). Qed.
Definition INJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32591 : A -> B => fun _32592 : A -> Prop => fun _32593 : B -> Prop => (forall x : A, (@IN A x _32592) -> @IN B (_32591 x) _32593) /\ (forall x : A, forall y : A, ((@IN A x _32592) /\ ((@IN A y _32592) /\ ((_32591 x) = (_32591 y)))) -> x = y).
Lemma INJ_def {A B : Type'} : (@INJ A B) = (fun _32591 : A -> B => fun _32592 : A -> Prop => fun _32593 : B -> Prop => (forall x : A, (@IN A x _32592) -> @IN B (_32591 x) _32593) /\ (forall x : A, forall y : A, ((@IN A x _32592) /\ ((@IN A y _32592) /\ ((_32591 x) = (_32591 y)))) -> x = y)).
Proof. exact (REFL (@INJ A B)). Qed.
Definition SURJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32612 : A -> B => fun _32613 : A -> Prop => fun _32614 : B -> Prop => (forall x : A, (@IN A x _32613) -> @IN B (_32612 x) _32614) /\ (forall x : B, (@IN B x _32614) -> exists y : A, (@IN A y _32613) /\ ((_32612 y) = x)).
Lemma SURJ_def {A B : Type'} : (@SURJ A B) = (fun _32612 : A -> B => fun _32613 : A -> Prop => fun _32614 : B -> Prop => (forall x : A, (@IN A x _32613) -> @IN B (_32612 x) _32614) /\ (forall x : B, (@IN B x _32614) -> exists y : A, (@IN A y _32613) /\ ((_32612 y) = x))).
Proof. exact (REFL (@SURJ A B)). Qed.
Definition BIJ {A B : Type'} : (A -> B) -> (A -> Prop) -> (B -> Prop) -> Prop := fun _32633 : A -> B => fun _32634 : A -> Prop => fun _32635 : B -> Prop => (@INJ A B _32633 _32634 _32635) /\ (@SURJ A B _32633 _32634 _32635).
Lemma BIJ_def {A B : Type'} : (@BIJ A B) = (fun _32633 : A -> B => fun _32634 : A -> Prop => fun _32635 : B -> Prop => (@INJ A B _32633 _32634 _32635) /\ (@SURJ A B _32633 _32634 _32635)).
Proof. exact (REFL (@BIJ A B)). Qed.
Definition CHOICE {A : Type'} : (A -> Prop) -> A := fun _32654 : A -> Prop => @ε A (fun x : A => @IN A x _32654).
Lemma CHOICE_def {A : Type'} : (@CHOICE A) = (fun _32654 : A -> Prop => @ε A (fun x : A => @IN A x _32654)).
Proof. exact (REFL (@CHOICE A)). Qed.
Definition REST {A : Type'} : (A -> Prop) -> A -> Prop := fun _32659 : A -> Prop => @DELETE A _32659 (@CHOICE A _32659).
Lemma REST_def {A : Type'} : (@REST A) = (fun _32659 : A -> Prop => @DELETE A _32659 (@CHOICE A _32659)).
Proof. exact (REFL (@REST A)). Qed.
Definition FINREC {A B : Type'} : (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _42261 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42261 f b s a (NUMERAL O)) = ((s = (@set0 A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _42261 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42261 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))))).
Lemma FINREC_def {A B : Type'} : (@FINREC A B) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop) (fun FINREC' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> (A -> B -> B) -> B -> (A -> Prop) -> B -> nat -> Prop => forall _42261 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall f : A -> B -> B, forall s : A -> Prop, forall a : B, forall b : B, (FINREC' _42261 f b s a (NUMERAL O)) = ((s = (@set0 A)) /\ (a = b))) /\ (forall b : B, forall s : A -> Prop, forall n : nat, forall a : B, forall f : A -> B -> B, (FINREC' _42261 f b s a (S n)) = (exists x : A, exists c : B, (@IN A x s) /\ ((FINREC' _42261 f b (@DELETE A s x) c n) /\ (a = (f x c)))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))))))).
Proof. exact (REFL (@FINREC A B)). Qed.
Definition HAS_SIZE {A : Type'} : (A -> Prop) -> nat -> Prop := fun _43489 : A -> Prop => fun _43490 : nat => (@finite_set A _43489) /\ ((@CARD A _43489) = _43490).
Lemma HAS_SIZE_def {A : Type'} : (@HAS_SIZE A) = (fun _43489 : A -> Prop => fun _43490 : nat => (@finite_set A _43489) /\ ((@CARD A _43489) = _43490)).
Proof. exact (REFL (@HAS_SIZE A)). Qed.
Definition CROSS {A B : Type'} : (A -> Prop) -> (B -> Prop) -> (prod A B) -> Prop := fun _47408 : A -> Prop => fun _47409 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47408) /\ (@IN B y _47409)) (@pair A B x y)).
Lemma CROSS_def {A B : Type'} : (@CROSS A B) = (fun _47408 : A -> Prop => fun _47409 : B -> Prop => @GSPEC (prod A B) (fun GEN_PVAR_132 : prod A B => exists x : A, exists y : B, @SETSPEC (prod A B) GEN_PVAR_132 ((@IN A x _47408) /\ (@IN B y _47409)) (@pair A B x y))).
Proof. exact (REFL (@CROSS A B)). Qed.
Definition ARB {A : Type'} : A := @ε A (fun x : A => False).
Lemma ARB_def {A : Type'} : (@ARB A) = (@ε A (fun x : A => False)).
Proof. exact (REFL (@ARB A)). Qed.
Definition EXTENSIONAL {A B : Type'} : (A -> Prop) -> (A -> B) -> Prop := fun _48182 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48182)) -> (f x) = (@ARB B)) f).
Lemma EXTENSIONAL_def {A B : Type'} : (@EXTENSIONAL A B) = (fun _48182 : A -> Prop => @GSPEC (A -> B) (fun GEN_PVAR_141 : A -> B => exists f : A -> B, @SETSPEC (A -> B) GEN_PVAR_141 (forall x : A, (~ (@IN A x _48182)) -> (f x) = (@ARB B)) f)).
Proof. exact (REFL (@EXTENSIONAL A B)). Qed.
Definition RESTRICTION {A B : Type'} : (A -> Prop) -> (A -> B) -> A -> B := fun _48234 : A -> Prop => fun _48235 : A -> B => fun _48236 : A => @COND B (@IN A _48236 _48234) (_48235 _48236) (@ARB B).
Lemma RESTRICTION_def {A B : Type'} : (@RESTRICTION A B) = (fun _48234 : A -> Prop => fun _48235 : A -> B => fun _48236 : A => @COND B (@IN A _48236 _48234) (_48235 _48236) (@ARB B)).
Proof. exact (REFL (@RESTRICTION A B)). Qed.
Definition cartesian_product {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (K -> A) -> Prop := fun _48429 : K -> Prop => fun _48430 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48429 f) /\ (forall i : K, (@IN K i _48429) -> @IN A (f i) (_48430 i))) f).
Lemma cartesian_product_def {A K : Type'} : (@cartesian_product A K) = (fun _48429 : K -> Prop => fun _48430 : K -> A -> Prop => @GSPEC (K -> A) (fun GEN_PVAR_142 : K -> A => exists f : K -> A, @SETSPEC (K -> A) GEN_PVAR_142 ((@EXTENSIONAL K A _48429 f) /\ (forall i : K, (@IN K i _48429) -> @IN A (f i) (_48430 i))) f)).
Proof. exact (REFL (@cartesian_product A K)). Qed.
Definition product_map {A B K : Type'} : (K -> Prop) -> (K -> A -> B) -> (K -> A) -> K -> B := fun _49478 : K -> Prop => fun _49479 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49478 (fun i : K => _49479 i (x i)).
Lemma product_map_def {A B K : Type'} : (@product_map A B K) = (fun _49478 : K -> Prop => fun _49479 : K -> A -> B => fun x : K -> A => @RESTRICTION K B _49478 (fun i : K => _49479 i (x i))).
Proof. exact (REFL (@product_map A B K)). Qed.
Definition disjoint_union {A K : Type'} : (K -> Prop) -> (K -> A -> Prop) -> (prod K A) -> Prop := fun _49614 : K -> Prop => fun _49615 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49614) /\ (@IN A x (_49615 i))) (@pair K A i x)).
Lemma disjoint_union_def {A K : Type'} : (@disjoint_union A K) = (fun _49614 : K -> Prop => fun _49615 : K -> A -> Prop => @GSPEC (prod K A) (fun GEN_PVAR_145 : prod K A => exists i : K, exists x : A, @SETSPEC (prod K A) GEN_PVAR_145 ((@IN K i _49614) /\ (@IN A x (_49615 i))) (@pair K A i x))).
Proof. exact (REFL (@disjoint_union A K)). Qed.
Definition pairwise {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _56702 : A -> A -> Prop => fun _56703 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56703) /\ ((@IN A y _56703) /\ (~ (x = y)))) -> _56702 x y.
Lemma pairwise_def {A : Type'} : (@pairwise A) = (fun _56702 : A -> A -> Prop => fun _56703 : A -> Prop => forall x : A, forall y : A, ((@IN A x _56703) /\ ((@IN A y _56703) /\ (~ (x = y)))) -> _56702 x y).
Proof. exact (REFL (@pairwise A)). Qed.
Definition UNION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57415 : ((A -> Prop) -> Prop) -> Prop => fun _57416 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57415 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57416 c) /\ ((@UNIONS A u) = s)).
Lemma UNION_OF_def {A : Type'} : (@UNION_OF A) = (fun _57415 : ((A -> Prop) -> Prop) -> Prop => fun _57416 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57415 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57416 c) /\ ((@UNIONS A u) = s))).
Proof. exact (REFL (@UNION_OF A)). Qed.
Definition INTERSECTION_OF {A : Type'} : (((A -> Prop) -> Prop) -> Prop) -> ((A -> Prop) -> Prop) -> (A -> Prop) -> Prop := fun _57427 : ((A -> Prop) -> Prop) -> Prop => fun _57428 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57427 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57428 c) /\ ((@INTERS A u) = s)).
Lemma INTERSECTION_OF_def {A : Type'} : (@INTERSECTION_OF A) = (fun _57427 : ((A -> Prop) -> Prop) -> Prop => fun _57428 : (A -> Prop) -> Prop => fun s : A -> Prop => exists u : (A -> Prop) -> Prop, (_57427 u) /\ ((forall c : A -> Prop, (@IN (A -> Prop) c u) -> _57428 c) /\ ((@INTERS A u) = s))).
Proof. exact (REFL (@INTERSECTION_OF A)). Qed.
Definition ARBITRARY {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _57563 : (A -> Prop) -> Prop => True.
Lemma ARBITRARY_def {A : Type'} : (@ARBITRARY A) = (fun _57563 : (A -> Prop) -> Prop => True).
Proof. exact (REFL (@ARBITRARY A)). Qed.
Definition le_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64157 : A -> Prop => fun _64158 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64157) -> @IN B (f x) _64158) /\ (forall x : A, forall y : A, ((@IN A x _64157) /\ ((@IN A y _64157) /\ ((f x) = (f y)))) -> x = y).
Lemma le_c_def {A B : Type'} : (@le_c A B) = (fun _64157 : A -> Prop => fun _64158 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64157) -> @IN B (f x) _64158) /\ (forall x : A, forall y : A, ((@IN A x _64157) /\ ((@IN A y _64157) /\ ((f x) = (f y)))) -> x = y)).
Proof. exact (REFL (@le_c A B)). Qed.
Definition lt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64169 : A -> Prop => fun _64170 : B -> Prop => (@le_c A B _64169 _64170) /\ (~ (@le_c B A _64170 _64169)).
Lemma lt_c_def {A B : Type'} : (@lt_c A B) = (fun _64169 : A -> Prop => fun _64170 : B -> Prop => (@le_c A B _64169 _64170) /\ (~ (@le_c B A _64170 _64169))).
Proof. exact (REFL (@lt_c A B)). Qed.
Definition eq_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64181 : A -> Prop => fun _64182 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64181) -> @IN B (f x) _64182) /\ (forall y : B, (@IN B y _64182) -> @ex1 A (fun x : A => (@IN A x _64181) /\ ((f x) = y))).
Lemma eq_c_def {A B : Type'} : (@eq_c A B) = (fun _64181 : A -> Prop => fun _64182 : B -> Prop => exists f : A -> B, (forall x : A, (@IN A x _64181) -> @IN B (f x) _64182) /\ (forall y : B, (@IN B y _64182) -> @ex1 A (fun x : A => (@IN A x _64181) /\ ((f x) = y)))).
Proof. exact (REFL (@eq_c A B)). Qed.
Definition ge_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64193 : A -> Prop => fun _64194 : B -> Prop => @le_c B A _64194 _64193.
Lemma ge_c_def {A B : Type'} : (@ge_c A B) = (fun _64193 : A -> Prop => fun _64194 : B -> Prop => @le_c B A _64194 _64193).
Proof. exact (REFL (@ge_c A B)). Qed.
Definition gt_c {A B : Type'} : (A -> Prop) -> (B -> Prop) -> Prop := fun _64205 : A -> Prop => fun _64206 : B -> Prop => @lt_c B A _64206 _64205.
Lemma gt_c_def {A B : Type'} : (@gt_c A B) = (fun _64205 : A -> Prop => fun _64206 : B -> Prop => @lt_c B A _64206 _64205).
Proof. exact (REFL (@gt_c A B)). Qed.
Definition COUNTABLE {A : Type'} : (A -> Prop) -> Prop := fun _64356 : A -> Prop => @ge_c nat A (@setT nat) _64356.
Lemma COUNTABLE_def {A : Type'} : (@COUNTABLE A) = (fun _64356 : A -> Prop => @ge_c nat A (@setT nat) _64356).
Proof. exact (REFL (@COUNTABLE A)). Qed.
Definition sup : (R -> Prop) -> R := fun _64361 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64361) -> ler x a) /\ (forall b : R, (forall x : R, (@IN R x _64361) -> ler x b) -> ler a b)).
Lemma sup_def : sup = (fun _64361 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _64361) -> ler x a) /\ (forall b : R, (forall x : R, (@IN R x _64361) -> ler x b) -> ler a b))).
Proof. exact (REFL sup). Qed.
Definition inf : (R -> Prop) -> R := fun _65220 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65220) -> ler a x) /\ (forall b : R, (forall x : R, (@IN R x _65220) -> ler b x) -> ler b a)).
Lemma inf_def : inf = (fun _65220 : R -> Prop => @ε R (fun a : R => (forall x : R, (@IN R x _65220) -> ler a x) /\ (forall b : R, (forall x : R, (@IN R x _65220) -> ler b x) -> ler b a))).
Proof. exact (REFL inf). Qed.
Definition has_inf : (R -> Prop) -> R -> Prop := fun _66570 : R -> Prop => fun _66571 : R => forall c : R, (forall x : R, (@IN R x _66570) -> ler c x) = (ler c _66571).
Lemma has_inf_def : has_inf = (fun _66570 : R -> Prop => fun _66571 : R => forall c : R, (forall x : R, (@IN R x _66570) -> ler c x) = (ler c _66571)).
Proof. exact (REFL has_inf). Qed.
Definition has_sup : (R -> Prop) -> R -> Prop := fun _66582 : R -> Prop => fun _66583 : R => forall c : R, (forall x : R, (@IN R x _66582) -> ler x c) = (ler _66583 c).
Lemma has_sup_def : has_sup = (fun _66582 : R -> Prop => fun _66583 : R => forall c : R, (forall x : R, (@IN R x _66582) -> ler x c) = (ler _66583 c)).
Proof. exact (REFL has_sup). Qed.
Definition monoidal {A : Type'} : (A -> A -> A) -> Prop := fun _68925 : A -> A -> A => (forall x : A, forall y : A, (_68925 x y) = (_68925 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68925 x (_68925 y z)) = (_68925 (_68925 x y) z)) /\ (forall x : A, (_68925 (@neutral A _68925) x) = x)).
Lemma monoidal_def {A : Type'} : (@monoidal A) = (fun _68925 : A -> A -> A => (forall x : A, forall y : A, (_68925 x y) = (_68925 y x)) /\ ((forall x : A, forall y : A, forall z : A, (_68925 x (_68925 y z)) = (_68925 (_68925 x y) z)) /\ (forall x : A, (_68925 (@neutral A _68925) x) = x))).
Proof. exact (REFL (@monoidal A)). Qed.
Definition iterato {A K : Type'} : (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76787 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76787 dom neut op ltle k f) = (@COND A ((@finite_set K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) = (@set0 K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76787 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))).
Lemma iterato_def {A K : Type'} : (@iterato A K) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A) (fun itty : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) -> (A -> Prop) -> A -> (A -> A -> A) -> (K -> K -> Prop) -> (K -> Prop) -> (K -> A) -> A => forall _76787 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))), forall dom : A -> Prop, forall neut : A, forall op : A -> A -> A, forall ltle : K -> K -> Prop, forall k : K -> Prop, forall f : K -> A, (itty _76787 dom neut op ltle k f) = (@COND A ((@finite_set K (@GSPEC K (fun GEN_PVAR_265 : K => exists i : K, @SETSPEC K GEN_PVAR_265 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i))) /\ (~ ((@GSPEC K (fun GEN_PVAR_266 : K => exists i : K, @SETSPEC K GEN_PVAR_266 ((@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A))))) i)) = (@set0 K)))) (@LET K A (fun i : K => @LET_END A (op (f i) (itty _76787 dom neut op ltle (@GSPEC K (fun GEN_PVAR_267 : K => exists j : K, @SETSPEC K GEN_PVAR_267 ((@IN K j (@DELETE K k i)) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A))))) j)) f))) (@COND K (exists i : K, (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i))) (@ε K (fun i : K => (@IN K i k) /\ ((@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))) /\ (forall j : K, ((ltle j i) /\ ((@IN K j k) /\ (@IN A (f j) (@setD A dom (@INSERT A neut (@set0 A)))))) -> j = i)))) (@ε K (fun i : K => (@IN K i k) /\ (@IN A (f i) (@setD A dom (@INSERT A neut (@set0 A)))))))) neut)) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))).
Proof. exact (REFL (@iterato A K)). Qed.
Definition nproduct {A : Type'} : (A -> Prop) -> (A -> nat) -> nat := @iterate A nat muln.
Lemma nproduct_def {A : Type'} : (@nproduct A) = (@iterate A nat muln).
Proof. exact (REFL (@nproduct A)). Qed.
Definition iproduct {A : Type'} : (A -> Prop) -> (A -> int) -> int := @iterate A int mulz.
Lemma iproduct_def {A : Type'} : (@iproduct A) = (@iterate A int mulz).
Proof. exact (REFL (@iproduct A)). Qed.
Definition product {A : Type'} : (A -> Prop) -> (A -> R) -> R := @iterate A R mulr.
Lemma product_def {A : Type'} : (@product A) = (@iterate A R mulr).
Proof. exact (REFL (@product A)). Qed.
Definition isum {A : Type'} : (A -> Prop) -> (A -> int) -> int := @iterate A int addz.
Lemma isum_def {A : Type'} : (@isum A) = (@iterate A int addz).
Proof. exact (REFL (@isum A)). Qed.
Definition nsum {A : Type'} : (A -> Prop) -> (A -> nat) -> nat := @iterate A nat addn.
Lemma nsum_def {A : Type'} : (@nsum A) = (@iterate A nat addn).
Proof. exact (REFL (@nsum A)). Qed.
Definition polynomial_function : (R -> R) -> Prop := fun _94200 : R -> R => exists m : nat, exists c : nat -> R, forall x : R, (_94200 x) = (@sum nat (dotdot (NUMERAL O) m) (fun i : nat => mulr (c i) (expr x i))).
Lemma polynomial_function_def : polynomial_function = (fun _94200 : R -> R => exists m : nat, exists c : nat -> R, forall x : R, (_94200 x) = (@sum nat (dotdot (NUMERAL O) m) (fun i : nat => mulr (c i) (expr x i)))).
Proof. exact (REFL polynomial_function). Qed.
Definition lambda {A B : Type'} : (nat -> A) -> cart A B := fun _94688 : nat -> A => @ε (cart A B) (fun f : cart A B => forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B f i) = (_94688 i)).
Lemma lambda_def {A B : Type'} : (@lambda A B) = (fun _94688 : nat -> A => @ε (cart A B) (fun f : cart A B => forall i : nat, ((leqn (NUMERAL (BIT1 O)) i) /\ (leqn i (@dimindex B (@setT B)))) -> (@dollar A B f i) = (_94688 i))).
Proof. exact (REFL (@lambda A B)). Qed.
Definition pastecart {A M N' : Type'} : (cart A M) -> (cart A N') -> cart A (finite_sum M N') := fun _94979 : cart A M => fun _94980 : cart A N' => @lambda A (finite_sum M N') (fun i : nat => @COND A (leqn i (@dimindex M (@setT M))) (@dollar A M _94979 i) (@dollar A N' _94980 (subn i (@dimindex M (@setT M))))).
Lemma pastecart_def {A M N' : Type'} : (@pastecart A M N') = (fun _94979 : cart A M => fun _94980 : cart A N' => @lambda A (finite_sum M N') (fun i : nat => @COND A (leqn i (@dimindex M (@setT M))) (@dollar A M _94979 i) (@dollar A N' _94980 (subn i (@dimindex M (@setT M)))))).
Proof. exact (REFL (@pastecart A M N')). Qed.
Definition fstcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A M := fun _94991 : cart A (finite_sum M N') => @lambda A M (fun i : nat => @dollar A (finite_sum M N') _94991 i).
Lemma fstcart_def {A M N' : Type'} : (@fstcart A M N') = (fun _94991 : cart A (finite_sum M N') => @lambda A M (fun i : nat => @dollar A (finite_sum M N') _94991 i)).
Proof. exact (REFL (@fstcart A M N')). Qed.
Definition sndcart {A M N' : Type'} : (cart A (finite_sum M N')) -> cart A N' := fun _94996 : cart A (finite_sum M N') => @lambda A N' (fun i : nat => @dollar A (finite_sum M N') _94996 (addn i (@dimindex M (@setT M)))).
Lemma sndcart_def {A M N' : Type'} : (@sndcart A M N') = (fun _94996 : cart A (finite_sum M N') => @lambda A N' (fun i : nat => @dollar A (finite_sum M N') _94996 (addn i (@dimindex M (@setT M))))).
Proof. exact (REFL (@sndcart A M N')). Qed.
Definition _100406 {A : Type'} : (finite_sum A A) -> tybit0 A := fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum A A))) a).
Lemma _100406_def {A : Type'} : (@_100406 A) = (fun a : finite_sum A A => @_mk_tybit0 A ((fun a' : finite_sum A A => @CONSTR (finite_sum A A) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum A A))) a)).
Proof. exact (REFL (@_100406 A)). Qed.
Definition mktybit0 {A : Type'} : (finite_sum A A) -> tybit0 A := @_100406 A.
Lemma mktybit0_def {A : Type'} : (@mktybit0 A) = (@_100406 A).
Proof. exact (REFL (@mktybit0 A)). Qed.
Definition _100425 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a).
Lemma _100425_def {A : Type'} : (@_100425 A) = (fun a : finite_sum (finite_sum A A) unit => @_mk_tybit1 A ((fun a' : finite_sum (finite_sum A A) unit => @CONSTR (finite_sum (finite_sum A A) unit) (NUMERAL O) a' (fun n : nat => @BOTTOM (finite_sum (finite_sum A A) unit))) a)).
Proof. exact (REFL (@_100425 A)). Qed.
Definition mktybit1 {A : Type'} : (finite_sum (finite_sum A A) unit) -> tybit1 A := @_100425 A.
Lemma mktybit1_def {A : Type'} : (@mktybit1 A) = (@_100425 A).
Proof. exact (REFL (@mktybit1 A)). Qed.
Definition vector {A N' : Type'} : (seq A) -> cart A N' := fun _102119 : seq A => @lambda A N' (fun i : nat => @EL A (subn i (NUMERAL (BIT1 O))) _102119).
Lemma vector_def {A N' : Type'} : (@vector A N') = (fun _102119 : seq A => @lambda A N' (fun i : nat => @EL A (subn i (NUMERAL (BIT1 O))) _102119)).
Proof. exact (REFL (@vector A N')). Qed.
Definition PCROSS {A M N' : Type'} : ((cart A M) -> Prop) -> ((cart A N') -> Prop) -> (cart A (finite_sum M N')) -> Prop := fun _102146 : (cart A M) -> Prop => fun _102147 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102146) /\ (@IN (cart A N') y _102147)) (@pastecart A M N' x y)).
Lemma PCROSS_def {A M N' : Type'} : (@PCROSS A M N') = (fun _102146 : (cart A M) -> Prop => fun _102147 : (cart A N') -> Prop => @GSPEC (cart A (finite_sum M N')) (fun GEN_PVAR_363 : cart A (finite_sum M N') => exists x : cart A M, exists y : cart A N', @SETSPEC (cart A (finite_sum M N')) GEN_PVAR_363 ((@IN (cart A M) x _102146) /\ (@IN (cart A N') y _102147)) (@pastecart A M N' x y))).
Proof. exact (REFL (@PCROSS A M N')). Qed.
Definition CASEWISE {_138002 _138038 _138042 _138043 : Type'} : (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 => forall _102751 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@nil (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) f x) = (@ε _138002 (fun y : _138002 => True))) /\ (forall h : prod (_138038 -> _138042) (_138043 -> _138038 -> _138002), forall t : seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)), forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@cons (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) h t) f x) = (@COND _138002 (exists y : _138038, (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x) (@snd (_138038 -> _138042) (_138043 -> _138038 -> _138002) h f (@ε _138038 (fun y : _138038 => (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x))) (CASEWISE' _102751 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))))))).
Lemma CASEWISE_def {_138002 _138038 _138042 _138043 : Type'} : (@CASEWISE _138002 _138038 _138042 _138043) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002) (fun CASEWISE' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) -> (seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) -> _138043 -> _138042 -> _138002 => forall _102751 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))), (forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@nil (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002))) f x) = (@ε _138002 (fun y : _138002 => True))) /\ (forall h : prod (_138038 -> _138042) (_138043 -> _138038 -> _138002), forall t : seq (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)), forall f : _138043, forall x : _138042, (CASEWISE' _102751 (@cons (prod (_138038 -> _138042) (_138043 -> _138038 -> _138002)) h t) f x) = (@COND _138002 (exists y : _138038, (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x) (@snd (_138038 -> _138042) (_138043 -> _138038 -> _138002) h f (@ε _138038 (fun y : _138038 => (@fst (_138038 -> _138042) (_138043 -> _138038 -> _138002) h y) = x))) (CASEWISE' _102751 t f x)))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))))))))).
Proof. exact (REFL (@CASEWISE _138002 _138038 _138042 _138043)). Qed.
Definition admissible {_138333 _138336 _138340 _138341 _138346 : Type'} : (_138340 -> _138333 -> Prop) -> ((_138340 -> _138336) -> _138346 -> Prop) -> (_138346 -> _138333) -> ((_138340 -> _138336) -> _138346 -> _138341) -> Prop := fun _103818 : _138340 -> _138333 -> Prop => fun _103819 : (_138340 -> _138336) -> _138346 -> Prop => fun _103820 : _138346 -> _138333 => fun _103821 : (_138340 -> _138336) -> _138346 -> _138341 => forall f : _138340 -> _138336, forall g : _138340 -> _138336, forall a : _138346, ((_103819 f a) /\ ((_103819 g a) /\ (forall z : _138340, (_103818 z (_103820 a)) -> (f z) = (g z)))) -> (_103821 f a) = (_103821 g a).
Lemma admissible_def {_138333 _138336 _138340 _138341 _138346 : Type'} : (@admissible _138333 _138336 _138340 _138341 _138346) = (fun _103818 : _138340 -> _138333 -> Prop => fun _103819 : (_138340 -> _138336) -> _138346 -> Prop => fun _103820 : _138346 -> _138333 => fun _103821 : (_138340 -> _138336) -> _138346 -> _138341 => forall f : _138340 -> _138336, forall g : _138340 -> _138336, forall a : _138346, ((_103819 f a) /\ ((_103819 g a) /\ (forall z : _138340, (_103818 z (_103820 a)) -> (f z) = (g z)))) -> (_103821 f a) = (_103821 g a)).
Proof. exact (REFL (@admissible _138333 _138336 _138340 _138341 _138346)). Qed.
Definition tailadmissible {A B P : Type'} : (A -> A -> Prop) -> ((A -> B) -> P -> Prop) -> (P -> A) -> ((A -> B) -> P -> B) -> Prop := fun _103850 : A -> A -> Prop => fun _103851 : (A -> B) -> P -> Prop => fun _103852 : P -> A => fun _103853 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103850 y (G f a))) -> _103850 y (_103852 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103850 z (_103852 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103851 f a) -> (_103853 f a) = (@COND B (P' f a) (f (G f a)) (H f a)))).
Lemma tailadmissible_def {A B P : Type'} : (@tailadmissible A B P) = (fun _103850 : A -> A -> Prop => fun _103851 : (A -> B) -> P -> Prop => fun _103852 : P -> A => fun _103853 : (A -> B) -> P -> B => exists P' : (A -> B) -> P -> Prop, exists G : (A -> B) -> P -> A, exists H : (A -> B) -> P -> B, (forall f : A -> B, forall a : P, forall y : A, ((P' f a) /\ (_103850 y (G f a))) -> _103850 y (_103852 a)) /\ ((forall f : A -> B, forall g : A -> B, forall a : P, (forall z : A, (_103850 z (_103852 a)) -> (f z) = (g z)) -> ((P' f a) = (P' g a)) /\ (((G f a) = (G g a)) /\ ((H f a) = (H g a)))) /\ (forall f : A -> B, forall a : P, (_103851 f a) -> (_103853 f a) = (@COND B (P' f a) (f (G f a)) (H f a))))).
Proof. exact (REFL (@tailadmissible A B P)). Qed.
Definition superadmissible {_138490 _138492 _138498 : Type'} : (_138490 -> _138490 -> Prop) -> ((_138490 -> _138492) -> _138498 -> Prop) -> (_138498 -> _138490) -> ((_138490 -> _138492) -> _138498 -> _138492) -> Prop := fun _103882 : _138490 -> _138490 -> Prop => fun _103883 : (_138490 -> _138492) -> _138498 -> Prop => fun _103884 : _138498 -> _138490 => fun _103885 : (_138490 -> _138492) -> _138498 -> _138492 => (@admissible _138490 _138492 _138490 Prop _138498 _103882 (fun f : _138490 -> _138492 => fun a : _138498 => True) _103884 _103883) -> @tailadmissible _138490 _138492 _138498 _103882 _103883 _103884 _103885.
Lemma superadmissible_def {_138490 _138492 _138498 : Type'} : (@superadmissible _138490 _138492 _138498) = (fun _103882 : _138490 -> _138490 -> Prop => fun _103883 : (_138490 -> _138492) -> _138498 -> Prop => fun _103884 : _138498 -> _138490 => fun _103885 : (_138490 -> _138492) -> _138498 -> _138492 => (@admissible _138490 _138492 _138490 Prop _138498 _103882 (fun f : _138490 -> _138492 => fun a : _138498 => True) _103884 _103883) -> @tailadmissible _138490 _138492 _138498 _103882 _103883 _103884 _103885).
Proof. exact (REFL (@superadmissible _138490 _138492 _138498)). Qed.
Definition psum : (prod nat nat) -> (nat -> R) -> R := @ε ((prod nat (prod nat (prod nat nat))) -> (prod nat nat) -> (nat -> R) -> R) (fun sum' : (prod nat (prod nat (prod nat nat))) -> (prod nat nat) -> (nat -> R) -> R => forall _114544 : prod nat (prod nat (prod nat nat)), (forall f : nat -> R, forall n : nat, (sum' _114544 (@pair nat nat n (NUMERAL O)) f) = (R_of_nat (NUMERAL O))) /\ (forall f : nat -> R, forall m : nat, forall n : nat, (sum' _114544 (@pair nat nat n (S m)) f) = (addr (sum' _114544 (@pair nat nat n m) f) (f (addn n m))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))).
Lemma psum_def : psum = (@ε ((prod nat (prod nat (prod nat nat))) -> (prod nat nat) -> (nat -> R) -> R) (fun sum' : (prod nat (prod nat (prod nat nat))) -> (prod nat nat) -> (nat -> R) -> R => forall _114544 : prod nat (prod nat (prod nat nat)), (forall f : nat -> R, forall n : nat, (sum' _114544 (@pair nat nat n (NUMERAL O)) f) = (R_of_nat (NUMERAL O))) /\ (forall f : nat -> R, forall m : nat, forall n : nat, (sum' _114544 (@pair nat nat n (S m)) f) = (addr (sum' _114544 (@pair nat nat n m) f) (f (addn n m))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))).
Proof. exact (REFL psum). Qed.
Definition istopology {A : Type'} : ((A -> Prop) -> Prop) -> Prop := fun _114641 : (A -> Prop) -> Prop => (_114641 (@set0 A)) /\ ((_114641 (@setT A)) /\ ((forall a : A -> Prop, forall b : A -> Prop, ((_114641 a) /\ (_114641 b)) -> _114641 (@setI A a b)) /\ (forall P : (A -> Prop) -> Prop, (@subset (A -> Prop) P _114641) -> _114641 (@UNIONS A P)))).
Lemma istopology_def {A : Type'} : (@istopology A) = (fun _114641 : (A -> Prop) -> Prop => (_114641 (@set0 A)) /\ ((_114641 (@setT A)) /\ ((forall a : A -> Prop, forall b : A -> Prop, ((_114641 a) /\ (_114641 b)) -> _114641 (@setI A a b)) /\ (forall P : (A -> Prop) -> Prop, (@subset (A -> Prop) P _114641) -> _114641 (@UNIONS A P))))).
Proof. exact (REFL (@istopology A)). Qed.
Definition closed {A : Type'} : (Topology A) -> (A -> Prop) -> Prop := fun _114675 : Topology A => fun _114676 : A -> Prop => @opens A _114675 (@setC A _114676).
Lemma closed_def {A : Type'} : (@closed A) = (fun _114675 : Topology A => fun _114676 : A -> Prop => @opens A _114675 (@setC A _114676)).
Proof. exact (REFL (@closed A)). Qed.
Definition limpt {A : Type'} : (Topology A) -> A -> (A -> Prop) -> Prop := fun _114687 : Topology A => fun _114688 : A => fun _114689 : A -> Prop => forall N' : A -> Prop, (@neigh A _114687 (@pair (A -> Prop) A N' _114688)) -> exists y : A, (~ (_114688 = y)) /\ ((_114689 y) /\ (N' y)).
Lemma limpt_def {A : Type'} : (@limpt A) = (fun _114687 : Topology A => fun _114688 : A => fun _114689 : A -> Prop => forall N' : A -> Prop, (@neigh A _114687 (@pair (A -> Prop) A N' _114688)) -> exists y : A, (~ (_114688 = y)) /\ ((_114689 y) /\ (N' y))).
Proof. exact (REFL (@limpt A)). Qed.
Definition ball {A : Type'} : (Metric A) -> (prod A R) -> A -> Prop := fun _114846 : Metric A => fun _114847 : prod A R => fun y : A => ltr (@mdist A _114846 (@pair A A (@fst A R _114847) y)) (@snd A R _114847).
Lemma ball_def {A : Type'} : (@ball A) = (fun _114846 : Metric A => fun _114847 : prod A R => fun y : A => ltr (@mdist A _114846 (@pair A A (@fst A R _114847) y)) (@snd A R _114847)).
Proof. exact (REFL (@ball A)). Qed.
Definition dorder {A : Type'} : (A -> A -> Prop) -> Prop := fun _114928 : A -> A -> Prop => forall x : A, forall y : A, ((_114928 x x) /\ (_114928 y y)) -> exists z : A, (_114928 z z) /\ (forall w : A, (_114928 w z) -> (_114928 w x) /\ (_114928 w y)).
Lemma dorder_def {A : Type'} : (@dorder A) = (fun _114928 : A -> A -> Prop => forall x : A, forall y : A, ((_114928 x x) /\ (_114928 y y)) -> exists z : A, (_114928 z z) /\ (forall w : A, (_114928 w z) -> (_114928 w x) /\ (_114928 w y))).
Proof. exact (REFL (@dorder A)). Qed.
Definition bounded {A B : Type'} : (prod (Metric A) (B -> B -> Prop)) -> (B -> A) -> Prop := fun _114960 : prod (Metric A) (B -> B -> Prop) => fun _114961 : B -> A => exists k : R, exists x : A, exists N' : B, (@snd (Metric A) (B -> B -> Prop) _114960 N' N') /\ (forall n : B, (@snd (Metric A) (B -> B -> Prop) _114960 n N') -> ltr (@mdist A (@fst (Metric A) (B -> B -> Prop) _114960) (@pair A A (_114961 n) x)) k).
Lemma bounded_def {A B : Type'} : (@bounded A B) = (fun _114960 : prod (Metric A) (B -> B -> Prop) => fun _114961 : B -> A => exists k : R, exists x : A, exists N' : B, (@snd (Metric A) (B -> B -> Prop) _114960 N' N') /\ (forall n : B, (@snd (Metric A) (B -> B -> Prop) _114960 n N') -> ltr (@mdist A (@fst (Metric A) (B -> B -> Prop) _114960) (@pair A A (_114961 n) x)) k)).
Proof. exact (REFL (@bounded A B)). Qed.
Definition convergent : (nat -> R) -> Prop := fun _115124 : nat -> R => exists l : R, tends_num_real _115124 l.
Lemma convergent_def : convergent = (fun _115124 : nat -> R => exists l : R, tends_num_real _115124 l).
Proof. exact (REFL convergent). Qed.
Definition cauchy : (nat -> R) -> Prop := fun _115129 : nat -> R => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall m : nat, forall n : nat, ((geqn m N') /\ (geqn n N')) -> ltr (normr (subr (_115129 m) (_115129 n))) e.
Lemma cauchy_def : cauchy = (fun _115129 : nat -> R => forall e : R, (ltr (R_of_nat (NUMERAL O)) e) -> exists N' : nat, forall m : nat, forall n : nat, ((geqn m N') /\ (geqn n N')) -> ltr (normr (subr (_115129 m) (_115129 n))) e).
Proof. exact (REFL cauchy). Qed.
Definition lim : (nat -> R) -> R := fun _115134 : nat -> R => @ε R (fun l : R => tends_num_real _115134 l).
Lemma lim_def : lim = (fun _115134 : nat -> R => @ε R (fun l : R => tends_num_real _115134 l)).
Proof. exact (REFL lim). Qed.
Definition subseq : (nat -> nat) -> Prop := fun _115139 : nat -> nat => forall m : nat, forall n : nat, (ltn m n) -> ltn (_115139 m) (_115139 n).
Lemma subseq_def : subseq = (fun _115139 : nat -> nat => forall m : nat, forall n : nat, (ltn m n) -> ltn (_115139 m) (_115139 n)).
Proof. exact (REFL subseq). Qed.
Definition mono : (nat -> R) -> Prop := fun _115146 : nat -> R => (forall m : nat, forall n : nat, (leqn m n) -> ler (_115146 m) (_115146 n)) \/ (forall m : nat, forall n : nat, (leqn m n) -> ger (_115146 m) (_115146 n)).
Lemma mono_def : mono = (fun _115146 : nat -> R => (forall m : nat, forall n : nat, (leqn m n) -> ler (_115146 m) (_115146 n)) \/ (forall m : nat, forall n : nat, (leqn m n) -> ger (_115146 m) (_115146 n))).
Proof. exact (REFL mono). Qed.
Definition sums : (nat -> R) -> R -> Prop := fun _115426 : nat -> R => fun _115427 : R => tends_num_real (fun n : nat => psum (@pair nat nat (NUMERAL O) n) _115426) _115427.
Lemma sums_def : sums = (fun _115426 : nat -> R => fun _115427 : R => tends_num_real (fun n : nat => psum (@pair nat nat (NUMERAL O) n) _115426) _115427).
Proof. exact (REFL sums). Qed.
Definition summable : (nat -> R) -> Prop := fun _115438 : nat -> R => exists s : R, sums _115438 s.
Lemma summable_def : summable = (fun _115438 : nat -> R => exists s : R, sums _115438 s).
Proof. exact (REFL summable). Qed.
Definition suminf : (nat -> R) -> R := fun _115443 : nat -> R => @ε R (fun s : R => sums _115443 s).
Lemma suminf_def : suminf = (fun _115443 : nat -> R => @ε R (fun s : R => sums _115443 s)).
Proof. exact (REFL suminf). Qed.
Definition fld {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _117705 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_377 : A => exists x : A, @SETSPEC A GEN_PVAR_377 (exists y : A, (_117705 x y) \/ (_117705 y x)) x).
Lemma fld_def {A : Type'} : (@fld A) = (fun _117705 : A -> A -> Prop => @GSPEC A (fun GEN_PVAR_377 : A => exists x : A, @SETSPEC A GEN_PVAR_377 (exists y : A, (_117705 x y) \/ (_117705 y x)) x)).
Proof. exact (REFL (@fld A)). Qed.
Definition qoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117760 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117760)) -> _117760 x x) /\ (forall x : A, forall y : A, forall z : A, ((_117760 x y) /\ (_117760 y z)) -> _117760 x z).
Lemma qoset_def {A : Type'} : (@qoset A) = (fun _117760 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117760)) -> _117760 x x) /\ (forall x : A, forall y : A, forall z : A, ((_117760 x y) /\ (_117760 y z)) -> _117760 x z)).
Proof. exact (REFL (@qoset A)). Qed.
Definition poset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117765 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117765)) -> _117765 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117765 x y) /\ (_117765 y z)) -> _117765 x z) /\ (forall x : A, forall y : A, ((_117765 x y) /\ (_117765 y x)) -> x = y)).
Lemma poset_def {A : Type'} : (@poset A) = (fun _117765 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117765)) -> _117765 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117765 x y) /\ (_117765 y z)) -> _117765 x z) /\ (forall x : A, forall y : A, ((_117765 x y) /\ (_117765 y x)) -> x = y))).
Proof. exact (REFL (@poset A)). Qed.
Definition toset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117770 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117770)) -> _117770 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117770 x y) /\ (_117770 y z)) -> _117770 x z) /\ ((forall x : A, forall y : A, ((_117770 x y) /\ (_117770 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _117770)) /\ (@IN A y (@fld A _117770))) -> (_117770 x y) \/ (_117770 y x)))).
Lemma toset_def {A : Type'} : (@toset A) = (fun _117770 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117770)) -> _117770 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117770 x y) /\ (_117770 y z)) -> _117770 x z) /\ ((forall x : A, forall y : A, ((_117770 x y) /\ (_117770 y x)) -> x = y) /\ (forall x : A, forall y : A, ((@IN A x (@fld A _117770)) /\ (@IN A y (@fld A _117770))) -> (_117770 x y) \/ (_117770 y x))))).
Proof. exact (REFL (@toset A)). Qed.
Definition woset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117775 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117775)) -> _117775 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117775 x y) /\ (_117775 y z)) -> _117775 x z) /\ ((forall x : A, forall y : A, ((_117775 x y) /\ (_117775 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _117775)) /\ (@IN A y (@fld A _117775))) -> (_117775 x y) \/ (_117775 y x)) /\ (forall s : A -> Prop, ((@subset A s (@fld A _117775)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _117775 x y))))).
Lemma woset_def {A : Type'} : (@woset A) = (fun _117775 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117775)) -> _117775 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117775 x y) /\ (_117775 y z)) -> _117775 x z) /\ ((forall x : A, forall y : A, ((_117775 x y) /\ (_117775 y x)) -> x = y) /\ ((forall x : A, forall y : A, ((@IN A x (@fld A _117775)) /\ (@IN A y (@fld A _117775))) -> (_117775 x y) \/ (_117775 y x)) /\ (forall s : A -> Prop, ((@subset A s (@fld A _117775)) /\ (~ (s = (@set0 A)))) -> exists x : A, (@IN A x s) /\ (forall y : A, (@IN A y s) -> _117775 x y)))))).
Proof. exact (REFL (@woset A)). Qed.
Definition wqoset {A : Type'} : (A -> A -> Prop) -> Prop := fun _117780 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117780)) -> _117780 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117780 x y) /\ (_117780 y z)) -> _117780 x z) /\ (forall s : A -> Prop, (@subset A s (@fld A _117780)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_117780 x y))))).
Lemma wqoset_def {A : Type'} : (@wqoset A) = (fun _117780 : A -> A -> Prop => (forall x : A, (@IN A x (@fld A _117780)) -> _117780 x x) /\ ((forall x : A, forall y : A, forall z : A, ((_117780 x y) /\ (_117780 y z)) -> _117780 x z) /\ (forall s : A -> Prop, (@subset A s (@fld A _117780)) -> exists t : A -> Prop, (@finite_set A t) /\ ((@subset A t s) /\ (forall y : A, (@IN A y s) -> exists x : A, (@IN A x t) /\ (_117780 x y)))))).
Proof. exact (REFL (@wqoset A)). Qed.
Definition chain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _117785 : A -> A -> Prop => fun _117786 : A -> Prop => forall x : A, forall y : A, ((@IN A x _117786) /\ (@IN A y _117786)) -> (_117785 x y) \/ (_117785 y x).
Lemma chain_def {A : Type'} : (@chain A) = (fun _117785 : A -> A -> Prop => fun _117786 : A -> Prop => forall x : A, forall y : A, ((@IN A x _117786) /\ (@IN A y _117786)) -> (_117785 x y) \/ (_117785 y x)).
Proof. exact (REFL (@chain A)). Qed.
Definition antichain {A : Type'} : (A -> A -> Prop) -> (A -> Prop) -> Prop := fun _117797 : A -> A -> Prop => fun _117798 : A -> Prop => (@subset A _117798 (@fld A _117797)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_117797 x y)) _117798).
Lemma antichain_def {A : Type'} : (@antichain A) = (fun _117797 : A -> A -> Prop => fun _117798 : A -> Prop => (@subset A _117798 (@fld A _117797)) /\ (@pairwise A (fun x : A => fun y : A => ~ (_117797 x y)) _117798)).
Proof. exact (REFL (@antichain A)). Qed.
Definition strictly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _118450 : A -> A -> Prop => fun x : A => fun y : A => (_118450 x y) /\ (~ (_118450 y x)).
Lemma strictly_def {A : Type'} : (@strictly A) = (fun _118450 : A -> A -> Prop => fun x : A => fun y : A => (_118450 x y) /\ (~ (_118450 y x))).
Proof. exact (REFL (@strictly A)). Qed.
Definition properly {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _118455 : A -> A -> Prop => fun x : A => fun y : A => (_118455 x y) /\ (~ (x = y)).
Lemma properly_def {A : Type'} : (@properly A) = (fun _118455 : A -> A -> Prop => fun x : A => fun y : A => (_118455 x y) /\ (~ (x = y))).
Proof. exact (REFL (@properly A)). Qed.
Definition inseg {A : Type'} : (A -> A -> Prop) -> (A -> A -> Prop) -> Prop := fun _122716 : A -> A -> Prop => fun _122717 : A -> A -> Prop => forall x : A, forall y : A, (_122716 x y) = ((_122717 x y) /\ (@fld A _122716 y)).
Lemma inseg_def {A : Type'} : (@inseg A) = (fun _122716 : A -> A -> Prop => fun _122717 : A -> A -> Prop => forall x : A, forall y : A, (_122716 x y) = ((_122717 x y) /\ (@fld A _122716 y))).
Proof. exact (REFL (@inseg A)). Qed.
Definition linseg {A : Type'} : (A -> A -> Prop) -> A -> A -> A -> Prop := fun _122788 : A -> A -> Prop => fun _122789 : A => fun x : A => fun y : A => (_122788 x y) /\ (@properly A _122788 y _122789).
Lemma linseg_def {A : Type'} : (@linseg A) = (fun _122788 : A -> A -> Prop => fun _122789 : A => fun x : A => fun y : A => (_122788 x y) /\ (@properly A _122788 y _122789)).
Proof. exact (REFL (@linseg A)). Qed.
Definition ordinal {A : Type'} : (A -> A -> Prop) -> Prop := fun _122800 : A -> A -> Prop => (@woset A _122800) /\ (forall x : A, (@fld A _122800 x) -> x = (@ε A (fun y : A => ~ (@properly A _122800 y x)))).
Lemma ordinal_def {A : Type'} : (@ordinal A) = (fun _122800 : A -> A -> Prop => (@woset A _122800) /\ (forall x : A, (@fld A _122800 x) -> x = (@ε A (fun y : A => ~ (@properly A _122800 y x))))).
Proof. exact (REFL (@ordinal A)). Qed.
Definition RC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall RC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (a1' = a0')) -> RC' a0' a1') -> RC' a0 a1.
Lemma RC_def {A : Type'} : (@RC A) = (fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall RC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (a1' = a0')) -> RC' a0' a1') -> RC' a0 a1).
Proof. exact (REFL (@RC A)). Qed.
Definition SC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall SC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (SC' a1' a0')) -> SC' a0' a1') -> SC' a0 a1.
Lemma SC_def {A : Type'} : (@SC A) = (fun R' : A -> A -> Prop => fun a0 : A => fun a1 : A => forall SC' : A -> A -> Prop, (forall a0' : A, forall a1' : A, ((R' a0' a1') \/ (SC' a1' a0')) -> SC' a0' a1') -> SC' a0 a1).
Proof. exact (REFL (@SC A)). Qed.
Definition RSC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _198766 : A -> A -> Prop => @RC A (@SC A _198766).
Lemma RSC_def {A : Type'} : (@RSC A) = (fun _198766 : A -> A -> Prop => @RC A (@SC A _198766)).
Proof. exact (REFL (@RSC A)). Qed.
Definition RTC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _198890 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A _198890).
Lemma RTC_def {A : Type'} : (@RTC A) = (fun _198890 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A _198890)).
Proof. exact (REFL (@RTC A)). Qed.
Definition STC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _200401 : A -> A -> Prop => @Relation_Operators.clos_trans A (@SC A _200401).
Lemma STC_def {A : Type'} : (@STC A) = (fun _200401 : A -> A -> Prop => @Relation_Operators.clos_trans A (@SC A _200401)).
Proof. exact (REFL (@STC A)). Qed.
Definition RSTC {A : Type'} : (A -> A -> Prop) -> A -> A -> Prop := fun _200693 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A (@SC A _200693)).
Lemma RSTC_def {A : Type'} : (@RSTC A) = (fun _200693 : A -> A -> Prop => @RC A (@Relation_Operators.clos_trans A (@SC A _200693))).
Proof. exact (REFL (@RSTC A)). Qed.
Definition INV {A B : Type'} : (B -> A -> Prop) -> A -> B -> Prop := fun _201638 : B -> A -> Prop => fun _201639 : A => fun _201640 : B => _201638 _201640 _201639.
Lemma INV_def {A B : Type'} : (@INV A B) = (fun _201638 : B -> A -> Prop => fun _201639 : A => fun _201640 : B => _201638 _201640 _201639).
Proof. exact (REFL (@INV A B)). Qed.
Definition RELPOW {A : Type'} : nat -> (A -> A -> Prop) -> A -> A -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> (A -> A -> Prop) -> A -> A -> Prop) (fun RELPOW' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> (A -> A -> Prop) -> A -> A -> Prop => forall _201714 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall R' : A -> A -> Prop, forall x : A, forall y : A, (RELPOW' _201714 (NUMERAL O) R' x y) = (x = y)) /\ (forall n : nat, forall x : A, forall R' : A -> A -> Prop, forall y : A, (RELPOW' _201714 (S n) R' x y) = (exists z : A, (RELPOW' _201714 n R' x z) /\ (R' z y)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O))))))))))))).
Lemma RELPOW_def {A : Type'} : (@RELPOW A) = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> (A -> A -> Prop) -> A -> A -> Prop) (fun RELPOW' : (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) -> nat -> (A -> A -> Prop) -> A -> A -> Prop => forall _201714 : prod nat (prod nat (prod nat (prod nat (prod nat nat)))), (forall R' : A -> A -> Prop, forall x : A, forall y : A, (RELPOW' _201714 (NUMERAL O) R' x y) = (x = y)) /\ (forall n : nat, forall x : A, forall R' : A -> A -> Prop, forall y : A, (RELPOW' _201714 (S n) R' x y) = (exists z : A, (RELPOW' _201714 n R' x z) /\ (R' z y)))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))))))))).
Proof. exact (REFL (@RELPOW A)). Qed.
Definition NORMAL {A : Type'} : (A -> A -> Prop) -> A -> Prop := fun _202372 : A -> A -> Prop => fun _202373 : A => ~ (exists y : A, _202372 _202373 y).
Lemma NORMAL_def {A : Type'} : (@NORMAL A) = (fun _202372 : A -> A -> Prop => fun _202373 : A => ~ (exists y : A, _202372 _202373 y)).
Proof. exact (REFL (@NORMAL A)). Qed.
Definition CR {A : Type'} : (A -> A -> Prop) -> Prop := fun _202384 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202384 x y1) /\ (_202384 x y2)) -> exists z : A, (_202384 y1 z) /\ (_202384 y2 z).
Lemma CR_def {A : Type'} : (@CR A) = (fun _202384 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202384 x y1) /\ (_202384 x y2)) -> exists z : A, (_202384 y1 z) /\ (_202384 y2 z)).
Proof. exact (REFL (@CR A)). Qed.
Definition WCR {A : Type'} : (A -> A -> Prop) -> Prop := fun _202389 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202389 x y1) /\ (_202389 x y2)) -> exists z : A, (@RTC A _202389 y1 z) /\ (@RTC A _202389 y2 z).
Lemma WCR_def {A : Type'} : (@WCR A) = (fun _202389 : A -> A -> Prop => forall x : A, forall y1 : A, forall y2 : A, ((_202389 x y1) /\ (_202389 x y2)) -> exists z : A, (@RTC A _202389 y1 z) /\ (@RTC A _202389 y2 z)).
Proof. exact (REFL (@WCR A)). Qed.
Definition WN {A : Type'} : (A -> A -> Prop) -> Prop := fun _202394 : A -> A -> Prop => forall x : A, exists y : A, (@RTC A _202394 x y) /\ (@NORMAL A _202394 y).
Lemma WN_def {A : Type'} : (@WN A) = (fun _202394 : A -> A -> Prop => forall x : A, exists y : A, (@RTC A _202394 x y) /\ (@NORMAL A _202394 y)).
Proof. exact (REFL (@WN A)). Qed.
Definition SN {A : Type'} : (A -> A -> Prop) -> Prop := fun _202399 : A -> A -> Prop => ~ (exists seq : nat -> A, forall n : nat, _202399 (seq n) (seq (S n))).
Lemma SN_def {A : Type'} : (@SN A) = (fun _202399 : A -> A -> Prop => ~ (exists seq : nat -> A, forall n : nat, _202399 (seq n) (seq (S n)))).
Proof. exact (REFL (@SN A)). Qed.
Definition TREE {A : Type'} : (A -> A -> Prop) -> Prop := fun _202404 : A -> A -> Prop => (forall y : A, ~ (@Relation_Operators.clos_trans A _202404 y y)) /\ (exists a : A, (@IN A a (@fld A _202404)) /\ (forall y : A, (@IN A y (@fld A _202404)) -> (y = a) \/ ((@Relation_Operators.clos_trans A _202404 a y) /\ (@ex1 A (fun x : A => _202404 x y))))).
Lemma TREE_def {A : Type'} : (@TREE A) = (fun _202404 : A -> A -> Prop => (forall y : A, ~ (@Relation_Operators.clos_trans A _202404 y y)) /\ (exists a : A, (@IN A a (@fld A _202404)) /\ (forall y : A, (@IN A y (@fld A _202404)) -> (y = a) \/ ((@Relation_Operators.clos_trans A _202404 a y) /\ (@ex1 A (fun x : A => _202404 x y)))))).
Proof. exact (REFL (@TREE A)). Qed.
Definition LF {A : Type'} : (A -> A -> Prop) -> Prop := fun _202409 : A -> A -> Prop => forall x : A, @finite_set A (@GSPEC A (fun GEN_PVAR_407 : A => exists y : A, @SETSPEC A GEN_PVAR_407 (_202409 x y) y)).
Lemma LF_def {A : Type'} : (@LF A) = (fun _202409 : A -> A -> Prop => forall x : A, @finite_set A (@GSPEC A (fun GEN_PVAR_407 : A => exists y : A, @SETSPEC A GEN_PVAR_407 (_202409 x y) y))).
Proof. exact (REFL (@LF A)). Qed.
Definition JOINABLE {_183549 : Type'} : (_183549 -> _183549 -> Prop) -> _183549 -> _183549 -> Prop := fun _203946 : _183549 -> _183549 -> Prop => fun _203947 : _183549 => fun _203948 : _183549 => exists u : _183549, (@RTC _183549 _203946 _203947 u) /\ (@RTC _183549 _203946 _203948 u).
Lemma JOINABLE_def {_183549 : Type'} : (@JOINABLE _183549) = (fun _203946 : _183549 -> _183549 -> Prop => fun _203947 : _183549 => fun _203948 : _183549 => exists u : _183549, (@RTC _183549 _203946 _203947 u) /\ (@RTC _183549 _203946 _203948 u)).
Proof. exact (REFL (@JOINABLE _183549)). Qed.
Definition loopcheck : (seq (prod nat term)) -> nat -> term -> Prop := @ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (seq (prod nat term)) -> nat -> term -> Prop) (fun loopcheck' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (seq (prod nat term)) -> nat -> term -> Prop => forall _260318 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), forall env : seq (prod nat term), forall x : nat, (LOOPFREE env) -> forall t : term, (loopcheck' _260318 env x t) = (exists y : nat, (@IN nat y (free_variables_term t)) /\ ((y = x) \/ (exists s : term, (@MEM (prod nat term) (@pair nat term y s) env) /\ (loopcheck' _260318 env x s))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))))))))))).
Lemma loopcheck_def : loopcheck = (@ε ((prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (seq (prod nat term)) -> nat -> term -> Prop) (fun loopcheck' : (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))))) -> (seq (prod nat term)) -> nat -> term -> Prop => forall _260318 : prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))), forall env : seq (prod nat term), forall x : nat, (LOOPFREE env) -> forall t : term, (loopcheck' _260318 env x t) = (exists y : nat, (@IN nat y (free_variables_term t)) /\ ((y = x) \/ (exists s : term, (@MEM (prod nat term) (@pair nat term y s) env) /\ (loopcheck' _260318 env x s))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))))) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat (prod nat nat)))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat (prod nat nat))))) (NUMERAL (BIT1 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat (prod nat nat)))) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT1 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O))))))))))))))))).
Proof. exact (REFL loopcheck). Qed.
Definition unify : (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term)) := @ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term))) (fun unify' : (prod nat (prod nat (prod nat (prod nat nat)))) -> (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term)) => forall _268496 : prod nat (prod nat (prod nat (prod nat nat))), forall pr : prod (seq (prod nat term)) (seq (prod term term)), (unify' _268496 pr) = (@COND (option (seq (prod nat term))) (~ (LOOPFREE (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((@snd (seq (prod nat term)) (seq (prod term term)) pr) = (@nil (prod term term))) (@Some (seq (prod nat term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@tpcases (option (seq (prod nat term))) (fun f : nat => fun fargs : seq term => fun g : nat => fun gargs : seq term => @COND (option (seq (prod nat term))) ((f = g) /\ ((@size term fargs) = (@size term gargs))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cat (prod term term) (@ZIP term term fargs gargs) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@None (seq (prod nat term)))) (fun x : nat => fun t : term => @COND (option (seq (prod nat term))) (@MEM nat x (@map (prod nat term) nat (@fst nat term) (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (@ASSOC nat term x (@fst (seq (prod nat term)) (seq (prod term term)) pr)) t) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@COND (option (seq (prod nat term))) ((istriv_HOL (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = Exception) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((istriv_HOL (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = TT) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@cons (prod nat term) (@pair nat term x t) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))))) (fun f : nat => fun args : seq term => fun x : nat => unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (V x) (Fn f args)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@HD (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O)))))))))))).
Lemma unify_def : unify = (@ε ((prod nat (prod nat (prod nat (prod nat nat)))) -> (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term))) (fun unify' : (prod nat (prod nat (prod nat (prod nat nat)))) -> (prod (seq (prod nat term)) (seq (prod term term))) -> option (seq (prod nat term)) => forall _268496 : prod nat (prod nat (prod nat (prod nat nat))), forall pr : prod (seq (prod nat term)) (seq (prod term term)), (unify' _268496 pr) = (@COND (option (seq (prod nat term))) (~ (LOOPFREE (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((@snd (seq (prod nat term)) (seq (prod term term)) pr) = (@nil (prod term term))) (@Some (seq (prod nat term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@tpcases (option (seq (prod nat term))) (fun f : nat => fun fargs : seq term => fun g : nat => fun gargs : seq term => @COND (option (seq (prod nat term))) ((f = g) /\ ((@size term fargs) = (@size term gargs))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cat (prod term term) (@ZIP term term fargs gargs) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@None (seq (prod nat term)))) (fun x : nat => fun t : term => @COND (option (seq (prod nat term))) (@MEM nat x (@map (prod nat term) nat (@fst nat term) (@fst (seq (prod nat term)) (seq (prod term term)) pr))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (@ASSOC nat term x (@fst (seq (prod nat term)) (seq (prod term term)) pr)) t) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@COND (option (seq (prod nat term))) ((istriv_HOL (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = Exception) (@None (seq (prod nat term))) (@COND (option (seq (prod nat term))) ((istriv_HOL (@fst (seq (prod nat term)) (seq (prod term term)) pr) x t) = TT) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))) (unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@cons (prod nat term) (@pair nat term x t) (@fst (seq (prod nat term)) (seq (prod term term)) pr)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))))) (fun f : nat => fun args : seq term => fun x : nat => unify' _268496 (@pair (seq (prod nat term)) (seq (prod term term)) (@fst (seq (prod nat term)) (seq (prod term term)) pr) (@cons (prod term term) (@pair term term (V x) (Fn f args)) (@TL (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr))))) (@HD (prod term term) (@snd (seq (prod nat term)) (seq (prod term term)) pr)))))) (@pair nat (prod nat (prod nat (prod nat nat))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat (prod nat nat)) (NUMERAL (BIT0 (BIT1 (BIT1 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat (prod nat nat) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT1 (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT0 (BIT1 (BIT1 (BIT1 (BIT1 O))))))))))))).
Proof. exact (REFL unify). Qed.
Definition unifies : (nat -> term) -> (seq (prod term term)) -> Prop := fun _268497 : nat -> term => fun _268498 : seq (prod term term) => @ALL (prod term term) (@ε ((prod term term) -> Prop) (fun f : (prod term term) -> Prop => forall s : term, forall t : term, @eq Prop (f (@pair term term s t)) ((termsubst _268497 s) = (termsubst _268497 t)))) _268498.
Lemma unifies_def : unifies = (fun _268497 : nat -> term => fun _268498 : seq (prod term term) => @ALL (prod term term) (@ε ((prod term term) -> Prop) (fun f : (prod term term) -> Prop => forall s : term, forall t : term, @eq Prop (f (@pair term term s t)) ((termsubst _268497 s) = (termsubst _268497 t)))) _268498).
Proof. exact (REFL unifies). Qed.
Definition THE {_212257 : Type'} : (option _212257) -> _212257 := @ε ((prod nat (prod nat nat)) -> (option _212257) -> _212257) (fun THE' : (prod nat (prod nat nat)) -> (option _212257) -> _212257 => forall _274519 : prod nat (prod nat nat), forall x : _212257, (THE' _274519 (@Some _212257 x)) = x) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O)))))))))).
Lemma THE_def {_212257 : Type'} : (@THE _212257) = (@ε ((prod nat (prod nat nat)) -> (option _212257) -> _212257) (fun THE' : (prod nat (prod nat nat)) -> (option _212257) -> _212257 => forall _274519 : prod nat (prod nat nat), forall x : _212257, (THE' _274519 (@Some _212257 x)) = x) (@pair nat (prod nat nat) (NUMERAL (BIT0 (BIT0 (BIT1 (BIT0 (BIT1 (BIT0 (BIT1 O)))))))) (@pair nat nat (NUMERAL (BIT0 (BIT0 (BIT0 (BIT1 (BIT0 (BIT0 (BIT1 O)))))))) (NUMERAL (BIT1 (BIT0 (BIT1 (BIT0 (BIT0 (BIT0 (BIT1 O))))))))))).
Proof. exact (REFL (@THE _212257)). Qed.
Definition unifier : (seq (prod nat term)) -> nat -> term := fun _274520 : seq (prod nat term) => @LET (seq (prod nat term)) (nat -> term) (fun sol : seq (prod nat term) => @LET_END (nat -> term) (@ITLIST (prod nat term) (nat -> term) (@valmod term nat) sol V)) (SOLVE (@nil (prod nat term)) _274520).
Lemma unifier_def : unifier = (fun _274520 : seq (prod nat term) => @LET (seq (prod nat term)) (nat -> term) (fun sol : seq (prod nat term) => @LET_END (nat -> term) (@ITLIST (prod nat term) (nat -> term) (@valmod term nat) sol V)) (SOLVE (@nil (prod nat term)) _274520)).
Proof. exact (REFL unifier). Qed.
Definition Unifies : (nat -> term) -> (form -> Prop) -> Prop := fun _275990 : nat -> term => fun _275991 : form -> Prop => forall p : form, forall q : form, ((@IN form p _275991) /\ (@IN form q _275991)) -> (formsubst _275990 p) = (formsubst _275990 q).
Lemma Unifies_def : Unifies = (fun _275990 : nat -> term => fun _275991 : form -> Prop => forall p : form, forall q : form, ((@IN form p _275991) /\ (@IN form q _275991)) -> (formsubst _275990 p) = (formsubst _275990 q)).
Proof. exact (REFL Unifies). Qed.
Definition mgu : (form -> Prop) -> nat -> term := fun _276368 : form -> Prop => @ε (nat -> term) (fun i : nat -> term => (Unifies i _276368) /\ (forall j : nat -> term, (Unifies j _276368) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p)))).
Lemma mgu_def : mgu = (fun _276368 : form -> Prop => @ε (nat -> term) (fun i : nat -> term => (Unifies i _276368) /\ (forall j : nat -> term, (Unifies j _276368) -> forall p : form, (qfree p) -> (formsubst j p) = (formsubst j (formsubst i p))))).
Proof. exact (REFL mgu). Qed.
Definition ismgu : (form -> Prop) -> (nat -> term) -> Prop := fun _276376 : form -> Prop => fun _276377 : nat -> term => (Unifies _276377 _276376) /\ (forall j : nat -> term, (Unifies j _276376) -> exists k : nat -> term, (termsubst j) = (@o term term term (termsubst k) (termsubst _276377))).
Lemma ismgu_def : ismgu = (fun _276376 : form -> Prop => fun _276377 : nat -> term => (Unifies _276377 _276376) /\ (forall j : nat -> term, (Unifies j _276376) -> exists k : nat -> term, (termsubst j) = (@o term term term (termsubst k) (termsubst _276377)))).
Proof. exact (REFL ismgu). Qed.
Definition renaming : (nat -> term) -> Prop := fun _276405 : nat -> term => exists j : nat -> term, ((@o term term term (termsubst j) (termsubst _276405)) = (@I term)) /\ ((@o term term term (termsubst _276405) (termsubst j)) = (@I term)).
Lemma renaming_def : renaming = (fun _276405 : nat -> term => exists j : nat -> term, ((@o term term term (termsubst j) (termsubst _276405)) = (@I term)) /\ ((@o term term term (termsubst _276405) (termsubst j)) = (@I term))).
Proof. exact (REFL renaming). Qed.
